<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.9" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.32" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://github.com/jimbo-master/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/11.%E6%8E%92%E5%BA%8F.html"><meta property="og:site_name" content="JimBoの学习妙妙屋"><meta property="og:title" content="第十一章：排序"><meta property="og:description" content="第十一章：排序 1.排序算法概念 排序算法（sorting algorithm）用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理 如下图所示，排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则 1.1 排序算法评..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="JimBo"><meta property="article:published_time" content="2024-03-11T00:00:00.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"第十一章：排序","image":[""],"datePublished":"2024-03-11T00:00:00.000Z","dateModified":null,"author":[{"@type":"Person","name":"JimBo","url":"https://github.com/jimbo-master"}]}</script><link rel="icon" href="/logo.png"><title>第十一章：排序 | JimBoの学习妙妙屋</title><meta name="description" content="第十一章：排序 1.排序算法概念 排序算法（sorting algorithm）用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理 如下图所示，排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则 1.1 排序算法评...">
    <link rel="preload" href="/assets/style-DVx1EBzc.css" as="style"><link rel="stylesheet" href="/assets/style-DVx1EBzc.css">
    <link rel="modulepreload" href="/assets/app-Dezzdk4T.js"><link rel="modulepreload" href="/assets/11.排序.html-OqKCFYs2.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-DlAUqK2U.js">
    
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="route-link vp-brand" href="/"><img class="vp-nav-logo" src="/logo.png" alt><!----><span class="vp-site-name hide-in-pad">JimBoの学习妙妙屋</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/" aria-label="主页"><span class="font-icon icon iconfont icon-home" style=""></span>主页<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="编程学习"><span class="title"><span class="font-icon icon iconfont icon-discover" style=""></span>编程学习</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="route-link nav-link" href="/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1.C%E8%AF%AD%E8%A8%80/" aria-label="C语言"><span class="font-icon icon iconfont icon-creative" style=""></span>C语言<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/2.CPP/" aria-label="CPP"><span class="font-icon icon iconfont icon-creative" style=""></span>CPP<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/编程学习/3.Python/" aria-label="Python"><span class="font-icon icon iconfont icon-creative" style=""></span>Python<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="算法学习"><span class="title"><span class="font-icon icon iconfont icon-repair" style=""></span>算法学习</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="route-link nav-link active" href="/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/" aria-label="算法知识"><span class="font-icon icon iconfont icon-creative" style=""></span>算法知识<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/2.%E7%AE%97%E6%B3%95%E9%A2%98%E5%9E%8B/" aria-label="算法题型"><span class="font-icon icon iconfont icon-creative" style=""></span>算法题型<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="计算机基础理论"><span class="title"><span class="font-icon icon iconfont icon-note" style=""></span>计算机基础理论</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="route-link nav-link" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" aria-label="数据结构"><span class="font-icon icon iconfont icon-creative" style=""></span>数据结构<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" aria-label="计算机组成原理"><span class="font-icon icon iconfont icon-creative" style=""></span>计算机组成原理<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/3.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" aria-label="操作系统"><span class="font-icon icon iconfont icon-creative" style=""></span>操作系统<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/4.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" aria-label="计算机网络"><span class="font-icon icon iconfont icon-creative" style=""></span>计算机网络<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="资源网站"><span class="title"><span class="font-icon icon iconfont icon-light" style=""></span>资源网站</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="http://qzbltushu.ysepan.com/" rel="noopener noreferrer" target="_blank" aria-label="考研考证升学" class="nav-link"><span class="font-icon icon iconfont icon-creative" style=""></span>考研考证升学<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></li><li class="dropdown-item"><a href="https://www.dmzshequ.com/forum.php" rel="noopener noreferrer" target="_blank" aria-label="IT自学资源" class="nav-link"><span class="font-icon icon iconfont icon-creative" style=""></span>IT自学资源<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></li><li class="dropdown-item"><a href="https://798798.site" rel="noopener noreferrer" target="_blank" aria-label="Hneko机场" class="nav-link"><span class="font-icon icon iconfont icon-creative" style=""></span>Hneko机场<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></li><li class="dropdown-item"><a href="https://blog.idejihuo.com/topics/jetbrains/idea" rel="noopener noreferrer" target="_blank" aria-label="jetbrains全家桶破解" class="nav-link"><span class="font-icon icon iconfont icon-creative" style=""></span>jetbrains全家桶破解<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></li></ul></button></div></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/jimbo-master" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!--[--><button type="button" class="search-pro-button" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="search-pro-placeholder">搜索</div><div class="search-pro-key-hints"><kbd class="search-pro-key">Ctrl</kbd><kbd class="search-pro-key">K</kbd></div></button><!--]--><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">编程学习</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">嵌入式学习</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">算法学习</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">1.算法知识</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html" aria-label="第一章：数据结构"><!---->第一章：数据结构<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/2.%E7%AE%97%E6%B3%95.html" aria-label="第二章：算法"><!---->第二章：算法<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/3.%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.html" aria-label="第三章：复杂度分析"><!---->第三章：复杂度分析<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/4.%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8.html" aria-label="第四章：数组与链表"><!---->第四章：数组与链表<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/5.%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97.html" aria-label="第五章：栈与队列"><!---->第五章：栈与队列<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/6.%E5%93%88%E5%B8%8C%E8%A1%A8.html" aria-label="第六章：哈希表"><!---->第六章：哈希表<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/7.%E6%A0%91.html" aria-label="第七章：树"><!---->第七章：树<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/8.%E5%A0%86.html" aria-label="第八章：堆"><!---->第八章：堆<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/9.%E5%9B%BE.html" aria-label="第九章：图"><!---->第九章：图<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/10.%E6%90%9C%E7%B4%A2.html" aria-label="第十章：搜索"><!---->第十章：搜索<!----></a></li><li><a class="route-link nav-link active vp-sidebar-link vp-sidebar-page active" href="/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/11.%E6%8E%92%E5%BA%8F.html" aria-label="第十一章：排序"><!---->第十一章：排序<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/12.%E5%88%86%E6%B2%BB.html" aria-label="第十二章：分治"><!---->第十二章：分治<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/13.%E5%9B%9E%E6%BA%AF.html" aria-label="第十三章：回溯"><!---->第十三章：回溯<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/14.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html" aria-label="第十四章：动态规划"><!---->第十四章：动态规划<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/15.%E8%B4%AA%E5%BF%83.html" aria-label="第十五章：贪心"><!---->第十五章：贪心<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">2.算法题型</span><span class="vp-arrow end"></span></button><!----></section></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">计算机基础理论</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">嵌入式基础理论</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->第十一章：排序</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://github.com/jimbo-master" target="_blank" rel="noopener noreferrer">JimBo</a></span><span property="author" content="JimBo"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2024-03-11T00:00:00.000Z"></span><span class="page-pageview-info" aria-label="访问量🔢" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon eye-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="eye icon"><path d="M992 512.096c0-5.76-.992-10.592-1.28-11.136-.192-2.88-1.152-8.064-2.08-10.816-.256-.672-.544-1.376-.832-2.08-.48-1.568-1.024-3.104-1.6-4.32C897.664 290.112 707.104 160 512 160c-195.072 0-385.632 130.016-473.76 322.592-1.056 2.112-1.792 4.096-2.272 5.856a55.512 55.512 0 00-.64 1.6c-1.76 5.088-1.792 8.64-1.632 7.744-.832 3.744-1.568 11.168-1.568 11.168-.224 2.272-.224 4.032.032 6.304 0 0 .736 6.464 1.088 7.808.128 1.824.576 4.512 1.12 6.976h-.032c.448 2.08 1.12 4.096 1.984 6.08.48 1.536.992 2.976 1.472 4.032C126.432 733.856 316.992 864 512 864c195.136 0 385.696-130.048 473.216-321.696 1.376-2.496 2.24-4.832 2.848-6.912.256-.608.48-1.184.672-1.728 1.536-4.48 1.856-8.32 1.728-8.32l-.032.032c.608-3.104 1.568-7.744 1.568-13.28zM512 672c-88.224 0-160-71.776-160-160s71.776-160 160-160 160 71.776 160 160-71.776 160-160 160z"></path></svg><span id="ArtalkPV" class="waline-pageview-count" data-path="/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/11.%E6%8E%92%E5%BA%8F.html">...</span></span><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 27 分钟</span><meta property="timeRequired" content="PT27M"></span><!----><!----></div><hr></div><div class="vp-toc-placeholder"><aside id="toc"><!--[--><!----><!--]--><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_1-排序算法概念">1.排序算法概念</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_1-1-排序算法评价维度">1.1 排序算法评价维度</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_1-2-理想的排序算法">1.2 理想的排序算法</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_2-选择排序算法">2.选择排序算法</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_2-1-选择排序原理">2.1 选择排序原理</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_3-冒泡排序算法">3.冒泡排序算法</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-1-冒牌排序算法流程">3.1 冒牌排序算法流程</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_3-2-冒泡排序效率优化">3.2 冒泡排序效率优化</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_4-插入排序算法">4.插入排序算法</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_4-1-插入排序算法流程">4.1 插入排序算法流程</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_5-快速排序算法">5.快速排序算法</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-1-快速排序算法流程">5.1 快速排序算法流程</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_5-2-快速排序为什么快">5.2 快速排序为什么快</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_6-归并排序算法">6.归并排序算法</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_6-1-归并排序算法流程">6.1 归并排序算法流程</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_7-堆排序算法">7.堆排序算法</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_7-1-堆排序算法流程">7.1 堆排序算法流程</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_8-桶排序算法">8.桶排序算法</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_8-1-桶排序算法流程">8.1 桶排序算法流程</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_8-2-如何实现平均分配">8.2 如何实现平均分配</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_9-计数排序算法">9.计数排序算法</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_9-1-计数排序算法的简单实现">9.1 计数排序算法的简单实现</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_9-2-计数排序算法的完整实现">9.2 计数排序算法的完整实现</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_10-基数排序算法">10.基数排序算法</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_10-1-基数排序算法流程">10.1 基数排序算法流程</a></li><!----><!--]--></ul></li><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h1 id="第十一章-排序" tabindex="-1"><a class="header-anchor" href="#第十一章-排序"><span>第十一章：排序</span></a></h1><h2 id="_1-排序算法概念" tabindex="-1"><a class="header-anchor" href="#_1-排序算法概念"><span>1.排序算法概念</span></a></h2><p><strong>排序算法（sorting algorithm）用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理</strong></p><p><strong>如下图所示，排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则</strong></p><figure><img src="/assets/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%88%A4%E6%96%AD%E8%A7%84%E5%88%99-C6YK3UU8.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_1-1-排序算法评价维度" tabindex="-1"><a class="header-anchor" href="#_1-1-排序算法评价维度"><span>1.1 排序算法评价维度</span></a></h3><p><strong>（1）运行效率：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要</strong></p><p><strong>（2）就地性：顾名思义，原地排序通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快</strong></p><p><strong>（3）稳定性：稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变</strong></p><blockquote><p><strong>稳定排序是多级排序场景的必要条件。假设我们有一个存储学生信息的表格，第 1 列和第 2 列分别是姓名和年龄。在这种情况下，非稳定排序可能导致输入数据的有序性丧失：</strong></p></blockquote><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code># 输入数据是按照姓名排序好的
# <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token char">&#39;A&#39;</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token char">&#39;B&#39;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token char">&#39;C&#39;</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token char">&#39;D&#39;</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token char">&#39;E&#39;</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span>

# 假设使用非稳定排序算法按年龄排序列表，
# 结果中 <span class="token punctuation">(</span><span class="token char">&#39;D&#39;</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span> 和 <span class="token punctuation">(</span><span class="token char">&#39;A&#39;</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span> 的相对位置改变，
# 输入数据按姓名排序的性质丢失
  <span class="token punctuation">(</span><span class="token char">&#39;B&#39;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token char">&#39;D&#39;</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token char">&#39;A&#39;</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token char">&#39;C&#39;</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token char">&#39;E&#39;</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>（4）自适应性：自适应排序的时间复杂度会受输入数据的影响，即最佳时间复杂度、最差时间复杂度、平均时间复杂度并不完全相等</strong></p><blockquote><p><strong>自适应性需要根据具体情况来评估。如果最差时间复杂度差于平均时间复杂度，说明排序算法在某些数据下性能可能劣化，因此被视为负面属性；而如果最佳时间复杂度优于平均时间复杂度，则被视为正面属性</strong></p></blockquote><p><strong>（5）是否基于比较：基于比较的排序依赖比较运算符（&lt;、=、&gt;）来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为O(nlogn)。而非比较排序不使用比较运算符，时间复杂度可达O(n)，但其通用性相对较差</strong></p><hr><h3 id="_1-2-理想的排序算法" tabindex="-1"><a class="header-anchor" href="#_1-2-理想的排序算法"><span>1.2 理想的排序算法</span></a></h3><p><strong>运行快、原地、稳定、正向自适应、通用性好。显然，迄今为止尚未发现兼具以上所有特性的排序算法。因此，在选择排序算法时，需要根据具体的数据特点和问题需求来决定</strong></p><hr><h2 id="_2-选择排序算法" tabindex="-1"><a class="header-anchor" href="#_2-选择排序算法"><span>2.选择排序算法</span></a></h2><h3 id="_2-1-选择排序原理" tabindex="-1"><a class="header-anchor" href="#_2-1-选择排序原理"><span>2.1 选择排序原理</span></a></h3><p><strong>选择排序（selection sort）的工作原理非常简单：开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾</strong></p><p><strong>设数组的长度为n，选择排序的算法流程如图下图所示：</strong></p><ul><li><strong>初始状态下，所有元素未排序，即未排序（索引）区间为[0，n-1]</strong></li><li><strong>选取区间[0，n-1]中的最小元素，将其与索引0处的元素交换。完成后，数组前1个元素已排序</strong></li><li><strong>选取区间[1，n-1]中的最小元素，将其与索引1处的元素交换。完成后，数组前2个元素已排序</strong></li><li><strong>以此类推。经过n-1轮选择与交换后，数组前n-1个元素已排序</strong></li><li><strong>仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成</strong></li></ul><figure><img src="/assets/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-BNsK9kfp.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>在代码中，我们用k来记录未排序区间内的最小元素：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 选择排序 */</span>
<span class="token keyword">void</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 外循环：未排序区间为 [i, n-1]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 内循环：找到未排序区间内的最小元素</span>
        <span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>
                k <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 记录最小元素的索引</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 将该最小元素与未排序区间的首个元素交换</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>时间复杂度为O(n^2)、非自适应排序：外循环共n-1轮，第一轮的未排序区间长度为n，最后一轮的未排序区间长度为2，即各轮外循环分别包含n、n-1、...、3、2轮内循环，求和为(n-1)(n+2)/2</strong><br><br><strong>空间复杂度为O(1)、原地排序：指针i和j使用常数大小的额外空间</strong><br><br><strong>非稳定排序：如下图所示，元素 nums[i] 有可能被交换至与其相等的元素的右边，导致两者的相对顺序发生改变</strong></p></blockquote><figure><img src="/assets/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E9%9D%9E%E7%A8%B3%E5%AE%9A%E6%80%A7-wH7gBfDE.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h2 id="_3-冒泡排序算法" tabindex="-1"><a class="header-anchor" href="#_3-冒泡排序算法"><span>3.冒泡排序算法</span></a></h2><p><strong>冒泡排序（bubble sort）通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序</strong></p><blockquote><p><strong>时间复杂度为O(n^2)、自适应排序：各轮“冒泡”遍历的数组长度依次为n-1、n-2、...、2、1，总和为(n-1)/2。在引入 flag 优化后，最佳时间复杂度可达到O(n)</strong><br><br><strong>空间复杂度为O(1)、原地排序：指针i和j使用常数大小的额外空间</strong><br><br><strong>稳定排序：由于在“冒泡”中遇到相等元素不交换</strong></p></blockquote><p><strong>如下图所示，冒泡过程可以利用元素交换操作来模拟：从数组最左端开始向右遍历，依次比较相邻元素大小，如果“左元素 &gt; 右元素”就交换二者。遍历完成后，最大的元素会被移动到数组的最右端</strong></p><figure><img src="/assets/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-BKTQ1K69.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_3-1-冒牌排序算法流程" tabindex="-1"><a class="header-anchor" href="#_3-1-冒牌排序算法流程"><span>3.1 冒牌排序算法流程</span></a></h3><p><strong>设数组的长度n，冒泡排序的步骤如下图所示：</strong></p><ul><li><strong>首先，对n个元素执行“冒泡”，将数组的最大元素交换至正确位置</strong></li><li><strong>接下来，对剩余n-1个元素执行“冒泡”，将第二大元素交换至正确位置</strong></li><li><strong>以此类推，经过n-1轮“冒泡”后，前n-1大的元素都被交换至正确位置</strong></li><li><strong>仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成</strong></li></ul><figure><img src="/assets/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B-BSBlS73g.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>示例代码如下：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 冒泡排序 */</span>
<span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 外循环：未排序区间为 [0, i]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> 
            <span class="token punctuation">{</span>
                <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_3-2-冒泡排序效率优化" tabindex="-1"><a class="header-anchor" href="#_3-2-冒泡排序效率优化"><span>3.2 冒泡排序效率优化</span></a></h3><p><strong>我们发现，如果某轮“冒泡”中没有执行任何交换操作，说明数组已经完成排序，可直接返回结果。因此，可以增加一个标志位 flag 来监测这种情况，一旦出现就立即返回</strong></p><p><strong>经过优化，冒泡排序的最差时间复杂度和平均时间复杂度仍为O(n^2)；但当输入数组完全有序时，可达到最佳时间复杂度O(n)</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 冒泡排序（标志优化）*/</span>
<span class="token keyword">void</span> <span class="token function">bubbleSortWithFlag</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 外循环：未排序区间为 [0, i]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        bool flag <span class="token operator">=</span> false<span class="token punctuation">;</span>
        <span class="token comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> 
            <span class="token punctuation">{</span>
                <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
                flag <span class="token operator">=</span> true<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_4-插入排序算法" tabindex="-1"><a class="header-anchor" href="#_4-插入排序算法"><span>4.插入排序算法</span></a></h2><p><strong>插入排序（insertion sort）是一种简单的排序算法，它的工作原理与手动整理一副牌的过程非常相似</strong></p><p><strong>具体来说，我们在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置</strong></p><p><strong>下图展示了数组插入元素的操作流程。设基准元素为 base ，我们需要将从目标索引到 base 之间的所有元素向右移动一位，然后将 base 赋值给目标索引</strong></p><figure><img src="/assets/%E5%8D%95%E6%AC%A1%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-WgCl52rn.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_4-1-插入排序算法流程" tabindex="-1"><a class="header-anchor" href="#_4-1-插入排序算法流程"><span>4.1 插入排序算法流程</span></a></h3><p><strong>插入排序的整体流程如下图所示：</strong></p><ul><li><strong>初始状态下，数组的第 1 个元素已完成排序</strong></li><li><strong>选取数组的第 2 个元素作为 base ，将其插入到正确位置后，数组的前 2 个元素已排序</strong></li><li><strong>选取第 3 个元素作为 base ，将其插入到正确位置后，数组的前 3 个元素已排序</strong></li><li><strong>以此类推，在最后一轮中，选取最后一个元素作为 base ，将其插入到正确位置后，所有元素均已排序</strong></li></ul><blockquote><p><strong>时间复杂度为O(n^ 2)、自适应排序：在最差情况下，每次插入操作分别需要循环n-1、n-2、...、2、1次，求和得到(n-1)n/2，因此时间复杂度为O(n^2) 。在遇到有序数据时，插入操作会提前终止。当输入数组完全有序时，插入排序达到最佳时间复杂度O(n)</strong><br><br><strong>空间复杂度为O(1)、原地排序：指针i和j使用常数大小的额外空间</strong><br><br><strong>稳定排序：在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序</strong></p></blockquote><figure><img src="/assets/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B-DD646liI.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 插入排序 */</span>
<span class="token keyword">void</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 外循环：已排序区间为 [0, i-1]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> base <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">// 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> base<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token comment">// 将 nums[j] 向右移动一位</span>
            nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            j<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 将 base 赋值到正确位置</span>
        nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> base<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_5-快速排序算法" tabindex="-1"><a class="header-anchor" href="#_5-快速排序算法"><span>5.快速排序算法</span></a></h2><p><strong>快速排序（quick sort）是一种基于分治策略的排序算法，运行高效，应用广泛</strong></p><p><strong>快速排序的核心操作是“哨兵划分”，其目标是：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。具体来说，哨兵划分的流程如下图所示</strong></p><ul><li><strong>选取数组最左端元素作为基准数，初始化两个指针i和j分别指向数组的两端</strong></li><li><strong>设置一个循环，在每轮中使用 i（j）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素</strong></li><li><strong>循环执行步骤2，直到 i 和 j 相遇时停止，最后将基准数交换至两个子数组的分界线</strong></li></ul><figure><img src="/assets/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B-BaIu-hTV.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="/assets/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B2-CrTZ0t5J.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>哨兵划分完成后，原数组被划分成三部分：左子数组、基准数、右子数组，且满足“左子数组任意元素 ≤ 基准数 ≤右子数组任意元素”。因此，我们接下来只需对这两个子数组进行排序</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 元素交换 */</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 快速排序类 */</span>
<span class="token comment">// 快速排序类-哨兵划分</span>
<span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 以 nums[left] 为基准数</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">,</span> j <span class="token operator">=</span> right<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token comment">// 从右向左找首个小于基准数的元素</span>
            j<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token comment">// 从左向右找首个大于基准数的元素</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 交换这两个元素</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将基准数交换至两子数组的分界线</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 返回基准数的索引</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_5-1-快速排序算法流程" tabindex="-1"><a class="header-anchor" href="#_5-1-快速排序算法流程"><span>5.1 快速排序算法流程</span></a></h3><p><strong>快速排序的整体流程如下图所示：</strong></p><ul><li><strong>首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组</strong></li><li><strong>然后，对左子数组和右子数组分别递归执行“哨兵划分”</strong></li><li><strong>持续递归，直至子数组长度为 1 时终止，从而完成整个数组的排序</strong></li></ul><blockquote><p><strong>时间复杂度为O(nlogn)、自适应排序：在平均情况下，哨兵划分的递归层数为logn，每层中的总循环数为n，总体使用O(nlogn)时间。在最差情况下，每轮哨兵划分操作都将长度为n的数组划分为长度为0和n-1的两个子数组，此时递归层数达到n，每层中的循环数为n，总体使用O(n^2)时间</strong><br><br><strong>空间复杂度为O(n)、原地排序：在输入数组完全倒序的情况下，达到最差递归深度n，使用O(n)栈帧空间。排序操作是在原数组上进行的，未借助额外数组</strong><br><br><strong>非稳定排序：在哨兵划分的最后一步，基准数可能会被交换至相等元素的右侧</strong></p></blockquote><figure><img src="/assets/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-Do3x1ZO2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 快速排序类 */</span>
<span class="token comment">// 快速排序类-哨兵划分</span>
<span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 以 nums[left] 为基准数</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">,</span> j <span class="token operator">=</span> right<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token comment">// 从右向左找首个小于基准数的元素</span>
            j<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token comment">// 从左向右找首个大于基准数的元素</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 交换这两个元素</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将基准数交换至两子数组的分界线</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 返回基准数的索引</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 快速排序类-快速排序</span>
<span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 子数组长度为 1 时终止递归</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 哨兵划分</span>
    <span class="token keyword">int</span> pivot <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 递归左子数组、右子数组</span>
    <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> pivot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> pivot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_5-2-快速排序为什么快" tabindex="-1"><a class="header-anchor" href="#_5-2-快速排序为什么快"><span>5.2 快速排序为什么快</span></a></h3><p><strong>从名称上就能看出，快速排序在效率方面应该具有一定的优势。尽管快速排序的平均时间复杂度与“归并排序”和“堆排序”相同，但通常快速排序的效率更高，主要有以下原因</strong></p><ul><li><strong>出现最差情况的概率很低：虽然快速排序的最差时间复杂度为O(n^2)，没有归并排序稳定，但在绝大多数情况下，快速排序能在O(nlogn)的时间复杂度下运行</strong></li><li><strong>缓存使用效率高：在执行哨兵划分操作时，系统可将整个子数组加载到缓存，因此访问元素的效率较高。而像“堆排序”这类算法需要跳跃式访问元素，从而缺乏这一特性</strong></li><li><strong>复杂度的常数系数小：在上述三种算法中，快速排序的比较、赋值、交换等操作的总数量最少。这与“插入排序”比“冒泡排序”更快的原因类似</strong></li></ul><hr><h2 id="_6-归并排序算法" tabindex="-1"><a class="header-anchor" href="#_6-归并排序算法"><span>6.归并排序算法</span></a></h2><p><strong>归并排序（merge sort）是一种基于分治策略的排序算法，包含图下图所示的“划分”和“合并”阶段</strong></p><ul><li><strong>划分阶段：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题</strong></li><li><strong>合并阶段：当子数组长度为 1 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束</strong></li></ul><figure><img src="/assets/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-DW_-oxQ6.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_6-1-归并排序算法流程" tabindex="-1"><a class="header-anchor" href="#_6-1-归并排序算法流程"><span>6.1 归并排序算法流程</span></a></h3><p><strong>如下图所示，“划分阶段”从顶至底递归地将数组从中点切分为两个子数组：</strong></p><ul><li><strong>计算数组中点 mid ，递归划分左子数组（区间 [left, mid] ）和右子数组（区间 [mid + 1, right] ）</strong></li><li><strong>递归执行步骤 1 ，直至子数组区间长度为 1 时终止</strong></li></ul><blockquote><p><strong>时间复杂度为O(nlogn)、非自适应排序：划分产生高度为logn的递归树，每层合并的总操作数量为n，因此总体时间复杂度为O(nlogn)</strong><br><br><strong>空间复杂度为O(1)、非原地排序：递归深度为logn，使用O(logn)大小的栈帧空间。合并操作需要借助辅助数组实现，使用O(n) 大小的额外空间</strong><br><br><strong>稳定排序：在合并过程中，相等元素的次序保持不变</strong></p></blockquote><p><strong>“合并阶段”从底至顶地将左子数组和右子数组合并为一个有序数组。需要注意的是，从长度为 1 的子数组开始合并，合并阶段中的每个子数组都是有序的</strong></p><figure><img src="/assets/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B-Dz1QYwiA.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>观察发现，归并排序与二叉树后序遍历的递归顺序是一致的</strong></p><ul><li><strong>后序遍历：先递归左子树，再递归右子树，最后处理根节点</strong></li><li><strong>归并排序：先递归左子数组，再递归右子数组，最后处理合并</strong></li></ul><p><strong>归并排序的实现如以下代码所示。请注意，nums 的待合并区间为 [left, right] ，而 tmp 的对应区间为 [0, right - left]</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 合并左子数组和右子数组 */</span>
<span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 左子数组区间为 [left, mid], 右子数组区间为 [mid+1, right]</span>
    <span class="token comment">// 创建一个临时数组 tmp ，用于存放合并后的结果</span>
    <span class="token keyword">int</span> tmpSize <span class="token operator">=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>tmp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>tmpSize <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 初始化左子数组和右子数组的起始索引</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">,</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 当左右子数组都还有元素时，进行比较并将较小的元素复制到临时数组中</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
        <span class="token keyword">else</span> 
        <span class="token punctuation">{</span>
            tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将左子数组和右子数组的剩余元素复制到临时数组中</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> tmpSize<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        nums<span class="token punctuation">[</span>left <span class="token operator">+</span> k<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 释放内存</span>
    <span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 归并排序 */</span>
<span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 终止条件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 当子数组长度为 1 时终止递归</span>
    <span class="token comment">// 划分阶段</span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment">// 计算中点</span>
    <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 递归左子数组</span>
    <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归右子数组</span>
    <span class="token comment">// 合并阶段</span>
    <span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_7-堆排序算法" tabindex="-1"><a class="header-anchor" href="#_7-堆排序算法"><span>7.堆排序算法</span></a></h2><p><strong>堆排序（heap sort）是一种基于堆数据结构实现的高效排序算法。我们可以利用已经学过的“建堆操作”和“元素出堆操作”实现堆排序</strong></p><ul><li><strong>输入数组并建立小顶堆，此时最小元素位于堆顶</strong></li><li><strong>不断执行出堆操作，依次记录出堆元素，即可得到从小到大排序的序列</strong></li></ul><p><strong>以上方法虽然可行，但需要借助一个额外数组来保存弹出的元素，比较浪费空间。在实际中，我们通常使用一种更加优雅的实现方式</strong></p><hr><h3 id="_7-1-堆排序算法流程" tabindex="-1"><a class="header-anchor" href="#_7-1-堆排序算法流程"><span>7.1 堆排序算法流程</span></a></h3><p><strong>设数组的长度为n，堆排序的流程如下图所示：</strong></p><ul><li><strong>输入数组并建立大顶堆。完成后，最大元素位于堆顶</strong></li><li><strong>将堆顶元素（第一个元素）与堆底元素（最后一个元素）交换。完成交换后，堆的长度减1，已排序元素数量加1</strong></li><li><strong>从堆顶元素开始，从顶到底执行堆化操作（sift down）。完成堆化后，堆的性质得到修复</strong></li><li><strong>循环执行第 2 步和第 3 步。循环n-1轮后，即可完成数组排序</strong></li></ul><blockquote><p><strong>时间复杂度为O(nlogn)、非自适应排序：建堆操作使用O(n)时间。从堆中提取最大元素的时间复杂度为O(logn)，共循环n-1轮</strong><br><br><strong>空间复杂度为O(1)、原地排序：几个指针变量使用O(1)空间。元素交换和堆化操作都是在原数组上进行的</strong><br><br><strong>非稳定排序：在交换堆顶元素和堆底元素时，相等元素的相对位置可能发生变化</strong></p></blockquote><figure><img src="/assets/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B-wSZbxsaX.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="/assets/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B2-BZxeEAsY.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>在代码实现中，我们使用了与“堆”章节相同的从顶至底堆化 sift_down() 函数。值得注意的是，由于堆的长度会随着提取最大元素而减小，因此我们需要给 sift_down() 函数添加一个长度参数n，用于指定堆的当前有效长度。代码如下所示：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 堆的长度为 n ，从节点 i 开始，从顶至底堆化 */</span>
<span class="token keyword">void</span> <span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 判断节点 i, l, r 中值最大的节点，记为 ma</span>
        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> ma <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>ma<span class="token punctuation">]</span><span class="token punctuation">)</span>
            ma <span class="token operator">=</span> l<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>ma<span class="token punctuation">]</span><span class="token punctuation">)</span>
            ma <span class="token operator">=</span> r<span class="token punctuation">;</span>
        <span class="token comment">// 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ma <span class="token operator">==</span> i<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 交换两节点</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>ma<span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span>ma<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token comment">// 循环向下堆化</span>
        i <span class="token operator">=</span> ma<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 堆排序 */</span>
<span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 建堆操作：堆化除叶节点以外的其他所有节点</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token function">siftDown</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 从堆中提取最大元素，循环 n-1 轮</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 交换根节点与最右叶节点（交换首元素与尾元素）</span>
        <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        <span class="token comment">// 以根节点为起点，从顶至底进行堆化</span>
        <span class="token function">siftDown</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_8-桶排序算法" tabindex="-1"><a class="header-anchor" href="#_8-桶排序算法"><span>8.桶排序算法</span></a></h2><p><strong>前述几种排序算法都属于“基于比较的排序算法”，它们通过比较元素间的大小来实现排序。此类排序算法的时间复杂度无法超越O(nlogn)。接下来，我们将探讨几种“非比较排序算法”，它们的时间复杂度可以达到线性阶。</strong></p><p><strong>桶排序（bucket sort）是分治策略的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并</strong></p><hr><h3 id="_8-1-桶排序算法流程" tabindex="-1"><a class="header-anchor" href="#_8-1-桶排序算法流程"><span>8.1 桶排序算法流程</span></a></h3><p><strong>考虑一个长度为n的数组，其元素是范围[0，1)内的浮点数。桶排序的流程如下图：</strong></p><ul><li><strong>初始化k个桶，将n个元素分配到k个桶中</strong></li><li><strong>对每个桶分别执行排序（这里采用编程语言的内置排序函数）</strong></li><li><strong>按照桶从小到大的顺序合并结果</strong></li></ul><figure><img src="/assets/%E6%A1%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7-DGTW_iKc.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="/assets/%E6%A1%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-tM2lrxRM.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 桶排序 */</span>
<span class="token keyword">void</span> <span class="token function">bucketSort</span><span class="token punctuation">(</span><span class="token keyword">float</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素</span>
    <span class="token keyword">int</span> k <span class="token operator">=</span> size <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> <span class="token operator">*</span><span class="token operator">*</span>buckets <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 每个桶最多可以分配 size 个元素</span>
        buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 1. 将数组元素分配到各个桶中</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 输入数据范围为 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]</span>
        <span class="token keyword">int</span> bucket_idx <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> k<span class="token punctuation">;</span>
        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果桶中有数据且数据小于当前值 nums[i], 要将其放到当前桶的后面，相当于 cpp 中的 push_back</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>bucket_idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> buckets<span class="token punctuation">[</span>bucket_idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">float</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span> buckets<span class="token punctuation">[</span>bucket_idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>temp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>bucket_idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        buckets<span class="token punctuation">[</span>bucket_idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 2. 对各个桶执行排序</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token function">qsort</span><span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> compare_float<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 3. 遍历桶合并结果</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> 
            <span class="token punctuation">{</span>
                nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> buckets<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 释放上述分配的内存</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">free</span><span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">free</span><span class="token punctuation">(</span>buckets<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_8-2-如何实现平均分配" tabindex="-1"><a class="header-anchor" href="#_8-2-如何实现平均分配"><span>8.2 如何实现平均分配</span></a></h3><p><strong>桶排序的时间复杂度理论上可以达到O(n)，关键在于将元素均匀分配到各个桶中，因为实际数据往往不是均匀分布的。例如，我们想要将淘宝上的所有商品按价格范围平均分配到 10 个桶中，但商品价格分布不均，低于 100 元的非常多，高于 1000 元的非常少。若将价格区间平均划分为 10 个，各个桶中的商品数量差距会非常大</strong></p><p><strong>为实现平均分配，我们可以先设定一条大致的分界线，将数据粗略地分到 3 个桶中。分配完毕后，再将商品较多的桶继续划分为 3 个桶，直至所有桶中的元素数量大致相等</strong></p><p><strong>如下图所示，这种方法本质上是创建一棵递归树，目标是让叶节点的值尽可能平均。当然，不一定要每轮将数据划分为 3 个桶，具体划分方式可根据数据特点灵活选择</strong></p><figure><img src="/assets/%E9%80%92%E5%BD%92%E5%88%92%E5%88%86%E6%A1%B6-DtiW3JUc.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>如果我们提前知道商品价格的概率分布，则可以根据数据概率分布设置每个桶的价格分界线。值得注意的是，数据分布并不一定需要特意统计，也可以根据数据特点采用某种概率模型进行近似</strong></p><p><strong>如下图所示，我们假设商品价格服从正态分布，这样就可以合理地设定价格区间，从而将商品平均分配到各个桶中</strong></p><figure><img src="/assets/%E9%80%92%E5%BD%92%E5%88%92%E5%88%86%E6%A1%B62-DLKIN5qn.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h2 id="_9-计数排序算法" tabindex="-1"><a class="header-anchor" href="#_9-计数排序算法"><span>9.计数排序算法</span></a></h2><p><strong>计数排序（counting sort）通过统计元素数量来实现排序，通常应用于整数数组</strong></p><hr><h3 id="_9-1-计数排序算法的简单实现" tabindex="-1"><a class="header-anchor" href="#_9-1-计数排序算法的简单实现"><span>9.1 计数排序算法的简单实现</span></a></h3><p><strong>先来看一个简单的例子。给定一个长度为n的数组 nums ，其中的元素都是“非负整数”，计数排序的整体流程如下图所示：</strong></p><ul><li><strong>遍历数组，找出其中的最大数字，记为m，然后创建一个长度为m+1的辅助数组 counter</strong></li><li><strong>借助 counter 统计 nums 中各数字的出现次数，其中 counter[num] 对应数字 num 的出现次数。统计方法很简单，只需遍历 nums（设当前数字为 num），每轮将 counter[num] 增加1即可</strong></li><li><strong>由于 counter 的各个索引天然有序，因此相当于所有数字已经排序好了。接下来，我们遍历 counter ，根据各数字出现次数从小到大的顺序填入 nums 即可</strong></li></ul><figure><img src="/assets/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B-DtzTHoy1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 计数排序 */</span>
<span class="token comment">// 简单实现，无法用于排序对象</span>
<span class="token keyword">void</span> <span class="token function">countingSortNaive</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 1. 统计数组最大元素 m</span>
    <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> m<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            m <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 2. 统计各数字的出现次数</span>
    <span class="token comment">// counter[num] 代表 num 的出现次数</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>counter <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        counter<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 3. 遍历 counter ，将各元素填入原数组 nums</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> num <span class="token operator">&lt;</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> num<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> counter<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 4. 释放内存</span>
    <span class="token function">free</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_9-2-计数排序算法的完整实现" tabindex="-1"><a class="header-anchor" href="#_9-2-计数排序算法的完整实现"><span>9.2 计数排序算法的完整实现</span></a></h3><figure><img src="/assets/%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0-CFlOayp4.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="/assets/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B-O3_biWBA.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 计数排序 */</span>
<span class="token comment">// 完整实现，可排序对象，并且是稳定排序</span>
<span class="token keyword">void</span> <span class="token function">countingSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 1. 统计数组最大元素 m</span>
    <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> m<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            m <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 2. 统计各数字的出现次数</span>
    <span class="token comment">// counter[num] 代表 num 的出现次数</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>counter <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        counter<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 3. 求 counter 的前缀和，将“出现次数”转换为“尾索引”</span>
    <span class="token comment">// 即 counter[num]-1 是 num 在 res 中最后一次出现的索引</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        counter<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 4. 倒序遍历 nums ，将各元素填入结果数组 res</span>
    <span class="token comment">// 初始化数组 res 用于记录结果</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>res <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> num <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        res<span class="token punctuation">[</span>counter<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span> <span class="token comment">// 将 num 放置到对应索引处</span>
        counter<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>              <span class="token comment">// 令前缀和自减 1 ，得到下次放置 num 的索引</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 使用结果数组 res 覆盖原数组 nums</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> res<span class="token punctuation">,</span> size <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 5. 释放内存</span>
    <span class="token function">free</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_10-基数排序算法" tabindex="-1"><a class="header-anchor" href="#_10-基数排序算法"><span>10.基数排序算法</span></a></h2><p><strong>基数排序（radix sort）的核心思想与计数排序一致，也通过统计个数来实现排序。在此基础上，基数排序利用数字各位之间的递进关系，依次对每一位进行排序，从而得到最终的排序结果</strong></p><hr><h3 id="_10-1-基数排序算法流程" tabindex="-1"><a class="header-anchor" href="#_10-1-基数排序算法流程"><span>10.1 基数排序算法流程</span></a></h3><p><strong>以学号数据为例，假设数字的最低位是第1位，最高位是第8位，基数排序的流程如下所示：</strong></p><ul><li><strong>初始化位数k=1</strong></li><li><strong>对学号的第k位执行“计数排序”。完成后，数据会根据第k位从小到大排序</strong></li><li><strong>将k增加1，然后返回步骤 2 继续迭代，直到所有位都排序完成后结束</strong></li></ul><blockquote><p><strong>时间复杂度为O(nk)：设数据量为n、据为d进制、最大位数为k，则对某一位执行计数排序使用O(n+d)时间，排序所有k位使用O((n+d)k)时间。通常情况下，d和k都相对较小，时间复杂度趋向O(n)</strong><br><br><strong>空间复杂度为O(n+d)、非原地排序：与计数排序相同，基数排序需要借助长度为n和d的数组 res 和 counter</strong><br><br><strong>稳定排序：当计数排序稳定时，基数排序也稳定；当计数排序不稳定时，基数排序无法保证得到正确的排序结果</strong></p></blockquote><figure><img src="/assets/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-L4XIL4Bm.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 获取元素 num 的第 k 位，其中 exp = 10^(k-1) */</span>
<span class="token keyword">int</span> <span class="token function">digit</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> exp<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>num <span class="token operator">/</span> exp<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 计数排序（根据 nums 第 k 位排序） */</span>
<span class="token keyword">void</span> <span class="token function">countingSortDigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> exp<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 十进制的位范围为 0~9 ，因此需要长度为 10 的桶数组</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>counter <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 统计 0~9 各数字的出现次数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 获取 nums[i] 第 k 位，记为 d</span>
        <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token function">digit</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> exp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 统计数字 d 的出现次数</span>
        counter<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 求前缀和，将“出现个数”转换为“数组索引”</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> counter<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 倒序遍历，根据桶内统计结果，将各元素填入 res</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token function">digit</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> exp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> j <span class="token operator">=</span> counter<span class="token punctuation">[</span>d<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 获取 d 在数组中的索引 j</span>
        res<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// 将当前元素填入索引 j</span>
        counter<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>           <span class="token comment">// 将 d 的数量减 1</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 使用结果覆盖原数组 nums</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 基数排序 */</span>
<span class="token keyword">void</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 获取数组的最大元素，用于判断最大位数</span>
    <span class="token keyword">int</span> max <span class="token operator">=</span> INT32_MIN<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> max<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            max <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 按照从低位到高位的顺序遍历</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> exp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> max <span class="token operator">&gt;=</span> exp<span class="token punctuation">;</span> exp <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">)</span>
        <span class="token comment">// 对数组元素的第 k 位执行计数排序</span>
        <span class="token comment">// k = 1 -&gt; exp = 1</span>
        <span class="token comment">// k = 2 -&gt; exp = 10</span>
        <span class="token comment">// 即 exp = 10^(k-1)</span>
        <span class="token function">countingSortDigit</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> size<span class="token punctuation">,</span> exp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><!--[--><!----><!--]--><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/jimbo-master/edit/main/src/算法学习/1.算法知识/11.排序.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><!----><!----></div></footer><nav class="vp-page-nav"><a class="route-link nav-link prev" href="/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/10.%E6%90%9C%E7%B4%A2.html" aria-label="第十章：搜索"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->第十章：搜索</div></a><a class="route-link nav-link next" href="/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/12.%E5%88%86%E6%B2%BB.html" aria-label="第十二章：分治"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">第十二章：分治<!----></div></a></nav><!----><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><!----><div class="vp-copyright">Copyright © 2024 JimBo </div></footer></div><!--]--><!--]--><!--[--><!----><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-Dezzdk4T.js" defer></script>
  </body>
</html>
