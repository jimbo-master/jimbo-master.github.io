import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,b as t}from"./app-Dezzdk4T.js";const p="/assets/11.C__%E7%89%B9%E6%AE%8A%E7%B1%BB%E8%AE%BE%E8%AE%A1-C_iKvoMc.png",e={},o=t('<h1 id="第十一章-c-特殊类设计" tabindex="-1"><a class="header-anchor" href="#第十一章-c-特殊类设计"><span>第十一章：C++特殊类设计</span></a></h1><h2 id="知识点思维导图" tabindex="-1"><a class="header-anchor" href="#知识点思维导图"><span>知识点思维导图</span></a></h2><figure><img src="'+p+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h2 id="复习代码" tabindex="-1"><a class="header-anchor" href="#复习代码"><span>复习代码</span></a></h2><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">//  Author：jimbo（1353429820@qq.com）</span>
<span class="token comment">//  Filename：main</span>
<span class="token comment">//  Date：2024/1/24</span>
<span class="token comment">//  Description：review knowledge points</span>
<span class="token comment">//  Copyrights（c）JimBo. All rights reserved</span>

<span class="token comment">//特殊类设计</span>
<span class="token comment">//1.只能在堆上创建对象</span>
<span class="token comment">//2.只能在栈上创建对象</span>
<span class="token comment">//3.不能被拷贝</span>
<span class="token comment">//4.不能被继承</span>
<span class="token comment">//5.只能创建一个对象(单例模式)</span>


<span class="token comment">//1.只能在堆上创建对象</span>
<span class="token comment">//实现说明：</span>
<span class="token comment">//①向外部提供的CreateObj函数必须设置为静态成员函数，因为外部调用该接口就是为了获取对象的，而非静态成员函数必须通过对象才能调用</span>
<span class="token comment">//②C++98通过将拷贝构造函数声明为私有以达到防拷贝的目的，C++11可以在拷贝构造函数后面加上=delete，表示让编译器将拷贝构造函数删除，此时也能达到防拷贝的目的</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>

class HeapOnlyClass
<span class="token punctuation">{</span>
 public<span class="token operator">:</span>
    <span class="token comment">//步骤二：提供一个获取对象的接口，并将该接口设置为静态成员函数</span>
    <span class="token keyword">static</span> HeapOnlyClass<span class="token operator">*</span> <span class="token function">CreateObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">return</span> new HeapOnlyClass<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

 private<span class="token operator">:</span>
    <span class="token comment">//步骤一：将构造函数设置为私有</span>
    <span class="token function">HeapOnlyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token comment">//步骤三：防止外部调用拷贝函数在栈上创建对象</span>
    <span class="token comment">//C++98：将拷贝构造函数设置为私有，并且只声明不实现</span>
    <span class="token comment">//HeapOnlyClass(const HeapOnlyClass&amp;);</span>

    <span class="token comment">//C++11：在拷贝构造函数后面加上=delete</span>
    <span class="token function">HeapOnlyClass</span><span class="token punctuation">(</span><span class="token keyword">const</span> HeapOnlyClass<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">//2.只能在栈上创建对象</span>
<span class="token comment">//方法一：将构造函数设置为私有，防止外部直接调用构造函数在堆上创建对象。向外提供一个获取对象的static接口，该接口在栈上创建一个对象返回</span>
<span class="token comment">//缺陷：无法防止外部调用拷贝构造函数创建对象，但是又不能将构造函数设置为私有，也不能用=delete方式将拷贝构造函数删除，因为CreateObj函数</span>
<span class="token comment">//当中创建的是局部对象，返回局部对象的过程势必需要调用拷贝构造函数</span>

<span class="token comment">//方法二：屏蔽operator new函数和operator delete函数</span>
<span class="token comment">//缺陷：无法防止外部在静态区创建对象，比如：static OnlyStackClass obj;//在静态区创建对象</span>

<span class="token comment">//方法一</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>

class OnlyStackClass
<span class="token punctuation">{</span>
 public<span class="token operator">:</span>
    <span class="token comment">//步骤二：提供一个获取对象的接口，并且该接口必须设置为静态成员函数</span>
    <span class="token keyword">static</span> OnlyStackClass <span class="token function">CreateObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">return</span> <span class="token function">OnlyStackClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

 private<span class="token operator">:</span>
    <span class="token comment">//步骤一：将构造函数设置为私有</span>
    <span class="token function">OnlyStackClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//方法二</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
class OnlyStackClass2
<span class="token punctuation">{</span>
 public<span class="token operator">:</span>
    <span class="token function">OnlyStackClass2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
 private<span class="token operator">:</span>
    <span class="token comment">//C++98</span>
    <span class="token keyword">void</span><span class="token operator">*</span> operator <span class="token function">new</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> operator <span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//C++11</span>
    <span class="token comment">//void* operator new(size_t size) = delete;</span>
    <span class="token comment">//void operator delete(void* ptr) = delete;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">//3.不能被拷贝</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
class BanCopyClass
<span class="token punctuation">{</span>
 public<span class="token operator">:</span>
    <span class="token function">BanCopyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
 private<span class="token operator">:</span>
    <span class="token comment">//C++98</span>
    <span class="token function">BanCopyClass</span><span class="token punctuation">(</span><span class="token keyword">const</span> BanCopyClass<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    BanCopyClass<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> BanCopyClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//C++11</span>
    <span class="token comment">//BanCopyClass(const BanCopyClass&amp;) = delete;</span>
    <span class="token comment">//BanCopyClass&amp; operator=(const BanCopyClass&amp;) = delete;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">//4.不能被继承</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
class BanInheritClass
<span class="token punctuation">{</span>
    <span class="token comment">//C++98，不够彻底，这个类仍可被继承，只是被继承后无法实例化出对象</span>
    <span class="token comment">//C++11则是在类外增加关键字final，比如：class BanInheritClass final{...};</span>
 public<span class="token operator">:</span>
    <span class="token keyword">static</span> BanInheritClass <span class="token function">CreateObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">return</span> <span class="token function">BanInheritClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 private<span class="token operator">:</span>
    <span class="token comment">//将构造函数设置为私有</span>
    <span class="token function">BanInheritClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">//5.只能创建一个对象(单例模式)</span>

<span class="token comment">//单例模式是一种设计模式，指的是一个类只能创建一个对象，该模式保证系统中该类只有一个实例，并提供一个全局访问点，该实例被所有程序模块共享</span>
<span class="token comment">//单例模式实现方式：饿汉模式、懒汉模式</span>

<span class="token comment">//饿汉模式实现方法：</span>
<span class="token comment">//1.将构造函数设置为私有，并将拷贝构造函数和赋值运算符重载设置为私有或删除，防止外部创建或拷贝对象</span>
<span class="token comment">//2.提供一个指向单例对象的static指针，并在程序入口之前完成单例对象的初始化</span>
<span class="token comment">//3.提供一个全局访问点获取单例对象</span>

<span class="token comment">//饿汉模式的线程安全问题</span>
<span class="token comment">//饿汉模式在程序运行主程序之前就完成了单例对象的创建，由于main函数之前是不存在多线程的，因此饿汉模式下单例对象的创建是线程安全的</span>
<span class="token comment">//后续所有多线程要访问这个单例对象，都需要通过调用GetInstance函数来获取，这个获取是不需要加锁的，因为这是一个读操作</span>
<span class="token comment">//当然，如果线程通过GetInstance获取到单例对象后，要用这个单例对象进行一些线程不安全的操作，那么这时就需要加锁了</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>

class Singleton
<span class="token punctuation">{</span>
 public<span class="token operator">:</span>
    <span class="token comment">//3.提供一个全局访问点获取单例对象</span>
    <span class="token keyword">static</span> Singleton<span class="token operator">*</span> <span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">return</span> singlePtr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 private<span class="token operator">:</span>
    <span class="token comment">//1.将构造函数设置为私有</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span>
    Singleton<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span>

    <span class="token comment">//2.提供一个指向单例对象的static指针</span>
    <span class="token keyword">static</span> Singleton<span class="token operator">*</span> singlePtr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//在程序入口之前完成单例对象的初始化</span>
Singleton<span class="token operator">*</span> Singleton<span class="token operator">::</span>singlePtr <span class="token operator">=</span> new Singleton<span class="token punctuation">;</span>



<span class="token comment">//懒汉模式实现方法：</span>
<span class="token comment">//1.将构造函数设置为私有，并将拷贝构造函数和赋值运算符重载函数设置为私有或删除，防止外部创建或拷贝对象</span>
<span class="token comment">//2.提供一个指向单例对象的static指针，并在程序入口之前现将其初始化为空</span>
<span class="token comment">//3.提供一个全局访问点获取单例对象</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;mutex&gt;</span></span>
class Singleton
<span class="token punctuation">{</span>
 public<span class="token operator">:</span>
    <span class="token comment">//3.提供一个全局访问点获取单例对象</span>
    <span class="token keyword">static</span> Singleton<span class="token operator">*</span> <span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token comment">//双检查</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>singlePtr <span class="token operator">==</span> nullptr<span class="token punctuation">)</span>
       <span class="token punctuation">{</span>
          mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span><span class="token punctuation">(</span>singlePtr <span class="token operator">==</span> nullptr<span class="token punctuation">)</span>
          <span class="token punctuation">{</span>
             singlePtr <span class="token operator">=</span> new Singleton<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">return</span> singlePtr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 private<span class="token operator">:</span>
    <span class="token comment">//1.将构造函数设置为私有，并防拷贝</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span>
    Singleton<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span>

    <span class="token comment">//2.提供一个指向单例对象的static指针</span>
    <span class="token keyword">static</span> Singleton<span class="token operator">*</span> singlePtr<span class="token punctuation">;</span>
    <span class="token keyword">static</span> std<span class="token operator">::</span>mutex mtx<span class="token punctuation">;</span><span class="token comment">//互斥锁</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//在程序入口前先将static指针初始化为空</span>
Singleton<span class="token operator">*</span> Singleton<span class="token operator">::</span>singlePtr <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
std<span class="token operator">::</span>mutex Singleton<span class="token operator">::</span>mtx<span class="token punctuation">;</span> <span class="token comment">//初始化互斥锁</span>


<span class="token comment">//懒汉模式实现方法：</span>
<span class="token comment">//1.将构造函数设置为私有，并将拷贝构造函数和赋值运算符重载函数设置为私有或删除，防止外部创建或拷贝对象</span>
<span class="token comment">//2.提供一个指向单例对象的static指针，并在程序入口之前现将其初始化为空</span>
<span class="token comment">//3.提供一个全局访问点获取单例对象</span>

<span class="token comment">//懒汉模式线程安全问题：</span>
<span class="token comment">//懒汉模式在程序运行之前没有进行单例对象的创建，而是等到某个线程需要使用这个单例对象时再进行创建，也就是GetInstance函数第一次被调用的时创建单例对象</span>
<span class="token comment">//因此在调用GetInstance函数获取单例对象时，先判断这个static指针是否为空，如果为空则说明这个单例对象还没有被创建，此时需要先创建这个单例对象然后再将单例对象返回</span>
<span class="token comment">//GetInstance函数第一次调用需要对static指针进行写入操作，这个过程不是线程安全的，因为多个线程可能同时调用GetInstance函数，如果不对这个过程进行保护，此时多个线程就会各自创建处一个对象</span>

<span class="token comment">//双检查加锁：</span>
<span class="token comment">//对GetInstance函数中创建单例对象的过程进行保护，本质就是需要引入互斥锁，最简单的加锁方式就是在进行if判断之前加锁，在整个if语句之后进行解锁</span>
<span class="token comment">//但实际只有GetInstance函数第一次被调用，创建单例对象时需要使用互斥锁进行保护，而后续调用GetInstance函数获取单例对象只是一个读操作，是不需要使用互斥锁进行保护的</span>
<span class="token comment">//如果简单的将加锁解锁操作放到if语句前后，那么在后续调用GetInstance函数获取已经创建好的单例对象时，就会进行大量无意义的加锁解锁操作，导致线程不断切入切出，进而影响程序运行效率</span>
<span class="token comment">//对于这种只有第一次需要加锁保护的场景可以使用双检查加锁，双检查就是在当前加锁和解锁的外面再进行一次if判断，判断static指针是否为空</span>
<span class="token comment">//这样一来，后续调用GetInstance函数获取已经创建好的单例对象时，外层新加的if判断就会起作用，这样就避免了后续无意义的加锁解锁操作</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;mutex&gt;</span></span>
class Singleton
<span class="token punctuation">{</span>
 public<span class="token operator">:</span>
    <span class="token comment">//3.提供一个全局访问点获取单例对象</span>
    <span class="token keyword">static</span> Singleton<span class="token operator">*</span> <span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token comment">//双检查</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>singlePtr <span class="token operator">==</span> nullptr<span class="token punctuation">)</span>
       <span class="token punctuation">{</span>
          mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span><span class="token punctuation">(</span>singlePtr <span class="token operator">==</span> nullptr<span class="token punctuation">)</span>
          <span class="token punctuation">{</span>
             singlePtr <span class="token operator">=</span> new Singleton<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
          mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">return</span> singlePtr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 private<span class="token operator">:</span>
    <span class="token comment">//1.将构造函数设置为私有，并防拷贝</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span>
    Singleton<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span>

    <span class="token comment">//2.提供一个指向单例对象的static指针</span>
    <span class="token keyword">static</span> Singleton<span class="token operator">*</span> singlePtr<span class="token punctuation">;</span>
    <span class="token keyword">static</span> std<span class="token operator">::</span>mutex mtx<span class="token punctuation">;</span><span class="token comment">//互斥锁</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//在程序入口前先将static指针初始化为空</span>
Singleton<span class="token operator">*</span> Singleton<span class="token operator">::</span>singlePtr <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
std<span class="token operator">::</span>mutex Singleton<span class="token operator">::</span>mtx<span class="token punctuation">;</span> <span class="token comment">//初始化互斥锁</span>


<span class="token comment">//其他版本的懒汉模式实现方式</span>
<span class="token comment">//1.将构造函数设置为私有，并将拷贝构造函数和赋值运算符重载函数设置为私有或删除，防止外部创建或拷贝对象</span>
<span class="token comment">//2.提供一个全局访问点获取单例对象</span>

<span class="token comment">//这种版本的懒汉主要有如下两个缺点：</span>
<span class="token comment">//单例对象定义在静态区，因此太大的单例对象不适合使用这种方式</span>
<span class="token comment">//单例对象创建在静态区后没办法主动释放</span>

<span class="token comment">//如果要考虑单例对象的释放，可以参考以下两种方式：</span>
<span class="token comment">//1.在单例类中编写一个DelInstance函数，在该函数中进行单例对象的释放动作，当不再需要该单例对象时就可以主动调用DelInstance释放单例对象</span>
<span class="token comment">//2.在单例类中实现一个内嵌的垃圾回收类，在垃圾回收类的析构函数中完成单例对象的释放。在单例类中定义一个静态的垃圾回收类对象，当该对象被消耗时就会调用其析构函数，这时便对单例对象进行了释放</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
class Singleton
<span class="token punctuation">{</span>
 public<span class="token operator">:</span>
    <span class="token comment">//2.提供一个全局访问点获取单例对象</span>
    <span class="token keyword">static</span> Singleton<span class="token operator">*</span> <span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">static</span> Singleton singlePtr<span class="token punctuation">;</span>
       <span class="token keyword">return</span> <span class="token operator">&amp;</span>singlePtr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 private<span class="token operator">:</span>
    <span class="token comment">//1.将构造函数设置为私有，并防止拷贝</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span>
    Singleton<span class="token operator">&amp;</span> operator<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> delete<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">//单例对象释放：方法一</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">DelInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    _mtx<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_inst <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       delete _inst<span class="token punctuation">;</span>
       _inst <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    _mtx<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//单例对象释放：方法二(垃圾回收类)</span>
class CGarbo
<span class="token punctuation">{</span>
public<span class="token operator">:</span>
    <span class="token operator">~</span><span class="token function">CGarbo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>_inst <span class="token operator">!=</span> nullptr<span class="token punctuation">)</span>
       <span class="token punctuation">{</span>
          delete _inst<span class="token punctuation">;</span>
          _inst <span class="token operator">=</span> nullptr<span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,6),c=[o];function l(i,u){return s(),a("div",null,c)}const d=n(e,[["render",l],["__file","11.C__特殊类设计.html.vue"]]),m=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/2.CPP/11.C__%E7%89%B9%E6%AE%8A%E7%B1%BB%E8%AE%BE%E8%AE%A1.html","title":"第十一章：C++特殊类设计","lang":"zh-CN","frontmatter":{"date":"2024-02-11T00:00:00.000Z","order":12,"description":"第十一章：C++特殊类设计 知识点思维导图 复习代码","head":[["meta",{"property":"og:url","content":"https://github.com/jimbo-master/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/2.CPP/11.C__%E7%89%B9%E6%AE%8A%E7%B1%BB%E8%AE%BE%E8%AE%A1.html"}],["meta",{"property":"og:site_name","content":"JimBoの学习妙妙屋"}],["meta",{"property":"og:title","content":"第十一章：C++特殊类设计"}],["meta",{"property":"og:description","content":"第十一章：C++特殊类设计 知识点思维导图 复习代码"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"JimBo"}],["meta",{"property":"article:published_time","content":"2024-02-11T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第十一章：C++特殊类设计\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-02-11T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JimBo\\",\\"url\\":\\"https://github.com/jimbo-master\\"}]}"]]},"headers":[{"level":2,"title":"知识点思维导图","slug":"知识点思维导图","link":"#知识点思维导图","children":[]},{"level":2,"title":"复习代码","slug":"复习代码","link":"#复习代码","children":[]}],"git":{},"readingTime":{"minutes":8.9,"words":2669},"filePathRelative":"编程学习/2.CPP/11.C++特殊类设计.md","localizedDate":"2024年2月11日","autoDesc":true,"excerpt":"\\n<h2>知识点思维导图</h2>\\n<figure><figcaption></figcaption></figure>\\n<hr>\\n<h2>复习代码</h2>\\n<div class=\\"language-c\\" data-ext=\\"c\\" data-title=\\"c\\"><pre class=\\"language-c\\"><code><span class=\\"token comment\\">//  Author：jimbo（1353429820@qq.com）</span>\\n<span class=\\"token comment\\">//  Filename：main</span>\\n<span class=\\"token comment\\">//  Date：2024/1/24</span>\\n<span class=\\"token comment\\">//  Description：review knowledge points</span>\\n<span class=\\"token comment\\">//  Copyrights（c）JimBo. All rights reserved</span>\\n\\n<span class=\\"token comment\\">//特殊类设计</span>\\n<span class=\\"token comment\\">//1.只能在堆上创建对象</span>\\n<span class=\\"token comment\\">//2.只能在栈上创建对象</span>\\n<span class=\\"token comment\\">//3.不能被拷贝</span>\\n<span class=\\"token comment\\">//4.不能被继承</span>\\n<span class=\\"token comment\\">//5.只能创建一个对象(单例模式)</span>\\n\\n\\n<span class=\\"token comment\\">//1.只能在堆上创建对象</span>\\n<span class=\\"token comment\\">//实现说明：</span>\\n<span class=\\"token comment\\">//①向外部提供的CreateObj函数必须设置为静态成员函数，因为外部调用该接口就是为了获取对象的，而非静态成员函数必须通过对象才能调用</span>\\n<span class=\\"token comment\\">//②C++98通过将拷贝构造函数声明为私有以达到防拷贝的目的，C++11可以在拷贝构造函数后面加上=delete，表示让编译器将拷贝构造函数删除，此时也能达到防拷贝的目的</span>\\n\\n<span class=\\"token macro property\\"><span class=\\"token directive-hash\\">#</span><span class=\\"token directive keyword\\">include</span><span class=\\"token string\\">&lt;iostream&gt;</span></span>\\n\\nclass HeapOnlyClass\\n<span class=\\"token punctuation\\">{</span>\\n public<span class=\\"token operator\\">:</span>\\n    <span class=\\"token comment\\">//步骤二：提供一个获取对象的接口，并将该接口设置为静态成员函数</span>\\n    <span class=\\"token keyword\\">static</span> HeapOnlyClass<span class=\\"token operator\\">*</span> <span class=\\"token function\\">CreateObj</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span>\\n    <span class=\\"token punctuation\\">{</span>\\n       <span class=\\"token keyword\\">return</span> new HeapOnlyClass<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n\\n private<span class=\\"token operator\\">:</span>\\n    <span class=\\"token comment\\">//步骤一：将构造函数设置为私有</span>\\n    <span class=\\"token function\\">HeapOnlyClass</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span><span class=\\"token punctuation\\">}</span>\\n\\n    <span class=\\"token comment\\">//步骤三：防止外部调用拷贝函数在栈上创建对象</span>\\n    <span class=\\"token comment\\">//C++98：将拷贝构造函数设置为私有，并且只声明不实现</span>\\n    <span class=\\"token comment\\">//HeapOnlyClass(const HeapOnlyClass&amp;);</span>\\n\\n    <span class=\\"token comment\\">//C++11：在拷贝构造函数后面加上=delete</span>\\n    <span class=\\"token function\\">HeapOnlyClass</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">const</span> HeapOnlyClass<span class=\\"token operator\\">&amp;</span><span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">=</span> delete<span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n\\n<span class=\\"token comment\\">//2.只能在栈上创建对象</span>\\n<span class=\\"token comment\\">//方法一：将构造函数设置为私有，防止外部直接调用构造函数在堆上创建对象。向外提供一个获取对象的static接口，该接口在栈上创建一个对象返回</span>\\n<span class=\\"token comment\\">//缺陷：无法防止外部调用拷贝构造函数创建对象，但是又不能将构造函数设置为私有，也不能用=delete方式将拷贝构造函数删除，因为CreateObj函数</span>\\n<span class=\\"token comment\\">//当中创建的是局部对象，返回局部对象的过程势必需要调用拷贝构造函数</span>\\n\\n<span class=\\"token comment\\">//方法二：屏蔽operator new函数和operator delete函数</span>\\n<span class=\\"token comment\\">//缺陷：无法防止外部在静态区创建对象，比如：static OnlyStackClass obj;//在静态区创建对象</span>\\n\\n<span class=\\"token comment\\">//方法一</span>\\n<span class=\\"token macro property\\"><span class=\\"token directive-hash\\">#</span><span class=\\"token directive keyword\\">include</span><span class=\\"token string\\">&lt;iostream&gt;</span></span>\\n\\nclass OnlyStackClass\\n<span class=\\"token punctuation\\">{</span>\\n public<span class=\\"token operator\\">:</span>\\n    <span class=\\"token comment\\">//步骤二：提供一个获取对象的接口，并且该接口必须设置为静态成员函数</span>\\n    <span class=\\"token keyword\\">static</span> OnlyStackClass <span class=\\"token function\\">CreateObj</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span>\\n    <span class=\\"token punctuation\\">{</span>\\n       <span class=\\"token keyword\\">return</span> <span class=\\"token function\\">OnlyStackClass</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n\\n private<span class=\\"token operator\\">:</span>\\n    <span class=\\"token comment\\">//步骤一：将构造函数设置为私有</span>\\n    <span class=\\"token function\\">OnlyStackClass</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span><span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token comment\\">//方法二</span>\\n<span class=\\"token macro property\\"><span class=\\"token directive-hash\\">#</span><span class=\\"token directive keyword\\">include</span><span class=\\"token string\\">&lt;iostream&gt;</span></span>\\nclass OnlyStackClass2\\n<span class=\\"token punctuation\\">{</span>\\n public<span class=\\"token operator\\">:</span>\\n    <span class=\\"token function\\">OnlyStackClass2</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span><span class=\\"token punctuation\\">}</span>\\n private<span class=\\"token operator\\">:</span>\\n    <span class=\\"token comment\\">//C++98</span>\\n    <span class=\\"token keyword\\">void</span><span class=\\"token operator\\">*</span> operator <span class=\\"token function\\">new</span><span class=\\"token punctuation\\">(</span><span class=\\"token class-name\\">size_t</span> size<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token keyword\\">void</span> operator <span class=\\"token function\\">delete</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">void</span><span class=\\"token operator\\">*</span> ptr<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token comment\\">//C++11</span>\\n    <span class=\\"token comment\\">//void* operator new(size_t size) = delete;</span>\\n    <span class=\\"token comment\\">//void operator delete(void* ptr) = delete;</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n\\n<span class=\\"token comment\\">//3.不能被拷贝</span>\\n<span class=\\"token macro property\\"><span class=\\"token directive-hash\\">#</span><span class=\\"token directive keyword\\">include</span><span class=\\"token string\\">&lt;iostream&gt;</span></span>\\nclass BanCopyClass\\n<span class=\\"token punctuation\\">{</span>\\n public<span class=\\"token operator\\">:</span>\\n    <span class=\\"token function\\">BanCopyClass</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span><span class=\\"token punctuation\\">}</span>\\n private<span class=\\"token operator\\">:</span>\\n    <span class=\\"token comment\\">//C++98</span>\\n    <span class=\\"token function\\">BanCopyClass</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">const</span> BanCopyClass<span class=\\"token operator\\">&amp;</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    BanCopyClass<span class=\\"token operator\\">&amp;</span> operator<span class=\\"token operator\\">=</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">const</span> BanCopyClass<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token comment\\">//C++11</span>\\n    <span class=\\"token comment\\">//BanCopyClass(const BanCopyClass&amp;) = delete;</span>\\n    <span class=\\"token comment\\">//BanCopyClass&amp; operator=(const BanCopyClass&amp;) = delete;</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n\\n<span class=\\"token comment\\">//4.不能被继承</span>\\n<span class=\\"token macro property\\"><span class=\\"token directive-hash\\">#</span><span class=\\"token directive keyword\\">include</span><span class=\\"token string\\">&lt;iostream&gt;</span></span>\\nclass BanInheritClass\\n<span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token comment\\">//C++98，不够彻底，这个类仍可被继承，只是被继承后无法实例化出对象</span>\\n    <span class=\\"token comment\\">//C++11则是在类外增加关键字final，比如：class BanInheritClass final{...};</span>\\n public<span class=\\"token operator\\">:</span>\\n    <span class=\\"token keyword\\">static</span> BanInheritClass <span class=\\"token function\\">CreateObj</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span>\\n    <span class=\\"token punctuation\\">{</span>\\n       <span class=\\"token keyword\\">return</span> <span class=\\"token function\\">BanInheritClass</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n private<span class=\\"token operator\\">:</span>\\n    <span class=\\"token comment\\">//将构造函数设置为私有</span>\\n    <span class=\\"token function\\">BanInheritClass</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span><span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n\\n<span class=\\"token comment\\">//5.只能创建一个对象(单例模式)</span>\\n\\n<span class=\\"token comment\\">//单例模式是一种设计模式，指的是一个类只能创建一个对象，该模式保证系统中该类只有一个实例，并提供一个全局访问点，该实例被所有程序模块共享</span>\\n<span class=\\"token comment\\">//单例模式实现方式：饿汉模式、懒汉模式</span>\\n\\n<span class=\\"token comment\\">//饿汉模式实现方法：</span>\\n<span class=\\"token comment\\">//1.将构造函数设置为私有，并将拷贝构造函数和赋值运算符重载设置为私有或删除，防止外部创建或拷贝对象</span>\\n<span class=\\"token comment\\">//2.提供一个指向单例对象的static指针，并在程序入口之前完成单例对象的初始化</span>\\n<span class=\\"token comment\\">//3.提供一个全局访问点获取单例对象</span>\\n\\n<span class=\\"token comment\\">//饿汉模式的线程安全问题</span>\\n<span class=\\"token comment\\">//饿汉模式在程序运行主程序之前就完成了单例对象的创建，由于main函数之前是不存在多线程的，因此饿汉模式下单例对象的创建是线程安全的</span>\\n<span class=\\"token comment\\">//后续所有多线程要访问这个单例对象，都需要通过调用GetInstance函数来获取，这个获取是不需要加锁的，因为这是一个读操作</span>\\n<span class=\\"token comment\\">//当然，如果线程通过GetInstance获取到单例对象后，要用这个单例对象进行一些线程不安全的操作，那么这时就需要加锁了</span>\\n\\n<span class=\\"token macro property\\"><span class=\\"token directive-hash\\">#</span><span class=\\"token directive keyword\\">include</span><span class=\\"token string\\">&lt;iostream&gt;</span></span>\\n\\nclass Singleton\\n<span class=\\"token punctuation\\">{</span>\\n public<span class=\\"token operator\\">:</span>\\n    <span class=\\"token comment\\">//3.提供一个全局访问点获取单例对象</span>\\n    <span class=\\"token keyword\\">static</span> Singleton<span class=\\"token operator\\">*</span> <span class=\\"token function\\">GetInstance</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span>\\n    <span class=\\"token punctuation\\">{</span>\\n       <span class=\\"token keyword\\">return</span> singlePtr<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n private<span class=\\"token operator\\">:</span>\\n    <span class=\\"token comment\\">//1.将构造函数设置为私有</span>\\n    <span class=\\"token function\\">Singleton</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span><span class=\\"token punctuation\\">}</span>\\n    <span class=\\"token function\\">Singleton</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">const</span> Singleton<span class=\\"token operator\\">&amp;</span><span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">=</span> delete<span class=\\"token punctuation\\">;</span>\\n    Singleton<span class=\\"token operator\\">&amp;</span> operator<span class=\\"token operator\\">=</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">const</span> Singleton<span class=\\"token operator\\">&amp;</span><span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">=</span> delete<span class=\\"token punctuation\\">;</span>\\n\\n    <span class=\\"token comment\\">//2.提供一个指向单例对象的static指针</span>\\n    <span class=\\"token keyword\\">static</span> Singleton<span class=\\"token operator\\">*</span> singlePtr<span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token comment\\">//在程序入口之前完成单例对象的初始化</span>\\nSingleton<span class=\\"token operator\\">*</span> Singleton<span class=\\"token operator\\">::</span>singlePtr <span class=\\"token operator\\">=</span> new Singleton<span class=\\"token punctuation\\">;</span>\\n\\n\\n\\n<span class=\\"token comment\\">//懒汉模式实现方法：</span>\\n<span class=\\"token comment\\">//1.将构造函数设置为私有，并将拷贝构造函数和赋值运算符重载函数设置为私有或删除，防止外部创建或拷贝对象</span>\\n<span class=\\"token comment\\">//2.提供一个指向单例对象的static指针，并在程序入口之前现将其初始化为空</span>\\n<span class=\\"token comment\\">//3.提供一个全局访问点获取单例对象</span>\\n\\n<span class=\\"token macro property\\"><span class=\\"token directive-hash\\">#</span><span class=\\"token directive keyword\\">include</span><span class=\\"token string\\">&lt;iostream&gt;</span></span>\\n<span class=\\"token macro property\\"><span class=\\"token directive-hash\\">#</span><span class=\\"token directive keyword\\">include</span><span class=\\"token string\\">&lt;mutex&gt;</span></span>\\nclass Singleton\\n<span class=\\"token punctuation\\">{</span>\\n public<span class=\\"token operator\\">:</span>\\n    <span class=\\"token comment\\">//3.提供一个全局访问点获取单例对象</span>\\n    <span class=\\"token keyword\\">static</span> Singleton<span class=\\"token operator\\">*</span> <span class=\\"token function\\">GetInstance</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span>\\n    <span class=\\"token punctuation\\">{</span>\\n       <span class=\\"token comment\\">//双检查</span>\\n       <span class=\\"token keyword\\">if</span><span class=\\"token punctuation\\">(</span>singlePtr <span class=\\"token operator\\">==</span> nullptr<span class=\\"token punctuation\\">)</span>\\n       <span class=\\"token punctuation\\">{</span>\\n          mtx<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">lock</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n          <span class=\\"token keyword\\">if</span><span class=\\"token punctuation\\">(</span>singlePtr <span class=\\"token operator\\">==</span> nullptr<span class=\\"token punctuation\\">)</span>\\n          <span class=\\"token punctuation\\">{</span>\\n             singlePtr <span class=\\"token operator\\">=</span> new Singleton<span class=\\"token punctuation\\">;</span>\\n          <span class=\\"token punctuation\\">}</span>\\n          mtx<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">unlock</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n       <span class=\\"token punctuation\\">}</span>\\n       <span class=\\"token keyword\\">return</span> singlePtr<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n private<span class=\\"token operator\\">:</span>\\n    <span class=\\"token comment\\">//1.将构造函数设置为私有，并防拷贝</span>\\n    <span class=\\"token function\\">Singleton</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span><span class=\\"token punctuation\\">}</span>\\n    <span class=\\"token function\\">Singleton</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">const</span> Singleton<span class=\\"token operator\\">&amp;</span><span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">=</span> delete<span class=\\"token punctuation\\">;</span>\\n    Singleton<span class=\\"token operator\\">&amp;</span> operator<span class=\\"token operator\\">=</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">const</span> Singleton<span class=\\"token operator\\">&amp;</span><span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">=</span> delete<span class=\\"token punctuation\\">;</span>\\n\\n    <span class=\\"token comment\\">//2.提供一个指向单例对象的static指针</span>\\n    <span class=\\"token keyword\\">static</span> Singleton<span class=\\"token operator\\">*</span> singlePtr<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token keyword\\">static</span> std<span class=\\"token operator\\">::</span>mutex mtx<span class=\\"token punctuation\\">;</span><span class=\\"token comment\\">//互斥锁</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token comment\\">//在程序入口前先将static指针初始化为空</span>\\nSingleton<span class=\\"token operator\\">*</span> Singleton<span class=\\"token operator\\">::</span>singlePtr <span class=\\"token operator\\">=</span> nullptr<span class=\\"token punctuation\\">;</span>\\nstd<span class=\\"token operator\\">::</span>mutex Singleton<span class=\\"token operator\\">::</span>mtx<span class=\\"token punctuation\\">;</span> <span class=\\"token comment\\">//初始化互斥锁</span>\\n\\n\\n<span class=\\"token comment\\">//懒汉模式实现方法：</span>\\n<span class=\\"token comment\\">//1.将构造函数设置为私有，并将拷贝构造函数和赋值运算符重载函数设置为私有或删除，防止外部创建或拷贝对象</span>\\n<span class=\\"token comment\\">//2.提供一个指向单例对象的static指针，并在程序入口之前现将其初始化为空</span>\\n<span class=\\"token comment\\">//3.提供一个全局访问点获取单例对象</span>\\n\\n<span class=\\"token comment\\">//懒汉模式线程安全问题：</span>\\n<span class=\\"token comment\\">//懒汉模式在程序运行之前没有进行单例对象的创建，而是等到某个线程需要使用这个单例对象时再进行创建，也就是GetInstance函数第一次被调用的时创建单例对象</span>\\n<span class=\\"token comment\\">//因此在调用GetInstance函数获取单例对象时，先判断这个static指针是否为空，如果为空则说明这个单例对象还没有被创建，此时需要先创建这个单例对象然后再将单例对象返回</span>\\n<span class=\\"token comment\\">//GetInstance函数第一次调用需要对static指针进行写入操作，这个过程不是线程安全的，因为多个线程可能同时调用GetInstance函数，如果不对这个过程进行保护，此时多个线程就会各自创建处一个对象</span>\\n\\n<span class=\\"token comment\\">//双检查加锁：</span>\\n<span class=\\"token comment\\">//对GetInstance函数中创建单例对象的过程进行保护，本质就是需要引入互斥锁，最简单的加锁方式就是在进行if判断之前加锁，在整个if语句之后进行解锁</span>\\n<span class=\\"token comment\\">//但实际只有GetInstance函数第一次被调用，创建单例对象时需要使用互斥锁进行保护，而后续调用GetInstance函数获取单例对象只是一个读操作，是不需要使用互斥锁进行保护的</span>\\n<span class=\\"token comment\\">//如果简单的将加锁解锁操作放到if语句前后，那么在后续调用GetInstance函数获取已经创建好的单例对象时，就会进行大量无意义的加锁解锁操作，导致线程不断切入切出，进而影响程序运行效率</span>\\n<span class=\\"token comment\\">//对于这种只有第一次需要加锁保护的场景可以使用双检查加锁，双检查就是在当前加锁和解锁的外面再进行一次if判断，判断static指针是否为空</span>\\n<span class=\\"token comment\\">//这样一来，后续调用GetInstance函数获取已经创建好的单例对象时，外层新加的if判断就会起作用，这样就避免了后续无意义的加锁解锁操作</span>\\n\\n<span class=\\"token macro property\\"><span class=\\"token directive-hash\\">#</span><span class=\\"token directive keyword\\">include</span><span class=\\"token string\\">&lt;iostream&gt;</span></span>\\n<span class=\\"token macro property\\"><span class=\\"token directive-hash\\">#</span><span class=\\"token directive keyword\\">include</span><span class=\\"token string\\">&lt;mutex&gt;</span></span>\\nclass Singleton\\n<span class=\\"token punctuation\\">{</span>\\n public<span class=\\"token operator\\">:</span>\\n    <span class=\\"token comment\\">//3.提供一个全局访问点获取单例对象</span>\\n    <span class=\\"token keyword\\">static</span> Singleton<span class=\\"token operator\\">*</span> <span class=\\"token function\\">GetInstance</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span>\\n    <span class=\\"token punctuation\\">{</span>\\n       <span class=\\"token comment\\">//双检查</span>\\n       <span class=\\"token keyword\\">if</span><span class=\\"token punctuation\\">(</span>singlePtr <span class=\\"token operator\\">==</span> nullptr<span class=\\"token punctuation\\">)</span>\\n       <span class=\\"token punctuation\\">{</span>\\n          mtx<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">lock</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n          <span class=\\"token keyword\\">if</span><span class=\\"token punctuation\\">(</span>singlePtr <span class=\\"token operator\\">==</span> nullptr<span class=\\"token punctuation\\">)</span>\\n          <span class=\\"token punctuation\\">{</span>\\n             singlePtr <span class=\\"token operator\\">=</span> new Singleton<span class=\\"token punctuation\\">;</span>\\n          <span class=\\"token punctuation\\">}</span>\\n          mtx<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">unlock</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n       <span class=\\"token punctuation\\">}</span>\\n       <span class=\\"token keyword\\">return</span> singlePtr<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n private<span class=\\"token operator\\">:</span>\\n    <span class=\\"token comment\\">//1.将构造函数设置为私有，并防拷贝</span>\\n    <span class=\\"token function\\">Singleton</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span><span class=\\"token punctuation\\">}</span>\\n    <span class=\\"token function\\">Singleton</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">const</span> Singleton<span class=\\"token operator\\">&amp;</span><span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">=</span> delete<span class=\\"token punctuation\\">;</span>\\n    Singleton<span class=\\"token operator\\">&amp;</span> operator<span class=\\"token operator\\">=</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">const</span> Singleton<span class=\\"token operator\\">&amp;</span><span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">=</span> delete<span class=\\"token punctuation\\">;</span>\\n\\n    <span class=\\"token comment\\">//2.提供一个指向单例对象的static指针</span>\\n    <span class=\\"token keyword\\">static</span> Singleton<span class=\\"token operator\\">*</span> singlePtr<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token keyword\\">static</span> std<span class=\\"token operator\\">::</span>mutex mtx<span class=\\"token punctuation\\">;</span><span class=\\"token comment\\">//互斥锁</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token comment\\">//在程序入口前先将static指针初始化为空</span>\\nSingleton<span class=\\"token operator\\">*</span> Singleton<span class=\\"token operator\\">::</span>singlePtr <span class=\\"token operator\\">=</span> nullptr<span class=\\"token punctuation\\">;</span>\\nstd<span class=\\"token operator\\">::</span>mutex Singleton<span class=\\"token operator\\">::</span>mtx<span class=\\"token punctuation\\">;</span> <span class=\\"token comment\\">//初始化互斥锁</span>\\n\\n\\n<span class=\\"token comment\\">//其他版本的懒汉模式实现方式</span>\\n<span class=\\"token comment\\">//1.将构造函数设置为私有，并将拷贝构造函数和赋值运算符重载函数设置为私有或删除，防止外部创建或拷贝对象</span>\\n<span class=\\"token comment\\">//2.提供一个全局访问点获取单例对象</span>\\n\\n<span class=\\"token comment\\">//这种版本的懒汉主要有如下两个缺点：</span>\\n<span class=\\"token comment\\">//单例对象定义在静态区，因此太大的单例对象不适合使用这种方式</span>\\n<span class=\\"token comment\\">//单例对象创建在静态区后没办法主动释放</span>\\n\\n<span class=\\"token comment\\">//如果要考虑单例对象的释放，可以参考以下两种方式：</span>\\n<span class=\\"token comment\\">//1.在单例类中编写一个DelInstance函数，在该函数中进行单例对象的释放动作，当不再需要该单例对象时就可以主动调用DelInstance释放单例对象</span>\\n<span class=\\"token comment\\">//2.在单例类中实现一个内嵌的垃圾回收类，在垃圾回收类的析构函数中完成单例对象的释放。在单例类中定义一个静态的垃圾回收类对象，当该对象被消耗时就会调用其析构函数，这时便对单例对象进行了释放</span>\\n\\n<span class=\\"token macro property\\"><span class=\\"token directive-hash\\">#</span><span class=\\"token directive keyword\\">include</span><span class=\\"token string\\">&lt;iostream&gt;</span></span>\\nclass Singleton\\n<span class=\\"token punctuation\\">{</span>\\n public<span class=\\"token operator\\">:</span>\\n    <span class=\\"token comment\\">//2.提供一个全局访问点获取单例对象</span>\\n    <span class=\\"token keyword\\">static</span> Singleton<span class=\\"token operator\\">*</span> <span class=\\"token function\\">GetInstance</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span>\\n    <span class=\\"token punctuation\\">{</span>\\n       <span class=\\"token keyword\\">static</span> Singleton singlePtr<span class=\\"token punctuation\\">;</span>\\n       <span class=\\"token keyword\\">return</span> <span class=\\"token operator\\">&amp;</span>singlePtr<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n private<span class=\\"token operator\\">:</span>\\n    <span class=\\"token comment\\">//1.将构造函数设置为私有，并防止拷贝</span>\\n    <span class=\\"token function\\">Singleton</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span><span class=\\"token punctuation\\">}</span>\\n    <span class=\\"token function\\">Singleton</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">const</span> Singleton<span class=\\"token operator\\">&amp;</span><span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">=</span> delete<span class=\\"token punctuation\\">;</span>\\n    Singleton<span class=\\"token operator\\">&amp;</span> operator<span class=\\"token operator\\">=</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">const</span> Singleton<span class=\\"token operator\\">&amp;</span><span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">=</span> delete<span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n\\n<span class=\\"token comment\\">//单例对象释放：方法一</span>\\n<span class=\\"token keyword\\">static</span> <span class=\\"token keyword\\">void</span> <span class=\\"token function\\">DelInstance</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span>\\n<span class=\\"token punctuation\\">{</span>\\n    _mtx<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">lock</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token keyword\\">if</span> <span class=\\"token punctuation\\">(</span>_inst <span class=\\"token operator\\">!=</span> nullptr<span class=\\"token punctuation\\">)</span>\\n    <span class=\\"token punctuation\\">{</span>\\n       delete _inst<span class=\\"token punctuation\\">;</span>\\n       _inst <span class=\\"token operator\\">=</span> nullptr<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n    _mtx<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">unlock</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n\\n<span class=\\"token comment\\">//单例对象释放：方法二(垃圾回收类)</span>\\nclass CGarbo\\n<span class=\\"token punctuation\\">{</span>\\npublic<span class=\\"token operator\\">:</span>\\n    <span class=\\"token operator\\">~</span><span class=\\"token function\\">CGarbo</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span>\\n    <span class=\\"token punctuation\\">{</span>\\n       <span class=\\"token keyword\\">if</span> <span class=\\"token punctuation\\">(</span>_inst <span class=\\"token operator\\">!=</span> nullptr<span class=\\"token punctuation\\">)</span>\\n       <span class=\\"token punctuation\\">{</span>\\n          delete _inst<span class=\\"token punctuation\\">;</span>\\n          _inst <span class=\\"token operator\\">=</span> nullptr<span class=\\"token punctuation\\">;</span>\\n       <span class=\\"token punctuation\\">}</span>\\n    <span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n</code></pre></div>"}');export{d as comp,m as data};
