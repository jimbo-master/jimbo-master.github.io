import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,b as t}from"./app-Dezzdk4T.js";const p="/assets/%E5%A4%A7%E9%A1%B6%E5%A0%86%E4%B8%8E%E5%B0%8F%E9%A1%B6%E5%A0%86-CRbqvRYM.png",e="/assets/%E5%A0%86%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%AD%98%E5%82%A8-ZnlD_7ou.png",o="/assets/%E5%85%83%E7%B4%A0%E5%85%A5%E5%A0%86-BEQs-dac.png",i="/assets/%E5%85%83%E7%B4%A0%E5%85%A5%E5%A0%862-CC5WNHJd.png",c="/assets/%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0%E5%87%BA%E5%A0%86-Cj-oGE0h.png",l="/assets/%E5%A0%86%E9%A1%B6%E5%85%83%E7%B4%A0%E5%87%BA%E5%A0%862-BjWRXckQ.png",u={},r=t('<h1 id="第八章-堆" tabindex="-1"><a class="header-anchor" href="#第八章-堆"><span>第八章：堆</span></a></h1><p><strong>堆（heap）是一种满足特定条件的完全二叉树，主要可分为两种类型：</strong></p><ul><li><strong>小顶堆（min heap）：任意节点的值 ≤ 其子节点的值</strong></li><li><strong>大顶堆（max heap）：任意节点的值 ≥ 其子节点的值</strong></li></ul><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>堆作为完全二叉树的一个特例，具有以下特性:</strong></p><ul><li><strong>最底层节点靠左填充，其他层的节点都被填满</strong></li><li><strong>我们将二叉树的根节点称为“堆顶”，将底层最靠右的节点称为“堆底”</strong></li><li><strong>对于大顶堆（小顶堆），堆顶元素（根节点）的值是最大（最小）的</strong></li></ul><hr><h2 id="_1-堆的存储与表示" tabindex="-1"><a class="header-anchor" href="#_1-堆的存储与表示"><span>1.堆的存储与表示</span></a></h2><p><strong>二叉树”章节讲过，完全二叉树非常适合用数组来表示。由于堆正是一种完全二叉树，因此我们将采用数组来存储堆</strong></p><p><strong>当使用数组表示二叉树时，元素代表节点值，索引代表节点在二叉树中的位置。节点指针通过索引映射公式来实现</strong></p><p><strong>如下图所示，给定索引i，其左子节点的索引为2i+1，右子节点的索引为2i+2，父节点的索引为(i-1)/2（向下整除）。当索引越界时，表示空节点或节点不存在</strong></p><figure><img src="'+e+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>我们可以将索引映射公式封装成函数，方便后续使用：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 获取左子节点的索引 */</span>
<span class="token keyword">int</span> <span class="token function">left</span><span class="token punctuation">(</span>MaxHeap <span class="token operator">*</span>maxHeap<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 获取右子节点的索引 */</span>
<span class="token keyword">int</span> <span class="token function">right</span><span class="token punctuation">(</span>MaxHeap <span class="token operator">*</span>maxHeap<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 获取父节点的索引 */</span>
<span class="token keyword">int</span> <span class="token function">parent</span><span class="token punctuation">(</span>MaxHeap <span class="token operator">*</span>maxHeap<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_2-访问堆顶元素" tabindex="-1"><a class="header-anchor" href="#_2-访问堆顶元素"><span>2.访问堆顶元素</span></a></h2><p><strong>堆顶元素即为二叉树的根节点，也就是列表的首个元素：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 访问堆顶元素 */</span>
<span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span>MaxHeap <span class="token operator">*</span>maxHeap<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> maxHeap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_3-元素入堆" tabindex="-1"><a class="header-anchor" href="#_3-元素入堆"><span>3.元素入堆</span></a></h2><p><strong>给定元素 val ，我们首先将其添加到堆底。添加之后，由于 val 可能大于堆中其他元素，堆的成立条件可能已被破坏，因此需要修复从插入节点到根节点的路径上的各个节点，这个操作被称为堆化（heapify）</strong></p><p><strong>考虑从入堆节点开始，从底至顶执行堆化。如下图所示，我们比较插入节点与其父节点的值，如果插入节点更大，则将它们交换。然后继续执行此操作，从底至顶修复堆中的各个节点，直至越过根节点或遇到无须交换的节点时结束</strong></p><figure><img src="`+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+i+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>设节点总数为n，则树的高度为O(logn)。由此可知，堆化操作的循环轮数最多为O(logn)，元素入堆操作的时间复杂度为O(logn)。代码如下所示：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 元素入堆 */</span>
<span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>MaxHeap <span class="token operator">*</span>maxHeap<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 默认情况下，不应该添加这么多节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>maxHeap<span class="token operator">-&gt;</span>size <span class="token operator">==</span> MAX_SIZE<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;heap is full!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 添加节点</span>
    maxHeap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>maxHeap<span class="token operator">-&gt;</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>
    maxHeap<span class="token operator">-&gt;</span>size<span class="token operator">++</span><span class="token punctuation">;</span>

    <span class="token comment">// 从底至顶堆化</span>
    <span class="token function">siftUp</span><span class="token punctuation">(</span>maxHeap<span class="token punctuation">,</span> maxHeap<span class="token operator">-&gt;</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 从节点 i 开始，从底至顶堆化 */</span>
<span class="token keyword">void</span> <span class="token function">siftUp</span><span class="token punctuation">(</span>MaxHeap <span class="token operator">*</span>maxHeap<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 获取节点 i 的父节点</span>
        <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token function">parent</span><span class="token punctuation">(</span>maxHeap<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 当“越过根节点”或“节点无须修复”时，结束堆化</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> maxHeap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> maxHeap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 交换两节点</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>maxHeap<span class="token punctuation">,</span> i<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 循环向上堆化</span>
        i <span class="token operator">=</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_4-堆顶元素出堆" tabindex="-1"><a class="header-anchor" href="#_4-堆顶元素出堆"><span>4.堆顶元素出堆</span></a></h2><p><strong>堆顶元素是二叉树的根节点，即列表首元素。如果我们直接从列表中删除首元素，那么二叉树中所有节点的索引都会发生变化，这将使得后续使用堆化进行修复变得困难。为了尽量减少元素索引的变动，我们采用以下操作步骤：</strong></p><ul><li><strong>交换堆顶元素与堆底元素（交换根节点与最右叶节点）</strong></li><li><strong>交换完成后，将堆底从列表中删除（注意，由于已经交换，因此实际上删除的是原来的堆顶元素）</strong></li><li><strong>从根节点开始，从顶至底执行堆化</strong></li></ul><p><strong>如下图所示，“从顶至底堆化”的操作方向与“从底至顶堆化”相反，我们将根节点的值与其两个子节点的值进行比较，将最大的子节点与根节点交换。然后循环执行此操作，直到越过叶节点或遇到无须交换的节点时结束</strong></p><figure><img src="`+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+l+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>与元素入堆操作相似，堆顶元素出堆操作的时间复杂度也为O(logn)，代码如下：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 元素出堆 */</span>
<span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span>MaxHeap <span class="token operator">*</span>maxHeap<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 判空处理</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>maxHeap<span class="token punctuation">)</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;heap is empty!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> INT_MAX<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 交换根节点与最右叶节点（交换首元素与尾元素）</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>maxHeap<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">size</span><span class="token punctuation">(</span>maxHeap<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 删除节点</span>
    <span class="token keyword">int</span> val <span class="token operator">=</span> maxHeap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>maxHeap<span class="token operator">-&gt;</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    maxHeap<span class="token operator">-&gt;</span>size<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token comment">// 从顶至底堆化</span>
    <span class="token function">siftDown</span><span class="token punctuation">(</span>maxHeap<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 返回堆顶元素</span>
    <span class="token keyword">return</span> val<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 从节点 i 开始，从顶至底堆化 */</span>
<span class="token keyword">void</span> <span class="token function">siftDown</span><span class="token punctuation">(</span>MaxHeap <span class="token operator">*</span>maxHeap<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 判断节点 i, l, r 中值最大的节点，记为 max</span>
        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token function">left</span><span class="token punctuation">(</span>maxHeap<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">right</span><span class="token punctuation">(</span>maxHeap<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> max <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> <span class="token function">size</span><span class="token punctuation">(</span>maxHeap<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> maxHeap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&gt;</span> maxHeap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>max<span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            max <span class="token operator">=</span> l<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> <span class="token function">size</span><span class="token punctuation">(</span>maxHeap<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> maxHeap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&gt;</span> maxHeap<span class="token operator">-&gt;</span>data<span class="token punctuation">[</span>max<span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            max <span class="token operator">=</span> r<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>max <span class="token operator">==</span> i<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 交换两节点</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>maxHeap<span class="token punctuation">,</span> i<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 循环向下堆化</span>
        i <span class="token operator">=</span> max<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,35),d=[r];function k(m,v){return s(),a("div",null,d)}const h=n(u,[["render",k],["__file","8.堆.html.vue"]]),f=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/8.%E5%A0%86.html","title":"第八章：堆","lang":"zh-CN","frontmatter":{"date":"2024-03-08T00:00:00.000Z","order":8,"description":"第八章：堆 堆（heap）是一种满足特定条件的完全二叉树，主要可分为两种类型： 小顶堆（min heap）：任意节点的值 ≤ 其子节点的值 大顶堆（max heap）：任意节点的值 ≥ 其子节点的值 堆作为完全二叉树的一个特例，具有以下特性: 最底层节点靠左填充，其他层的节点都被填满 我们将二叉树的根节点称为“堆顶”，将底层最靠右的节点称为“堆底” 对...","head":[["meta",{"property":"og:url","content":"https://github.com/jimbo-master/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/8.%E5%A0%86.html"}],["meta",{"property":"og:site_name","content":"JimBoの学习妙妙屋"}],["meta",{"property":"og:title","content":"第八章：堆"}],["meta",{"property":"og:description","content":"第八章：堆 堆（heap）是一种满足特定条件的完全二叉树，主要可分为两种类型： 小顶堆（min heap）：任意节点的值 ≤ 其子节点的值 大顶堆（max heap）：任意节点的值 ≥ 其子节点的值 堆作为完全二叉树的一个特例，具有以下特性: 最底层节点靠左填充，其他层的节点都被填满 我们将二叉树的根节点称为“堆顶”，将底层最靠右的节点称为“堆底” 对..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"JimBo"}],["meta",{"property":"article:published_time","content":"2024-03-08T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第八章：堆\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-08T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JimBo\\",\\"url\\":\\"https://github.com/jimbo-master\\"}]}"]]},"headers":[{"level":2,"title":"1.堆的存储与表示","slug":"_1-堆的存储与表示","link":"#_1-堆的存储与表示","children":[]},{"level":2,"title":"2.访问堆顶元素","slug":"_2-访问堆顶元素","link":"#_2-访问堆顶元素","children":[]},{"level":2,"title":"3.元素入堆","slug":"_3-元素入堆","link":"#_3-元素入堆","children":[]},{"level":2,"title":"4.堆顶元素出堆","slug":"_4-堆顶元素出堆","link":"#_4-堆顶元素出堆","children":[]}],"git":{},"readingTime":{"minutes":4.64,"words":1392},"filePathRelative":"算法学习/1.算法知识/8.堆.md","localizedDate":"2024年3月8日","autoDesc":true,"excerpt":"\\n<p><strong>堆（heap）是一种满足特定条件的完全二叉树，主要可分为两种类型：</strong></p>\\n<ul>\\n<li><strong>小顶堆（min heap）：任意节点的值 ≤ 其子节点的值</strong></li>\\n<li><strong>大顶堆（max heap）：任意节点的值 ≥ 其子节点的值</strong></li>\\n</ul>\\n<figure><figcaption></figcaption></figure>\\n<p><strong>堆作为完全二叉树的一个特例，具有以下特性:</strong></p>\\n<ul>\\n<li><strong>最底层节点靠左填充，其他层的节点都被填满</strong></li>\\n<li><strong>我们将二叉树的根节点称为“堆顶”，将底层最靠右的节点称为“堆底”</strong></li>\\n<li><strong>对于大顶堆（小顶堆），堆顶元素（根节点）的值是最大（最小）的</strong></li>\\n</ul>"}');export{h as comp,f as data};
