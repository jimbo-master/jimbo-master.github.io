import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,b as t}from"./app-Dezzdk4T.js";const p="/assets/%E5%89%8D%E7%BC%80%E9%81%8D%E5%8E%86%E4%B8%AD%E6%90%9C%E7%B4%A2%E8%8A%82%E7%82%B9-OeQGcrwb.png",o="/assets/%E5%B0%9D%E8%AF%95%E4%B8%8E%E5%9B%9E%E9%80%80-Cf_mXMpL.png",e="/assets/%E5%89%AA%E6%9E%9D-BfgDEec3.png",c="/assets/%E4%BF%9D%E7%95%99%E4%B8%8E%E5%88%A0%E9%99%A4return%E6%90%9C%E7%B4%A2-CAylgFgk.png",i="/assets/%E5%85%A8%E6%8E%92%E5%88%97%E5%AE%9E%E4%BE%8B-D5VdaKCd.png",l="/assets/%E5%85%A8%E6%8E%92%E5%88%97%E9%80%92%E5%BD%92%E6%A0%91-BI5GxjEd.png",u="/assets/%E5%85%A8%E6%8E%92%E5%88%97%E5%89%AA%E6%9E%9D-DDbY_sBW.png",r="/assets/%E9%87%8D%E5%A4%8D%E6%8E%92%E5%88%97-BKn8zmlT.png",k="/assets/%E9%87%8D%E5%A4%8D%E6%8E%92%E5%88%97%E5%89%AA%E6%9E%9D-d1xSQ5-O.png",d="/assets/%E5%89%AA%E6%9E%9D%E5%AF%B9%E6%AF%94-DyI4kTPi.png",v="/assets/%E5%AD%90%E9%9B%86%E6%90%9C%E7%B4%A2%E4%B8%8E%E8%B6%8A%E7%95%8C%E5%89%AA%E6%9E%9D-B_4GOChh.png",m="/assets/%E9%87%8D%E5%A4%8D%E5%AD%90%E9%9B%86-DaYBz5UJ.png",b="/assets/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B01-Bxa80lOg.png",g="/assets/%E5%AD%90%E9%9B%86%E5%92%8C%E5%9B%9E%E6%BA%AF%E8%BF%87%E7%A8%8B-CgfElthH.png",h="/assets/%E7%9B%B8%E5%90%8C%E5%85%83%E7%B4%A0%E5%AF%BC%E8%87%B4%E7%9A%84%E9%87%8D%E5%A4%8D%E5%AD%90%E9%9B%86-GVJ-fqWg.png",f="/assets/%E5%AD%90%E9%9B%86%E5%92%8C%E5%9B%9E%E6%BA%AF%E8%BF%87%E7%A8%8B2-hsVVBVk5.png",y="/assets/n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3-JY6Zw3N7.png",w="/assets/n%E7%9A%87%E5%90%8E%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6-BTTj6qG2.png",E="/assets/%E9%80%90%E8%A1%8C%E6%94%BE%E7%BD%AE%E7%AD%96%E7%95%A5-D4O3XwfO.png",z="/assets/%E5%A4%84%E7%90%86%E7%BA%A6%E6%9D%9F%E4%B8%8E%E5%AF%B9%E8%A7%92%E7%BA%BF%E7%BA%A6%E6%9D%9F-N_A8aokf.png",_={},S=t('<h1 id="第十三章-回溯" tabindex="-1"><a class="header-anchor" href="#第十三章-回溯"><span>第十三章：回溯</span></a></h1><p><strong>回溯算法（backtracking algorithm）是一种通过穷举来解决问题的方法，它的核心思想是从一个初始状态出发，暴力搜索所有可能的解决方案，当遇到正确的解则将其记录，直到找到解或者尝试了所有可能的选择都无法找到解为止</strong></p><p><strong>回溯算法通常采用“深度优先搜索”来遍历解空间。在“二叉树”章节中，我们提到前序、中序和后序遍历都属于深度优先搜索。接下来，我们利用前序遍历构造一个回溯问题，逐步了解回溯算法的工作原理</strong></p><blockquote><p><strong>问题：给定一棵二叉树，搜索并记录所有值为8的节点，请返回节点列表</strong></p></blockquote><p><strong>对于此题，我们前序遍历这棵树，并判断当前节点的值是否为7，若是，则将该节点的值加入结果列表 res 之中。相关过程实现如下图和以下代码所示：</strong></p><figure><img src="'+p+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 前序遍历：例题一 */</span>
<span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>val <span class="token operator">==</span> <span class="token number">7</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 记录解</span>
        res<span class="token punctuation">[</span>resSize<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_1-尝试与回退" tabindex="-1"><a class="header-anchor" href="#_1-尝试与回退"><span>1.尝试与回退</span></a></h2><p><strong>之所以称之为回溯算法，是因为该算法在搜索解空间时会采用“尝试”与“回退”的策略。当算法在搜索过程中遇到某个状态无法继续前进或无法得到满足条件的解时，它会撤销上一步的选择，退回到之前的状态，并尝试其他可能的选择</strong></p><p><strong>对于例题一，访问每个节点都代表一次“尝试”，而越过叶节点或返回父节点的 return 则表示“回退”</strong></p><p><strong>值得说明的是，回退并不仅仅包括函数返回。为解释这一点，我们对例题一稍作拓展</strong></p><blockquote><p><strong>问题2：在二叉树中搜索所有值为7的节点，请返回根节点到这些节点的路径</strong></p></blockquote><p><strong>在例题一代码的基础上，我们需要借助一个列表 path 记录访问过的节点路径。当访问到值为7的节点时，则复制 path 并添加进结果列表 res 。遍历完成后，res 中保存的就是所有的解。代码如下所示：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 前序遍历：例题二 */</span>
<span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 尝试</span>
    path<span class="token punctuation">[</span>pathSize<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> root<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>val <span class="token operator">==</span> <span class="token number">7</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 记录解</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pathSize<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            res<span class="token punctuation">[</span>resSize<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        resSize<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 回退</span>
    pathSize<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>在每次“尝试”中，我们通过将当前节点添加进 path 来记录路径；而在“回退”前，我们需要将该节点从 path 中弹出，以恢复本次尝试之前的状态</strong></p><p><strong>观察下图所示的过程，我们可以将尝试和回退理解为“前进”与“撤销”，两个操作互为逆向</strong></p><figure><img src="`+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h2 id="_2-剪枝" tabindex="-1"><a class="header-anchor" href="#_2-剪枝"><span>2.剪枝</span></a></h2><p><strong>复杂的回溯问题通常包含一个或多个约束条件，约束条件通常可用于“剪枝”</strong></p><blockquote><p><strong>问题3：在二叉树中搜索所有值为7的节点，请返回根节点到这些节点的路径，并要求路径中不包含值为3的节点</strong></p></blockquote><p><strong>为了满足以上约束条件，我们需要添加剪枝操作：在搜索过程中，若遇到值为3的节点，则提前返回，不再继续搜索。代码如下所示：</strong></p><p><strong>“剪枝”是一个非常形象的名词。如下图所示，在搜索过程中，我们“剪掉”了不满足约束条件的搜索分支，避免许多无意义的尝试，从而提高了搜索效率</strong></p><figure><img src="'+e+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 前序遍历：例题三 */</span>
<span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>root<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 剪枝</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> root<span class="token operator">-&gt;</span>val <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 尝试</span>
    path<span class="token punctuation">[</span>pathSize<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> root<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>val <span class="token operator">==</span> <span class="token number">7</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 记录解</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pathSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            res<span class="token punctuation">[</span>resSize<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        resSize<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 回退</span>
    pathSize<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_3-框架代码" tabindex="-1"><a class="header-anchor" href="#_3-框架代码"><span>3.框架代码</span></a></h2><p><strong>接下来，我们尝试将回溯的“尝试、回退、剪枝”的主体框架提炼出来，提升代码的通用性</strong></p><p><strong>以下框架代码中，state 表示问题的当前状态，choices 表示当前状态下可以做出的选择：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 回溯算法框架 */</span>
<span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>State <span class="token operator">*</span>state<span class="token punctuation">,</span> Choice <span class="token operator">*</span>choices<span class="token punctuation">,</span> <span class="token keyword">int</span> numChoices<span class="token punctuation">,</span> State <span class="token operator">*</span>res<span class="token punctuation">,</span> <span class="token keyword">int</span> numRes<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 判断是否为解</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSolution</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 记录解</span>
        <span class="token function">recordSolution</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> res<span class="token punctuation">,</span> numRes<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 不再继续搜索</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 遍历所有选择</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numChoices<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 剪枝：判断选择是否合法</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> <span class="token operator">&amp;</span>choices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token comment">// 尝试：做出选择，更新状态</span>
            <span class="token function">makeChoice</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> <span class="token operator">&amp;</span>choices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">backtrack</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> choices<span class="token punctuation">,</span> numChoices<span class="token punctuation">,</span> res<span class="token punctuation">,</span> numRes<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 回退：撤销选择，恢复到之前的状态</span>
            <span class="token function">undoChoice</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> <span class="token operator">&amp;</span>choices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>接下来，我们基于框架代码来解决例题三。状态 state 为节点遍历路径，选择 choices 为当前节点的左子节点和右子节点，结果 res 是路径列表：</strong></p><p><strong>根据题意，我们在找到值为7的节点后应该继续搜索，因此需要将记录解之后的 return 语句删除。下图对比了保留或删除 return 语句的搜索过程</strong></p><figure><img src="`+c+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p><strong>相比基于前序遍历的代码实现，基于回溯算法框架的代码实现虽然显得啰唆，但通用性更好。实际上，许多回溯问题可以在该框架下解决。我们只需根据具体问题来定义 state 和 choices ，并实现框架中的各个方法即可</strong></p></blockquote><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 判断当前状态是否为解 */</span>
bool <span class="token function">isSolution</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> pathSize <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> path<span class="token punctuation">[</span>pathSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span>val <span class="token operator">==</span> <span class="token number">7</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 记录解 */</span>
<span class="token keyword">void</span> <span class="token function">recordSolution</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pathSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        res<span class="token punctuation">[</span>resSize<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    resSize<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 判断在当前状态下，该选择是否合法 */</span>
bool <span class="token function">isValid</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>choice<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> choice <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> choice<span class="token operator">-&gt;</span>val <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 更新状态 */</span>
<span class="token keyword">void</span> <span class="token function">makeChoice</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>choice<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    path<span class="token punctuation">[</span>pathSize<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> choice<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 恢复状态 */</span>
<span class="token keyword">void</span> <span class="token function">undoChoice</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    pathSize<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 回溯算法：例题三 */</span>
<span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>TreeNode <span class="token operator">*</span>choices<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 检查是否为解</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isSolution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 记录解</span>
        <span class="token function">recordSolution</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 遍历所有选择</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        TreeNode <span class="token operator">*</span>choice <span class="token operator">=</span> choices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 剪枝：检查选择是否合法</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isValid</span><span class="token punctuation">(</span>choice<span class="token punctuation">)</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token comment">// 尝试：做出选择，更新状态</span>
            <span class="token function">makeChoice</span><span class="token punctuation">(</span>choice<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 进行下一轮选择</span>
            TreeNode <span class="token operator">*</span>nextChoices<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>choice<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> choice<span class="token operator">-&gt;</span>right<span class="token punctuation">}</span><span class="token punctuation">;</span>
            <span class="token function">backtrack</span><span class="token punctuation">(</span>nextChoices<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 回退：撤销选择，恢复到之前的状态</span>
            <span class="token function">undoChoice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_4-优点与缺点" tabindex="-1"><a class="header-anchor" href="#_4-优点与缺点"><span>4.优点与缺点</span></a></h2><p><strong>回溯算法本质上是一种深度优先搜索算法，它尝试所有可能的解决方案直到找到满足条件的解。这种方法的优点在于能够找到所有可能的解决方案，而且在合理的剪枝操作下，具有很高的效率</strong></p><p><strong>然而，在处理大规模或者复杂问题时，回溯算法的运行效率可能难以接受</strong></p><ul><li><strong>时间：回溯算法通常需要遍历状态空间的所有可能，时间复杂度可以达到指数阶或阶乘阶</strong></li><li><strong>空间：在递归调用中需要保存当前的状态（例如路径、用于剪枝的辅助变量等），当深度很大时，空间需求可能会变得很大</strong></li></ul><p><strong>即便如此，回溯算法仍然是某些搜索问题和约束满足问题的最佳解决方案。对于这些问题，由于无法预测哪些选择可生成有效的解，因此我们必须对所有可能的选择进行遍历。在这种情况下，关键是如何优化效率，常见的效率优化方法有两种</strong></p><ul><li><strong>剪枝：避免搜索那些肯定不会产生解的路径，从而节省时间和空间</strong></li><li><strong>启发式搜索：在搜索过程中引入一些策略或者估计值，从而优先搜索最有可能产生有效解的路径</strong></li></ul><hr><h2 id="_5-回溯算法经典例题" tabindex="-1"><a class="header-anchor" href="#_5-回溯算法经典例题"><span>5.回溯算法经典例题</span></a></h2><p><strong>回溯算法可用于解决许多搜索问题、约束满足问题和组合优化问题</strong></p><p><strong>搜索问题：这类问题的目标是找到满足特定条件的解决方案</strong></p><ul><li><strong>全排列问题：给定一个集合，求出其所有可能的排列组合</strong></li><li><strong>子集和问题：给定一个集合和一个目标和，找到集合中所有和为目标和的子集</strong></li><li><strong>汉诺塔问题：给定三根柱子和一系列大小不同的圆盘，要求将所有圆盘从一根柱子移动到另一根柱子，每次只能移动一个圆盘，且不能将大圆盘放在小圆盘上</strong></li></ul><p><strong>约束满足问题：这类问题的目标是找到满足所有约束条件的解</strong></p><ul><li><strong>n皇后：在nxn 的棋盘上放置n个皇后，使得它们互不攻击</strong></li><li><strong>数独：在9x9的网格中填入数字1~9，使得每行、每列和每个3x3子网格中的数字不重复</strong></li><li><strong>图着色问题：给定一个无向图，用最少的颜色给图的每个顶点着色，使得相邻顶点颜色不同</strong></li></ul><p><strong>组合优化问题：这类问题的目标是在一个组合空间中找到满足某些条件的最优解</strong></p><ul><li><strong>0-1 背包问题：给定一组物品和一个背包，每个物品有一定的价值和重量，要求在背包容量限制内，选择物品使得总价值最大</strong></li><li><strong>旅行商问题：在一个图中，从一个点出发，访问所有其他点恰好一次后返回起点，求最短路径</strong></li><li><strong>最大团问题：给定一个无向图，找到最大的完全子图，即子图中的任意两个顶点之间都有边相连</strong></li></ul><p><strong>请注意，对于许多组合优化问题，回溯不是最优解决方案</strong></p><ul><li><strong>0-1 背包问题通常使用动态规划解决，以达到更高的时间效率</strong></li><li><strong>旅行商是一个著名的 NP-Hard 问题，常用解法有遗传算法和蚁群算法等</strong></li><li><strong>最大团问题是图论中的一个经典问题，可用贪心算法等启发式算法来解决</strong></li></ul><hr><h2 id="_6-全排列问题" tabindex="-1"><a class="header-anchor" href="#_6-全排列问题"><span>6.全排列问题</span></a></h2><p><strong>全排列问题是回溯算法的一个典型应用。它的定义是在给定一个集合（如一个数组或字符串）的情况下，找出其中元素的所有可能的排列</strong></p><p><strong>下图列举了几个示例数据，包括输入数组和对应的所有排列</strong></p><figure><img src="`+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_6-1-无相等元素的情况" tabindex="-1"><a class="header-anchor" href="#_6-1-无相等元素的情况"><span>6.1 无相等元素的情况</span></a></h3><blockquote><p><strong>问题：输入一个整数数组，其中不包含重复元素，返回所有可能的排列</strong></p></blockquote><p><strong>从回溯算法的角度看，我们可以把生成排列的过程想象成一系列选择的结果。假设输入数组为[1,2,3]，如果我们先选择1，再选择3，最后选择2，则获得排列[1,3,2]。回退表示撤销一个选择，之后继续尝试其他选择</strong></p><p><strong>从回溯代码的角度看，候选集合 choices 是输入数组中的所有元素，状态 state 是直至目前已被选择的元素。请注意，每个元素只允许被选择一次，因此 state 中的所有元素都应该是唯一的</strong></p><p><strong>如下图所示，我们可以将搜索过程展开成一棵递归树，树中的每个节点代表当前状态 state 。从根节点开始，经过三轮选择后到达叶节点，每个叶节点都对应一个排列</strong></p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>（1）重新选择剪枝</strong></p><p><strong>为了实现每个元素只被选择一次，我们考虑引入一个布尔型数组 selected ，其中 selected[i] 表示 choices[i] 是否已被选择，并基于它实现以下剪枝操作</strong></p><ul><li><strong>在做出选择 choice[i] 后，我们就将 selected[i] 赋值为True，代表它已被选择</strong></li><li><strong>遍历选择列表 choices 时，跳过所有已被选择的节点，即剪枝</strong></li></ul><p><strong>如下图所示，假设我们第一轮选择 1 ，第二轮选择 3 ，第三轮选择 2 ，则需要在第二轮剪掉元素 1 的分支，在第三轮剪掉元素 1 和元素 3 的分支</strong></p><figure><img src="'+u+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>观察上图发现，该剪枝操作将搜索空间大小从O(n^n)减小至O(n!)</strong></p><p><strong>（2）代码实现</strong></p><p><strong>想清楚以上信息之后，我们就可以在框架代码中做“完形填空”了。为了缩短整体代码，我们不单独实现框架代码中的各个函数，而是将它们展开在 backtrack() 函数中：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 回溯算法：全排列 I */</span>
<span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>state<span class="token punctuation">,</span> <span class="token keyword">int</span> stateSize<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>choices<span class="token punctuation">,</span> <span class="token keyword">int</span> choicesSize<span class="token punctuation">,</span> bool <span class="token operator">*</span>selected<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>res<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>resSize<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 当状态长度等于元素数量时，记录解</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>stateSize <span class="token operator">==</span> choicesSize<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        res<span class="token punctuation">[</span><span class="token operator">*</span>resSize<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>choicesSize <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> choicesSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            res<span class="token punctuation">[</span><span class="token operator">*</span>resSize<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> state<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>resSize<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 遍历所有选择</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> choicesSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> choice <span class="token operator">=</span> choices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 剪枝：不允许重复选择元素</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>selected<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token comment">// 尝试：做出选择，更新状态</span>
            selected<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>
            state<span class="token punctuation">[</span>stateSize<span class="token punctuation">]</span> <span class="token operator">=</span> choice<span class="token punctuation">;</span>
            <span class="token comment">// 进行下一轮选择</span>
            <span class="token function">backtrack</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> stateSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> choices<span class="token punctuation">,</span> choicesSize<span class="token punctuation">,</span> selected<span class="token punctuation">,</span> res<span class="token punctuation">,</span> resSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 回退：撤销选择，恢复到之前的状态</span>
            selected<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 全排列 I */</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token function">permutationsI</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> numsSize<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>returnSize<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>state <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>numsSize <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    bool <span class="token operator">*</span>selected <span class="token operator">=</span> <span class="token punctuation">(</span>bool <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>numsSize <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>bool<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numsSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        selected<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>MAX_SIZE <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>returnSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token function">backtrack</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">,</span> numsSize<span class="token punctuation">,</span> selected<span class="token punctuation">,</span> res<span class="token punctuation">,</span> returnSize<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">free</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>selected<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_6-2-考虑相等元素情况" tabindex="-1"><a class="header-anchor" href="#_6-2-考虑相等元素情况"><span>6.2 考虑相等元素情况</span></a></h3><p><strong>问题：输入一个整数数组，数组中可能包含重复元素，返回所有不重复的排列</strong></p><p><strong>假设输入数组为[1,1,2]。为了方便区分两个重复元素1，我们将第二个1记为i</strong></p><p><strong>如下图所示，上述方法生成的排列有一半是重复的</strong></p><figure><img src="`+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>那么如何去除重复的排列呢？最直接地，考虑借助一个哈希表，直接对排列结果进行去重。然而这样做不够优雅，因为生成重复排列的搜索分支没有必要，应当提前识别并剪枝，这样可以进一步提升算法效率</strong></p><p><strong>（1）相等元素剪枝</strong></p><p><strong>观察下图，在第一轮中，选择1或选择1^ 是等价的，在这两个选择之下生成的所有排列都是重复的。因此应该把1^ 剪枝</strong></p><p><strong>同理，在第一轮选择2之后，第二轮选择中的1和1^ 也会产生重复分支，因此也应将第二轮的1^ 剪枝</strong></p><p><strong>从本质上看，我们的目标是在某一轮选择中，保证多个相等的元素仅被选择一次</strong></p><figure><img src="'+k+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>（2）代码实现</strong></p><p><strong>在上一题的代码的基础上，我们考虑在每一轮选择中开启一个哈希表 duplicated ，用于记录该轮中已经尝试过的元素，并将重复元素剪枝：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 回溯算法：全排列 II */</span>
<span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>state<span class="token punctuation">,</span> <span class="token keyword">int</span> stateSize<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>choices<span class="token punctuation">,</span> <span class="token keyword">int</span> choicesSize<span class="token punctuation">,</span> bool <span class="token operator">*</span>selected<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>res<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>resSize<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 当状态长度等于元素数量时，记录解</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>stateSize <span class="token operator">==</span> choicesSize<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        res<span class="token punctuation">[</span><span class="token operator">*</span>resSize<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>choicesSize <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> choicesSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            res<span class="token punctuation">[</span><span class="token operator">*</span>resSize<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> state<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>resSize<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 遍历所有选择</span>
    bool duplicated<span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>false<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> choicesSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> choice <span class="token operator">=</span> choices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 剪枝：不允许重复选择元素 且 不允许重复选择相等元素</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>selected<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>duplicated<span class="token punctuation">[</span>choice<span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token comment">// 尝试：做出选择，更新状态</span>
            duplicated<span class="token punctuation">[</span>choice<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span> <span class="token comment">// 记录选择过的元素值</span>
            selected<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>
            state<span class="token punctuation">[</span>stateSize<span class="token punctuation">]</span> <span class="token operator">=</span> choice<span class="token punctuation">;</span>
            <span class="token comment">// 进行下一轮选择</span>
            <span class="token function">backtrack</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> stateSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> choices<span class="token punctuation">,</span> choicesSize<span class="token punctuation">,</span> selected<span class="token punctuation">,</span> res<span class="token punctuation">,</span> resSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 回退：撤销选择，恢复到之前的状态</span>
            selected<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 全排列 II */</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token function">permutationsII</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> numsSize<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>returnSize<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>state <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>numsSize <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    bool <span class="token operator">*</span>selected <span class="token operator">=</span> <span class="token punctuation">(</span>bool <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>numsSize <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>bool<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numsSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        selected<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>MAX_SIZE <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>returnSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token function">backtrack</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">,</span> numsSize<span class="token punctuation">,</span> selected<span class="token punctuation">,</span> res<span class="token punctuation">,</span> returnSize<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">free</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>selected<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>假设元素两两之间互不相同，则n个元素共有n!种排列（阶乘）；在记录结果时，需要复制长度为n的列表，使用O(n) 时间。因此时间复杂度为O(n!n)</strong></p><p><strong>最大递归深度为n，使用O(n)栈帧空间。selected 使用O(n)空间。同一时刻最多共有n个duplicated ，使用O(n^ 2)空间。因此空间复杂度为O(n^ 2)</strong></p><hr><h3 id="_6-3-两种剪枝对比" tabindex="-1"><a class="header-anchor" href="#_6-3-两种剪枝对比"><span>6.3 两种剪枝对比</span></a></h3><p><strong>请注意，虽然 selected 和 duplicated 都用于剪枝，但两者的目标不同</strong></p><ul><li><strong>重复选择剪枝：整个搜索过程中只有一个 selected 。它记录的是当前状态中包含哪些元素，其作用是避免某个元素在 state 中重复出现</strong></li><li><strong>相等元素剪枝：每轮选择（每个调用的 backtrack 函数）都包含一个 duplicated 。它记录的是在本轮遍历（for 循环）中哪些元素已被选择过，其作用是保证相等元素只被选择一次</strong></li></ul><p><strong>下图展示了两个剪枝条件的生效范围。注意，树中的每个节点代表一个选择，从根节点到叶节点的路径上的各个节点构成一个排列</strong></p><figure><img src="`+d+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h2 id="_7-子集和问题" tabindex="-1"><a class="header-anchor" href="#_7-子集和问题"><span>7.子集和问题</span></a></h2><h3 id="_7-1-无重复元素的情况" tabindex="-1"><a class="header-anchor" href="#_7-1-无重复元素的情况"><span>7.1 无重复元素的情况</span></a></h3><blockquote><p><strong>问题：给定一个正整数数组 nums 和一个目标正整数 target ，请找出所有可能的组合，使得组合中的元素和等于 target 。给定数组无重复元素，每个元素可以被选取多次。请以列表形式返回这些组合，列表中不应包含重复组合</strong></p></blockquote><p><strong>例如，输入集合{3,4,5}和目标整数9，解为{3,3,3},{4,5}。需要注意两点：</strong></p><ul><li><strong>输入集合中的元素可以被无限次重复选取</strong></li><li><strong>子集不区分元素顺序，比如{4,5}和{5,4}是同一个子集</strong></li></ul><p><strong>（1）参考全排列解法</strong></p><p><strong>类似于全排列问题，我们可以把子集的生成过程想象成一系列选择的结果，并在选择过程中实时更新“元素和”，当元素和等于 target 时，就将子集记录至结果列表</strong></p><p><strong>而与全排列问题不同的是，本题集合中的元素可以被无限次选取，因此无须借助 selected 布尔列表来记录元素是否已被选择。我们可以对全排列代码进行小幅修改，初步得到解题代码：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 回溯算法：子集和 I */</span>
<span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> total<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>choices<span class="token punctuation">,</span> <span class="token keyword">int</span> choicesSize<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 子集和等于 target 时，记录解</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>total <span class="token operator">==</span> target<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> stateSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            res<span class="token punctuation">[</span>resSize<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> state<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        resColSizes<span class="token punctuation">[</span>resSize<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> stateSize<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 遍历所有选择</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> choicesSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 剪枝：若子集和超过 target ，则跳过该选择</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>total <span class="token operator">+</span> choices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> target<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 尝试：做出选择，更新元素和 total</span>
        state<span class="token punctuation">[</span>stateSize<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> choices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 进行下一轮选择</span>
        <span class="token function">backtrack</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> total <span class="token operator">+</span> choices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> choices<span class="token punctuation">,</span> choicesSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 回退：撤销选择，恢复到之前的状态</span>
        stateSize<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 求解子集和 I（包含重复子集） */</span>
<span class="token keyword">void</span> <span class="token function">subsetSumINaive</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> numsSize<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    resSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 初始化解的数量为0</span>
    <span class="token function">backtrack</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">,</span> numsSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>向以上代码输入数组[3,4,5]和目标9，输出结果为[3,3,3],[4,5],[5,4]。虽然成功找出了所有和为9的子集，但其中存在重复的子集[4,5]和[5,4]</strong></p><p><strong>这是因为搜索过程是区分选择顺序的，然而子集不区分选择顺序。如下图所示，先选4后选5与先选5后选4是不同的分支，但对应同一个子集</strong></p><figure><img src="`+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>为了去除重复子集，一种直接的思路是对结果列表进行去重。但这个方法效率很低，有两方面原因：</strong></p><ul><li><strong>当数组元素较多，尤其是当 target 较大时，搜索过程会产生大量的重复子集</strong></li><li><strong>比较子集（数组）的异同非常耗时，需要先排序数组，再比较数组中每个元素的异同</strong></li></ul><p><strong>（2）重复子集剪枝</strong></p><p><strong>我们考虑在搜索过程中通过剪枝进行去重。观察下图，重复子集是在以不同顺序选择数组元素时产生的，例如以下情况</strong></p><ul><li><strong>当第一轮和第二轮分别选择3和4时，会生成包含这两个元素的所有子集，记为[3,4,...]</strong></li><li><strong>之后，当第一轮选择4时，则第二轮应该跳过3，因为该选择产生的子集[4,3,...]和第1步中产生的子集完全重复</strong></li></ul><p><strong>在搜索过程中，每一层的选择都是从左到右被逐个尝试的，因此越靠右的分支被剪掉的越多</strong></p><ul><li><strong>前两轮选择3和5，生成子集[3,5,...]</strong></li><li><strong>前两轮选择4和5，生成子集[4,5,...]</strong></li><li><strong>若第一轮选择5，则第二轮应该跳过3和4，因为子集[5,3,...]和[5,4,...]与第1步和第2步中描述的子集完全重复</strong></li></ul><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>总结来看，给定输入数组[x1,x2,...,xn]，设搜索过程中的选择序列为[xi1,xi2,...,xim]，则该选择序列需要满足i1 ≤ i2 ≤ ... ≤ im，不满足该条件的选择序列都会造成重复，应当剪枝</strong></p><p><strong>（3）代码实现</strong></p><figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>下图所示为将数组[3,4,5]和目标9输入以下代码后的整体回溯效果</strong></p><figure><img src="'+g+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 回溯算法：子集和 I */</span>
<span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>choices<span class="token punctuation">,</span> <span class="token keyword">int</span> choicesSize<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 子集和等于 target 时，记录解</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> stateSize<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            res<span class="token punctuation">[</span>resSize<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> state<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        resColSizes<span class="token punctuation">[</span>resSize<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> stateSize<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 遍历所有选择</span>
    <span class="token comment">// 剪枝二：从 start 开始遍历，避免生成重复子集</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> choicesSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 剪枝一：若子集和超过 target ，则直接结束循环</span>
        <span class="token comment">// 这是因为数组已排序，后边元素更大，子集和一定超过 target</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">-</span> choices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 尝试：做出选择，更新 target, start</span>
        state<span class="token punctuation">[</span>stateSize<span class="token punctuation">]</span> <span class="token operator">=</span> choices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        stateSize<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token comment">// 进行下一轮选择</span>
        <span class="token function">backtrack</span><span class="token punctuation">(</span>target <span class="token operator">-</span> choices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> choices<span class="token punctuation">,</span> choicesSize<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 回退：撤销选择，恢复到之前的状态</span>
        stateSize<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 求解子集和 I */</span>
<span class="token keyword">void</span> <span class="token function">subsetSumI</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> numsSize<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token function">qsort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> numsSize<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 对 nums 进行排序</span>
    <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                           <span class="token comment">// 遍历起始点</span>
    <span class="token function">backtrack</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> numsSize<span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_7-2-考虑重复元素情况" tabindex="-1"><a class="header-anchor" href="#_7-2-考虑重复元素情况"><span>7.2 考虑重复元素情况</span></a></h3><blockquote><p><strong>问题：给定一个正整数数组 nums 和一个目标正整数 target ，请找出所有可能的组合，使得组合中的元素和等于 target 。给定数组可能包含重复元素，每个元素只可被选择一次。请以列表形式返回这些组合，列表中不应包含重复组合</strong></p></blockquote><p><strong>相比于上题，本题的输入数组可能包含重复元素，这引入了新的问题。例如，给定数组[4,4^,5]和目标元素9，则现有代码的输出结果为[4,5]，[4 ^,5]，出现了重复子集</strong></p><p><strong>造成这种重复的原因是相等元素在某轮中被多次选择。在下图中，第一轮共有三个选择，其中两个都为4，会产生两个重复的搜索分支，从而输出重复子集；同理，第二轮的两个4也会产生重复子集</strong></p><figure><img src="`+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>（1）相等元素剪枝</strong></p><p><strong>为解决此问题，我们需要限制相等元素在每一轮中只能被选择一次。实现方式比较巧妙：由于数组是已排序的，因此相等元素都是相邻的。这意味着在某轮选择中，若当前元素与其左边元素相等，则说明它已经被选择过，因此直接跳过当前元素</strong></p><p><strong>与此同时，本题规定每个数组元素只能被选择一次。幸运的是，我们也可以利用变量 start 来满足该约束：当做出选择xi后，设定下一轮从索引i+1开始向后遍历。这样既能去除重复子集，也能避免重复选择元素</strong></p><p><strong>（2）代码实现</strong></p><p><strong>下图展示了数组[4,4,5]和目标元素9的回溯过程，共包含四种剪枝操作。请你将图示与代码注释相结合，理解整个搜索过程，以及每种剪枝操作是如何工作的</strong></p><figure><img src="'+f+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 回溯算法：子集和 II */</span>
<span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>choices<span class="token punctuation">,</span> <span class="token keyword">int</span> choicesSize<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 子集和等于 target 时，记录解</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> stateSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            res<span class="token punctuation">[</span>resSize<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> state<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        resColSizes<span class="token punctuation">[</span>resSize<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> stateSize<span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 遍历所有选择</span>
    <span class="token comment">// 剪枝二：从 start 开始遍历，避免生成重复子集</span>
    <span class="token comment">// 剪枝三：从 start 开始遍历，避免重复选择同一元素</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> choicesSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 剪枝一：若子集和超过 target ，则直接跳过</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">-</span> choices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 剪枝四：如果该元素与左边元素相等，说明该搜索分支重复，直接跳过</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> start <span class="token operator">&amp;&amp;</span> choices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> choices<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 尝试：做出选择，更新 target, start</span>
        state<span class="token punctuation">[</span>stateSize<span class="token punctuation">]</span> <span class="token operator">=</span> choices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        stateSize<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token comment">// 进行下一轮选择</span>
        <span class="token function">backtrack</span><span class="token punctuation">(</span>target <span class="token operator">-</span> choices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> choices<span class="token punctuation">,</span> choicesSize<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 回退：撤销选择，恢复到之前的状态</span>
        stateSize<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 求解子集和 II */</span>
<span class="token keyword">void</span> <span class="token function">subsetSumII</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> numsSize<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 对 nums 进行排序</span>
    <span class="token function">qsort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> numsSize<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 开始回溯</span>
    <span class="token function">backtrack</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> numsSize<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_8-n皇后问题" tabindex="-1"><a class="header-anchor" href="#_8-n皇后问题"><span>8.N皇后问题</span></a></h2><p><strong>问题：根据国际象棋的规则，皇后可以攻击与同处一行、一列或一条斜线上的棋子。给定n个皇后和一个nxn大小的棋盘，寻找使得所有皇后之间无法相互攻击的摆放方案</strong></p><p><strong>如下图所示，当n=4时，共可以找到两个解。从回溯算法的角度看，nxn大小的棋盘共有n^2个格子，给出了所有的选择 choices 。在逐个放置皇后的过程中，棋盘状态在不断地变化，每个时刻的棋盘就是状态 state</strong></p><figure><img src="`+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>下图展示了本题的三个约束条件：多个皇后不能在同一行、同一列、同一条对角线上。值得注意的是，对角线分为主对角线 \\ 和次对角线 / 两种</strong></p><figure><img src="'+w+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_8-1-逐行放置策略" tabindex="-1"><a class="header-anchor" href="#_8-1-逐行放置策略"><span>8.1 逐行放置策略</span></a></h3><p><strong>皇后的数量和棋盘的行数都为n，因此我们容易得到一个推论：棋盘每行都允许且只允许放置一个皇后</strong></p><p><strong>也就是说，我们可以采取逐行放置策略：从第一行开始，在每行放置一个皇后，直至最后一行结束</strong></p><p><strong>下图所示为4皇后问题的逐行放置过程。受画幅限制，下图仅展开了第一行的其中一个搜索分支，并且将不满足列约束和对角线约束的方案都进行了剪枝</strong></p><figure><img src="'+E+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>从本质上看，逐行放置策略起到了剪枝的作用，它避免了同一行出现多个皇后的所有搜索分支</strong></p><hr><h3 id="_8-2-列与对角线剪枝" tabindex="-1"><a class="header-anchor" href="#_8-2-列与对角线剪枝"><span>8.2 列与对角线剪枝</span></a></h3><p><strong>为了满足列约束，我们可以利用一个长度为n的布尔型数组 cols 记录每一列是否有皇后。在每次决定放置前，我们通过 cols 将已有皇后的列进行剪枝，并在回溯中动态更新 cols 的状态</strong></p><p><strong>那么，如何处理对角线约束呢？设棋盘中某个格子的行列索引为(row,col)，选定矩阵中的某条主对角线，我们发现该对角线上所有格子的行索引减列索引都相等，即对角线上所有格子的row-col为恒定值</strong></p><p><strong>也就是说，如果两个格子满足row1-col1=row2-col2，则它们一定处在同一条主对角线上。利用该规律，我们可以借助下图所示的数组 diags1 记录每条主对角线上是否有皇后</strong></p><p><strong>同理，次对角线上的所有格子的row+col是恒定值。我们同样也可以借助数组 diags2 来处理次对角线约束</strong></p><figure><img src="'+z+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_8-3-代码实现" tabindex="-1"><a class="header-anchor" href="#_8-3-代码实现"><span>8.3 代码实现</span></a></h3><p><strong>请注意，n维方阵中row-col的范围是[-n+1,n-1]，row+col的范围是[0,2n-2]，所以主对角线和次对角线的数量都为2n-1，即数组diags1 和 diags2 的长度都为2n-1</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 回溯算法：n 皇后 */</span>
<span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span> row<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">char</span> state<span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>res<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>resSize<span class="token punctuation">,</span> bool cols<span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">,</span>bool diags1<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> MAX_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> bool diags2<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> MAX_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 当放置完所有行时，记录解</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>row <span class="token operator">==</span> n<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        res<span class="token punctuation">[</span><span class="token operator">*</span>resSize<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            res<span class="token punctuation">[</span><span class="token operator">*</span>resSize<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">strcpy</span><span class="token punctuation">(</span>res<span class="token punctuation">[</span><span class="token operator">*</span>resSize<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> state<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">(</span><span class="token operator">*</span>resSize<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 遍历所有列</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> col <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> col<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 计算该格子对应的主对角线和次对角线</span>
        <span class="token keyword">int</span> diag1 <span class="token operator">=</span> row <span class="token operator">-</span> col <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> diag2 <span class="token operator">=</span> row <span class="token operator">+</span> col<span class="token punctuation">;</span>
        <span class="token comment">// 剪枝：不允许该格子所在列、主对角线、次对角线上存在皇后</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cols<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>diags1<span class="token punctuation">[</span>diag1<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>diags2<span class="token punctuation">[</span>diag2<span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token comment">// 尝试：将皇后放置在该格子</span>
            state<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">&#39;Q&#39;</span><span class="token punctuation">;</span>
            cols<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> diags1<span class="token punctuation">[</span>diag1<span class="token punctuation">]</span> <span class="token operator">=</span> diags2<span class="token punctuation">[</span>diag2<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>
            <span class="token comment">// 放置下一行</span>
            <span class="token function">backtrack</span><span class="token punctuation">(</span>row <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> state<span class="token punctuation">,</span> res<span class="token punctuation">,</span> resSize<span class="token punctuation">,</span> cols<span class="token punctuation">,</span> diags1<span class="token punctuation">,</span> diags2<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 回退：将该格子恢复为空位</span>
            state<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">&#39;#&#39;</span><span class="token punctuation">;</span>
            cols<span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">=</span> diags1<span class="token punctuation">[</span>diag1<span class="token punctuation">]</span> <span class="token operator">=</span> diags2<span class="token punctuation">[</span>diag2<span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 求解 n 皇后 */</span>
<span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token function">nQueens</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>returnSize<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> state<span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 初始化 n*n 大小的棋盘，其中 &#39;Q&#39; 代表皇后，&#39;#&#39; 代表空位</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            state<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">&#39;#&#39;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        state<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">&#39;\\0&#39;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    bool cols<span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>false<span class="token punctuation">}</span><span class="token punctuation">;</span>           <span class="token comment">// 记录列是否有皇后</span>
    bool diags1<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> MAX_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>false<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 记录主对角线上是否有皇后</span>
    bool diags2<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> MAX_SIZE <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>false<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 记录次对角线上是否有皇后</span>

    <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">*</span> MAX_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>returnSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> state<span class="token punctuation">,</span> res<span class="token punctuation">,</span> returnSize<span class="token punctuation">,</span> cols<span class="token punctuation">,</span> diags1<span class="token punctuation">,</span> diags2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>逐行放置n次，考虑列约束，则从第一行到最后一行分别有n、n-1、...、2、1个选择，使用O(n!)时间。当记录解时，需要复制矩阵 state 并添加进 res ，复制操作使用O(n^2)时间。因此，总体时间复杂度为O(n!n ^2) 。实际上，根据对角线约束的剪枝也能够大幅缩小搜索空间，因而搜索效率往往优于以上时间复杂度</strong></p><p><strong>数组 state 使用O(n^2)空间，数组 cols、diags1 和 diags2 皆使用O(n)空间。最大递归深度为n，使用O(n)栈帧空间。因此，空间复杂度为O(n^2)</strong></p>`,165),A=[S];function B(x,D){return s(),a("div",null,A)}const O=n(_,[["render",B],["__file","13.回溯.html.vue"]]),N=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/13.%E5%9B%9E%E6%BA%AF.html","title":"第十三章：回溯","lang":"zh-CN","frontmatter":{"date":"2024-03-13T00:00:00.000Z","order":13,"description":"第十三章：回溯 回溯算法（backtracking algorithm）是一种通过穷举来解决问题的方法，它的核心思想是从一个初始状态出发，暴力搜索所有可能的解决方案，当遇到正确的解则将其记录，直到找到解或者尝试了所有可能的选择都无法找到解为止 回溯算法通常采用“深度优先搜索”来遍历解空间。在“二叉树”章节中，我们提到前序、中序和后序遍历都属于深度优先搜...","head":[["meta",{"property":"og:url","content":"https://github.com/jimbo-master/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/13.%E5%9B%9E%E6%BA%AF.html"}],["meta",{"property":"og:site_name","content":"JimBoの学习妙妙屋"}],["meta",{"property":"og:title","content":"第十三章：回溯"}],["meta",{"property":"og:description","content":"第十三章：回溯 回溯算法（backtracking algorithm）是一种通过穷举来解决问题的方法，它的核心思想是从一个初始状态出发，暴力搜索所有可能的解决方案，当遇到正确的解则将其记录，直到找到解或者尝试了所有可能的选择都无法找到解为止 回溯算法通常采用“深度优先搜索”来遍历解空间。在“二叉树”章节中，我们提到前序、中序和后序遍历都属于深度优先搜..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"JimBo"}],["meta",{"property":"article:published_time","content":"2024-03-13T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第十三章：回溯\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-13T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JimBo\\",\\"url\\":\\"https://github.com/jimbo-master\\"}]}"]]},"headers":[{"level":2,"title":"1.尝试与回退","slug":"_1-尝试与回退","link":"#_1-尝试与回退","children":[]},{"level":2,"title":"2.剪枝","slug":"_2-剪枝","link":"#_2-剪枝","children":[]},{"level":2,"title":"3.框架代码","slug":"_3-框架代码","link":"#_3-框架代码","children":[]},{"level":2,"title":"4.优点与缺点","slug":"_4-优点与缺点","link":"#_4-优点与缺点","children":[]},{"level":2,"title":"5.回溯算法经典例题","slug":"_5-回溯算法经典例题","link":"#_5-回溯算法经典例题","children":[]},{"level":2,"title":"6.全排列问题","slug":"_6-全排列问题","link":"#_6-全排列问题","children":[{"level":3,"title":"6.1 无相等元素的情况","slug":"_6-1-无相等元素的情况","link":"#_6-1-无相等元素的情况","children":[]},{"level":3,"title":"6.2 考虑相等元素情况","slug":"_6-2-考虑相等元素情况","link":"#_6-2-考虑相等元素情况","children":[]},{"level":3,"title":"6.3 两种剪枝对比","slug":"_6-3-两种剪枝对比","link":"#_6-3-两种剪枝对比","children":[]}]},{"level":2,"title":"7.子集和问题","slug":"_7-子集和问题","link":"#_7-子集和问题","children":[{"level":3,"title":"7.1 无重复元素的情况","slug":"_7-1-无重复元素的情况","link":"#_7-1-无重复元素的情况","children":[]},{"level":3,"title":"7.2 考虑重复元素情况","slug":"_7-2-考虑重复元素情况","link":"#_7-2-考虑重复元素情况","children":[]}]},{"level":2,"title":"8.N皇后问题","slug":"_8-n皇后问题","link":"#_8-n皇后问题","children":[{"level":3,"title":"8.1 逐行放置策略","slug":"_8-1-逐行放置策略","link":"#_8-1-逐行放置策略","children":[]},{"level":3,"title":"8.2 列与对角线剪枝","slug":"_8-2-列与对角线剪枝","link":"#_8-2-列与对角线剪枝","children":[]},{"level":3,"title":"8.3 代码实现","slug":"_8-3-代码实现","link":"#_8-3-代码实现","children":[]}]}],"git":{},"readingTime":{"minutes":25.83,"words":7750},"filePathRelative":"算法学习/1.算法知识/13.回溯.md","localizedDate":"2024年3月13日","autoDesc":true,"excerpt":"\\n<p><strong>回溯算法（backtracking algorithm）是一种通过穷举来解决问题的方法，它的核心思想是从一个初始状态出发，暴力搜索所有可能的解决方案，当遇到正确的解则将其记录，直到找到解或者尝试了所有可能的选择都无法找到解为止</strong></p>\\n<p><strong>回溯算法通常采用“深度优先搜索”来遍历解空间。在“二叉树”章节中，我们提到前序、中序和后序遍历都属于深度优先搜索。接下来，我们利用前序遍历构造一个回溯问题，逐步了解回溯算法的工作原理</strong></p>\\n<blockquote>\\n<p><strong>问题：给定一棵二叉树，搜索并记录所有值为8的节点，请返回节点列表</strong></p>\\n</blockquote>"}');export{O as comp,N as data};
