import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,b as t}from"./app-Dezzdk4T.js";const p="/assets/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98-BWuCQ9gA.png",e="/assets/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%BC%98%E7%BC%BA%E7%82%B9-BIaqEKJ8.png",i="/assets/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E6%97%A0%E6%B3%95%E6%89%BE%E5%87%BA%E6%9C%80%E4%BC%98%E8%A7%A3-BFAatkkw.png",o="/assets/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%89%B9%E5%BE%81-DIhuT1FZ.png",c="/assets/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4-CpBqSBXd.png",l="/assets/%E5%88%86%E6%95%B0%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-CP-GzkCH.png",r="/assets/%E5%8D%95%E4%BD%8D%E4%BB%B7%E5%80%BC-DWYgebpB.png",u="/assets/%E5%88%86%E6%95%B0%E8%83%8C%E5%8C%85%E7%AD%96%E7%95%A5-Cfmto56Z.png",d="/assets/%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E-BMIQudwg.png",k="/assets/%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F%E9%97%AE%E9%A2%98-JBGVENlr.png",g="/assets/%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F%E5%8E%9F%E7%90%86-DaREHF7Z.png",m="/assets/%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81-BAW7d_AA.png",v="/assets/%E5%90%91%E5%86%85%E7%A7%BB%E5%8A%A8%E5%90%8E%E7%8A%B6%E6%80%81-3IoLcPyb.png",E="/assets/%E5%90%91%E5%86%85%E7%A7%BB%E5%8A%A8%E5%90%8E%E7%8A%B6%E6%80%812-DaqnLVW_.png",b="/assets/%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F%E8%B4%AA%E5%BF%83%E8%BF%87%E7%A8%8B-BAD95f-R.png",h="/assets/%E6%9C%80%E5%A4%A7%E5%AE%B9%E9%87%8F%E8%B4%AA%E5%BF%83%E8%BF%87%E7%A8%8B2-8lFmA9nt.png",f="/assets/%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E2-BEIwrKev.png",A="/assets/%E6%9C%80%E5%A4%A7%E5%88%87%E5%88%86%E4%B9%98%E7%A7%AF%E9%97%AE%E9%A2%98-D8ZoCs7A.png",_="/assets/%E6%9C%80%E5%A4%A7%E5%88%87%E5%88%86%E4%B9%98%E7%A7%AF%E9%97%AE%E9%A2%98%E6%8E%A2%E8%AE%A8-CCwGGJ81.png",y="/assets/%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5%E7%A1%AE%E5%AE%9A-4DEsgM-I.png",B="/assets/%E5%88%87%E5%88%86%E5%AF%BC%E8%87%B4%E4%B9%98%E7%A7%AF%E5%8F%98%E5%A4%A7-g24d5rXG.png",w="/assets/%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5-ubG27txI.png",x="/assets/%E6%9C%80%E5%A4%A7%E5%88%87%E5%88%86%E4%B9%98%E7%A7%AF%E8%AE%A1%E7%AE%97-1AH_6fqK.png",C="/assets/%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E3-B5xxd-2S.png",F={},z=t('<h1 id="第十五章-贪心" tabindex="-1"><a class="header-anchor" href="#第十五章-贪心"><span>第十五章：贪心</span></a></h1><h2 id="_1-贪心算法" tabindex="-1"><a class="header-anchor" href="#_1-贪心算法"><span>1.贪心算法</span></a></h2><p><strong>贪心算法（greedy algorithm）是一种常见的解决优化问题的算法，其基本思想是在问题的每个决策阶段，都选择当前看起来最优的选择，即贪心地做出局部最优的决策，以期获得全局最优解。贪心算法简洁且高效，在许多实际问题中有着广泛的应用</strong></p><p><strong>贪心算法和动态规划都常用于解决优化问题。它们之间存在一些相似之处，比如都依赖最优子结构性质，但工作原理不同</strong></p><ul><li><strong>动态规划会根据之前阶段的所有决策来考虑当前决策，并使用过去子问题的解来构建当前子问题的解</strong></li><li><strong>贪心算法不会考虑过去的决策，而是一路向前地进行贪心选择，不断缩小问题范围，直至问题被解决</strong></li></ul><p><strong>问题：给定n种硬币，第i种硬币的面值为coins[i-1]，目标金额为amt，每种硬币可以重复选取，问能够凑出目标金额的最少硬币数量。如果无法凑出目标金额，则返回-1</strong></p><p><strong>本题采取的贪心策略如下图所示。给定目标金额，我们贪心地选择不大于且最接近它的硬币，不断循环该步骤，直至凑出目标金额为止</strong></p><figure><img src="'+p+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>实现代码如下所示：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 零钱兑换：贪心 */</span>
<span class="token keyword">int</span> <span class="token function">coinChangeGreedy</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>coins<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> amt<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 假设 coins 列表有序</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 循环进行贪心选择，直到无剩余金额</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>amt <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 找到小于且最接近剩余金额的硬币</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> coins<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> amt<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            i<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 选择 coins[i]</span>
        amt <span class="token operator">-=</span> coins<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 若未找到可行方案，则返回 -1</span>
    <span class="token keyword">return</span> amt <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> count <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>你可能会不由地发出感叹：So clean ！贪心算法仅用约十行代码就解决了零钱兑换问题</strong></p><hr><h2 id="_2-贪心算法的优点与缺点" tabindex="-1"><a class="header-anchor" href="#_2-贪心算法的优点与缺点"><span>2.贪心算法的优点与缺点</span></a></h2><figure><img src="`+e+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>也就是说，对于零钱兑换问题，贪心算法无法保证找到全局最优解，并且有可能找到非常差的解。它更适合用动态规划解决</strong></p><p><strong>一般情况下，贪心算法的适用情况分以下两种：</strong></p><ul><li><strong>可以保证找到最优解：贪心算法在这种情况下往往是最优选择，因为它往往比回溯、动态规划更高效</strong></li><li><strong>可以找到近似最优解：贪心算法在这种情况下也是可用的。对于很多复杂问题来说，寻找全局最优解非常困难，能以较高效率找到次优解也是非常不错的</strong></li></ul><hr><h2 id="_3-贪心算法特征" tabindex="-1"><a class="header-anchor" href="#_3-贪心算法特征"><span>3.贪心算法特征</span></a></h2><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h2 id="_4-贪心算法解题步骤" tabindex="-1"><a class="header-anchor" href="#_4-贪心算法解题步骤"><span>4.贪心算法解题步骤</span></a></h2><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h2 id="_5-贪心算法经典问题" tabindex="-1"><a class="header-anchor" href="#_5-贪心算法经典问题"><span>5.贪心算法经典问题</span></a></h2><p><strong>贪心算法常常应用在满足贪心选择性质和最优子结构的优化问题中，以下列举了一些典型的贪心算法问题</strong></p><ul><li><strong>硬币找零问题：在某些硬币组合下，贪心算法总是可以得到最优解</strong></li><li><strong>区间调度问题：假设你有一些任务，每个任务在一段时间内进行，你的目标是完成尽可能多的任务。如果每次都选择结束时间最早的任务，那么贪心算法就可以得到最优解</strong></li><li><strong>分数背包问题：给定一组物品和一个载重量，你的目标是选择一组物品，使得总重量不超过载重量，且总价值最大。如果每次都选择性价比最高（价值 / 重量）的物品，那么贪心算法在一些情况下可以得到最优解</strong></li><li><strong>股票买卖问题：给定一组股票的历史价格，你可以进行多次买卖，但如果你已经持有股票，那么在卖出之前不能再买，目标是获取最大利润</strong></li><li><strong>霍夫曼编码：霍夫曼编码是一种用于无损数据压缩的贪心算法。通过构建霍夫曼树，每次选择出现频率最低的两个节点合并，最后得到的霍夫曼树的带权路径长度（编码长度）最小</strong></li><li><strong>Dijkstra 算法：它是一种解决给定源顶点到其余各顶点的最短路径问题的贪心算法</strong></li></ul><hr><h2 id="_6-分数背包问题" tabindex="-1"><a class="header-anchor" href="#_6-分数背包问题"><span>6.分数背包问题</span></a></h2><p><strong>问题：给定n个物品，第i个物品的重量为wgt[i-1]、价值为val[i-1]，和一个容量为cap的背包。每个物品只能选择一次，但可以选择物品的一部分，价值根据选择的重量比例计算，问在限定背包容量下背包中物品的最大价值。如下图所示：</strong></p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>分数背包问题和 0-1 背包问题整体上非常相似，状态包含当前物品i和容量c，目标是求限定背包容量下的最大价值</strong></p><p><strong>不同点在于，本题允许只选择物品的一部分。如下图所示，我们可以对物品任意地进行切分，并按照重量比例来计算相应价值</strong></p><ul><li><strong>对于物品i，它在单位重量下的价值为val[i-1]/wgt[i-1]，简称单位价值</strong></li><li><strong>假设放入一部分物品i，重量为w，则背包增加的价值为w x val[i-1] / wgt[i-1]</strong></li></ul><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_6-1-贪心策略确定" tabindex="-1"><a class="header-anchor" href="#_6-1-贪心策略确定"><span>6.1 贪心策略确定</span></a></h3><p><strong>最大化背包内物品总价值，本质上是最大化单位重量下的物品价值。由此便可推理出下图所示的贪心策略</strong></p><ul><li><strong>将物品按照单位价值从高到低进行排序</strong></li><li><strong>遍历所有物品，每轮贪心地选择单位价值最高的物品</strong></li><li><strong>若剩余背包容量不足，则使用当前物品的一部分填满背包</strong></li></ul><figure><img src="'+u+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_6-2-代码实现" tabindex="-1"><a class="header-anchor" href="#_6-2-代码实现"><span>6.2 代码实现</span></a></h3><p><strong>我们建立了一个物品类 Item ，以便将物品按照单位价值进行排序。循环进行贪心选择，当背包已满时跳出并返回解：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 物品 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> w<span class="token punctuation">;</span> <span class="token comment">// 物品重量</span>
    <span class="token keyword">int</span> v<span class="token punctuation">;</span> <span class="token comment">// 物品价值</span>
<span class="token punctuation">}</span> Item<span class="token punctuation">;</span>

<span class="token comment">/* 分数背包：贪心 */</span>
<span class="token keyword">float</span> <span class="token function">fractionalKnapsack</span><span class="token punctuation">(</span><span class="token keyword">int</span> wgt<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> itemCount<span class="token punctuation">,</span> <span class="token keyword">int</span> cap<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 创建物品列表，包含两个属性：重量、价值</span>
    Item <span class="token operator">*</span>items <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>Item<span class="token punctuation">)</span> <span class="token operator">*</span> itemCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> itemCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        items<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>Item<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span>w <span class="token operator">=</span> wgt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>v <span class="token operator">=</span> val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 按照单位价值 item.v / item.w 从高到低进行排序</span>
    <span class="token function">qsort</span><span class="token punctuation">(</span>items<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span>itemCount<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Item<span class="token punctuation">)</span><span class="token punctuation">,</span> sortByValueDensity<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 循环贪心选择</span>
    <span class="token keyword">float</span> res <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> itemCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w <span class="token operator">&lt;=</span> cap<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token comment">// 若剩余容量充足，则将当前物品整个装进背包</span>
            res <span class="token operator">+=</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>
            cap <span class="token operator">-=</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
        <span class="token keyword">else</span> 
        <span class="token punctuation">{</span>
            <span class="token comment">// 若剩余容量不足，则将当前物品的一部分装进背包</span>
            res <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>cap <span class="token operator">/</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w <span class="token operator">*</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>v<span class="token punctuation">;</span>
            cap <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">free</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>除排序之外，在最差情况下，需要遍历整个物品列表，因此时间复杂度为O(n)，其中n为物品数量</strong></p><p><strong>由于初始化了一个 Item 对象列表，因此空间复杂度为O(n)</strong></p><hr><h3 id="_6-3-正确性证明" tabindex="-1"><a class="header-anchor" href="#_6-3-正确性证明"><span>6.3 正确性证明</span></a></h3><figure><img src="`+d+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h2 id="_7-最大容量问题" tabindex="-1"><a class="header-anchor" href="#_7-最大容量问题"><span>7.最大容量问题</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>问题：
    输入一个数组 \\(ht\\) ，其中的每个元素代表一个垂直隔板的高度。数组中的任意两个隔板，以及它们之间的空间可以组成一个容器

    容器的容量等于高度和宽度的乘积（面积），其中高度由较短的隔板决定，宽度是两个隔板的数组索引之差

    请在数组中选择两个隔板，使得组成的容器的容量最大，返回最大容量。如下图所示
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>容器由任意两个隔板围成，因此本题的状态为两个隔板的索引，记为[i,j]</strong></p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_7-1-贪心策略确定" tabindex="-1"><a class="header-anchor" href="#_7-1-贪心策略确定"><span>7.1 贪心策略确定</span></a></h3><p><strong>这道题还有更高效率的解法。如下图所示，现选取一个状态[i,j]，其满足索引i &lt; j 且高度ht[i] &lt; ht[j]，即i为短板、j为长版</strong></p><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>如下图所示，若此时将长板j向短板i靠近，则容量一定变小</strong></p><p><strong>这是因为在移动长板j后，宽度j-i肯定变小；而高度由短板决定，因此高度只可能不变（i仍为短板）或变小（移动后的j成为短板）</strong></p><figure><img src="'+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>反向思考，我们只有向内收缩短板i，才有可能使容量变大。因为虽然宽度一定变小，但高度可能会变大（移动后的短板i可能会变长）。例如在下图中，移动短板后面积变大</strong></p><figure><img src="'+E+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>由此便可推出本题的贪心策略：初始化两指针，使其分列容器两端，每轮向内收缩短板对应的指针，直至两指针相遇</strong></p><p><strong>下图展示了贪心策略的执行过程：</strong></p><ul><li><strong>初始状态下，指针i和j分列数组两端</strong></li><li><strong>计算当前状态的容量cap[i,j]，并更新最大容量</strong></li><li><strong>比较板i和板j的高度，并将短板向内移动一格</strong></li><li><strong>循环执行第2步和第3步，直至i和j相遇时结束</strong></li></ul><figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+h+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_7-2-代码实现" tabindex="-1"><a class="header-anchor" href="#_7-2-代码实现"><span>7.2 代码实现</span></a></h3><p><strong>代码循环最多n轮，因此时间复杂度为0(n)</strong></p><p><strong>变量i、j、res使用常数大小的额外空间，因此空间复杂度为O(1)</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 最大容量：贪心 */</span>
<span class="token keyword">int</span> <span class="token function">maxCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> ht<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> htLength<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 初始化 i, j，使其分列数组两端</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> htLength <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 初始最大容量为 0</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 循环贪心选择，直至两板相遇</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 更新最大容量</span>
        <span class="token keyword">int</span> capacity <span class="token operator">=</span> <span class="token function">myMin</span><span class="token punctuation">(</span>ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> ht<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        res <span class="token operator">=</span> <span class="token function">myMax</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 向内移动短板</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ht<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> ht<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
        <span class="token keyword">else</span> 
        <span class="token punctuation">{</span>
            j<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_7-3-正确性证明" tabindex="-1"><a class="header-anchor" href="#_7-3-正确性证明"><span>7.3 正确性证明</span></a></h3><figure><img src="`+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h2 id="_8-最大切分乘积问题" tabindex="-1"><a class="header-anchor" href="#_8-最大切分乘积问题"><span>8.最大切分乘积问题</span></a></h2><p><strong>问题：给定一个正整数n，将其切分为至少两个正整数的和，求切分后所有整数的乘积最大是多少，如下图所示：</strong></p><figure><img src="'+A+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_8-1-贪心策略确定" tabindex="-1"><a class="header-anchor" href="#_8-1-贪心策略确定"><span>8.1 贪心策略确定</span></a></h3><figure><img src="'+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+B+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>接下来思考哪个因子是最优的。在1、2、3这三个因子中，显然1是最差的，因为1 x (n-1) &lt; n 恒成立，即切分出1反而会导致乘积减少</strong></p><p><strong>如下图所示，当n=6时，有3x3 &gt; 2x2x2。这意味着切分出的3比切分出2更优</strong></p><figure><img src="'+w+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_8-2-代码实现" tabindex="-1"><a class="header-anchor" href="#_8-2-代码实现"><span>8.2 代码实现</span></a></h3><p><strong>如下图所示，我们无须通过循环来切分整数，而可以利用向下整除运算得到3的个数a，用取模运算得到余数b，此时有：n=3a+b</strong></p><p><strong>请注意：对于n ≤ 3的边界情况，必须拆分出一个1，乘积为1 x (n-1)</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 最大切分乘积：贪心 */</span>
<span class="token keyword">int</span> <span class="token function">maxProductCutting</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 当 n &lt;= 3 时，必须切分出一个 1</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 贪心地切分出 3 ，a 为 3 的个数，b 为余数</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> n <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 当余数为 1 时，将一对 1 * 3 转化为 2 * 2</span>
        <span class="token keyword">return</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> a <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 当余数为 2 时，不做处理</span>
        <span class="token keyword">return</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 当余数为 0 时，不做处理</span>
    <span class="token keyword">return</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+x+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>时间复杂度取决于编程语言的幂运算的实现方法</strong></p><p><strong>变量a和b使用常数大小的额外空间，因此空间复杂度为O(1)</strong></p><hr><h3 id="_8-3-正确性证明" tabindex="-1"><a class="header-anchor" href="#_8-3-正确性证明"><span>8.3 正确性证明</span></a></h3><figure><img src="'+C+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',101),j=[z];function D(I,G){return s(),a("div",null,j)}const P=n(F,[["render",D],["__file","15.贪心.html.vue"]]),q=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/15.%E8%B4%AA%E5%BF%83.html","title":"第十五章：贪心","lang":"zh-CN","frontmatter":{"date":"2024-03-15T00:00:00.000Z","order":15,"description":"第十五章：贪心 1.贪心算法 贪心算法（greedy algorithm）是一种常见的解决优化问题的算法，其基本思想是在问题的每个决策阶段，都选择当前看起来最优的选择，即贪心地做出局部最优的决策，以期获得全局最优解。贪心算法简洁且高效，在许多实际问题中有着广泛的应用 贪心算法和动态规划都常用于解决优化问题。它们之间存在一些相似之处，比如都依赖最优子结构...","head":[["meta",{"property":"og:url","content":"https://github.com/jimbo-master/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/15.%E8%B4%AA%E5%BF%83.html"}],["meta",{"property":"og:site_name","content":"JimBoの学习妙妙屋"}],["meta",{"property":"og:title","content":"第十五章：贪心"}],["meta",{"property":"og:description","content":"第十五章：贪心 1.贪心算法 贪心算法（greedy algorithm）是一种常见的解决优化问题的算法，其基本思想是在问题的每个决策阶段，都选择当前看起来最优的选择，即贪心地做出局部最优的决策，以期获得全局最优解。贪心算法简洁且高效，在许多实际问题中有着广泛的应用 贪心算法和动态规划都常用于解决优化问题。它们之间存在一些相似之处，比如都依赖最优子结构..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"JimBo"}],["meta",{"property":"article:published_time","content":"2024-03-15T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第十五章：贪心\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-15T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JimBo\\",\\"url\\":\\"https://github.com/jimbo-master\\"}]}"]]},"headers":[{"level":2,"title":"1.贪心算法","slug":"_1-贪心算法","link":"#_1-贪心算法","children":[]},{"level":2,"title":"2.贪心算法的优点与缺点","slug":"_2-贪心算法的优点与缺点","link":"#_2-贪心算法的优点与缺点","children":[]},{"level":2,"title":"3.贪心算法特征","slug":"_3-贪心算法特征","link":"#_3-贪心算法特征","children":[]},{"level":2,"title":"4.贪心算法解题步骤","slug":"_4-贪心算法解题步骤","link":"#_4-贪心算法解题步骤","children":[]},{"level":2,"title":"5.贪心算法经典问题","slug":"_5-贪心算法经典问题","link":"#_5-贪心算法经典问题","children":[]},{"level":2,"title":"6.分数背包问题","slug":"_6-分数背包问题","link":"#_6-分数背包问题","children":[{"level":3,"title":"6.1 贪心策略确定","slug":"_6-1-贪心策略确定","link":"#_6-1-贪心策略确定","children":[]},{"level":3,"title":"6.2 代码实现","slug":"_6-2-代码实现","link":"#_6-2-代码实现","children":[]},{"level":3,"title":"6.3 正确性证明","slug":"_6-3-正确性证明","link":"#_6-3-正确性证明","children":[]}]},{"level":2,"title":"7.最大容量问题","slug":"_7-最大容量问题","link":"#_7-最大容量问题","children":[{"level":3,"title":"7.1 贪心策略确定","slug":"_7-1-贪心策略确定","link":"#_7-1-贪心策略确定","children":[]},{"level":3,"title":"7.2 代码实现","slug":"_7-2-代码实现","link":"#_7-2-代码实现","children":[]},{"level":3,"title":"7.3 正确性证明","slug":"_7-3-正确性证明","link":"#_7-3-正确性证明","children":[]}]},{"level":2,"title":"8.最大切分乘积问题","slug":"_8-最大切分乘积问题","link":"#_8-最大切分乘积问题","children":[{"level":3,"title":"8.1 贪心策略确定","slug":"_8-1-贪心策略确定","link":"#_8-1-贪心策略确定","children":[]},{"level":3,"title":"8.2 代码实现","slug":"_8-2-代码实现","link":"#_8-2-代码实现","children":[]},{"level":3,"title":"8.3 正确性证明","slug":"_8-3-正确性证明","link":"#_8-3-正确性证明","children":[]}]}],"git":{},"readingTime":{"minutes":10.63,"words":3190},"filePathRelative":"算法学习/1.算法知识/15.贪心.md","localizedDate":"2024年3月15日","autoDesc":true,"excerpt":"\\n<h2>1.贪心算法</h2>\\n<p><strong>贪心算法（greedy algorithm）是一种常见的解决优化问题的算法，其基本思想是在问题的每个决策阶段，都选择当前看起来最优的选择，即贪心地做出局部最优的决策，以期获得全局最优解。贪心算法简洁且高效，在许多实际问题中有着广泛的应用</strong></p>\\n<p><strong>贪心算法和动态规划都常用于解决优化问题。它们之间存在一些相似之处，比如都依赖最优子结构性质，但工作原理不同</strong></p>\\n<ul>\\n<li><strong>动态规划会根据之前阶段的所有决策来考虑当前决策，并使用过去子问题的解来构建当前子问题的解</strong></li>\\n<li><strong>贪心算法不会考虑过去的决策，而是一路向前地进行贪心选择，不断缩小问题范围，直至问题被解决</strong></li>\\n</ul>"}');export{P as comp,q as data};
