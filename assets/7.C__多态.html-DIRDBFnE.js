import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,b as t}from"./app-Dezzdk4T.js";const p="/assets/7.C__%E5%A4%9A%E6%80%81-BBAKcGM9.png",e={},o=t('<h1 id="第七章-c-多态" tabindex="-1"><a class="header-anchor" href="#第七章-c-多态"><span>第七章：C++多态</span></a></h1><h2 id="知识点思维导图" tabindex="-1"><a class="header-anchor" href="#知识点思维导图"><span>知识点思维导图</span></a></h2><figure><img src="'+p+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h2 id="复习代码" tabindex="-1"><a class="header-anchor" href="#复习代码"><span>复习代码</span></a></h2><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">//  Author：jimbo（1353429820@qq.com）</span>
<span class="token comment">//  Filename：main</span>
<span class="token comment">//  Date：2024/1/20</span>
<span class="token comment">//  Description：review knowledge points</span>
<span class="token comment">//  Copyrights（c）JimBo. All rights reserved</span>


<span class="token comment">//1.虚函数的重写</span>
<span class="token comment">//虚函数的重写也叫虚函数的覆盖，若派生类中有一个和基类完全相同的虚函数，此时称该派生类虚函数重写了基类虚函数</span>
<span class="token comment">//在重写基类虚函数时，派生类虚函数不加virtual关键字也构成重写，因为继承后基类的虚函数被继承下来，但不推荐不加</span>
<span class="token comment">//C++11引入final修饰虚函数，表示不能被继承或重写。而override放在虚函数声明后，用于检查是否存在于基类虚函数相匹配的函数</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>

<span class="token comment">//基类</span>
class Shape
<span class="token punctuation">{</span>
 public<span class="token operator">:</span>
    <span class="token comment">//虚函数</span>
    virtual <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span>
       std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Drawing a shape&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//虚拟析构函数，保证正确释放资源</span>
    virtual <span class="token operator">~</span><span class="token function">Shape</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//派生类：Circle</span>
class Circle <span class="token operator">:</span> public Shape
<span class="token punctuation">{</span>
 public<span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> override
    <span class="token punctuation">{</span>
       std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Drawing a circle&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//派生类：Square</span>
class Square <span class="token operator">:</span> public Shape
<span class="token punctuation">{</span>
 public<span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> override
    <span class="token punctuation">{</span>
       std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Drawing a  square&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//函数：接收Shape的基类指针，并调用虚函数draw()</span>
<span class="token keyword">void</span> <span class="token function">drawShape</span><span class="token punctuation">(</span><span class="token keyword">const</span> Shape<span class="token operator">*</span> shape<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    shape<span class="token operator">-&gt;</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//创建对象</span>
    Circle circle<span class="token punctuation">;</span>
    Square square<span class="token punctuation">;</span>

    <span class="token comment">//使用基类指针调用虚函数，实现多态性</span>
    <span class="token function">drawShape</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>circle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">drawShape</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>square<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*
    运行结果：
            Drawing a circle
            Drawing a square
*/</span>


<span class="token comment">//2.虚函数重写的两个例外：协变、析构函数重写，两个特例也构成重载</span>
<span class="token comment">//协变：派生类重写基类虚函数时，与基类虚函数返回值类型不同，基类虚函数返回基类对象的指针或引用，派生类返回派生类对象的指针或引用</span>
<span class="token comment">//析构函数重写：如果基类的析构函数为虚函数，此时派生类析构函数只要定义，无论是否加virtual，都与基类析构函数构成重写，即使名字不同</span>

<span class="token comment">//协变例子</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>

<span class="token comment">//基类</span>
class Animal
<span class="token punctuation">{</span>
 public<span class="token operator">:</span>
    virtual Animal<span class="token operator">*</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span>
       std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span> <span class="token string">&quot;cloning an animal&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
       <span class="token keyword">return</span> new <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//派生类</span>
class Dog <span class="token operator">:</span> public Animal
<span class="token punctuation">{</span>
 public<span class="token operator">:</span>
    <span class="token comment">//Dog类中采用协变，重写了clone()函数。并返回Dog*类型的指针</span>
    Dog<span class="token operator">*</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> override
    <span class="token punctuation">{</span>
       std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span> <span class="token string">&quot;cloning a dog&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
       <span class="token keyword">return</span> new <span class="token function">Dog</span><span class="token punctuation">(</span><span class="token operator">*</span>this<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//创建派生类</span>
    Dog myDog<span class="token punctuation">;</span>

    <span class="token comment">//使用基类指针调用虚函数</span>
    Animal<span class="token operator">*</span> clonedAnimal <span class="token operator">=</span> myDog<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//说明：通过基类指针调用clone()函数，由于协变存在，实际调用Dog类的clone()函数</span>
    <span class="token comment">//协变使得在派生类中的虚函数能够返回更具体的类型，提高了灵活性和代码的可读性</span>

    <span class="token comment">//清理指针</span>
    delete clonedAnimal<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 运行结果：cloning a dog</span>


<span class="token comment">//析构函数重写例子</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>

<span class="token comment">//基类</span>
class Base
<span class="token punctuation">{</span>
 public<span class="token operator">:</span>
    <span class="token comment">//基类的虚拟析构函数</span>
    virtual <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Base Destructor&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//派生类</span>
class Derived <span class="token operator">:</span> public Base
<span class="token punctuation">{</span>
 public<span class="token operator">:</span>
    <span class="token comment">//派生类的虚拟析构函数，重写基类的析构函数</span>
    <span class="token operator">~</span><span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override
    <span class="token punctuation">{</span>
       std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Derived Destructor&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//使用基类指针指向派生类对象</span>
    Base<span class="token operator">*</span> ptr <span class="token operator">=</span> new Derived<span class="token punctuation">;</span>

    <span class="token comment">//使用基类指针删除对象，调用派生类析构函数</span>
    delete ptr<span class="token punctuation">;</span>
    <span class="token comment">//说明：基类析构被声明为虚析构函数，则被重写为Dervied类的析构函数，然后再调用Base类的虚析构函数</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*
    运行结果：
          Derived Destructor
          Base    Destructor
*/</span>


<span class="token comment">//3.抽象类(接口类)</span>
<span class="token comment">//在虚函数后加=0，则这个函数称为存虚函数，包含纯虚函数的类叫做抽象类，也叫接口类，抽象类不能实例化对象</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>

<span class="token comment">//抽象类</span>
class Shape
<span class="token punctuation">{</span>
 public<span class="token operator">:</span>
    <span class="token comment">//纯虚函数，使得Shape成为抽象类</span>
    virtual <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">//普通成员函数</span>
    <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span>
       std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;displaying a shape&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//虚析构函数，通常在抽象类中声明为虚析构函数</span>
    virtual <span class="token operator">~</span><span class="token function">Shape</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
       std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;shape destructor&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//派生类</span>
class Circle <span class="token operator">:</span> public Shape
<span class="token punctuation">{</span>
 public<span class="token operator">:</span>
    <span class="token comment">//实现抽象类中的纯虚函数</span>
    <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> override
    <span class="token punctuation">{</span>
       std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;drawing a circle&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//派生类的其他成员函数</span>
    <span class="token keyword">void</span> <span class="token function">calculateArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span>
       std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;calculating the area of a circle&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">//派生类的析构函数</span>
    <span class="token operator">~</span><span class="token function">Circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> override
    <span class="token punctuation">{</span>
       std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;circle destructor&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//抽象类(接口类)不能实例化</span>
    <span class="token comment">//Shape shape; //报错：不能实例化</span>

    <span class="token comment">//使用基类指针指向派生类对象，向上转型切片</span>
    Shape<span class="token operator">*</span> circle <span class="token operator">=</span> new Circle<span class="token punctuation">;</span>

    <span class="token comment">//说明：向上转型进行了切片，舍去了派生类的draw()，但是Circle对象赋值给Shape*，</span>
    <span class="token comment">//虽然静态类型变成了基类Shape*，但是动态类型还是派生类Circle，因此虚函数调用时</span>
    <span class="token comment">//会根据动态类型调用响应的实现</span>

    <span class="token comment">//调用纯虚函数，实际调用了派生类的实现</span>
    circle<span class="token operator">-&gt;</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//调用普通成员函数，也是通过基类指针调用</span>
    circle<span class="token operator">-&gt;</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//使用基类指针删除对象，调用派生类的析构函数</span>
    delete circle<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*
 运行结果：
    drawing a circle
    displaying a shape
    circle destructor
    shape destructor
*/</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,6),c=[o];function l(i,u){return s(),a("div",null,c)}const d=n(e,[["render",l],["__file","7.C__多态.html.vue"]]),m=JSON.parse('{"path":"/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/2.CPP/7.C__%E5%A4%9A%E6%80%81.html","title":"第七章：C++多态","lang":"zh-CN","frontmatter":{"date":"2024-02-07T00:00:00.000Z","order":8,"description":"第七章：C++多态 知识点思维导图 复习代码","head":[["meta",{"property":"og:url","content":"https://github.com/jimbo-master/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/2.CPP/7.C__%E5%A4%9A%E6%80%81.html"}],["meta",{"property":"og:site_name","content":"JimBoの学习妙妙屋"}],["meta",{"property":"og:title","content":"第七章：C++多态"}],["meta",{"property":"og:description","content":"第七章：C++多态 知识点思维导图 复习代码"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"JimBo"}],["meta",{"property":"article:published_time","content":"2024-02-07T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第七章：C++多态\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-02-07T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JimBo\\",\\"url\\":\\"https://github.com/jimbo-master\\"}]}"]]},"headers":[{"level":2,"title":"知识点思维导图","slug":"知识点思维导图","link":"#知识点思维导图","children":[]},{"level":2,"title":"复习代码","slug":"复习代码","link":"#复习代码","children":[]}],"git":{},"readingTime":{"minutes":4.21,"words":1263},"filePathRelative":"编程学习/2.CPP/7.C++多态.md","localizedDate":"2024年2月7日","autoDesc":true,"excerpt":"\\n<h2>知识点思维导图</h2>\\n<figure><figcaption></figcaption></figure>\\n<hr>\\n<h2>复习代码</h2>\\n<div class=\\"language-c\\" data-ext=\\"c\\" data-title=\\"c\\"><pre class=\\"language-c\\"><code><span class=\\"token comment\\">//  Author：jimbo（1353429820@qq.com）</span>\\n<span class=\\"token comment\\">//  Filename：main</span>\\n<span class=\\"token comment\\">//  Date：2024/1/20</span>\\n<span class=\\"token comment\\">//  Description：review knowledge points</span>\\n<span class=\\"token comment\\">//  Copyrights（c）JimBo. All rights reserved</span>\\n\\n\\n<span class=\\"token comment\\">//1.虚函数的重写</span>\\n<span class=\\"token comment\\">//虚函数的重写也叫虚函数的覆盖，若派生类中有一个和基类完全相同的虚函数，此时称该派生类虚函数重写了基类虚函数</span>\\n<span class=\\"token comment\\">//在重写基类虚函数时，派生类虚函数不加virtual关键字也构成重写，因为继承后基类的虚函数被继承下来，但不推荐不加</span>\\n<span class=\\"token comment\\">//C++11引入final修饰虚函数，表示不能被继承或重写。而override放在虚函数声明后，用于检查是否存在于基类虚函数相匹配的函数</span>\\n\\n<span class=\\"token macro property\\"><span class=\\"token directive-hash\\">#</span><span class=\\"token directive keyword\\">include</span><span class=\\"token string\\">&lt;iostream&gt;</span></span>\\n\\n<span class=\\"token comment\\">//基类</span>\\nclass Shape\\n<span class=\\"token punctuation\\">{</span>\\n public<span class=\\"token operator\\">:</span>\\n    <span class=\\"token comment\\">//虚函数</span>\\n    virtual <span class=\\"token keyword\\">void</span> <span class=\\"token function\\">draw</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token keyword\\">const</span>\\n    <span class=\\"token punctuation\\">{</span>\\n       std<span class=\\"token operator\\">::</span>cout <span class=\\"token operator\\">&lt;&lt;</span> <span class=\\"token string\\">\\"Drawing a shape\\"</span> <span class=\\"token operator\\">&lt;&lt;</span> std<span class=\\"token operator\\">::</span>endl<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n    <span class=\\"token comment\\">//虚拟析构函数，保证正确释放资源</span>\\n    virtual <span class=\\"token operator\\">~</span><span class=\\"token function\\">Shape</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">{</span><span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token comment\\">//派生类：Circle</span>\\nclass Circle <span class=\\"token operator\\">:</span> public Shape\\n<span class=\\"token punctuation\\">{</span>\\n public<span class=\\"token operator\\">:</span>\\n    <span class=\\"token keyword\\">void</span> <span class=\\"token function\\">draw</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token keyword\\">const</span> override\\n    <span class=\\"token punctuation\\">{</span>\\n       std<span class=\\"token operator\\">::</span>cout <span class=\\"token operator\\">&lt;&lt;</span> <span class=\\"token string\\">\\"Drawing a circle\\"</span> <span class=\\"token operator\\">&lt;&lt;</span> std<span class=\\"token operator\\">::</span>endl<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token comment\\">//派生类：Square</span>\\nclass Square <span class=\\"token operator\\">:</span> public Shape\\n<span class=\\"token punctuation\\">{</span>\\n public<span class=\\"token operator\\">:</span>\\n    <span class=\\"token keyword\\">void</span> <span class=\\"token function\\">draw</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token keyword\\">const</span> override\\n    <span class=\\"token punctuation\\">{</span>\\n       std<span class=\\"token operator\\">::</span>cout <span class=\\"token operator\\">&lt;&lt;</span> <span class=\\"token string\\">\\"Drawing a  square\\"</span> <span class=\\"token operator\\">&lt;&lt;</span> std<span class=\\"token operator\\">::</span>endl<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token comment\\">//函数：接收Shape的基类指针，并调用虚函数draw()</span>\\n<span class=\\"token keyword\\">void</span> <span class=\\"token function\\">drawShape</span><span class=\\"token punctuation\\">(</span><span class=\\"token keyword\\">const</span> Shape<span class=\\"token operator\\">*</span> shape<span class=\\"token punctuation\\">)</span>\\n<span class=\\"token punctuation\\">{</span>\\n    shape<span class=\\"token operator\\">-&gt;</span><span class=\\"token function\\">draw</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n\\n<span class=\\"token keyword\\">int</span> <span class=\\"token function\\">main</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span>\\n<span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token comment\\">//创建对象</span>\\n    Circle circle<span class=\\"token punctuation\\">;</span>\\n    Square square<span class=\\"token punctuation\\">;</span>\\n\\n    <span class=\\"token comment\\">//使用基类指针调用虚函数，实现多态性</span>\\n    <span class=\\"token function\\">drawShape</span><span class=\\"token punctuation\\">(</span><span class=\\"token operator\\">&amp;</span>circle<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token function\\">drawShape</span><span class=\\"token punctuation\\">(</span><span class=\\"token operator\\">&amp;</span>square<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token keyword\\">return</span> <span class=\\"token number\\">0</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n<span class=\\"token comment\\">/*\\n    运行结果：\\n            Drawing a circle\\n            Drawing a square\\n*/</span>\\n\\n\\n<span class=\\"token comment\\">//2.虚函数重写的两个例外：协变、析构函数重写，两个特例也构成重载</span>\\n<span class=\\"token comment\\">//协变：派生类重写基类虚函数时，与基类虚函数返回值类型不同，基类虚函数返回基类对象的指针或引用，派生类返回派生类对象的指针或引用</span>\\n<span class=\\"token comment\\">//析构函数重写：如果基类的析构函数为虚函数，此时派生类析构函数只要定义，无论是否加virtual，都与基类析构函数构成重写，即使名字不同</span>\\n\\n<span class=\\"token comment\\">//协变例子</span>\\n<span class=\\"token macro property\\"><span class=\\"token directive-hash\\">#</span><span class=\\"token directive keyword\\">include</span><span class=\\"token string\\">&lt;iostream&gt;</span></span>\\n\\n<span class=\\"token comment\\">//基类</span>\\nclass Animal\\n<span class=\\"token punctuation\\">{</span>\\n public<span class=\\"token operator\\">:</span>\\n    virtual Animal<span class=\\"token operator\\">*</span> <span class=\\"token function\\">clone</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token keyword\\">const</span>\\n    <span class=\\"token punctuation\\">{</span>\\n       std<span class=\\"token operator\\">::</span>cout<span class=\\"token operator\\">&lt;&lt;</span> <span class=\\"token string\\">\\"cloning an animal\\"</span> <span class=\\"token operator\\">&lt;&lt;</span> std<span class=\\"token operator\\">::</span>endl<span class=\\"token punctuation\\">;</span>\\n       <span class=\\"token keyword\\">return</span> new <span class=\\"token function\\">Animal</span><span class=\\"token punctuation\\">(</span><span class=\\"token operator\\">*</span>this<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token comment\\">//派生类</span>\\nclass Dog <span class=\\"token operator\\">:</span> public Animal\\n<span class=\\"token punctuation\\">{</span>\\n public<span class=\\"token operator\\">:</span>\\n    <span class=\\"token comment\\">//Dog类中采用协变，重写了clone()函数。并返回Dog*类型的指针</span>\\n    Dog<span class=\\"token operator\\">*</span> <span class=\\"token function\\">clone</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token keyword\\">const</span> override\\n    <span class=\\"token punctuation\\">{</span>\\n       std<span class=\\"token operator\\">::</span>cout<span class=\\"token operator\\">&lt;&lt;</span> <span class=\\"token string\\">\\"cloning a dog\\"</span> <span class=\\"token operator\\">&lt;&lt;</span> std<span class=\\"token operator\\">::</span>endl<span class=\\"token punctuation\\">;</span>\\n       <span class=\\"token keyword\\">return</span> new <span class=\\"token function\\">Dog</span><span class=\\"token punctuation\\">(</span><span class=\\"token operator\\">*</span>this<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token keyword\\">int</span> <span class=\\"token function\\">main</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span>\\n<span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token comment\\">//创建派生类</span>\\n    Dog myDog<span class=\\"token punctuation\\">;</span>\\n\\n    <span class=\\"token comment\\">//使用基类指针调用虚函数</span>\\n    Animal<span class=\\"token operator\\">*</span> clonedAnimal <span class=\\"token operator\\">=</span> myDog<span class=\\"token punctuation\\">.</span><span class=\\"token function\\">clone</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token comment\\">//说明：通过基类指针调用clone()函数，由于协变存在，实际调用Dog类的clone()函数</span>\\n    <span class=\\"token comment\\">//协变使得在派生类中的虚函数能够返回更具体的类型，提高了灵活性和代码的可读性</span>\\n\\n    <span class=\\"token comment\\">//清理指针</span>\\n    delete clonedAnimal<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token keyword\\">return</span> <span class=\\"token number\\">0</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n<span class=\\"token comment\\">// 运行结果：cloning a dog</span>\\n\\n\\n<span class=\\"token comment\\">//析构函数重写例子</span>\\n<span class=\\"token macro property\\"><span class=\\"token directive-hash\\">#</span><span class=\\"token directive keyword\\">include</span><span class=\\"token string\\">&lt;iostream&gt;</span></span>\\n\\n<span class=\\"token comment\\">//基类</span>\\nclass Base\\n<span class=\\"token punctuation\\">{</span>\\n public<span class=\\"token operator\\">:</span>\\n    <span class=\\"token comment\\">//基类的虚拟析构函数</span>\\n    virtual <span class=\\"token operator\\">~</span><span class=\\"token function\\">Base</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span>\\n    <span class=\\"token punctuation\\">{</span>\\n       std<span class=\\"token operator\\">::</span>cout <span class=\\"token operator\\">&lt;&lt;</span> <span class=\\"token string\\">\\"Base Destructor\\"</span> <span class=\\"token operator\\">&lt;&lt;</span> std<span class=\\"token operator\\">::</span>endl<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token comment\\">//派生类</span>\\nclass Derived <span class=\\"token operator\\">:</span> public Base\\n<span class=\\"token punctuation\\">{</span>\\n public<span class=\\"token operator\\">:</span>\\n    <span class=\\"token comment\\">//派生类的虚拟析构函数，重写基类的析构函数</span>\\n    <span class=\\"token operator\\">~</span><span class=\\"token function\\">Derived</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> override\\n    <span class=\\"token punctuation\\">{</span>\\n       std<span class=\\"token operator\\">::</span>cout <span class=\\"token operator\\">&lt;&lt;</span> <span class=\\"token string\\">\\"Derived Destructor\\"</span> <span class=\\"token operator\\">&lt;&lt;</span> std<span class=\\"token operator\\">::</span>endl<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token keyword\\">int</span> <span class=\\"token function\\">main</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span>\\n<span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token comment\\">//使用基类指针指向派生类对象</span>\\n    Base<span class=\\"token operator\\">*</span> ptr <span class=\\"token operator\\">=</span> new Derived<span class=\\"token punctuation\\">;</span>\\n\\n    <span class=\\"token comment\\">//使用基类指针删除对象，调用派生类析构函数</span>\\n    delete ptr<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token comment\\">//说明：基类析构被声明为虚析构函数，则被重写为Dervied类的析构函数，然后再调用Base类的虚析构函数</span>\\n    <span class=\\"token keyword\\">return</span> <span class=\\"token number\\">0</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n<span class=\\"token comment\\">/*\\n    运行结果：\\n          Derived Destructor\\n          Base    Destructor\\n*/</span>\\n\\n\\n<span class=\\"token comment\\">//3.抽象类(接口类)</span>\\n<span class=\\"token comment\\">//在虚函数后加=0，则这个函数称为存虚函数，包含纯虚函数的类叫做抽象类，也叫接口类，抽象类不能实例化对象</span>\\n\\n<span class=\\"token macro property\\"><span class=\\"token directive-hash\\">#</span><span class=\\"token directive keyword\\">include</span><span class=\\"token string\\">&lt;iostream&gt;</span></span>\\n\\n<span class=\\"token comment\\">//抽象类</span>\\nclass Shape\\n<span class=\\"token punctuation\\">{</span>\\n public<span class=\\"token operator\\">:</span>\\n    <span class=\\"token comment\\">//纯虚函数，使得Shape成为抽象类</span>\\n    virtual <span class=\\"token keyword\\">void</span> <span class=\\"token function\\">draw</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token keyword\\">const</span> <span class=\\"token operator\\">=</span> <span class=\\"token number\\">0</span><span class=\\"token punctuation\\">;</span>\\n\\n    <span class=\\"token comment\\">//普通成员函数</span>\\n    <span class=\\"token keyword\\">void</span> <span class=\\"token function\\">display</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token keyword\\">const</span>\\n    <span class=\\"token punctuation\\">{</span>\\n       std<span class=\\"token operator\\">::</span>cout <span class=\\"token operator\\">&lt;&lt;</span> <span class=\\"token string\\">\\"displaying a shape\\"</span> <span class=\\"token operator\\">&lt;&lt;</span> std<span class=\\"token operator\\">::</span>endl<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n\\n    <span class=\\"token comment\\">//虚析构函数，通常在抽象类中声明为虚析构函数</span>\\n    virtual <span class=\\"token operator\\">~</span><span class=\\"token function\\">Shape</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span>\\n    <span class=\\"token punctuation\\">{</span>\\n       std<span class=\\"token operator\\">::</span>cout <span class=\\"token operator\\">&lt;&lt;</span> <span class=\\"token string\\">\\"shape destructor\\"</span> <span class=\\"token operator\\">&lt;&lt;</span> std<span class=\\"token operator\\">::</span>endl<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token comment\\">//派生类</span>\\nclass Circle <span class=\\"token operator\\">:</span> public Shape\\n<span class=\\"token punctuation\\">{</span>\\n public<span class=\\"token operator\\">:</span>\\n    <span class=\\"token comment\\">//实现抽象类中的纯虚函数</span>\\n    <span class=\\"token keyword\\">void</span> <span class=\\"token function\\">draw</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token keyword\\">const</span> override\\n    <span class=\\"token punctuation\\">{</span>\\n       std<span class=\\"token operator\\">::</span>cout <span class=\\"token operator\\">&lt;&lt;</span> <span class=\\"token string\\">\\"drawing a circle\\"</span> <span class=\\"token operator\\">&lt;&lt;</span> std<span class=\\"token operator\\">::</span>endl<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n\\n    <span class=\\"token comment\\">//派生类的其他成员函数</span>\\n    <span class=\\"token keyword\\">void</span> <span class=\\"token function\\">calculateArea</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token keyword\\">const</span>\\n    <span class=\\"token punctuation\\">{</span>\\n       std<span class=\\"token operator\\">::</span>cout <span class=\\"token operator\\">&lt;&lt;</span> <span class=\\"token string\\">\\"calculating the area of a circle\\"</span> <span class=\\"token operator\\">&lt;&lt;</span> std<span class=\\"token operator\\">::</span>endl<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n\\n    <span class=\\"token comment\\">//派生类的析构函数</span>\\n    <span class=\\"token operator\\">~</span><span class=\\"token function\\">Circle</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> override\\n    <span class=\\"token punctuation\\">{</span>\\n       std<span class=\\"token operator\\">::</span>cout <span class=\\"token operator\\">&lt;&lt;</span> <span class=\\"token string\\">\\"circle destructor\\"</span> <span class=\\"token operator\\">&lt;&lt;</span> std<span class=\\"token operator\\">::</span>endl<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token punctuation\\">}</span>\\n<span class=\\"token punctuation\\">}</span><span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token keyword\\">int</span> <span class=\\"token function\\">main</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span>\\n<span class=\\"token punctuation\\">{</span>\\n    <span class=\\"token comment\\">//抽象类(接口类)不能实例化</span>\\n    <span class=\\"token comment\\">//Shape shape; //报错：不能实例化</span>\\n\\n    <span class=\\"token comment\\">//使用基类指针指向派生类对象，向上转型切片</span>\\n    Shape<span class=\\"token operator\\">*</span> circle <span class=\\"token operator\\">=</span> new Circle<span class=\\"token punctuation\\">;</span>\\n\\n    <span class=\\"token comment\\">//说明：向上转型进行了切片，舍去了派生类的draw()，但是Circle对象赋值给Shape*，</span>\\n    <span class=\\"token comment\\">//虽然静态类型变成了基类Shape*，但是动态类型还是派生类Circle，因此虚函数调用时</span>\\n    <span class=\\"token comment\\">//会根据动态类型调用响应的实现</span>\\n\\n    <span class=\\"token comment\\">//调用纯虚函数，实际调用了派生类的实现</span>\\n    circle<span class=\\"token operator\\">-&gt;</span><span class=\\"token function\\">draw</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n\\n    <span class=\\"token comment\\">//调用普通成员函数，也是通过基类指针调用</span>\\n    circle<span class=\\"token operator\\">-&gt;</span><span class=\\"token function\\">display</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n\\n    <span class=\\"token comment\\">//使用基类指针删除对象，调用派生类的析构函数</span>\\n    delete circle<span class=\\"token punctuation\\">;</span>\\n    <span class=\\"token keyword\\">return</span> <span class=\\"token number\\">0</span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n<span class=\\"token comment\\">/*\\n 运行结果：\\n    drawing a circle\\n    displaying a shape\\n    circle destructor\\n    shape destructor\\n*/</span>\\n</code></pre></div>"}');export{d as comp,m as data};
