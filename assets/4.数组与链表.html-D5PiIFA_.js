import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,b as t}from"./app-Dezzdk4T.js";const e="/assets/%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F-U1UXyK8y.png",p="/assets/%E6%95%B0%E7%BB%84%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0-D42SpY3X.png",o="/assets/%E6%95%B0%E7%BB%84%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0-BV6VMeKF.png",i="/assets/%E6%95%B0%E7%BB%84%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-D5QtoOGl.png",c="/assets/%E9%93%BE%E8%A1%A8%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F-iq-rl2tU.png",l="/assets/%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E7%BB%93%E7%82%B9-C4ZR9RLW.png",r="/assets/%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9-DTo_-UgF.png",u="/assets/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AF%B9%E6%AF%94-DBhX-nPA.png",d="/assets/%E5%B8%B8%E8%A7%81%E9%93%BE%E8%A1%A8%E7%A7%8D%E7%B1%BB-CkMDV7YH.png",k={},v=t('<h1 id="第四章-数组与链表" tabindex="-1"><a class="header-anchor" href="#第四章-数组与链表"><span>第四章：数组与链表</span></a></h1><h2 id="_1-数组" tabindex="-1"><a class="header-anchor" href="#_1-数组"><span>1.数组</span></a></h2><figure><img src="'+e+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>数组（array）是一种线性数据结构，其将相同类型的元素存储在连续的内存空间中。我们将元素在数组中的位置称为该元素的索引（index）。如上图展示了数组的主要概念和存储方式</strong></p><p><strong>优点：</strong></p><ul><li><strong>空间效率高：数组为数据分配了连续的内存块，无须额外的结构开销</strong></li><li><strong>支持随机访问：数组允许在O（1）时间内访问任何元素</strong></li><li><strong>缓存局部性：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度</strong></li></ul><p><strong>缺点：</strong></p><ul><li><strong>插入与删除效率低：当数组中元素较多时，插入与删除操作需要移动大量的元素</strong></li><li><strong>长度不可变：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大</strong></li><li><strong>空间浪费：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了</strong></li></ul><hr><h3 id="_1-1-初始化数组" tabindex="-1"><a class="header-anchor" href="#_1-1-初始化数组"><span>1.1 初始化数组</span></a></h3><p><strong>我们可以根据需求选用数组的两种初始化方式：无初始值、给定初始值。在未指定初始值的情况下，大多数编程语言会将数组元素初始化为0：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 初始化数组 */</span>
<span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// { 0, 0, 0, 0, 0 }</span>
<span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_1-2-访问元素" tabindex="-1"><a class="header-anchor" href="#_1-2-访问元素"><span>1.2 访问元素</span></a></h3><figure><img src="`+p+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>数组元素被存储在连续的内存空间中，这意味着计算数组元素的内存地址非常容易。给定数组内存地址（首元素内存地址）和某个元素的索引，我们可以使用上图所示的公式计算得到该元素的内存地址，从而直接访问该元素</strong></p><p><strong>我们发现数组首个元素的索引为0，这似乎有些反直觉，因为从1开始计数会更自然。但从地址计算公式的角度看，索引本质上是内存地址的偏移量。首个元素的地址偏移量是0，因此它的索引为0是合理的</strong></p><p><strong>在数组中访问元素非常高效，我们可以在O（1）时间内随机访问数组中任何一个元素</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 随机访问元素 */</span>
<span class="token keyword">int</span> <span class="token function">randomAccess</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 在区间 [0, size) 中随机抽取一个数字</span>
    <span class="token keyword">int</span> randomIndex <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> size<span class="token punctuation">;</span>
    <span class="token comment">// 获取并返回随机元素</span>
    <span class="token keyword">int</span> randomNum <span class="token operator">=</span> nums<span class="token punctuation">[</span>randomIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> randomNum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_1-3-插入元素" tabindex="-1"><a class="header-anchor" href="#_1-3-插入元素"><span>1.3 插入元素</span></a></h3><figure><img src="`+o+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>数组元素在内存中是“紧挨着的”，它们之间没有空间再存放任何数据。如图上图所示，如果想在数组中间插入一个元素，则需要将该元素之后的所有元素都向后移动一位，之后再把元素赋值给该索引</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 在数组的索引 index 处插入元素 num */</span>
<span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 把索引 index 以及之后的所有元素向后移动一位</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将 num 赋给 index 处的元素</span>
    nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_1-4-删除元素" tabindex="-1"><a class="header-anchor" href="#_1-4-删除元素"><span>1.4 删除元素</span></a></h3><figure><img src="`+i+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>同理，如上图所示，要删除索引i处的元素，则需要把索引i之后的元素都往前移动一位</strong></p><p><strong>请注意，删除元素完成后，原先末尾的元素变得“无意义”了，所以我们无须特意去修改它</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 删除索引 index 处的元素 */</span>
<span class="token comment">// 注意：stdio.h 占用了 remove 关键词</span>
<span class="token keyword">void</span> <span class="token function">removeItem</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 把索引 index 之后的所有元素向前移动一位</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> index<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>总的来看，数组的插入与删除操作有以下缺点：</strong></p><ul><li><strong>时间复杂度高：数组的插入和删除的平均时间复杂度均为O（n），其中n为数组长度</strong></li><li><strong>丢失元素：由于数组的长度不可变，因此在插入元素后，超出数组长度范围的元素会丢失</strong></li><li><strong>内存浪费：我们可以初始化一个比较长的数组，只用前面一部分，这样在插入数据时，丢失的末尾元素都是“无意义”的，但这样做会造成部分内存空间浪费</strong></li></ul><hr><h3 id="_1-5-遍历数组" tabindex="-1"><a class="header-anchor" href="#_1-5-遍历数组"><span>1.5 遍历数组</span></a></h3><p><strong>在大多数编程语言中，我们既可以通过索引遍历数组，也可以直接遍历获取数组中的每个元素：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 遍历数组 */</span>
<span class="token keyword">void</span> <span class="token function">traverse</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 通过索引遍历数组</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        count <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_1-6-查找元素" tabindex="-1"><a class="header-anchor" href="#_1-6-查找元素"><span>1.6 查找元素</span></a></h3><p><strong>在数组中查找指定元素需要遍历数组，每轮判断元素值是否匹配，若匹配则输出对应索引</strong></p><p><strong>因为数组是线性数据结构，所以上述查找操作被称为“线性查找”</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 在数组中查找指定元素 */</span>
<span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span>
            <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_1-7-扩容数组" tabindex="-1"><a class="header-anchor" href="#_1-7-扩容数组"><span>1.7 扩容数组</span></a></h3><p><strong>在复杂的系统环境中，程序难以保证数组之后的内存空间是可用的，从而无法安全地扩展数组容量。因此在大多数编程语言中，数组的长度是不可变的</strong></p><p><strong>如果我们希望扩容数组，则需重新建立一个更大的数组，然后把原数组元素依次复制到新数组。这是一个O（n）的操作，在数组很大的情况下非常耗时</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 扩展数组长度 */</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> enlarge<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 初始化一个扩展长度后的数组</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>size <span class="token operator">+</span> enlarge<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 将原数组中的所有元素复制到新数组</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 初始化扩展后的空间</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size <span class="token operator">+</span> enlarge<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回扩展后的新数组</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_2-链表" tabindex="-1"><a class="header-anchor" href="#_2-链表"><span>2.链表</span></a></h2><figure><img src="`+c+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>链表（linked list）是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过“引用”相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点</strong></p><p><strong>链表的设计使得各个节点可以分散存储在内存各处，它们的内存地址无须连续</strong></p><p><strong>链表的组成单位是节点（node）对象。每个节点都包含两项数据：节点的“值”和指向下一节点的“引用”</strong></p><ul><li><strong>链表的首个节点被称为“头节点”，最后一个节点被称为“尾节点”</strong></li><li><strong>尾节点指向的是“空”，它在 Java、C++ 和 Python 中分别被记为 null、nullptr 和 None</strong></li><li><strong>在 C、C++、Go 和 Rust 等支持指针的语言中，上述“引用”应被替换为“指针”</strong></li></ul><p><strong>链表节点 ListNode 除了包含值，还需额外保存一个引用（指针）。因此在相同数据量下，链表比数组占用更多的内存空间</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 链表节点结构体 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ListNode</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>               <span class="token comment">// 节点值</span>
    <span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 指向下一节点的指针</span>
<span class="token punctuation">}</span> ListNode<span class="token punctuation">;</span>

<span class="token comment">/* 构造函数 */</span>
ListNode <span class="token operator">*</span><span class="token function">newListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    ListNode <span class="token operator">*</span>node<span class="token punctuation">;</span>
    node <span class="token operator">=</span> <span class="token punctuation">(</span>ListNode <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ListNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    node<span class="token operator">-&gt;</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
    node<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_2-1-初始化链表" tabindex="-1"><a class="header-anchor" href="#_2-1-初始化链表"><span>2.1 初始化链表</span></a></h3><p><strong>建立链表分为两步，第一步是初始化各个节点对象，第二步是构建节点之间的引用关系。初始化完成后，我们就可以从链表的头节点出发，通过引用指向 next 依次访问所有节点</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 初始化链表 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */</span>
<span class="token comment">// 初始化各个节点</span>
ListNode<span class="token operator">*</span> n0 <span class="token operator">=</span> <span class="token function">newListNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ListNode<span class="token operator">*</span> n1 <span class="token operator">=</span> <span class="token function">newListNode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ListNode<span class="token operator">*</span> n2 <span class="token operator">=</span> <span class="token function">newListNode</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ListNode<span class="token operator">*</span> n3 <span class="token operator">=</span> <span class="token function">newListNode</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ListNode<span class="token operator">*</span> n4 <span class="token operator">=</span> <span class="token function">newListNode</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 构建节点之间的引用</span>
n0<span class="token operator">-&gt;</span>next <span class="token operator">=</span> n1<span class="token punctuation">;</span>
n1<span class="token operator">-&gt;</span>next <span class="token operator">=</span> n2<span class="token punctuation">;</span>
n2<span class="token operator">-&gt;</span>next <span class="token operator">=</span> n3<span class="token punctuation">;</span>
n3<span class="token operator">-&gt;</span>next <span class="token operator">=</span> n4<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>数组整体是一个变量，比如数组 nums 包含元素 nums[0] 和 nums[1] 等，而链表是由多个独立的节点对象组成的。我们通常将头节点当作链表的代称，比如以上代码中的链表可记作链表 n0</strong></p><hr><h3 id="_2-2-插入结点" tabindex="-1"><a class="header-anchor" href="#_2-2-插入结点"><span>2.2 插入结点</span></a></h3><figure><img src="`+l+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>在链表中插入节点非常容易。如上图所示，假设我们想在相邻的两个节点 n0 和 n1 之间插入一个新节点 P ，则只需改变两个节点引用（指针）即可，时间复杂度为O（1）</strong></p><p><strong>相比之下，在数组中插入元素的时间复杂度为O（n），在大数据量下的效率较低</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 在链表的节点 n0 之后插入节点 P */</span>
<span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>n0<span class="token punctuation">,</span> ListNode <span class="token operator">*</span>P<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    ListNode <span class="token operator">*</span>n1 <span class="token operator">=</span> n0<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    P<span class="token operator">-&gt;</span>next <span class="token operator">=</span> n1<span class="token punctuation">;</span>
    n0<span class="token operator">-&gt;</span>next <span class="token operator">=</span> P<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_2-3-删除结点" tabindex="-1"><a class="header-anchor" href="#_2-3-删除结点"><span>2.3 删除结点</span></a></h3><figure><img src="`+r+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>在链表中删除节点也非常方便，只需改变一个节点的引用（指针）即可，请注意，尽管在删除操作完成后节点 P 仍然指向 n1 ，但实际上遍历此链表已经无法访问到 P ，这意味着 P 已经不再属于该链表了</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 删除链表的节点 n0 之后的首个节点 */</span>
<span class="token comment">// 注意：stdio.h 占用了 remove 关键词</span>
<span class="token keyword">void</span> <span class="token function">removeItem</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>n0<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n0<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token comment">// n0 -&gt; P -&gt; n1</span>
    ListNode <span class="token operator">*</span>P <span class="token operator">=</span> n0<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    ListNode <span class="token operator">*</span>n1 <span class="token operator">=</span> P<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    n0<span class="token operator">-&gt;</span>next <span class="token operator">=</span> n1<span class="token punctuation">;</span>
    <span class="token comment">// 释放内存</span>
    <span class="token function">free</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_2-4-访问结点" tabindex="-1"><a class="header-anchor" href="#_2-4-访问结点"><span>2.4 访问结点</span></a></h3><p><strong>在链表中访问节点的效率较低。如上一节所述，我们可以在O（1）时间下访问数组中的任意元素。链表则不然，程序需要从头节点出发，逐个向后遍历，直至找到目标节点。也就是说，访问链表的第i个节点需要循环i-1轮，时间复杂度为O（n）</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 访问链表中索引为 index 的节点 */</span>
ListNode <span class="token operator">*</span><span class="token function">access</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        head <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_2-5-查找结点" tabindex="-1"><a class="header-anchor" href="#_2-5-查找结点"><span>2.5 查找结点</span></a></h3><p><strong>遍历链表，查找其中值为 target 的节点，输出该节点在链表中的索引。此过程也属于线性查找</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 在链表中查找值为 target 的首个节点 */</span>
<span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span>ListNode <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>head<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-&gt;</span>val <span class="token operator">==</span> target<span class="token punctuation">)</span>
            <span class="token keyword">return</span> index<span class="token punctuation">;</span>
        head <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
        index<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_3-数组与链表的对比" tabindex="-1"><a class="header-anchor" href="#_3-数组与链表的对比"><span>3.数组与链表的对比</span></a></h2><figure><img src="`+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h2 id="_4-常见链表类型" tabindex="-1"><a class="header-anchor" href="#_4-常见链表类型"><span>4.常见链表类型</span></a></h2><figure><img src="'+d+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>常见的链表类型包括三种：</strong></p><ul><li><strong>单向链表：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 None</strong></li><li><strong>环形链表：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点</strong></li><li><strong>双向链表：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间</strong></li></ul><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 双向链表节点结构体 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ListNode</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>               <span class="token comment">// 节点值</span>
    <span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 指向后继节点的指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span> <span class="token comment">// 指向前驱节点的指针</span>
<span class="token punctuation">}</span> ListNode<span class="token punctuation">;</span>

<span class="token comment">/* 构造函数 */</span>
ListNode <span class="token operator">*</span><span class="token function">newListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    ListNode <span class="token operator">*</span>node<span class="token punctuation">;</span>
    node <span class="token operator">=</span> <span class="token punctuation">(</span>ListNode <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ListNode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    node<span class="token operator">-&gt;</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
    node<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    node<span class="token operator">-&gt;</span>prev <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,88),m=[v];function g(b,h){return s(),a("div",null,m)}const f=n(k,[["render",g],["__file","4.数组与链表.html.vue"]]),_=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/4.%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8.html","title":"第四章：数组与链表","lang":"zh-CN","frontmatter":{"date":"2024-03-04T00:00:00.000Z","order":4,"description":"第四章：数组与链表 1.数组 数组（array）是一种线性数据结构，其将相同类型的元素存储在连续的内存空间中。我们将元素在数组中的位置称为该元素的索引（index）。如上图展示了数组的主要概念和存储方式 优点： 空间效率高：数组为数据分配了连续的内存块，无须额外的结构开销 支持随机访问：数组允许在O（1）时间内访问任何元素 缓存局部性：当访问数组元素时...","head":[["meta",{"property":"og:url","content":"https://github.com/jimbo-master/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/4.%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8.html"}],["meta",{"property":"og:site_name","content":"JimBoの学习妙妙屋"}],["meta",{"property":"og:title","content":"第四章：数组与链表"}],["meta",{"property":"og:description","content":"第四章：数组与链表 1.数组 数组（array）是一种线性数据结构，其将相同类型的元素存储在连续的内存空间中。我们将元素在数组中的位置称为该元素的索引（index）。如上图展示了数组的主要概念和存储方式 优点： 空间效率高：数组为数据分配了连续的内存块，无须额外的结构开销 支持随机访问：数组允许在O（1）时间内访问任何元素 缓存局部性：当访问数组元素时..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"JimBo"}],["meta",{"property":"article:published_time","content":"2024-03-04T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第四章：数组与链表\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-04T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JimBo\\",\\"url\\":\\"https://github.com/jimbo-master\\"}]}"]]},"headers":[{"level":2,"title":"1.数组","slug":"_1-数组","link":"#_1-数组","children":[{"level":3,"title":"1.1 初始化数组","slug":"_1-1-初始化数组","link":"#_1-1-初始化数组","children":[]},{"level":3,"title":"1.2 访问元素","slug":"_1-2-访问元素","link":"#_1-2-访问元素","children":[]},{"level":3,"title":"1.3 插入元素","slug":"_1-3-插入元素","link":"#_1-3-插入元素","children":[]},{"level":3,"title":"1.4 删除元素","slug":"_1-4-删除元素","link":"#_1-4-删除元素","children":[]},{"level":3,"title":"1.5 遍历数组","slug":"_1-5-遍历数组","link":"#_1-5-遍历数组","children":[]},{"level":3,"title":"1.6 查找元素","slug":"_1-6-查找元素","link":"#_1-6-查找元素","children":[]},{"level":3,"title":"1.7 扩容数组","slug":"_1-7-扩容数组","link":"#_1-7-扩容数组","children":[]}]},{"level":2,"title":"2.链表","slug":"_2-链表","link":"#_2-链表","children":[{"level":3,"title":"2.1 初始化链表","slug":"_2-1-初始化链表","link":"#_2-1-初始化链表","children":[]},{"level":3,"title":"2.2 插入结点","slug":"_2-2-插入结点","link":"#_2-2-插入结点","children":[]},{"level":3,"title":"2.3 删除结点","slug":"_2-3-删除结点","link":"#_2-3-删除结点","children":[]},{"level":3,"title":"2.4 访问结点","slug":"_2-4-访问结点","link":"#_2-4-访问结点","children":[]},{"level":3,"title":"2.5 查找结点","slug":"_2-5-查找结点","link":"#_2-5-查找结点","children":[]}]},{"level":2,"title":"3.数组与链表的对比","slug":"_3-数组与链表的对比","link":"#_3-数组与链表的对比","children":[]},{"level":2,"title":"4.常见链表类型","slug":"_4-常见链表类型","link":"#_4-常见链表类型","children":[]}],"git":{},"readingTime":{"minutes":10.06,"words":3018},"filePathRelative":"算法学习/1.算法知识/4.数组与链表.md","localizedDate":"2024年3月4日","autoDesc":true,"excerpt":"\\n<h2>1.数组</h2>\\n<figure><figcaption></figcaption></figure>\\n<p><strong>数组（array）是一种线性数据结构，其将相同类型的元素存储在连续的内存空间中。我们将元素在数组中的位置称为该元素的索引（index）。如上图展示了数组的主要概念和存储方式</strong></p>\\n<p><strong>优点：</strong></p>\\n<ul>\\n<li><strong>空间效率高：数组为数据分配了连续的内存块，无须额外的结构开销</strong></li>\\n<li><strong>支持随机访问：数组允许在O（1）时间内访问任何元素</strong></li>\\n<li><strong>缓存局部性：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度</strong></li>\\n</ul>"}');export{f as comp,_ as data};
