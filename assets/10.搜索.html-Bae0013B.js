import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,b as t}from"./app-Dezzdk4T.js";const p="/assets/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-BGMjKW1a.png",e="/assets/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B5%81%E7%A8%8B-oX1lpJTj.png",o="/assets/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8C%BA%E9%97%B4%E8%A1%A8%E7%A4%BA-XTSNjnUN.png",c="/assets/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E6%83%85%E5%86%B5-DEwseRLu.png",i="/assets/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E6%83%85%E5%86%B5-CKFlthGU.png",l="/assets/%E6%9F%A5%E6%89%BE%E5%8F%B3%E8%BE%B9%E7%95%8C-CehNmApz.png",r="/assets/%E6%9F%A5%E6%89%BE%E5%8F%B3%E8%BE%B9%E7%95%8C2-C06w6sbv.png",u="/assets/%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE-BNLFAJ8q.png",k="/assets/%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE-C03uL8aD.png",d={},m=t('<h1 id="第十章-搜索" tabindex="-1"><a class="header-anchor" href="#第十章-搜索"><span>第十章：搜索</span></a></h1><h2 id="_1-二分查找" tabindex="-1"><a class="header-anchor" href="#_1-二分查找"><span>1.二分查找</span></a></h2><p><strong>二分查找（binary search）是一种基于分治策略的高效搜索算法。它利用数据的有序性，每轮缩小一半搜索范围，直至找到目标元素或搜索区间为空为止</strong></p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>如上图所示，我们先初始化指针i=0和j=n-1，分别指向数组首元素和尾元素，代表搜索区间[0,n-1]。请注意，中括号表示闭区间，其包含边界值本身</strong></p><blockquote><p><strong>时间复杂度为O(logn)：在二分循环中，区间每轮缩小一半，因此循环次数为logn</strong><br><br><strong>空间复杂度为O(1)：指针i和j使用常数大小空间</strong></p></blockquote><p><strong>接下来，循环执行以下两步：</strong></p><ul><li><strong>计算中点索引m=[(i+j)/2]（向下取整）</strong></li><li><strong>判断 nums[m] 和 target 的大小关系，分为以下三种情况</strong></li><li><ul><li><strong>当 nums[m] &lt; target 时，说明 target 在区间[m+1，j]中，因此执行i=m+1</strong></li></ul></li><li><ul><li><strong>当 nums[m] &gt; target 时，说明 target 在区间[i，m-1]中，因此执行j=m-1</strong></li></ul></li><li><ul><li><strong>当 nums[m] = target 时，说明找到 target ，因此返回索引m</strong></li></ul></li></ul><p><strong>若数组不包含目标元素，搜索区间最终会缩小为空。此时返回-1</strong></p><p><strong>二分查找流程如下：</strong></p><figure><img src="'+e+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p><strong>值得注意的是，由于i和j都是int类型，因此i+j可能超出int类型的取值范围。为了避免大数越界，我们通常采用公式m=[i+(j-i)/2]来计算中点</strong></p></blockquote><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 二分查找（双闭区间） */</span>
<span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 初始化双闭区间 [0, n-1] ，即 i, j 分别指向数组首元素、尾元素</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 循环，当搜索区间为空时跳出（当 i &gt; j 时为空）</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> j<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> m <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> i<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 计算中点索引 m</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span>    <span class="token comment">// 此情况说明 target 在区间 [m+1, j] 中</span>
            i <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&gt;</span> target<span class="token punctuation">)</span> <span class="token comment">// 此情况说明 target 在区间 [i, m-1] 中</span>
            j <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token comment">// 找到目标元素，返回其索引</span>
            <span class="token keyword">return</span> m<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 未找到目标元素，返回 -1</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_2-二分查找的区间表示方法" tabindex="-1"><a class="header-anchor" href="#_2-二分查找的区间表示方法"><span>2.二分查找的区间表示方法</span></a></h2><p><strong>除了上述双闭区间外，常见的区间表示还有“左闭右开”区间，定义为[0,n)，即左边界包含自身，右边界不包含自身。在该表示下，区间[i,j)在i=j时为空</strong></p><p><strong>我们可以基于该表示实现具有相同功能的二分查找算法：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 二分查找（左闭右开区间） */</span>
<span class="token keyword">int</span> <span class="token function">binarySearchLCRO</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 初始化左闭右开区间 [0, n) ，即 i, j 分别指向数组首元素、尾元素+1</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> len<span class="token punctuation">;</span>
    <span class="token comment">// 循环，当搜索区间为空时跳出（当 i = j 时为空）</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> m <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> i<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 计算中点索引 m</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span>    <span class="token comment">// 此情况说明 target 在区间 [m+1, j) 中</span>
            i <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&gt;</span> target<span class="token punctuation">)</span> <span class="token comment">// 此情况说明 target 在区间 [i, m) 中</span>
            j <span class="token operator">=</span> m<span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token comment">// 找到目标元素，返回其索引</span>
            <span class="token keyword">return</span> m<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 未找到目标元素，返回 -1</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>由于“双闭区间”表示中的左右边界都被定义为闭区间，因此通过指针i和指针j缩小区间的操作也是对称的。这样更不容易出错，因此一般建议采用“双闭区间”的写法</strong></p></blockquote><figure><img src="`+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h2 id="_3-二分查找插入点" tabindex="-1"><a class="header-anchor" href="#_3-二分查找插入点"><span>3.二分查找插入点</span></a></h2><p><strong>二分查找不仅可用于搜索目标元素，还可用于解决许多变种问题，比如搜索目标元素的插入位置</strong></p><h3 id="_3-1-无重复元素的情况" tabindex="-1"><a class="header-anchor" href="#_3-1-无重复元素的情况"><span>3.1 无重复元素的情况</span></a></h3><figure><img src="'+c+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 二分查找插入点（无重复元素） */</span>
<span class="token keyword">int</span> <span class="token function">binarySearchInsertionSimple</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> numSize<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> numSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 初始化双闭区间 [0, n-1]</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> j<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> m <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> i<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 计算中点索引 m</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            i <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// target 在区间 [m+1, j] 中</span>
        <span class="token punctuation">}</span> 
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&gt;</span> target<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            j <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// target 在区间 [i, m-1] 中</span>
        <span class="token punctuation">}</span> 
        <span class="token keyword">else</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> m<span class="token punctuation">;</span> <span class="token comment">// 找到 target ，返回插入点 m</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 未找到 target ，返回插入点 i</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_3-2-存在重复元素情况" tabindex="-1"><a class="header-anchor" href="#_3-2-存在重复元素情况"><span>3.2 存在重复元素情况</span></a></h3><p><strong>假设数组中存在多个 target ，则普通二分查找只能返回其中一个 target 的索引，而无法确定该元素的左边和右边还有多少 target</strong></p><figure><img src="`+i+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>观察以下代码，判断分支 nums[m] &gt; target 和 nums[m] == target 的操作相同，因此两者可以合并</strong></p><p><strong>即便如此，我们仍然可以将判断条件保持展开，因为其逻辑更加清晰、可读性更好</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 二分查找插入点（存在重复元素） */</span>
<span class="token keyword">int</span> <span class="token function">binarySearchInsertion</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> numSize<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> numSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 初始化双闭区间 [0, n-1]</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> j<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> m <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> i<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 计算中点索引 m</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            i <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// target 在区间 [m+1, j] 中</span>
        <span class="token punctuation">}</span> 
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">&gt;</span> target<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            j <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// target 在区间 [i, m-1] 中</span>
        <span class="token punctuation">}</span> 
        <span class="token keyword">else</span> 
        <span class="token punctuation">{</span>
            j <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 首个小于 target 的元素在区间 [i, m-1] 中</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回插入点 i</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_4-二分查找边界" tabindex="-1"><a class="header-anchor" href="#_4-二分查找边界"><span>4.二分查找边界</span></a></h2><h3 id="_4-1-查找左边界" tabindex="-1"><a class="header-anchor" href="#_4-1-查找左边界"><span>4.1 查找左边界</span></a></h3><p><strong>回忆二分查找插入点的方法，搜索完成后i指向最左一个 target ，因此查找插入点本质上是在查找最左一个 target 的索引</strong></p><p><strong>考虑通过查找插入点的函数实现查找左边界。请注意，数组中可能不包含 target ，这种情况可能导致以下两种结果：</strong></p><ul><li><strong>插入点的索引i越界</strong></li><li><strong>元素nums[i] 与 target 不相等</strong></li></ul><p><strong>当遇到以上两种情况时，直接返回-1即可，代码如下所示：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 二分查找最左一个 target */</span>
<span class="token keyword">int</span> <span class="token function">binarySearchLeftEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> numSize<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 等价于查找 target 的插入点</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">binarySearchInsertion</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> numSize<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 未找到 target ，返回 -1</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> numSize <span class="token operator">||</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> target<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 找到 target ，返回索引 i</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_4-2-查找右边界" tabindex="-1"><a class="header-anchor" href="#_4-2-查找右边界"><span>4.2 查找右边界</span></a></h3><p><strong>（1）方法一：复用查找左边界</strong></p><p><strong>实际上，我们可以利用查找最左元素的函数来查找最右元素，具体方法为：将查找最右一个 target 转化为查找最左一个 target + 1</strong></p><p><strong>如下图所示，查找完成后，指针i指向最左一个 target + 1（如果存在），而j指向最右一个 target ，因此返回j即可</strong></p><figure><img src="`+l+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>请注意，返回的插入点是i，因此需要将其减1，从而获得j：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 二分查找最右一个 target */</span>
<span class="token keyword">int</span> <span class="token function">binarySearchRightEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> numSize<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 转化为查找最左一个 target + 1</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">binarySearchInsertion</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> numSize<span class="token punctuation">,</span> target <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// j 指向最右一个 target ，i 指向首个大于 target 的元素</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 未找到 target ，返回 -1</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> target<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 找到 target ，返回索引 j</span>
    <span class="token keyword">return</span> j<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>（2）方法二：转化为查找元素</strong></p><p><strong>我们知道，当数组不包含 target 时，最终i和j会分别指向首个大于、小于 target 的元素</strong></p><p><strong>因此，如下图所示，我们可以构造一个数组中不存在的元素，用于查找左右边界：</strong></p><ul><li><strong>查找最左一个 target ：可以转化为查找 target - 0.5 ，并返回指针i</strong></li><li><strong>查找最右一个 target ：可以转化为查找 target + 0.5 ，并返回指针j</strong></li></ul><figure><img src="`+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>代码在此省略，以下两点值得注意：</strong></p><ul><li><strong>给定数组不包含小数，这意味着我们无须关心如何处理相等的情况</strong></li><li><strong>因为该方法引入了小数，所以需要将函数中的变量 target 改为浮点数类型</strong></li></ul><hr><h2 id="_5-哈希优化策略" tabindex="-1"><a class="header-anchor" href="#_5-哈希优化策略"><span>5.哈希优化策略</span></a></h2><p><strong>在算法题中，我们常通过将线性查找替换为哈希查找来降低算法的时间复杂度</strong></p><hr><h3 id="_5-1-线性查找-以时间换空间" tabindex="-1"><a class="header-anchor" href="#_5-1-线性查找-以时间换空间"><span>5.1 线性查找：以时间换空间</span></a></h3><p><strong>考虑直接遍历所有可能的组合。如下图所示，我们开启一个两层循环，在每轮中判断两个整数的和是否为 target ，若是，则返回它们的索引</strong></p><blockquote><p><strong>此方法的时间复杂度为O（n^2），空间复杂度为O(1)，在大数据量下非常耗时</strong></p></blockquote><figure><img src="'+u+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 方法一：暴力枚举 */</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">twoSumBruteForce</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> numsSize<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>returnSize<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numsSize<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> numsSize<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> 
            <span class="token punctuation">{</span>
                <span class="token keyword">int</span> <span class="token operator">*</span>res <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">,</span> res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>
                <span class="token operator">*</span>returnSize <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> res<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token operator">*</span>returnSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_5-2-哈希查找-以空间换时间" tabindex="-1"><a class="header-anchor" href="#_5-2-哈希查找-以空间换时间"><span>5.2 哈希查找：以空间换时间</span></a></h3><p><strong>考虑借助一个哈希表，键值对分别为数组元素和元素索引。循环遍历数组，每轮执行图如下所示：</strong></p><blockquote><p><strong>此方法通过哈希查找将时间复杂度从O(n^2)降至O(n)，大幅提升运行效率</strong><br><br><strong>由于需要维护一个额外的哈希表，因此空间复杂度为O(n)</strong></p></blockquote><ul><li><strong>判断数字 target - nums[i] 是否在哈希表中，若是，则直接返回这两个元素的索引</strong></li><li><strong>将键值对 nums[i] 和索引 i 添加进哈希表</strong></li></ul><figure><img src="`+k+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>实现代码如下所示，仅需单层循环即可：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 哈希表 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> key<span class="token punctuation">;</span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>
    UT_hash_handle hh<span class="token punctuation">;</span> <span class="token comment">// 基于 uthash.h 实现</span>
<span class="token punctuation">}</span> HashTable<span class="token punctuation">;</span>

<span class="token comment">/* 哈希表查询 */</span>
HashTable <span class="token operator">*</span><span class="token function">find</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>h<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    HashTable <span class="token operator">*</span>tmp<span class="token punctuation">;</span>
    <span class="token function">HASH_FIND_INT</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">&amp;</span>key<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 哈希表元素插入 */</span>
<span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span>HashTable <span class="token operator">*</span>h<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    HashTable <span class="token operator">*</span>t <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        HashTable <span class="token operator">*</span>tmp <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>HashTable<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tmp<span class="token operator">-&gt;</span>key <span class="token operator">=</span> key<span class="token punctuation">,</span> tmp<span class="token operator">-&gt;</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
        <span class="token function">HASH_ADD_INT</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> key<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> 
    <span class="token punctuation">{</span>
        t<span class="token operator">-&gt;</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 方法二：辅助哈希表 */</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">twoSumHashTable</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> numsSize<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>returnSize<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    HashTable <span class="token operator">*</span>hashtable <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numsSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        HashTable <span class="token operator">*</span>t <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>hashtable<span class="token punctuation">,</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">int</span> <span class="token operator">*</span>res <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token operator">-&gt;</span>val<span class="token punctuation">,</span> res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
            <span class="token operator">*</span>returnSize <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> res<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">insert</span><span class="token punctuation">(</span>hashtable<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">*</span>returnSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,73),v=[m];function g(b,h){return s(),a("div",null,v)}const f=n(d,[["render",g],["__file","10.搜索.html.vue"]]),_=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/10.%E6%90%9C%E7%B4%A2.html","title":"第十章：搜索","lang":"zh-CN","frontmatter":{"date":"2024-03-10T00:00:00.000Z","order":10,"description":"第十章：搜索 1.二分查找 二分查找（binary search）是一种基于分治策略的高效搜索算法。它利用数据的有序性，每轮缩小一半搜索范围，直至找到目标元素或搜索区间为空为止 如上图所示，我们先初始化指针i=0和j=n-1，分别指向数组首元素和尾元素，代表搜索区间[0,n-1]。请注意，中括号表示闭区间，其包含边界值本身 时间复杂度为O(logn)：...","head":[["meta",{"property":"og:url","content":"https://github.com/jimbo-master/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/10.%E6%90%9C%E7%B4%A2.html"}],["meta",{"property":"og:site_name","content":"JimBoの学习妙妙屋"}],["meta",{"property":"og:title","content":"第十章：搜索"}],["meta",{"property":"og:description","content":"第十章：搜索 1.二分查找 二分查找（binary search）是一种基于分治策略的高效搜索算法。它利用数据的有序性，每轮缩小一半搜索范围，直至找到目标元素或搜索区间为空为止 如上图所示，我们先初始化指针i=0和j=n-1，分别指向数组首元素和尾元素，代表搜索区间[0,n-1]。请注意，中括号表示闭区间，其包含边界值本身 时间复杂度为O(logn)：..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"JimBo"}],["meta",{"property":"article:published_time","content":"2024-03-10T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第十章：搜索\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-10T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JimBo\\",\\"url\\":\\"https://github.com/jimbo-master\\"}]}"]]},"headers":[{"level":2,"title":"1.二分查找","slug":"_1-二分查找","link":"#_1-二分查找","children":[]},{"level":2,"title":"2.二分查找的区间表示方法","slug":"_2-二分查找的区间表示方法","link":"#_2-二分查找的区间表示方法","children":[]},{"level":2,"title":"3.二分查找插入点","slug":"_3-二分查找插入点","link":"#_3-二分查找插入点","children":[{"level":3,"title":"3.1 无重复元素的情况","slug":"_3-1-无重复元素的情况","link":"#_3-1-无重复元素的情况","children":[]},{"level":3,"title":"3.2 存在重复元素情况","slug":"_3-2-存在重复元素情况","link":"#_3-2-存在重复元素情况","children":[]}]},{"level":2,"title":"4.二分查找边界","slug":"_4-二分查找边界","link":"#_4-二分查找边界","children":[{"level":3,"title":"4.1 查找左边界","slug":"_4-1-查找左边界","link":"#_4-1-查找左边界","children":[]},{"level":3,"title":"4.2 查找右边界","slug":"_4-2-查找右边界","link":"#_4-2-查找右边界","children":[]}]},{"level":2,"title":"5.哈希优化策略","slug":"_5-哈希优化策略","link":"#_5-哈希优化策略","children":[{"level":3,"title":"5.1 线性查找：以时间换空间","slug":"_5-1-线性查找-以时间换空间","link":"#_5-1-线性查找-以时间换空间","children":[]},{"level":3,"title":"5.2 哈希查找：以空间换时间","slug":"_5-2-哈希查找-以空间换时间","link":"#_5-2-哈希查找-以空间换时间","children":[]}]}],"git":{},"readingTime":{"minutes":8.38,"words":2514},"filePathRelative":"算法学习/1.算法知识/10.搜索.md","localizedDate":"2024年3月10日","autoDesc":true,"excerpt":"\\n<h2>1.二分查找</h2>\\n<p><strong>二分查找（binary search）是一种基于分治策略的高效搜索算法。它利用数据的有序性，每轮缩小一半搜索范围，直至找到目标元素或搜索区间为空为止</strong></p>\\n<figure><figcaption></figcaption></figure>\\n<p><strong>如上图所示，我们先初始化指针i=0和j=n-1，分别指向数组首元素和尾元素，代表搜索区间[0,n-1]。请注意，中括号表示闭区间，其包含边界值本身</strong></p>\\n<blockquote>\\n<p><strong>时间复杂度为O(logn)：在二分循环中，区间每轮缩小一半，因此循环次数为logn</strong><br><br>\\n<strong>空间复杂度为O(1)：指针i和j使用常数大小空间</strong></p>\\n</blockquote>"}');export{f as comp,_ as data};
