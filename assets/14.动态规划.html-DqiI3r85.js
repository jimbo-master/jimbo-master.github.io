import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as c,o as i,c as l,a as n,d as a,w as p,b as o,e as t}from"./app-Dezzdk4T.js";const u="/assets/%E7%88%AC%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98-Da7eK-Ca.png",r="/assets/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2%E5%8E%9F%E7%90%86-D3ln7XcH.png",k="/assets/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2-DrmIcKQ2.png",d="/assets/%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AF%B9%E5%BA%94%E9%80%92%E5%BD%92%E6%A0%91-DGraAE33.png",m="/assets/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E5%AF%B9%E5%BA%94%E9%80%92%E5%BD%92%E6%A0%91-Ci8JH_12.png",v="/assets/%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-DaTL99uG.png",b="/assets/%E7%88%AC%E5%88%B03%E9%98%B6%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7-CVpRoLJL.png",g="/assets/%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E5%8E%9F%E7%90%86-BdjmWweB.png",f="/assets/%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%BF%87%E7%A8%8B-_oIKpTVJ.png",y="/assets/%E5%B8%A6%E7%BA%A6%E6%9D%9F%E7%88%AC%E6%A5%BC%E6%A2%AF-F4mAxmBf.png",w="/assets/%E5%B8%A6%E7%BA%A6%E6%9D%9F%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%8E%9F%E7%90%86-BgiBD5I6.png",E="/assets/%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6%E4%B8%8B%E9%80%92%E6%8E%A8-BLZOQ6Cv.png",h="/assets/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%AE%9E%E4%BE%8B-CwZfM7oz.png",_="/assets/%E7%8A%B6%E6%80%81%E5%AE%9A%E4%B9%89%E4%B8%8Edp%E8%A1%A8-DpSk-cjw.png",A="/assets/%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E5%8E%9F%E7%90%86-D9YUxBGD.png",B="/assets/%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E4%B8%8E%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B-CuDsLEfc.png",x="/assets/%E8%BE%B9%E7%95%8C%E6%9D%A1%E4%BB%B6%E4%B8%8E%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B-_YmHVLIS.png",C="/assets/%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A22-BFRTsJVw.png",j="/assets/%E6%9A%B4%E5%8A%9B%E9%80%92%E5%BD%92%E6%A0%91-DLlymYQB.png",D="/assets/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E9%80%92%E5%BD%92%E6%A0%91-tIbcsDQ-.png",z="/assets/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%E8%A7%84%E5%88%92%E8%BF%87%E7%A8%8B-C6AR8QXV.png",F="/assets/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%E8%A7%84%E5%88%92%E8%BF%87%E7%A8%8B2-nfqxYwhi.png",S="/assets/01%E8%83%8C%E5%8C%85%E5%AE%9E%E4%BE%8B-TVds40Rn.png",M="/assets/01%E8%83%8C%E5%8C%85%E5%8E%9F%E7%90%86-fMZpZPJ-.png",P="/assets/01%E8%83%8C%E5%8C%85%E6%9A%B4%E5%8A%9B-0pl6d_t6.png",I="/assets/01%E8%83%8C%E5%8C%85%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2-R2_TeEK4.png",T="/assets/01%E8%83%8C%E5%8C%85%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%BF%87%E7%A8%8B-CTGGjDqZ.png",X="/assets/03%E8%83%8C%E5%8C%85%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%BF%87%E7%A8%8B2-A36vVu8f.png",Z="/assets/01%E8%83%8C%E5%8C%85%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%BF%87%E7%A8%8B3-DbgplxTm.png",O="/assets/%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96-DowtpQqQ.png",N={},V=o('<h1 id="第十四章-动态规划" tabindex="-1"><a class="header-anchor" href="#第十四章-动态规划"><span>第十四章：动态规划</span></a></h1><h2 id="_1-动态规划问题探索" tabindex="-1"><a class="header-anchor" href="#_1-动态规划问题探索"><span>1.动态规划问题探索</span></a></h2><p><strong>动态规划（dynamic programming）是一个重要的算法范式，它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率</strong></p><p><strong>在本节中，我们从一个经典例题入手，先给出它的暴力回溯解法，观察其中包含的重叠子问题，再逐步导出更高效的动态规划解法</strong></p><p><strong>爬楼梯问题：给定一个共有n阶的楼梯，你每步可以上1阶或2阶，请问有多少种方案可以爬到楼顶？</strong></p><p><strong>如下图，对于一个3阶楼梯，共有3种方案可以爬到楼顶</strong></p><figure><img src="'+u+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>本题的目标是求解方案数量，我们可以考虑通过回溯来穷举所有可能性。具体来说，将爬楼梯想象为一个多轮选择的过程：从地面出发，每轮选择上1阶或2阶，每当到达楼梯顶部时就将方案数量加1，当越过楼梯顶部时就将其剪枝。代码如下所示：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 回溯 */</span>
<span class="token keyword">void</span> <span class="token function">backtrack</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>choices<span class="token punctuation">,</span> <span class="token keyword">int</span> state<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>res<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 当爬到第 n 阶时，方案数量加 1</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> n<span class="token punctuation">)</span>
        res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment">// 遍历所有选择</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> choice <span class="token operator">=</span> choices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 剪枝：不允许越过第 n 阶</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">+</span> choice <span class="token operator">&gt;</span> n<span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token comment">// 尝试：做出选择，更新状态</span>
        <span class="token function">backtrack</span><span class="token punctuation">(</span>choices<span class="token punctuation">,</span> state <span class="token operator">+</span> choice<span class="token punctuation">,</span> n<span class="token punctuation">,</span> res<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 回退</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 爬楼梯：回溯 */</span>
<span class="token keyword">int</span> <span class="token function">climbingStairsBacktrack</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> choices<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 可选择向上爬 1 阶或 2 阶</span>
    <span class="token keyword">int</span> state <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>           <span class="token comment">// 从第 0 阶开始爬</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">*</span>res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 使用 res[0] 记录方案数量</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>choices<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">backtrack</span><span class="token punctuation">(</span>choices<span class="token punctuation">,</span> state<span class="token punctuation">,</span> n<span class="token punctuation">,</span> res<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token operator">*</span>res<span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_1-1-方法一-暴力搜索" tabindex="-1"><a class="header-anchor" href="#_1-1-方法一-暴力搜索"><span>1.1 方法一：暴力搜索</span></a></h3><p><strong>回溯算法通常并不显式地对问题进行拆解，而是将求解问题看作一系列决策步骤，通过试探和剪枝，搜索所有可能的解</strong></p><figure><img src="`+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>下图展示了该递推关系：</strong></p><figure><img src="'+k+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>我们可以根据递推公式得到暴力搜索解法。以dp[n]为为起始点，递归地将一个较大问题拆解为两个较小问题的和，直至到达最小子问题dp[1]和dp[2]时返回。其中，最小子问题的解是已知的，即dp[1]=1、dp[2]=2，表示爬到第1、2阶分别有1、2种方案</strong></p><p><strong>观察以下代码，它和标准回溯代码都属于深度优先搜索，但更加简洁：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 搜索 */</span>
<span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 已知 dp[1] 和 dp[2] ，返回之</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token comment">// dp[i] = dp[i-1] + dp[i-2]</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">dfs</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 爬楼梯：搜索 */</span>
<span class="token keyword">int</span> <span class="token function">climbingStairsDFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>下图展示了暴力搜索形成的递归树。对于问题dp[n]，其递归树的深度为n，时间复杂度为O(2^n)。指数阶属于爆炸式增长，如果我们输入一个比较大的n，则会陷入漫长的等待之中</strong></p><figure><img src="`+d+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_1-2-方法二-记忆化搜索" tabindex="-1"><a class="header-anchor" href="#_1-2-方法二-记忆化搜索"><span>1.2 方法二：记忆化搜索</span></a></h3><p><strong>为了提升算法效率，我们希望所有的重叠子问题都只被计算一次。为此，我们声明一个数组 mem 来记录每个子问题的解，并在搜索过程中将重叠子问题剪枝</strong></p><ul><li><strong>当首次计算dp[i]时，我们将其记录至 mem[i] ，以便之后使用</strong></li><li><strong>当再次需要计算dp[i]时，我们便可直接从 mem[i] 中获取结果，从而避免重复计算该子问题</strong></li></ul><p><strong>代码如下所示：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 记忆化搜索 */</span>
<span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>mem<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 已知 dp[1] 和 dp[2] ，返回之</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> i <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token comment">// 若存在记录 dp[i] ，则直接返回之</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// dp[i] = dp[i-1] + dp[i-2]</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> mem<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">dfs</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> mem<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 记录 dp[i]</span>
    mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token punctuation">;</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 爬楼梯：记忆化搜索 */</span>
<span class="token keyword">int</span> <span class="token function">climbingStairsDFSMem</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// mem[i] 记录爬到第 i 阶的方案总数，-1 代表无记录</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>mem <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> mem<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>如下图，经过记忆化处理后，所有重叠子问题都只需计算一次，时间复杂度优化至O(n)，这是一个巨大的飞跃</strong></p><figure><img src="`+m+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_1-3-方法三-动态规划" tabindex="-1"><a class="header-anchor" href="#_1-3-方法三-动态规划"><span>1.3 方法三：动态规划</span></a></h3><p><strong>记忆化搜索是一种“从顶至底”的方法：我们从原问题（根节点）开始，递归地将较大子问题分解为较小子问题，直至解已知的最小子问题（叶节点）。之后，通过回溯逐层收集子问题的解，构建出原问题的解</strong></p><p><strong>与之相反，动态规划是一种“从底至顶”的方法：从最小子问题的解开始，迭代地构建更大子问题的解，直至得到原问题的解</strong></p><p><strong>由于动态规划不包含回溯过程，因此只需使用循环迭代实现，无须使用递归。在以下代码中，我们初始化一个数组 dp 来存储子问题的解，它起到了与记忆化搜索中数组 mem 相同的记录作用：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 爬楼梯：动态规划 */</span>
<span class="token keyword">int</span> <span class="token function">climbingStairsDP</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> n<span class="token punctuation">;</span>
    <span class="token comment">// 初始化 dp 表，用于存储子问题的解</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>dp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 初始状态：预设最小子问题的解</span>
    dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    dp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token comment">// 状态转移：从较小子问题逐步求解较大子问题</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> result <span class="token operator">=</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">free</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>下图模拟了以上代码的执行过程：</strong></p><figure><img src="`+v+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>与回溯算法一样，动态规划也使用“状态”概念来表示问题求解的特定阶段，每个状态都对应一个子问题以及相应的局部最优解。例如，爬楼梯问题的状态定义为当前所在楼梯阶数i</strong></p><p><strong>根据以上内容，我们可以总结出动态规划的常用术语：</strong></p><ul><li><strong>将数组 dp 称为 dp 表，dp[i]表示状态i对应子问题的解</strong></li><li><strong>将最小子问题对应的状态（第1阶和第2阶楼梯）称为初始状态</strong></li><li><strong>将递推公式dp[i]=dp[i-1]+dp[i-2]称为状态转移方程</strong></li></ul><hr><h3 id="_1-4-空间优化" tabindex="-1"><a class="header-anchor" href="#_1-4-空间优化"><span>1.4 空间优化</span></a></h3><p><strong>细心的读者可能发现了，由于dp[i]只与dp[i-1]和dp[i-2]有关，因此我们无须使用一个数组 dp 来存储所有子问题的解，而只需两个变量滚动前进即可。代码如下所示：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 爬楼梯：空间优化后的动态规划 */</span>
<span class="token keyword">int</span> <span class="token function">climbingStairsDPComp</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> n<span class="token punctuation">;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> tmp <span class="token operator">=</span> b<span class="token punctuation">;</span>
        b <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
        a <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>观察以上代码，由于省去了数组 dp 占用的空间，因此空间复杂度从O(n)降低至O(1)</strong></p><p><strong>在动态规划问题中，当前状态往往仅与前面有限个状态有关，这时我们可以只保留必要的状态，通过“降维”来节省内存空间。这种空间优化技巧被称为“滚动变量”或“滚动数组”</strong></p><hr><h2 id="_2-dp问题特性" tabindex="-1"><a class="header-anchor" href="#_2-dp问题特性"><span>2.DP问题特性</span></a></h2><p><strong>我们学习动态规划是如何通过子问题分解来求解原问题的。实际上，子问题分解是一种通用的算法思路，在分治、动态规划、回溯中的侧重点不同</strong></p><ul><li><strong>分治算法递归地将原问题划分为多个相互独立的子问题，直至最小子问题，并在回溯中合并子问题的解，最终得到原问题的解</strong></li><li><strong>动态规划也对问题进行递归分解，但与分治算法的主要区别是，动态规划中的子问题是相互依赖的，在分解过程中会出现许多重叠子问题</strong></li><li><strong>回溯算法在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。原问题的解由一系列决策步骤构成，我们可以将每个决策步骤之前的子序列看作一个子问题</strong></li></ul><p><strong>实际上，动态规划常用来求解最优化问题，它们不仅包含重叠子问题，还具有另外两大特性：最优子结构、无后效性</strong></p><hr><h3 id="_2-1-最优子结构" tabindex="-1"><a class="header-anchor" href="#_2-1-最优子结构"><span>2.1 最优子结构</span></a></h3><p><strong>我们对爬楼梯问题稍作改动，使之更加适合展示最优子结构概念</strong></p><p><strong>爬楼梯做小代价问题：给定一个楼梯，你每步可以上1阶或2阶，每一阶楼梯上都贴有一个非负整数，表示你在该台阶所需要付出的代价。给定一个非负整数数组cost，其中cost[i]表示在第i个台阶需要付出的代价，cost[0]为地面（起始点）。请计算最少需要付出多少代价才能到达顶部？</strong></p><p><strong>如下图所示，若第1、2、3阶的代价分别为1、10、1，则从地面爬到第3阶的最小代价为2</strong></p><figure><img src="`+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+g+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 爬楼梯最小代价：动态规划 */</span>
<span class="token keyword">int</span> <span class="token function">minCostClimbingStairsDP</span><span class="token punctuation">(</span><span class="token keyword">int</span> cost<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> costSize<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> costSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> cost<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 初始化 dp 表，用于存储子问题的解</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>dp <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 初始状态：预设最小子问题的解</span>
    dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> cost<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    dp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> cost<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 状态转移：从较小子问题逐步求解较大子问题</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">myMin</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 释放内存</span>
    <span class="token function">free</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>下图展示了以上代码的动态规划过程：</strong></p><figure><img src="`+f+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>本题也可以进行空间优化，将一维压缩至零维，使得空间复杂度从O(n)降至O(1)：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 爬楼梯最小代价：空间优化后的动态规划 */</span>
<span class="token keyword">int</span> <span class="token function">minCostClimbingStairsDPComp</span><span class="token punctuation">(</span><span class="token keyword">int</span> cost<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> costSize<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> costSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> cost<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> cost<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b <span class="token operator">=</span> cost<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> tmp <span class="token operator">=</span> b<span class="token punctuation">;</span>
        b <span class="token operator">=</span> <span class="token function">myMin</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> tmp<span class="token punctuation">)</span> <span class="token operator">+</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        a <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_2-2-无后效性" tabindex="-1"><a class="header-anchor" href="#_2-2-无后效性"><span>2.2 无后效性</span></a></h3><p><strong>无后效性是动态规划能够有效解决问题的重要特性之一，其定义为：给定一个确定的状态，它的未来发展只与当前状态有关，而与过去经历的所有状态无关</strong></p><p><strong>以爬楼梯问题为例，给定状态i，它会发展出状态i+1和状态i+2，分别对应跳1步和跳2步。在做出这两种选择时，我们无须考虑状态i之前的状态，它们对状态i的未来没有影响</strong></p><p><strong>然而，如果我们给爬楼梯问题添加一个约束，情况就不一样了</strong></p><p><strong>带约束的爬楼梯问题：给定一个共有n个楼梯，你每步可以上1阶或2阶，但不能连续两轮跳1阶，请问有多少种方案可以爬到楼顶？</strong></p><p><strong>如下图所示，爬上3阶仅剩下2种可行方案，其中连续三次跳1阶的方案不满足约束条件，因此被舍弃</strong></p><figure><img src="`+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+w+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+E+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>最终，返回dp[n,1]+dp[n,2]即可，两者之和代表爬到第n阶的方案总数：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 带约束爬楼梯：动态规划 */</span>
<span class="token keyword">int</span> <span class="token function">climbingStairsConstraintDP</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 初始化 dp 表，用于存储子问题的解</span>
    <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>dp <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 初始状态：预设最小子问题的解</span>
    dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    dp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    dp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 状态转移：从较小子问题逐步求解较大子问题</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 释放内存</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token function">free</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">free</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>在上面的案例中，由于仅需多考虑前面一个状态，因此我们仍然可以通过扩展状态定义，使得问题重新满足无后效性。然而，某些问题具有非常严重的“有后效性”</strong></p><hr><h2 id="_3-dp解题思路" tabindex="-1"><a class="header-anchor" href="#_3-dp解题思路"><span>3.DP解题思路</span></a></h2><h3 id="_3-1-问题判断" tabindex="-1"><a class="header-anchor" href="#_3-1-问题判断"><span>3.1 问题判断</span></a></h3><p><strong>总的来说，如果一个问题包含重叠子问题、最优子结构，并满足无后效性，那么它通常适合用动态规划求解。然而，我们很难从问题描述中直接提取出这些特性。因此我们通常会放宽条件，先观察问题是否适合使用回溯（穷举）解决</strong></p><p><strong>适合用回溯解决的问题通常满足“决策树模型”，这种问题可以使用树形结构来描述，其中每一个节点代表一个决策，每一条路径代表一个决策序列</strong></p><p><strong>换句话说，如果问题包含明确的决策概念，并且解是通过一系列决策产生的，那么它就满足决策树模型，通常可以使用回溯来解决</strong></p><p><strong>在此基础上，动态规划问题还有一些判断的“加分项”：</strong></p><ul><li><strong>问题包含最大（小）或最多（少）等最优化描述</strong></li><li><strong>问题的状态能够使用一个列表、多维矩阵或树来表示，并且一个状态与其周围的状态存在递推关系</strong></li></ul><p><strong>相应地，也存在一些“减分项”：</strong></p><ul><li><strong>问题的目标是找出所有可能的解决方案，而不是找出最优解</strong></li><li><strong>问题描述中有明显的排列组合的特征，需要返回具体的多个方案</strong></li></ul><p><strong>如果一个问题满足决策树模型，并具有较为明显的“加分项”，我们就可以假设它是一个动态规划问题，并在求解过程中验证它</strong></p><hr><h3 id="_3-2-问题求解步骤" tabindex="-1"><a class="header-anchor" href="#_3-2-问题求解步骤"><span>3.2 问题求解步骤</span></a></h3><p><strong>动态规划的解题流程会因问题的性质和难度而有所不同，但通常遵循以下步骤：描述决策，定义状态，建立dp表，推导状态转移方程，确定边界条件等</strong></p><p><strong>为了更形象地展示解题步骤，我们使用一个经典问题“最小路径和”来举例</strong></p><p><strong>问题：给定一个nxm的二维网络grid，网格中的每个单元格包含一个非负整数，表示该单元格的代价。机器人以左上角单元格为起始点，每次只能向下或者向右移动一步，直至到达右下角单元格。请返回从左上角到右下角的最小路径和</strong></p><p><strong>下图展示了一个例子，给定网格的最小路径和为13</strong></p><figure><img src="`+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',93),J=n("blockquote",null,[n("p",null,[n("strong",null,"本题的每一轮的决策就是从当前格子向下或向右走一步。设当前格子的行列索引为[i,j]，则向下或向右走一步后，索引变为[i+1,j]或[i,j+1] 。因此，状态应包含行索引和列索引两个变量，记为[i,j]"),n("br"),n("br"),n("strong",null,"状态[i,h]对应的子问题是：从起始点[0,0]走到[i,j]的最小路径和，解记为dp[i,j]"),n("br"),n("br"),n("strong",null,"自此，我们就得到了下图所示的二维dp矩阵，其尺寸与输入网格grid相同")])],-1),L=n("figure",null,[n("img",{src:_,alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1),Q=n("figure",null,[n("img",{src:A,alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1),R=n("figure",null,[n("img",{src:B,alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1),G=o('<p><strong>在本题中，处在首行的状态只能从其左边的状态得来，处在首列的状态只能从其上边的状态得来，因此首行i=0和首列j=0 是边界条件</strong></p><p><strong>如下图所示，由于每个格子是由其左方格子和上方格子转移而来，因此我们使用循环来遍历矩阵，外循环遍历各行，内循环遍历各列</strong></p><figure><img src="'+x+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_3-3-方法一-暴力搜索" tabindex="-1"><a class="header-anchor" href="#_3-3-方法一-暴力搜索"><span>3.3 方法一：暴力搜索</span></a></h3><figure><img src="'+C+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 最小路径和：暴力搜索 */</span>
<span class="token keyword">int</span> <span class="token function">minPathSumDFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> grid<span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 若为左上角单元格，则终止搜索</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 若行列索引越界，则返回 +∞ 代价</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> INT_MAX<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 计算从左上角到 (i-1, j) 和 (i, j-1) 的最小路径代价</span>
    <span class="token keyword">int</span> up <span class="token operator">=</span> <span class="token function">minPathSumDFS</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">minPathSumDFS</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 返回从左上角到 (i, j) 的最小路径代价</span>
    <span class="token keyword">return</span> <span class="token function">myMin</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> up<span class="token punctuation">)</span> <span class="token operator">!=</span> INT_MAX <span class="token operator">?</span> <span class="token function">myMin</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> up<span class="token punctuation">)</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">:</span> INT_MAX<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>下图给出了以dp[2,1]为根节点的递归树，其中包含一些重叠子问题，其数量会随着网格 grid 的尺寸变大而急剧增多</strong></p><p><strong>从本质上看，造成重叠子问题的原因为：存在多条路径可以从左上角到达某一单元格</strong></p><figure><img src="`+j+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>每个状态都有向下和向右两种选择，从左上角走到右下角总共需要m+n-2步，所以最差时间复杂度为O(2^ m+2)。请注意，这种计算方式未考虑临近网格边界的情况，当到达网络边界时只剩下一种选择，因此实际的路径数量会少一些</strong></p><hr><h3 id="_3-4-方法二-记忆化搜索" tabindex="-1"><a class="header-anchor" href="#_3-4-方法二-记忆化搜索"><span>3.4 方法二：记忆化搜索</span></a></h3><p><strong>我们引入一个和网格 grid 相同尺寸的记忆列表 mem ，用于记录各个子问题的解，并将重叠子问题进行剪枝：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 最小路径和：记忆化搜索 */</span>
<span class="token keyword">int</span> <span class="token function">minPathSumDFSMem</span><span class="token punctuation">(</span><span class="token keyword">int</span> grid<span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> mem<span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 若为左上角单元格，则终止搜索</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 若行列索引越界，则返回 +∞ 代价</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> INT_MAX<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 若已有记录，则直接返回</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 左边和上边单元格的最小路径代价</span>
    <span class="token keyword">int</span> up <span class="token operator">=</span> <span class="token function">minPathSumDFSMem</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> mem<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token function">minPathSumDFSMem</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> mem<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 记录并返回左上角到 (i, j) 的最小路径代价</span>
    mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">myMin</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> up<span class="token punctuation">)</span> <span class="token operator">!=</span> INT_MAX <span class="token operator">?</span> <span class="token function">myMin</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> up<span class="token punctuation">)</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">:</span> INT_MAX<span class="token punctuation">;</span>
    <span class="token keyword">return</span> mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>如下图所示，在引入记忆化后，所有子问题的解只需计算一次，因此时间复杂度取决于状态总数，即网格尺寸O(mn)</strong></p><figure><img src="`+D+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_3-5-方法三-动态规划" tabindex="-1"><a class="header-anchor" href="#_3-5-方法三-动态规划"><span>3.5 方法三：动态规划</span></a></h3><p><strong>基于迭代实现动态规划解法，代码如下所示：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 最小路径和：动态规划 */</span>
<span class="token keyword">int</span> <span class="token function">minPathSumDP</span><span class="token punctuation">(</span><span class="token keyword">int</span> grid<span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 初始化 dp 表</span>
    <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>dp <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 状态转移：首行</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 状态转移：首列</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 状态转移：其余行和列</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">myMin</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 释放内存</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token function">free</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>下图展示了最小路径和的状态转移过程，其遍历了整个网格，因此时间复杂度为O(nm)，数组dp大小为nxm，因此空间复杂度为O(nm)</strong></p><figure><img src="`+z+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+F+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_3-6-空间优化" tabindex="-1"><a class="header-anchor" href="#_3-6-空间优化"><span>3.6 空间优化</span></a></h3><p><strong>由于每个格子只与其左边和上边的格子有关，因此我们可以只用一个单行数组来实现dp表</strong></p><p><strong>请注意，因为数组 dp 只能表示一行的状态，所以我们无法提前初始化首列状态，而是在遍历每行时更新它：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 最小路径和：空间优化后的动态规划 */</span>
<span class="token keyword">int</span> <span class="token function">minPathSumDPComp</span><span class="token punctuation">(</span><span class="token keyword">int</span> grid<span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">[</span>MAX_SIZE<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 初始化 dp 表</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>dp <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 状态转移：首行</span>
    dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 状态转移：其余行</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 状态转移：首列</span>
        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 状态转移：其余列</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">myMin</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> dp<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 释放内存</span>
    <span class="token function">free</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_4-0-1背包问题" tabindex="-1"><a class="header-anchor" href="#_4-0-1背包问题"><span>4.0-1背包问题</span></a></h2><p><strong>背包问题是一个非常好的动态规划入门题目，是动态规划中最常见的问题形式。其具有很多变种，例如 0-1 背包问题、完全背包问题、多重背包问题等</strong></p><p><strong>在本节中，我们先来求解最常见的 0-1 背包问题</strong></p><p><strong>问题：给定n个物品，第i个物品的重量为wgt[i-1]、价值为val[i-1]，和一个容量为cap的背包。每个物品只能选择一次，问在限定背包容量下能放入物品的最大价值</strong></p><p><strong>如下图，由于物品编号i从1开始计数，数组索引从0开始计数，因此物品i对应重量wgt[i-1]和价值val[i-1]</strong></p><figure><img src="`+S+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>我们可以将 0-1 背包问题看作一个由n轮决策组成的过程，对于每个物体都有不放入和放入两种决策，因此该问题满足决策树模型</strong></p><p><strong>该问题的目标是求解“在限定背包容量下能放入物品的最大价值”，因此较大概率是一个动态规划问题</strong></p><figure><img src="'+M+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_4-1-方法一-暴力搜索" tabindex="-1"><a class="header-anchor" href="#_4-1-方法一-暴力搜索"><span>4.1 方法一：暴力搜索</span></a></h3><p><strong>搜索代码包含以下要素：</strong></p><ul><li><strong>递归参数：状态[i,c]</strong></li><li><strong>返回值：子问题的解dp[i,c]</strong></li><li><strong>终止条件：当物品编号越界i=0或背包剩余容量为0时，终止递归并返回价值0</strong></li><li><strong>剪枝：若当前物品重量超出背包剩余容量，则只能选择不放入背包</strong></li></ul><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 0-1 背包：暴力搜索 */</span>
<span class="token keyword">int</span> <span class="token function">knapsackDFS</span><span class="token punctuation">(</span><span class="token keyword">int</span> wgt<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 若已选完所有物品或背包无剩余容量，则返回价值 0</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 若超过背包容量，则只能选择不放入背包</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>wgt<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> c<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">knapsackDFS</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 计算不放入和放入物品 i 的最大价值</span>
    <span class="token keyword">int</span> no <span class="token operator">=</span> <span class="token function">knapsackDFS</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> yes <span class="token operator">=</span> <span class="token function">knapsackDFS</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> c <span class="token operator">-</span> wgt<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> val<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 返回两种方案中价值更大的那一个</span>
    <span class="token keyword">return</span> <span class="token function">myMax</span><span class="token punctuation">(</span>no<span class="token punctuation">,</span> yes<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>如下图所示，由于每个物品都会产生不选和选两条搜索分支，因此时间复杂度为O(2^n)</strong></p><p><strong>观察递归树，容易发现其中存在重叠子问题，例如dp[1,10]等。而当物品较多、背包容量较大，尤其是相同重量的物品较多时，重叠子问题的数量将会大幅增多</strong></p><figure><img src="`+P+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_4-2-方法二-记忆化搜索" tabindex="-1"><a class="header-anchor" href="#_4-2-方法二-记忆化搜索"><span>4.2 方法二：记忆化搜索</span></a></h3><p><strong>为了保证重叠子问题只被计算一次，我们借助记忆列表 mem 来记录子问题的解，其中 mem[i][c] 对应dp[i,c]</strong></p><p><strong>引入记忆化之后，时间复杂度取决于子问题数量，也就是O(n x cap)。实现代码如下</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 0-1 背包：记忆化搜索 */</span>
<span class="token keyword">int</span> <span class="token function">knapsackDFSMem</span><span class="token punctuation">(</span><span class="token keyword">int</span> wgt<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> memCols<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>mem<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 若已选完所有物品或背包无剩余容量，则返回价值 0</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 若已有记录，则直接返回</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 若超过背包容量，则只能选择不放入背包</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>wgt<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> c<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">knapsackDFSMem</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val<span class="token punctuation">,</span> memCols<span class="token punctuation">,</span> mem<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 计算不放入和放入物品 i 的最大价值</span>
    <span class="token keyword">int</span> no <span class="token operator">=</span> <span class="token function">knapsackDFSMem</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val<span class="token punctuation">,</span> memCols<span class="token punctuation">,</span> mem<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> yes <span class="token operator">=</span> <span class="token function">knapsackDFSMem</span><span class="token punctuation">(</span>wgt<span class="token punctuation">,</span> val<span class="token punctuation">,</span> memCols<span class="token punctuation">,</span> mem<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> c <span class="token operator">-</span> wgt<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> val<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 记录并返回两种方案中价值更大的那一个</span>
    mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">myMax</span><span class="token punctuation">(</span>no<span class="token punctuation">,</span> yes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> mem<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>下图展示了在记忆化搜索中被剪掉的搜索分支：</strong></p><figure><img src="`+I+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_4-3-方法三-动态规划" tabindex="-1"><a class="header-anchor" href="#_4-3-方法三-动态规划"><span>4.3 方法三：动态规划</span></a></h3><p><strong>动态规划实质上就是在状态转移中填充dp表的过程，代码如下所示：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 0-1 背包：动态规划 */</span>
<span class="token keyword">int</span> <span class="token function">knapsackDP</span><span class="token punctuation">(</span><span class="token keyword">int</span> wgt<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> cap<span class="token punctuation">,</span> <span class="token keyword">int</span> wgtSize<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> wgtSize<span class="token punctuation">;</span>
    <span class="token comment">// 初始化 dp 表</span>
    <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>dp <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span>cap <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 状态转移</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> c <span class="token operator">&lt;=</span> cap<span class="token punctuation">;</span> c<span class="token operator">++</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>wgt<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> c<span class="token punctuation">)</span> 
            <span class="token punctuation">{</span>
                <span class="token comment">// 若超过背包容量，则不选物品 i</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> 
            <span class="token keyword">else</span> 
            <span class="token punctuation">{</span>
                <span class="token comment">// 不选和选物品 i 这两种方案的较大值</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">myMax</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c <span class="token operator">-</span> wgt<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> val<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>cap<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 释放内存</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token function">free</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>如下图所示，时间复杂度和空间复杂度都由数组 dp 大小决定，即O(n x cap)</strong></p><figure><img src="`+T+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+X+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+Z+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_4-4-空间优化" tabindex="-1"><a class="header-anchor" href="#_4-4-空间优化"><span>4.4 空间优化</span></a></h3><p><strong>由于每个状态都只与其上一行的状态有关，因此我们可以使用两个数组滚动前进，将空间复杂度从O(n^2)降至O(n)</strong></p><p><strong>进一步思考，我们能否仅用一个数组实现空间优化呢？观察可知，每个状态都是由正上方或左上方的格子转移过来的。假设只有一个数组，当开始遍历第i行时，该数组存储的仍然是第i-1行的状态</strong></p><ul><li><strong>如果采取正序遍历，那么遍历到dp[i,j]时，左上方dp[i-1,1]~dp[i-1,j-1]值可能已经被覆盖，此时就无法得到正确的状态转移结果</strong></li><li><strong>如果采取倒序遍历，则不会发生覆盖问题，状态转移可以正确进行</strong></li></ul><p><strong>下图展示了在单个数组下从第i=1行转换至第i=2行的过程</strong></p><figure><img src="'+O+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>在代码实现中，我们仅需将数组 dp 的第一维i直接删除，，并且把内循环更改为倒序遍历即可：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 0-1 背包：空间优化后的动态规划 */</span>
<span class="token keyword">int</span> <span class="token function">knapsackDPComp</span><span class="token punctuation">(</span><span class="token keyword">int</span> wgt<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> cap<span class="token punctuation">,</span> <span class="token keyword">int</span> wgtSize<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> wgtSize<span class="token punctuation">;</span>
    <span class="token comment">// 初始化 dp 表</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>dp <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span>cap <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 状态转移</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 倒序遍历</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> c <span class="token operator">=</span> cap<span class="token punctuation">;</span> c <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> c<span class="token operator">--</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>wgt<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> c<span class="token punctuation">)</span> 
            <span class="token punctuation">{</span>
                <span class="token comment">// 不选和选物品 i 这两种方案的较大值</span>
                dp<span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">myMax</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>c <span class="token operator">-</span> wgt<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> val<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> dp<span class="token punctuation">[</span>cap<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 释放内存</span>
    <span class="token function">free</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,71);function q(K,Y){const s=c("font");return i(),l("div",null,[V,n("p",null,[n("strong",null,[a(s,{color:"red"},{default:p(()=>[t("第一步：思考每轮的决策，定义状态，从而得到dp表")]),_:1})])]),J,L,n("p",null,[n("strong",null,[a(s,{color:"red"},{default:p(()=>[t("第二步：找出最优子结构，进而推导出状态转移方程")]),_:1})])]),Q,R,n("p",null,[n("strong",null,[a(s,{color:"red"},{default:p(()=>[t("第三步：确定边界条件和状态转移顺序")]),_:1})])]),G])}const W=e(N,[["render",q],["__file","14.动态规划.html.vue"]]),$=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/14.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html","title":"第十四章：动态规划","lang":"zh-CN","frontmatter":{"date":"2024-03-14T00:00:00.000Z","order":14,"description":"第十四章：动态规划 1.动态规划问题探索 动态规划（dynamic programming）是一个重要的算法范式，它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率 在本节中，我们从一个经典例题入手，先给出它的暴力回溯解法，观察其中包含的重叠子问题，再逐步导出更高效的动态规划解法 爬楼梯问题：给定一个共有n阶...","head":[["meta",{"property":"og:url","content":"https://github.com/jimbo-master/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/14.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html"}],["meta",{"property":"og:site_name","content":"JimBoの学习妙妙屋"}],["meta",{"property":"og:title","content":"第十四章：动态规划"}],["meta",{"property":"og:description","content":"第十四章：动态规划 1.动态规划问题探索 动态规划（dynamic programming）是一个重要的算法范式，它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率 在本节中，我们从一个经典例题入手，先给出它的暴力回溯解法，观察其中包含的重叠子问题，再逐步导出更高效的动态规划解法 爬楼梯问题：给定一个共有n阶..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"JimBo"}],["meta",{"property":"article:published_time","content":"2024-03-14T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第十四章：动态规划\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-14T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JimBo\\",\\"url\\":\\"https://github.com/jimbo-master\\"}]}"]]},"headers":[{"level":2,"title":"1.动态规划问题探索","slug":"_1-动态规划问题探索","link":"#_1-动态规划问题探索","children":[{"level":3,"title":"1.1 方法一：暴力搜索","slug":"_1-1-方法一-暴力搜索","link":"#_1-1-方法一-暴力搜索","children":[]},{"level":3,"title":"1.2 方法二：记忆化搜索","slug":"_1-2-方法二-记忆化搜索","link":"#_1-2-方法二-记忆化搜索","children":[]},{"level":3,"title":"1.3 方法三：动态规划","slug":"_1-3-方法三-动态规划","link":"#_1-3-方法三-动态规划","children":[]},{"level":3,"title":"1.4 空间优化","slug":"_1-4-空间优化","link":"#_1-4-空间优化","children":[]}]},{"level":2,"title":"2.DP问题特性","slug":"_2-dp问题特性","link":"#_2-dp问题特性","children":[{"level":3,"title":"2.1 最优子结构","slug":"_2-1-最优子结构","link":"#_2-1-最优子结构","children":[]},{"level":3,"title":"2.2 无后效性","slug":"_2-2-无后效性","link":"#_2-2-无后效性","children":[]}]},{"level":2,"title":"3.DP解题思路","slug":"_3-dp解题思路","link":"#_3-dp解题思路","children":[{"level":3,"title":"3.1 问题判断","slug":"_3-1-问题判断","link":"#_3-1-问题判断","children":[]},{"level":3,"title":"3.2 问题求解步骤","slug":"_3-2-问题求解步骤","link":"#_3-2-问题求解步骤","children":[]},{"level":3,"title":"3.3 方法一：暴力搜索","slug":"_3-3-方法一-暴力搜索","link":"#_3-3-方法一-暴力搜索","children":[]},{"level":3,"title":"3.4 方法二：记忆化搜索","slug":"_3-4-方法二-记忆化搜索","link":"#_3-4-方法二-记忆化搜索","children":[]},{"level":3,"title":"3.5 方法三：动态规划","slug":"_3-5-方法三-动态规划","link":"#_3-5-方法三-动态规划","children":[]},{"level":3,"title":"3.6 空间优化","slug":"_3-6-空间优化","link":"#_3-6-空间优化","children":[]}]},{"level":2,"title":"4.0-1背包问题","slug":"_4-0-1背包问题","link":"#_4-0-1背包问题","children":[{"level":3,"title":"4.1 方法一：暴力搜索","slug":"_4-1-方法一-暴力搜索","link":"#_4-1-方法一-暴力搜索","children":[]},{"level":3,"title":"4.2 方法二：记忆化搜索","slug":"_4-2-方法二-记忆化搜索","link":"#_4-2-方法二-记忆化搜索","children":[]},{"level":3,"title":"4.3 方法三：动态规划","slug":"_4-3-方法三-动态规划","link":"#_4-3-方法三-动态规划","children":[]},{"level":3,"title":"4.4 空间优化","slug":"_4-4-空间优化","link":"#_4-4-空间优化","children":[]}]}],"git":{},"readingTime":{"minutes":23.34,"words":7002},"filePathRelative":"算法学习/1.算法知识/14.动态规划.md","localizedDate":"2024年3月14日","autoDesc":true,"excerpt":"\\n<h2>1.动态规划问题探索</h2>\\n<p><strong>动态规划（dynamic programming）是一个重要的算法范式，它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率</strong></p>\\n<p><strong>在本节中，我们从一个经典例题入手，先给出它的暴力回溯解法，观察其中包含的重叠子问题，再逐步导出更高效的动态规划解法</strong></p>\\n<p><strong>爬楼梯问题：给定一个共有n阶的楼梯，你每步可以上1阶或2阶，请问有多少种方案可以爬到楼顶？</strong></p>\\n<p><strong>如下图，对于一个3阶楼梯，共有3种方案可以爬到楼顶</strong></p>"}');export{W as comp,$ as data};
