import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,b as t}from"./app-Dezzdk4T.js";const p="/assets/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%88%A4%E6%96%AD%E8%A7%84%E5%88%99-C6YK3UU8.png",o="/assets/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-BNsK9kfp.png",e="/assets/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E9%9D%9E%E7%A8%B3%E5%AE%9A%E6%80%A7-wH7gBfDE.png",c="/assets/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-BKTQ1K69.png",i="/assets/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B-BSBlS73g.png",l="/assets/%E5%8D%95%E6%AC%A1%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-WgCl52rn.png",u="/assets/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B-DD646liI.png",r="/assets/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B-BaIu-hTV.png",k="/assets/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B2-CrTZ0t5J.png",d="/assets/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-Do3x1ZO2.png",m="/assets/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-DW_-oxQ6.png",v="/assets/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B-Dz1QYwiA.png",b="/assets/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B-wSZbxsaX.png",g="/assets/%E5%A0%86%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B2-BZxeEAsY.png",f="/assets/%E6%A1%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7-DGTW_iKc.png",h="/assets/%E6%A1%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-tM2lrxRM.png",y="/assets/%E9%80%92%E5%BD%92%E5%88%92%E5%88%86%E6%A1%B6-DtiW3JUc.png",w="/assets/%E9%80%92%E5%BD%92%E5%88%92%E5%88%86%E6%A1%B62-DLKIN5qn.png",E="/assets/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B-DtzTHoy1.png",_="/assets/%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0-CFlOayp4.png",B="/assets/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B-O3_biWBA.png",x="/assets/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-L4XIL4Bm.png",A={},j=t('<h1 id="第十一章-排序" tabindex="-1"><a class="header-anchor" href="#第十一章-排序"><span>第十一章：排序</span></a></h1><h2 id="_1-排序算法概念" tabindex="-1"><a class="header-anchor" href="#_1-排序算法概念"><span>1.排序算法概念</span></a></h2><p><strong>排序算法（sorting algorithm）用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理</strong></p><p><strong>如下图所示，排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则</strong></p><figure><img src="'+p+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_1-1-排序算法评价维度" tabindex="-1"><a class="header-anchor" href="#_1-1-排序算法评价维度"><span>1.1 排序算法评价维度</span></a></h3><p><strong>（1）运行效率：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要</strong></p><p><strong>（2）就地性：顾名思义，原地排序通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快</strong></p><p><strong>（3）稳定性：稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变</strong></p><blockquote><p><strong>稳定排序是多级排序场景的必要条件。假设我们有一个存储学生信息的表格，第 1 列和第 2 列分别是姓名和年龄。在这种情况下，非稳定排序可能导致输入数据的有序性丧失：</strong></p></blockquote><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code># 输入数据是按照姓名排序好的
# <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token char">&#39;A&#39;</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token char">&#39;B&#39;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token char">&#39;C&#39;</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token char">&#39;D&#39;</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token char">&#39;E&#39;</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span>

# 假设使用非稳定排序算法按年龄排序列表，
# 结果中 <span class="token punctuation">(</span><span class="token char">&#39;D&#39;</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span> 和 <span class="token punctuation">(</span><span class="token char">&#39;A&#39;</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span> 的相对位置改变，
# 输入数据按姓名排序的性质丢失
  <span class="token punctuation">(</span><span class="token char">&#39;B&#39;</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token char">&#39;D&#39;</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token char">&#39;A&#39;</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token char">&#39;C&#39;</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token char">&#39;E&#39;</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>（4）自适应性：自适应排序的时间复杂度会受输入数据的影响，即最佳时间复杂度、最差时间复杂度、平均时间复杂度并不完全相等</strong></p><blockquote><p><strong>自适应性需要根据具体情况来评估。如果最差时间复杂度差于平均时间复杂度，说明排序算法在某些数据下性能可能劣化，因此被视为负面属性；而如果最佳时间复杂度优于平均时间复杂度，则被视为正面属性</strong></p></blockquote><p><strong>（5）是否基于比较：基于比较的排序依赖比较运算符（&lt;、=、&gt;）来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为O(nlogn)。而非比较排序不使用比较运算符，时间复杂度可达O(n)，但其通用性相对较差</strong></p><hr><h3 id="_1-2-理想的排序算法" tabindex="-1"><a class="header-anchor" href="#_1-2-理想的排序算法"><span>1.2 理想的排序算法</span></a></h3><p><strong>运行快、原地、稳定、正向自适应、通用性好。显然，迄今为止尚未发现兼具以上所有特性的排序算法。因此，在选择排序算法时，需要根据具体的数据特点和问题需求来决定</strong></p><hr><h2 id="_2-选择排序算法" tabindex="-1"><a class="header-anchor" href="#_2-选择排序算法"><span>2.选择排序算法</span></a></h2><h3 id="_2-1-选择排序原理" tabindex="-1"><a class="header-anchor" href="#_2-1-选择排序原理"><span>2.1 选择排序原理</span></a></h3><p><strong>选择排序（selection sort）的工作原理非常简单：开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾</strong></p><p><strong>设数组的长度为n，选择排序的算法流程如图下图所示：</strong></p><ul><li><strong>初始状态下，所有元素未排序，即未排序（索引）区间为[0，n-1]</strong></li><li><strong>选取区间[0，n-1]中的最小元素，将其与索引0处的元素交换。完成后，数组前1个元素已排序</strong></li><li><strong>选取区间[1，n-1]中的最小元素，将其与索引1处的元素交换。完成后，数组前2个元素已排序</strong></li><li><strong>以此类推。经过n-1轮选择与交换后，数组前n-1个元素已排序</strong></li><li><strong>仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成</strong></li></ul><figure><img src="`+o+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>在代码中，我们用k来记录未排序区间内的最小元素：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 选择排序 */</span>
<span class="token keyword">void</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 外循环：未排序区间为 [i, n-1]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 内循环：找到未排序区间内的最小元素</span>
        <span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>
                k <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 记录最小元素的索引</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 将该最小元素与未排序区间的首个元素交换</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>时间复杂度为O(n^2)、非自适应排序：外循环共n-1轮，第一轮的未排序区间长度为n，最后一轮的未排序区间长度为2，即各轮外循环分别包含n、n-1、...、3、2轮内循环，求和为(n-1)(n+2)/2</strong><br><br><strong>空间复杂度为O(1)、原地排序：指针i和j使用常数大小的额外空间</strong><br><br><strong>非稳定排序：如下图所示，元素 nums[i] 有可能被交换至与其相等的元素的右边，导致两者的相对顺序发生改变</strong></p></blockquote><figure><img src="`+e+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h2 id="_3-冒泡排序算法" tabindex="-1"><a class="header-anchor" href="#_3-冒泡排序算法"><span>3.冒泡排序算法</span></a></h2><p><strong>冒泡排序（bubble sort）通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序</strong></p><blockquote><p><strong>时间复杂度为O(n^2)、自适应排序：各轮“冒泡”遍历的数组长度依次为n-1、n-2、...、2、1，总和为(n-1)/2。在引入 flag 优化后，最佳时间复杂度可达到O(n)</strong><br><br><strong>空间复杂度为O(1)、原地排序：指针i和j使用常数大小的额外空间</strong><br><br><strong>稳定排序：由于在“冒泡”中遇到相等元素不交换</strong></p></blockquote><p><strong>如下图所示，冒泡过程可以利用元素交换操作来模拟：从数组最左端开始向右遍历，依次比较相邻元素大小，如果“左元素 &gt; 右元素”就交换二者。遍历完成后，最大的元素会被移动到数组的最右端</strong></p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_3-1-冒牌排序算法流程" tabindex="-1"><a class="header-anchor" href="#_3-1-冒牌排序算法流程"><span>3.1 冒牌排序算法流程</span></a></h3><p><strong>设数组的长度n，冒泡排序的步骤如下图所示：</strong></p><ul><li><strong>首先，对n个元素执行“冒泡”，将数组的最大元素交换至正确位置</strong></li><li><strong>接下来，对剩余n-1个元素执行“冒泡”，将第二大元素交换至正确位置</strong></li><li><strong>以此类推，经过n-1轮“冒泡”后，前n-1大的元素都被交换至正确位置</strong></li><li><strong>仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成</strong></li></ul><figure><img src="'+i+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>示例代码如下：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 冒泡排序 */</span>
<span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 外循环：未排序区间为 [0, i]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> 
            <span class="token punctuation">{</span>
                <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_3-2-冒泡排序效率优化" tabindex="-1"><a class="header-anchor" href="#_3-2-冒泡排序效率优化"><span>3.2 冒泡排序效率优化</span></a></h3><p><strong>我们发现，如果某轮“冒泡”中没有执行任何交换操作，说明数组已经完成排序，可直接返回结果。因此，可以增加一个标志位 flag 来监测这种情况，一旦出现就立即返回</strong></p><p><strong>经过优化，冒泡排序的最差时间复杂度和平均时间复杂度仍为O(n^2)；但当输入数组完全有序时，可达到最佳时间复杂度O(n)</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 冒泡排序（标志优化）*/</span>
<span class="token keyword">void</span> <span class="token function">bubbleSortWithFlag</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 外循环：未排序区间为 [0, i]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        bool flag <span class="token operator">=</span> false<span class="token punctuation">;</span>
        <span class="token comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> 
            <span class="token punctuation">{</span>
                <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
                flag <span class="token operator">=</span> true<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_4-插入排序算法" tabindex="-1"><a class="header-anchor" href="#_4-插入排序算法"><span>4.插入排序算法</span></a></h2><p><strong>插入排序（insertion sort）是一种简单的排序算法，它的工作原理与手动整理一副牌的过程非常相似</strong></p><p><strong>具体来说，我们在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置</strong></p><p><strong>下图展示了数组插入元素的操作流程。设基准元素为 base ，我们需要将从目标索引到 base 之间的所有元素向右移动一位，然后将 base 赋值给目标索引</strong></p><figure><img src="`+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_4-1-插入排序算法流程" tabindex="-1"><a class="header-anchor" href="#_4-1-插入排序算法流程"><span>4.1 插入排序算法流程</span></a></h3><p><strong>插入排序的整体流程如下图所示：</strong></p><ul><li><strong>初始状态下，数组的第 1 个元素已完成排序</strong></li><li><strong>选取数组的第 2 个元素作为 base ，将其插入到正确位置后，数组的前 2 个元素已排序</strong></li><li><strong>选取第 3 个元素作为 base ，将其插入到正确位置后，数组的前 3 个元素已排序</strong></li><li><strong>以此类推，在最后一轮中，选取最后一个元素作为 base ，将其插入到正确位置后，所有元素均已排序</strong></li></ul><blockquote><p><strong>时间复杂度为O(n^ 2)、自适应排序：在最差情况下，每次插入操作分别需要循环n-1、n-2、...、2、1次，求和得到(n-1)n/2，因此时间复杂度为O(n^2) 。在遇到有序数据时，插入操作会提前终止。当输入数组完全有序时，插入排序达到最佳时间复杂度O(n)</strong><br><br><strong>空间复杂度为O(1)、原地排序：指针i和j使用常数大小的额外空间</strong><br><br><strong>稳定排序：在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序</strong></p></blockquote><figure><img src="'+u+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 插入排序 */</span>
<span class="token keyword">void</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 外循环：已排序区间为 [0, i-1]</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> base <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">// 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> base<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token comment">// 将 nums[j] 向右移动一位</span>
            nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
            j<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 将 base 赋值到正确位置</span>
        nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> base<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_5-快速排序算法" tabindex="-1"><a class="header-anchor" href="#_5-快速排序算法"><span>5.快速排序算法</span></a></h2><p><strong>快速排序（quick sort）是一种基于分治策略的排序算法，运行高效，应用广泛</strong></p><p><strong>快速排序的核心操作是“哨兵划分”，其目标是：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。具体来说，哨兵划分的流程如下图所示</strong></p><ul><li><strong>选取数组最左端元素作为基准数，初始化两个指针i和j分别指向数组的两端</strong></li><li><strong>设置一个循环，在每轮中使用 i（j）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素</strong></li><li><strong>循环执行步骤2，直到 i 和 j 相遇时停止，最后将基准数交换至两个子数组的分界线</strong></li></ul><figure><img src="`+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+k+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>哨兵划分完成后，原数组被划分成三部分：左子数组、基准数、右子数组，且满足“左子数组任意元素 ≤ 基准数 ≤右子数组任意元素”。因此，我们接下来只需对这两个子数组进行排序</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 元素交换 */</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 快速排序类 */</span>
<span class="token comment">// 快速排序类-哨兵划分</span>
<span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 以 nums[left] 为基准数</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">,</span> j <span class="token operator">=</span> right<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token comment">// 从右向左找首个小于基准数的元素</span>
            j<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token comment">// 从左向右找首个大于基准数的元素</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 交换这两个元素</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将基准数交换至两子数组的分界线</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 返回基准数的索引</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_5-1-快速排序算法流程" tabindex="-1"><a class="header-anchor" href="#_5-1-快速排序算法流程"><span>5.1 快速排序算法流程</span></a></h3><p><strong>快速排序的整体流程如下图所示：</strong></p><ul><li><strong>首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组</strong></li><li><strong>然后，对左子数组和右子数组分别递归执行“哨兵划分”</strong></li><li><strong>持续递归，直至子数组长度为 1 时终止，从而完成整个数组的排序</strong></li></ul><blockquote><p><strong>时间复杂度为O(nlogn)、自适应排序：在平均情况下，哨兵划分的递归层数为logn，每层中的总循环数为n，总体使用O(nlogn)时间。在最差情况下，每轮哨兵划分操作都将长度为n的数组划分为长度为0和n-1的两个子数组，此时递归层数达到n，每层中的循环数为n，总体使用O(n^2)时间</strong><br><br><strong>空间复杂度为O(n)、原地排序：在输入数组完全倒序的情况下，达到最差递归深度n，使用O(n)栈帧空间。排序操作是在原数组上进行的，未借助额外数组</strong><br><br><strong>非稳定排序：在哨兵划分的最后一步，基准数可能会被交换至相等元素的右侧</strong></p></blockquote><figure><img src="`+d+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 快速排序类 */</span>
<span class="token comment">// 快速排序类-哨兵划分</span>
<span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 以 nums[left] 为基准数</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">,</span> j <span class="token operator">=</span> right<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token comment">// 从右向左找首个小于基准数的元素</span>
            j<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token comment">// 从左向右找首个大于基准数的元素</span>
            i<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 交换这两个元素</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将基准数交换至两子数组的分界线</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 返回基准数的索引</span>
    <span class="token keyword">return</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 快速排序类-快速排序</span>
<span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 子数组长度为 1 时终止递归</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 哨兵划分</span>
    <span class="token keyword">int</span> pivot <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 递归左子数组、右子数组</span>
    <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> pivot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> pivot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_5-2-快速排序为什么快" tabindex="-1"><a class="header-anchor" href="#_5-2-快速排序为什么快"><span>5.2 快速排序为什么快</span></a></h3><p><strong>从名称上就能看出，快速排序在效率方面应该具有一定的优势。尽管快速排序的平均时间复杂度与“归并排序”和“堆排序”相同，但通常快速排序的效率更高，主要有以下原因</strong></p><ul><li><strong>出现最差情况的概率很低：虽然快速排序的最差时间复杂度为O(n^2)，没有归并排序稳定，但在绝大多数情况下，快速排序能在O(nlogn)的时间复杂度下运行</strong></li><li><strong>缓存使用效率高：在执行哨兵划分操作时，系统可将整个子数组加载到缓存，因此访问元素的效率较高。而像“堆排序”这类算法需要跳跃式访问元素，从而缺乏这一特性</strong></li><li><strong>复杂度的常数系数小：在上述三种算法中，快速排序的比较、赋值、交换等操作的总数量最少。这与“插入排序”比“冒泡排序”更快的原因类似</strong></li></ul><hr><h2 id="_6-归并排序算法" tabindex="-1"><a class="header-anchor" href="#_6-归并排序算法"><span>6.归并排序算法</span></a></h2><p><strong>归并排序（merge sort）是一种基于分治策略的排序算法，包含图下图所示的“划分”和“合并”阶段</strong></p><ul><li><strong>划分阶段：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题</strong></li><li><strong>合并阶段：当子数组长度为 1 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束</strong></li></ul><figure><img src="`+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="_6-1-归并排序算法流程" tabindex="-1"><a class="header-anchor" href="#_6-1-归并排序算法流程"><span>6.1 归并排序算法流程</span></a></h3><p><strong>如下图所示，“划分阶段”从顶至底递归地将数组从中点切分为两个子数组：</strong></p><ul><li><strong>计算数组中点 mid ，递归划分左子数组（区间 [left, mid] ）和右子数组（区间 [mid + 1, right] ）</strong></li><li><strong>递归执行步骤 1 ，直至子数组区间长度为 1 时终止</strong></li></ul><blockquote><p><strong>时间复杂度为O(nlogn)、非自适应排序：划分产生高度为logn的递归树，每层合并的总操作数量为n，因此总体时间复杂度为O(nlogn)</strong><br><br><strong>空间复杂度为O(1)、非原地排序：递归深度为logn，使用O(logn)大小的栈帧空间。合并操作需要借助辅助数组实现，使用O(n) 大小的额外空间</strong><br><br><strong>稳定排序：在合并过程中，相等元素的次序保持不变</strong></p></blockquote><p><strong>“合并阶段”从底至顶地将左子数组和右子数组合并为一个有序数组。需要注意的是，从长度为 1 的子数组开始合并，合并阶段中的每个子数组都是有序的</strong></p><figure><img src="'+v+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>观察发现，归并排序与二叉树后序遍历的递归顺序是一致的</strong></p><ul><li><strong>后序遍历：先递归左子树，再递归右子树，最后处理根节点</strong></li><li><strong>归并排序：先递归左子数组，再递归右子数组，最后处理合并</strong></li></ul><p><strong>归并排序的实现如以下代码所示。请注意，nums 的待合并区间为 [left, right] ，而 tmp 的对应区间为 [0, right - left]</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 合并左子数组和右子数组 */</span>
<span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 左子数组区间为 [left, mid], 右子数组区间为 [mid+1, right]</span>
    <span class="token comment">// 创建一个临时数组 tmp ，用于存放合并后的结果</span>
    <span class="token keyword">int</span> tmpSize <span class="token operator">=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>tmp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>tmpSize <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 初始化左子数组和右子数组的起始索引</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">,</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// 当左右子数组都还有元素时，进行比较并将较小的元素复制到临时数组中</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> 
        <span class="token keyword">else</span> 
        <span class="token punctuation">{</span>
            tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将左子数组和右子数组的剩余元素复制到临时数组中</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> tmpSize<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        nums<span class="token punctuation">[</span>left <span class="token operator">+</span> k<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 释放内存</span>
    <span class="token function">free</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 归并排序 */</span>
<span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 终止条件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&gt;=</span> right<span class="token punctuation">)</span>
        <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 当子数组长度为 1 时终止递归</span>
    <span class="token comment">// 划分阶段</span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment">// 计算中点</span>
    <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 递归左子数组</span>
    <span class="token function">mergeSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归右子数组</span>
    <span class="token comment">// 合并阶段</span>
    <span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_7-堆排序算法" tabindex="-1"><a class="header-anchor" href="#_7-堆排序算法"><span>7.堆排序算法</span></a></h2><p><strong>堆排序（heap sort）是一种基于堆数据结构实现的高效排序算法。我们可以利用已经学过的“建堆操作”和“元素出堆操作”实现堆排序</strong></p><ul><li><strong>输入数组并建立小顶堆，此时最小元素位于堆顶</strong></li><li><strong>不断执行出堆操作，依次记录出堆元素，即可得到从小到大排序的序列</strong></li></ul><p><strong>以上方法虽然可行，但需要借助一个额外数组来保存弹出的元素，比较浪费空间。在实际中，我们通常使用一种更加优雅的实现方式</strong></p><hr><h3 id="_7-1-堆排序算法流程" tabindex="-1"><a class="header-anchor" href="#_7-1-堆排序算法流程"><span>7.1 堆排序算法流程</span></a></h3><p><strong>设数组的长度为n，堆排序的流程如下图所示：</strong></p><ul><li><strong>输入数组并建立大顶堆。完成后，最大元素位于堆顶</strong></li><li><strong>将堆顶元素（第一个元素）与堆底元素（最后一个元素）交换。完成交换后，堆的长度减1，已排序元素数量加1</strong></li><li><strong>从堆顶元素开始，从顶到底执行堆化操作（sift down）。完成堆化后，堆的性质得到修复</strong></li><li><strong>循环执行第 2 步和第 3 步。循环n-1轮后，即可完成数组排序</strong></li></ul><blockquote><p><strong>时间复杂度为O(nlogn)、非自适应排序：建堆操作使用O(n)时间。从堆中提取最大元素的时间复杂度为O(logn)，共循环n-1轮</strong><br><br><strong>空间复杂度为O(1)、原地排序：几个指针变量使用O(1)空间。元素交换和堆化操作都是在原数组上进行的</strong><br><br><strong>非稳定排序：在交换堆顶元素和堆底元素时，相等元素的相对位置可能发生变化</strong></p></blockquote><figure><img src="`+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+g+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>在代码实现中，我们使用了与“堆”章节相同的从顶至底堆化 sift_down() 函数。值得注意的是，由于堆的长度会随着提取最大元素而减小，因此我们需要给 sift_down() 函数添加一个长度参数n，用于指定堆的当前有效长度。代码如下所示：</strong></p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 堆的长度为 n ，从节点 i 开始，从顶至底堆化 */</span>
<span class="token keyword">void</span> <span class="token function">siftDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 判断节点 i, l, r 中值最大的节点，记为 ma</span>
        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> ma <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>ma<span class="token punctuation">]</span><span class="token punctuation">)</span>
            ma <span class="token operator">=</span> l<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&gt;</span> nums<span class="token punctuation">[</span>ma<span class="token punctuation">]</span><span class="token punctuation">)</span>
            ma <span class="token operator">=</span> r<span class="token punctuation">;</span>
        <span class="token comment">// 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ma <span class="token operator">==</span> i<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 交换两节点</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>ma<span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span>ma<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token comment">// 循环向下堆化</span>
        i <span class="token operator">=</span> ma<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 堆排序 */</span>
<span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 建堆操作：堆化除叶节点以外的其他所有节点</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token function">siftDown</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 从堆中提取最大元素，循环 n-1 轮</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 交换根节点与最右叶节点（交换首元素与尾元素）</span>
        <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        <span class="token comment">// 以根节点为起点，从顶至底进行堆化</span>
        <span class="token function">siftDown</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_8-桶排序算法" tabindex="-1"><a class="header-anchor" href="#_8-桶排序算法"><span>8.桶排序算法</span></a></h2><p><strong>前述几种排序算法都属于“基于比较的排序算法”，它们通过比较元素间的大小来实现排序。此类排序算法的时间复杂度无法超越O(nlogn)。接下来，我们将探讨几种“非比较排序算法”，它们的时间复杂度可以达到线性阶。</strong></p><p><strong>桶排序（bucket sort）是分治策略的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并</strong></p><hr><h3 id="_8-1-桶排序算法流程" tabindex="-1"><a class="header-anchor" href="#_8-1-桶排序算法流程"><span>8.1 桶排序算法流程</span></a></h3><p><strong>考虑一个长度为n的数组，其元素是范围[0，1)内的浮点数。桶排序的流程如下图：</strong></p><ul><li><strong>初始化k个桶，将n个元素分配到k个桶中</strong></li><li><strong>对每个桶分别执行排序（这里采用编程语言的内置排序函数）</strong></li><li><strong>按照桶从小到大的顺序合并结果</strong></li></ul><figure><img src="`+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+h+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 桶排序 */</span>
<span class="token keyword">void</span> <span class="token function">bucketSort</span><span class="token punctuation">(</span><span class="token keyword">float</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素</span>
    <span class="token keyword">int</span> k <span class="token operator">=</span> size <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> <span class="token operator">*</span><span class="token operator">*</span>buckets <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 每个桶最多可以分配 size 个元素</span>
        buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 1. 将数组元素分配到各个桶中</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 输入数据范围为 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]</span>
        <span class="token keyword">int</span> bucket_idx <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> k<span class="token punctuation">;</span>
        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果桶中有数据且数据小于当前值 nums[i], 要将其放到当前桶的后面，相当于 cpp 中的 push_back</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>bucket_idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> buckets<span class="token punctuation">[</span>bucket_idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">float</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span> buckets<span class="token punctuation">[</span>bucket_idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>temp<span class="token punctuation">,</span> <span class="token operator">&amp;</span>buckets<span class="token punctuation">[</span>bucket_idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            j<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        buckets<span class="token punctuation">[</span>bucket_idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 2. 对各个桶执行排序</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token function">qsort</span><span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">,</span> compare_float<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 3. 遍历桶合并结果</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> 
            <span class="token punctuation">{</span>
                nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> buckets<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 释放上述分配的内存</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token function">free</span><span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">free</span><span class="token punctuation">(</span>buckets<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_8-2-如何实现平均分配" tabindex="-1"><a class="header-anchor" href="#_8-2-如何实现平均分配"><span>8.2 如何实现平均分配</span></a></h3><p><strong>桶排序的时间复杂度理论上可以达到O(n)，关键在于将元素均匀分配到各个桶中，因为实际数据往往不是均匀分布的。例如，我们想要将淘宝上的所有商品按价格范围平均分配到 10 个桶中，但商品价格分布不均，低于 100 元的非常多，高于 1000 元的非常少。若将价格区间平均划分为 10 个，各个桶中的商品数量差距会非常大</strong></p><p><strong>为实现平均分配，我们可以先设定一条大致的分界线，将数据粗略地分到 3 个桶中。分配完毕后，再将商品较多的桶继续划分为 3 个桶，直至所有桶中的元素数量大致相等</strong></p><p><strong>如下图所示，这种方法本质上是创建一棵递归树，目标是让叶节点的值尽可能平均。当然，不一定要每轮将数据划分为 3 个桶，具体划分方式可根据数据特点灵活选择</strong></p><figure><img src="`+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>如果我们提前知道商品价格的概率分布，则可以根据数据概率分布设置每个桶的价格分界线。值得注意的是，数据分布并不一定需要特意统计，也可以根据数据特点采用某种概率模型进行近似</strong></p><p><strong>如下图所示，我们假设商品价格服从正态分布，这样就可以合理地设定价格区间，从而将商品平均分配到各个桶中</strong></p><figure><img src="'+w+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h2 id="_9-计数排序算法" tabindex="-1"><a class="header-anchor" href="#_9-计数排序算法"><span>9.计数排序算法</span></a></h2><p><strong>计数排序（counting sort）通过统计元素数量来实现排序，通常应用于整数数组</strong></p><hr><h3 id="_9-1-计数排序算法的简单实现" tabindex="-1"><a class="header-anchor" href="#_9-1-计数排序算法的简单实现"><span>9.1 计数排序算法的简单实现</span></a></h3><p><strong>先来看一个简单的例子。给定一个长度为n的数组 nums ，其中的元素都是“非负整数”，计数排序的整体流程如下图所示：</strong></p><ul><li><strong>遍历数组，找出其中的最大数字，记为m，然后创建一个长度为m+1的辅助数组 counter</strong></li><li><strong>借助 counter 统计 nums 中各数字的出现次数，其中 counter[num] 对应数字 num 的出现次数。统计方法很简单，只需遍历 nums（设当前数字为 num），每轮将 counter[num] 增加1即可</strong></li><li><strong>由于 counter 的各个索引天然有序，因此相当于所有数字已经排序好了。接下来，我们遍历 counter ，根据各数字出现次数从小到大的顺序填入 nums 即可</strong></li></ul><figure><img src="'+E+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 计数排序 */</span>
<span class="token comment">// 简单实现，无法用于排序对象</span>
<span class="token keyword">void</span> <span class="token function">countingSortNaive</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 1. 统计数组最大元素 m</span>
    <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> m<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            m <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 2. 统计各数字的出现次数</span>
    <span class="token comment">// counter[num] 代表 num 的出现次数</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>counter <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        counter<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 3. 遍历 counter ，将各元素填入原数组 nums</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> num <span class="token operator">&lt;</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> num<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> counter<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 4. 释放内存</span>
    <span class="token function">free</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_9-2-计数排序算法的完整实现" tabindex="-1"><a class="header-anchor" href="#_9-2-计数排序算法的完整实现"><span>9.2 计数排序算法的完整实现</span></a></h3><figure><img src="`+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+B+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 计数排序 */</span>
<span class="token comment">// 完整实现，可排序对象，并且是稳定排序</span>
<span class="token keyword">void</span> <span class="token function">countingSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 1. 统计数组最大元素 m</span>
    <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> m<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            m <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 2. 统计各数字的出现次数</span>
    <span class="token comment">// counter[num] 代表 num 的出现次数</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>counter <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        counter<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 3. 求 counter 的前缀和，将“出现次数”转换为“尾索引”</span>
    <span class="token comment">// 即 counter[num]-1 是 num 在 res 中最后一次出现的索引</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        counter<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 4. 倒序遍历 nums ，将各元素填入结果数组 res</span>
    <span class="token comment">// 初始化数组 res 用于记录结果</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>res <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> num <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        res<span class="token punctuation">[</span>counter<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span> <span class="token comment">// 将 num 放置到对应索引处</span>
        counter<span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>              <span class="token comment">// 令前缀和自减 1 ，得到下次放置 num 的索引</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 使用结果数组 res 覆盖原数组 nums</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> res<span class="token punctuation">,</span> size <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 5. 释放内存</span>
    <span class="token function">free</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_10-基数排序算法" tabindex="-1"><a class="header-anchor" href="#_10-基数排序算法"><span>10.基数排序算法</span></a></h2><p><strong>基数排序（radix sort）的核心思想与计数排序一致，也通过统计个数来实现排序。在此基础上，基数排序利用数字各位之间的递进关系，依次对每一位进行排序，从而得到最终的排序结果</strong></p><hr><h3 id="_10-1-基数排序算法流程" tabindex="-1"><a class="header-anchor" href="#_10-1-基数排序算法流程"><span>10.1 基数排序算法流程</span></a></h3><p><strong>以学号数据为例，假设数字的最低位是第1位，最高位是第8位，基数排序的流程如下所示：</strong></p><ul><li><strong>初始化位数k=1</strong></li><li><strong>对学号的第k位执行“计数排序”。完成后，数据会根据第k位从小到大排序</strong></li><li><strong>将k增加1，然后返回步骤 2 继续迭代，直到所有位都排序完成后结束</strong></li></ul><blockquote><p><strong>时间复杂度为O(nk)：设数据量为n、据为d进制、最大位数为k，则对某一位执行计数排序使用O(n+d)时间，排序所有k位使用O((n+d)k)时间。通常情况下，d和k都相对较小，时间复杂度趋向O(n)</strong><br><br><strong>空间复杂度为O(n+d)、非原地排序：与计数排序相同，基数排序需要借助长度为n和d的数组 res 和 counter</strong><br><br><strong>稳定排序：当计数排序稳定时，基数排序也稳定；当计数排序不稳定时，基数排序无法保证得到正确的排序结果</strong></p></blockquote><figure><img src="`+x+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token comment">/* 获取元素 num 的第 k 位，其中 exp = 10^(k-1) */</span>
<span class="token keyword">int</span> <span class="token function">digit</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> exp<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>num <span class="token operator">/</span> exp<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 计数排序（根据 nums 第 k 位排序） */</span>
<span class="token keyword">void</span> <span class="token function">countingSortDigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> exp<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 十进制的位范围为 0~9 ，因此需要长度为 10 的桶数组</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>counter <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 统计 0~9 各数字的出现次数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// 获取 nums[i] 第 k 位，记为 d</span>
        <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token function">digit</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> exp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 统计数字 d 的出现次数</span>
        counter<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 求前缀和，将“出现个数”转换为“数组索引”</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        counter<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> counter<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 倒序遍历，根据桶内统计结果，将各元素填入 res</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">*</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token function">digit</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> exp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> j <span class="token operator">=</span> counter<span class="token punctuation">[</span>d<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 获取 d 在数组中的索引 j</span>
        res<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment">// 将当前元素填入索引 j</span>
        counter<span class="token punctuation">[</span>d<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>           <span class="token comment">// 将 d 的数量减 1</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 使用结果覆盖原数组 nums</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 基数排序 */</span>
<span class="token keyword">void</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// 获取数组的最大元素，用于判断最大位数</span>
    <span class="token keyword">int</span> max <span class="token operator">=</span> INT32_MIN<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> max<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            max <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 按照从低位到高位的顺序遍历</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> exp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> max <span class="token operator">&gt;=</span> exp<span class="token punctuation">;</span> exp <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">)</span>
        <span class="token comment">// 对数组元素的第 k 位执行计数排序</span>
        <span class="token comment">// k = 1 -&gt; exp = 1</span>
        <span class="token comment">// k = 2 -&gt; exp = 10</span>
        <span class="token comment">// 即 exp = 10^(k-1)</span>
        <span class="token function">countingSortDigit</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> size<span class="token punctuation">,</span> exp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,154),z=[j];function O(F,D){return s(),a("div",null,z)}const C=n(A,[["render",O],["__file","11.排序.html.vue"]]),I=JSON.parse('{"path":"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/11.%E6%8E%92%E5%BA%8F.html","title":"第十一章：排序","lang":"zh-CN","frontmatter":{"date":"2024-03-11T00:00:00.000Z","order":11,"description":"第十一章：排序 1.排序算法概念 排序算法（sorting algorithm）用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理 如下图所示，排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则 1.1 排序算法评...","head":[["meta",{"property":"og:url","content":"https://github.com/jimbo-master/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/1.%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/11.%E6%8E%92%E5%BA%8F.html"}],["meta",{"property":"og:site_name","content":"JimBoの学习妙妙屋"}],["meta",{"property":"og:title","content":"第十一章：排序"}],["meta",{"property":"og:description","content":"第十一章：排序 1.排序算法概念 排序算法（sorting algorithm）用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理 如下图所示，排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则 1.1 排序算法评..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"JimBo"}],["meta",{"property":"article:published_time","content":"2024-03-11T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第十一章：排序\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-11T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"JimBo\\",\\"url\\":\\"https://github.com/jimbo-master\\"}]}"]]},"headers":[{"level":2,"title":"1.排序算法概念","slug":"_1-排序算法概念","link":"#_1-排序算法概念","children":[{"level":3,"title":"1.1 排序算法评价维度","slug":"_1-1-排序算法评价维度","link":"#_1-1-排序算法评价维度","children":[]},{"level":3,"title":"1.2 理想的排序算法","slug":"_1-2-理想的排序算法","link":"#_1-2-理想的排序算法","children":[]}]},{"level":2,"title":"2.选择排序算法","slug":"_2-选择排序算法","link":"#_2-选择排序算法","children":[{"level":3,"title":"2.1 选择排序原理","slug":"_2-1-选择排序原理","link":"#_2-1-选择排序原理","children":[]}]},{"level":2,"title":"3.冒泡排序算法","slug":"_3-冒泡排序算法","link":"#_3-冒泡排序算法","children":[{"level":3,"title":"3.1 冒牌排序算法流程","slug":"_3-1-冒牌排序算法流程","link":"#_3-1-冒牌排序算法流程","children":[]},{"level":3,"title":"3.2 冒泡排序效率优化","slug":"_3-2-冒泡排序效率优化","link":"#_3-2-冒泡排序效率优化","children":[]}]},{"level":2,"title":"4.插入排序算法","slug":"_4-插入排序算法","link":"#_4-插入排序算法","children":[{"level":3,"title":"4.1 插入排序算法流程","slug":"_4-1-插入排序算法流程","link":"#_4-1-插入排序算法流程","children":[]}]},{"level":2,"title":"5.快速排序算法","slug":"_5-快速排序算法","link":"#_5-快速排序算法","children":[{"level":3,"title":"5.1 快速排序算法流程","slug":"_5-1-快速排序算法流程","link":"#_5-1-快速排序算法流程","children":[]},{"level":3,"title":"5.2 快速排序为什么快","slug":"_5-2-快速排序为什么快","link":"#_5-2-快速排序为什么快","children":[]}]},{"level":2,"title":"6.归并排序算法","slug":"_6-归并排序算法","link":"#_6-归并排序算法","children":[{"level":3,"title":"6.1 归并排序算法流程","slug":"_6-1-归并排序算法流程","link":"#_6-1-归并排序算法流程","children":[]}]},{"level":2,"title":"7.堆排序算法","slug":"_7-堆排序算法","link":"#_7-堆排序算法","children":[{"level":3,"title":"7.1 堆排序算法流程","slug":"_7-1-堆排序算法流程","link":"#_7-1-堆排序算法流程","children":[]}]},{"level":2,"title":"8.桶排序算法","slug":"_8-桶排序算法","link":"#_8-桶排序算法","children":[{"level":3,"title":"8.1 桶排序算法流程","slug":"_8-1-桶排序算法流程","link":"#_8-1-桶排序算法流程","children":[]},{"level":3,"title":"8.2 如何实现平均分配","slug":"_8-2-如何实现平均分配","link":"#_8-2-如何实现平均分配","children":[]}]},{"level":2,"title":"9.计数排序算法","slug":"_9-计数排序算法","link":"#_9-计数排序算法","children":[{"level":3,"title":"9.1 计数排序算法的简单实现","slug":"_9-1-计数排序算法的简单实现","link":"#_9-1-计数排序算法的简单实现","children":[]},{"level":3,"title":"9.2 计数排序算法的完整实现","slug":"_9-2-计数排序算法的完整实现","link":"#_9-2-计数排序算法的完整实现","children":[]}]},{"level":2,"title":"10.基数排序算法","slug":"_10-基数排序算法","link":"#_10-基数排序算法","children":[{"level":3,"title":"10.1 基数排序算法流程","slug":"_10-1-基数排序算法流程","link":"#_10-1-基数排序算法流程","children":[]}]}],"git":{},"readingTime":{"minutes":26.64,"words":7991},"filePathRelative":"算法学习/1.算法知识/11.排序.md","localizedDate":"2024年3月11日","autoDesc":true,"excerpt":"\\n<h2>1.排序算法概念</h2>\\n<p><strong>排序算法（sorting algorithm）用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理</strong></p>\\n<p><strong>如下图所示，排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则</strong></p>\\n<figure><figcaption></figcaption></figure>\\n<hr>\\n<h3>1.1 排序算法评价维度</h3>\\n<p><strong>（1）运行效率：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要</strong></p>"}');export{C as comp,I as data};
