const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:n})=>n),bt=et(V(JSON.parse("{\"/\":{\"documentCount\":537,\"nextId\":537,\"documentIds\":{\"0\":\"0\",\"1\":\"1\",\"2\":\"2\",\"3\":\"3\",\"4\":\"4\",\"5\":\"5\",\"6\":\"6\",\"7\":\"7\",\"8\":\"8\",\"9\":\"9\",\"10\":\"10\",\"11\":\"11\",\"12\":\"12\",\"13\":\"13\",\"14\":\"13#_1-逻辑结构-线性与非线性\",\"15\":\"13#_2-存储结构-连续与分散\",\"16\":\"13#_3-基本数据类型\",\"17\":\"13#_4-数字编码\",\"18\":\"13#_5-字符编码\",\"19\":\"14\",\"20\":\"14#_1-二分查找\",\"21\":\"14#_2-二分查找的区间表示方法\",\"22\":\"14#_3-二分查找插入点\",\"23\":\"14#_3-1-无重复元素的情况\",\"24\":\"14#_3-2-存在重复元素情况\",\"25\":\"14#_4-二分查找边界\",\"26\":\"14#_4-1-查找左边界\",\"27\":\"14#_4-2-查找右边界\",\"28\":\"14#_5-哈希优化策略\",\"29\":\"14#_5-1-线性查找-以时间换空间\",\"30\":\"14#_5-2-哈希查找-以空间换时间\",\"31\":\"15\",\"32\":\"15#_1-排序算法概念\",\"33\":\"15#_1-1-排序算法评价维度\",\"34\":\"15#_1-2-理想的排序算法\",\"35\":\"15#_2-选择排序算法\",\"36\":\"15#_2-1-选择排序原理\",\"37\":\"15#_3-冒泡排序算法\",\"38\":\"15#_3-1-冒牌排序算法流程\",\"39\":\"15#_3-2-冒泡排序效率优化\",\"40\":\"15#_4-插入排序算法\",\"41\":\"15#_4-1-插入排序算法流程\",\"42\":\"15#_5-快速排序算法\",\"43\":\"15#_5-1-快速排序算法流程\",\"44\":\"15#_5-2-快速排序为什么快\",\"45\":\"15#_6-归并排序算法\",\"46\":\"15#_6-1-归并排序算法流程\",\"47\":\"15#_7-堆排序算法\",\"48\":\"15#_7-1-堆排序算法流程\",\"49\":\"15#_8-桶排序算法\",\"50\":\"15#_8-1-桶排序算法流程\",\"51\":\"15#_8-2-如何实现平均分配\",\"52\":\"15#_9-计数排序算法\",\"53\":\"15#_9-1-计数排序算法的简单实现\",\"54\":\"15#_9-2-计数排序算法的完整实现\",\"55\":\"15#_10-基数排序算法\",\"56\":\"15#_10-1-基数排序算法流程\",\"57\":\"16\",\"58\":\"16#_1-分治基本概念\",\"59\":\"16#_2-如何判断分治问题\",\"60\":\"16#_3-通过分治提高效率\",\"61\":\"16#_3-1-操作数量优化\",\"62\":\"16#_3-2-并行计算优化\",\"63\":\"16#_4-分治的常见应用\",\"64\":\"16#_5-分治搜索策略\",\"65\":\"16#_6-构建树问题\",\"66\":\"16#_6-1-判断是否为分治问题\",\"67\":\"16#_6-2-如何划分子树\",\"68\":\"16#_6-3-基于变量描述子树区间\",\"69\":\"16#_6-4-构建树问题代码实现\",\"70\":\"16#_7-汉诺塔问题\",\"71\":\"16#_7-1-考虑基本情况\",\"72\":\"16#_7-2-子问题分解\",\"73\":\"16#_7-3-汉诺塔问题代码实现\",\"74\":\"17\",\"75\":\"17#_1-尝试与回退\",\"76\":\"17#_2-剪枝\",\"77\":\"17#_3-框架代码\",\"78\":\"17#_4-优点与缺点\",\"79\":\"17#_5-回溯算法经典例题\",\"80\":\"17#_6-全排列问题\",\"81\":\"17#_6-1-无相等元素的情况\",\"82\":\"17#_6-2-考虑相等元素情况\",\"83\":\"17#_6-3-两种剪枝对比\",\"84\":\"17#_7-子集和问题\",\"85\":\"17#_7-1-无重复元素的情况\",\"86\":\"17#_7-2-考虑重复元素情况\",\"87\":\"17#_8-n皇后问题\",\"88\":\"17#_8-1-逐行放置策略\",\"89\":\"17#_8-2-列与对角线剪枝\",\"90\":\"17#_8-3-代码实现\",\"91\":\"18\",\"92\":\"18#_1-动态规划问题探索\",\"93\":\"18#_1-1-方法一-暴力搜索\",\"94\":\"18#_1-2-方法二-记忆化搜索\",\"95\":\"18#_1-3-方法三-动态规划\",\"96\":\"18#_1-4-空间优化\",\"97\":\"18#_2-dp问题特性\",\"98\":\"18#_2-1-最优子结构\",\"99\":\"18#_2-2-无后效性\",\"100\":\"18#_3-dp解题思路\",\"101\":\"18#_3-1-问题判断\",\"102\":\"18#_3-2-问题求解步骤\",\"103\":\"18#_3-3-方法一-暴力搜索\",\"104\":\"18#_3-4-方法二-记忆化搜索\",\"105\":\"18#_3-5-方法三-动态规划\",\"106\":\"18#_3-6-空间优化\",\"107\":\"18#_4-0-1背包问题\",\"108\":\"18#_4-1-方法一-暴力搜索\",\"109\":\"18#_4-2-方法二-记忆化搜索\",\"110\":\"18#_4-3-方法三-动态规划\",\"111\":\"18#_4-4-空间优化\",\"112\":\"19\",\"113\":\"19#_1-贪心算法\",\"114\":\"19#_2-贪心算法的优点与缺点\",\"115\":\"19#_3-贪心算法特征\",\"116\":\"19#_4-贪心算法解题步骤\",\"117\":\"19#_5-贪心算法经典问题\",\"118\":\"19#_6-分数背包问题\",\"119\":\"19#_6-1-贪心策略确定\",\"120\":\"19#_6-2-代码实现\",\"121\":\"19#_6-3-正确性证明\",\"122\":\"19#_7-最大容量问题\",\"123\":\"19#_7-1-贪心策略确定\",\"124\":\"19#_7-2-代码实现\",\"125\":\"19#_7-3-正确性证明\",\"126\":\"19#_8-最大切分乘积问题\",\"127\":\"19#_8-1-贪心策略确定\",\"128\":\"19#_8-2-代码实现\",\"129\":\"19#_8-3-正确性证明\",\"130\":\"20\",\"131\":\"20#_1-算法的定义\",\"132\":\"20#_2-数据结构定义\",\"133\":\"20#_3-数据结构与算法的关系\",\"134\":\"21\",\"135\":\"21#_1-算法效率评估\",\"136\":\"21#_2-迭代与递归\",\"137\":\"22\",\"138\":\"22#_1-数组\",\"139\":\"22#_1-1-初始化数组\",\"140\":\"22#_1-2-访问元素\",\"141\":\"22#_1-3-插入元素\",\"142\":\"22#_1-4-删除元素\",\"143\":\"22#_1-5-遍历数组\",\"144\":\"22#_1-6-查找元素\",\"145\":\"22#_1-7-扩容数组\",\"146\":\"22#_2-链表\",\"147\":\"22#_2-1-初始化链表\",\"148\":\"22#_2-2-插入结点\",\"149\":\"22#_2-3-删除结点\",\"150\":\"22#_2-4-访问结点\",\"151\":\"22#_2-5-查找结点\",\"152\":\"22#_3-数组与链表的对比\",\"153\":\"22#_4-常见链表类型\",\"154\":\"23\",\"155\":\"23#_1-栈\",\"156\":\"23#_1-1-栈的链式实现\",\"157\":\"23#_1-2-栈的顺序实现\",\"158\":\"23#_1-3-栈的两种实现对比\",\"159\":\"23#_2-队列\",\"160\":\"23#_2-1-队列的链式实现\",\"161\":\"23#_2-2-队列的顺序实现\",\"162\":\"23#_3-双向队列\",\"163\":\"23#_3-1-双向队列的链式实现\",\"164\":\"23#_3-2-双向队列的顺序实现\",\"165\":\"24\",\"166\":\"24#_1-哈希表\",\"167\":\"24#_1-1-哈希表的简单实现\",\"168\":\"24#_1-2-哈希冲突与扩容\",\"169\":\"24#_2-哈希冲突\",\"170\":\"24#_2-1-链式地址\",\"171\":\"24#_2-2-开放寻址\",\"172\":\"24#_2-2-1-线性探测\",\"173\":\"24#_2-2-2-平方探测\",\"174\":\"24#_2-2-3-多次哈希\",\"175\":\"24#_3-哈希算法\",\"176\":\"24#_3-1-哈希算法的目标\",\"177\":\"24#_3-2-哈希算法的设计\",\"178\":\"24#_3-3-常见哈希算法\",\"179\":\"25\",\"180\":\"25#_1-二叉树的基本概念\",\"181\":\"25#_1-1-二叉树常见术语\",\"182\":\"25#_1-2-二叉树基本操作\",\"183\":\"25#_1-3-常见二叉树类型\",\"184\":\"25#_1-4-二叉树的退化\",\"185\":\"25#_2-二叉树的遍历\",\"186\":\"25#_2-1-层序遍历\",\"187\":\"25#_2-2-前序、中序、后序遍历\",\"188\":\"25#_3-二叉树的数组表示\",\"189\":\"25#_3-1-表示满二叉树\",\"190\":\"25#_3-2-表示任意二叉树\",\"191\":\"25#_3-3-优点与缺点\",\"192\":\"25#_4-二叉搜索树-bst树\",\"193\":\"25#_4-1-查找结点\",\"194\":\"25#_4-2-插入结点\",\"195\":\"25#_4-3-删除结点\",\"196\":\"25#_4-4-中序遍历有序\",\"197\":\"25#_4-5-二叉搜索树的效率\",\"198\":\"25#_5-平衡二叉树-avl树\",\"199\":\"25#_5-1-avl树的常见术语\",\"200\":\"25#_5-2-avl树的旋转\",\"201\":\"25#_5-2-1-右旋\",\"202\":\"25#_5-2-2-左旋\",\"203\":\"25#_5-2-3-先左旋再右旋\",\"204\":\"25#_5-2-4-先右旋再左旋\",\"205\":\"25#_5-2-5-旋转的选择\",\"206\":\"25#_5-3-avl树插入节点\",\"207\":\"25#_5-4-avl树删除节点\",\"208\":\"26\",\"209\":\"26#_1-堆的存储与表示\",\"210\":\"26#_2-访问堆顶元素\",\"211\":\"26#_3-元素入堆\",\"212\":\"26#_4-堆顶元素出堆\",\"213\":\"27\",\"214\":\"27#_1-图的常见类型与术语\",\"215\":\"27#_2-图的表示\",\"216\":\"27#_2-1-邻接矩阵\",\"217\":\"27#_2-2-邻接表\",\"218\":\"27#_3-图基于邻接矩阵的实现\",\"219\":\"27#_4-图基于邻接表的实现\",\"220\":\"27#_5-邻接矩阵与邻接表的效率对比\",\"221\":\"27#_6-图的遍历\",\"222\":\"27#_6-1-广度优先遍历-bfs\",\"223\":\"27#_6-2-bfs的算法实现\",\"224\":\"27#_6-3-深度优先遍历-dfs\",\"225\":\"27#_6-4-dfs的算法实现\",\"226\":\"28\",\"227\":\"28#_1-分支与循环语句\",\"228\":\"28#_2-函数\",\"229\":\"28#_3-数组\",\"230\":\"28#_4-操作符\",\"231\":\"28#_5-指针\",\"232\":\"28#_6-字符与字符串\",\"233\":\"28#_7-结构体、枚举、联合体、位段\",\"234\":\"28#_8-数据存储\",\"235\":\"28#_9-动态内存分配\",\"236\":\"28#_10-文件\",\"237\":\"28#_11-程序的编译、链接、预处理\",\"238\":\"29\",\"239\":\"29#_1-什么是程序\",\"240\":\"29#_2-计算机语言简史\",\"241\":\"29#_3-c语言的发行版本\",\"242\":\"30\",\"243\":\"30#_1-数组的概念\",\"244\":\"30#_2-数组的操作\",\"245\":\"30#_3-字符数组-字符串\",\"246\":\"30#_4-多维数组\",\"247\":\"31\",\"248\":\"31#_1-变量\",\"249\":\"31#_1-1-变量的概念\",\"250\":\"31#_1-2-变量的声明和使用\",\"251\":\"31#_1-3-输出变量\",\"252\":\"31#_1-4-输入赋值变量\",\"253\":\"31#_2-常量\",\"254\":\"31#_2-1-常量的分类\",\"255\":\"31#_2-2-常量的定义\",\"256\":\"31#_3-标识符\",\"257\":\"31#_3-1-标识符命名规范\",\"258\":\"31#_3-2-规范命名风格\",\"259\":\"31#_3-3-关键字\",\"260\":\"32\",\"261\":\"32#_1-指针的理解\",\"262\":\"32#_2-指针的运算\",\"263\":\"32#_3-指针和数组\",\"264\":\"32#_4-指针和函数\",\"265\":\"32#_5-多级指针-指向指针的指针\",\"266\":\"32#_7-空指针\",\"267\":\"32#_8-野指针\",\"268\":\"32#_9-指针的描述\",\"269\":\"33\",\"270\":\"33#_1-开发工具选择\",\"271\":\"33#_2-c程序执行流程\",\"272\":\"33#_3-c语言开发注意事项\",\"273\":\"33#_4-c语言注释\",\"274\":\"34\",\"275\":\"34#_1-运算符基础\",\"276\":\"34#_2-算术运算符\",\"277\":\"34#_3-关系运算符\",\"278\":\"34#_4-逻辑运算符\",\"279\":\"34#_5-赋值运算符\",\"280\":\"34#_6-位运算符\",\"281\":\"34#_7-三目运算符\",\"282\":\"34#_8-逗号表达式\",\"283\":\"34#_9-运算符优先级\",\"284\":\"35\",\"285\":\"35#_1-函数基本概念\",\"286\":\"35#_2-函数基本语法\",\"287\":\"35#_3-主函数与函数原型\",\"288\":\"35#_4-函数作用域\",\"289\":\"35#_5-static关键字\",\"290\":\"35#_6-递归函数\",\"291\":\"35#_7-常用系统函数\",\"292\":\"35#_8-常用字符串函数\",\"293\":\"35#_9-常用字符函数\",\"294\":\"35#_10-常用内存操作函数\",\"295\":\"36\",\"296\":\"36#_1-顺序控制语句\",\"297\":\"36#_2-分支控制语句\",\"298\":\"36#_3-循环控制语句\",\"299\":\"36#_4-跳转控制语句\",\"300\":\"37\",\"301\":\"37#_1-枚举\",\"302\":\"37#_2-结构体\",\"303\":\"37#_3-共用体\",\"304\":\"37#_4-typedef\",\"305\":\"37#_5-位段\",\"306\":\"37#_6-内存对齐规则\",\"307\":\"38\",\"308\":\"38#_1-文件基本介绍\",\"309\":\"38#_2-c语言的输入与输出\",\"310\":\"38#_3-c语言的文件读写\",\"311\":\"39\",\"312\":\"39#_1-c程序动态内存分配\",\"313\":\"39#_2-void指针-无类型指针\",\"314\":\"39#_3-内存分配相关函数\",\"315\":\"39#_4-内存分配基本原则\",\"316\":\"40\",\"317\":\"40#_1-预处理器基本介绍\",\"318\":\"40#_2-宏定义\",\"319\":\"40#_3-带参数的宏定义\",\"320\":\"40#_4-文件包含\",\"321\":\"40#_5-条件编译\",\"322\":\"40#_6-预处理命令总结\",\"323\":\"41\",\"324\":\"41#_1-二进制\",\"325\":\"41#_1-1-进制\",\"326\":\"41#_1-2-进制的转换\",\"327\":\"41#_1-3-原码、补码、反码\",\"328\":\"41#_1-4-计算机为什么要用补码\",\"329\":\"41#_2-数据类型\",\"330\":\"41#_2-1-整形类型\",\"331\":\"41#_2-2-浮点类型\",\"332\":\"41#_2-3-字符类型\",\"333\":\"41#_2-4-布尔类型\",\"334\":\"41#_2-5-存储类别说明符\",\"335\":\"41#_3-获取数据的存储大小\",\"336\":\"41#_4-数据类型转换\",\"337\":\"41#_4-1-隐式类型转换\",\"338\":\"41#_4-2-显示类型转换\",\"339\":\"41#_5-大小端存储\",\"340\":\"42\",\"341\":\"42#_1-项目效果\",\"342\":\"42#_2-项目要求\",\"343\":\"42#_3-项目代码\",\"344\":\"42#_3-1-contact-h头文件\",\"345\":\"42#_3-2-main-c源文件\",\"346\":\"43\",\"347\":\"43#知识点思维导图\",\"348\":\"43#复习代码\",\"349\":\"44\",\"350\":\"44#知识点思维导图\",\"351\":\"44#复习代码\",\"352\":\"45\",\"353\":\"45#知识点思维导图\",\"354\":\"45#复习代码\",\"355\":\"46\",\"356\":\"46#知识点思维导图\",\"357\":\"46#复习代码\",\"358\":\"47\",\"359\":\"48\",\"360\":\"48#知识点思维导图\",\"361\":\"48#复习代码\",\"362\":\"49\",\"363\":\"49#知识点思维导图\",\"364\":\"49#复习代码\",\"365\":\"50\",\"366\":\"50#知识点思维导图\",\"367\":\"50#复习代码\",\"368\":\"51\",\"369\":\"51#知识点思维导图\",\"370\":\"51#复习代码\",\"371\":\"52\",\"372\":\"52#知识点思维导图\",\"373\":\"52#复习代码\",\"374\":\"53\",\"375\":\"53#知识点思维导图\",\"376\":\"53#复习代码\",\"377\":\"54\",\"378\":\"54#知识点思维导图\",\"379\":\"54#复习代码\",\"380\":\"55\",\"381\":\"55#知识点思维导图\",\"382\":\"55#复习代码\",\"383\":\"56\",\"384\":\"56#知识点思维导图\",\"385\":\"57\",\"386\":\"57#_1-知识点思维导图\",\"387\":\"57#_2-poll服务器代码\",\"388\":\"57#_2-1-pollserver类\",\"389\":\"57#_2-2-运行服务器\",\"390\":\"57#_2-3-事件处理\",\"391\":\"57#_2-4-poll服务器测试\",\"392\":\"58\",\"393\":\"58#_1-知识点思维导图\",\"394\":\"58#_2-epoll服务器代码\",\"395\":\"58#_2-1-epollserver类\",\"396\":\"58#_2-2-运行服务器\",\"397\":\"58#_2-3-事件处理\",\"398\":\"58#_2-4-epoll服务器测试\",\"399\":\"59\",\"400\":\"59#知识点思维导图\",\"401\":\"60\",\"402\":\"60#_1-知识点思维导图\",\"403\":\"60#_2-用命名管道实现server-client通信\",\"404\":\"60#_3-用命名管道实现派发计算任务\",\"405\":\"60#_4-用命名管道实现进程遥控\",\"406\":\"60#_5-用命名管道实现文件拷贝\",\"407\":\"61\",\"408\":\"61#知识点思维导图\",\"409\":\"62\",\"410\":\"62#知识点思维导图\",\"411\":\"63\",\"412\":\"63#知识点思维导图\",\"413\":\"64\",\"414\":\"64#知识点思维导图\",\"415\":\"65\",\"416\":\"65#知识点思维导图\",\"417\":\"66\",\"418\":\"66#知识点思维导图\",\"419\":\"67\",\"420\":\"67#知识点思维导图\",\"421\":\"68\",\"422\":\"68#知识点思维导图\",\"423\":\"69\",\"424\":\"69#知识点思维导图\",\"425\":\"70\",\"426\":\"70#知识点思维导图\",\"427\":\"71\",\"428\":\"71#知识点思维导图\",\"429\":\"72\",\"430\":\"72#知识点思维导图\",\"431\":\"73\",\"432\":\"73#知识点思维导图\",\"433\":\"74\",\"434\":\"74#_1-知识点思维导图\",\"435\":\"74#_2-select服务器代码\",\"436\":\"74#_2-1-select服务器的socket类\",\"437\":\"74#_2-2-select服务器的selectserver类\",\"438\":\"74#_2-3-select服务器的运行\",\"439\":\"74#_2-4-timeout测试\",\"440\":\"74#_2-5-select服务器事件处理\",\"441\":\"74#_3-select服务器测试\",\"442\":\"74#_4-select服务器存在的问题\",\"443\":\"75\",\"444\":\"75#_1-绪论\",\"445\":\"76\",\"446\":\"76#_1-线性表\",\"447\":\"76#_2-线性表的链式表示\",\"448\":\"77\",\"449\":\"77#_1-栈\",\"450\":\"77#_2-队列\",\"451\":\"78\",\"452\":\"78#_1-串、数组和特殊矩阵\",\"453\":\"79\",\"454\":\"79#_1-树与二叉树\",\"455\":\"79#_2-二叉树的遍历-递归方式\",\"456\":\"79#_3-二叉树的遍历-非递归方式\",\"457\":\"79#_4-线索二叉树\",\"458\":\"79#_5-树和森林\",\"459\":\"79#_6-树与二叉树的应用\",\"460\":\"80\",\"461\":\"80#_1-图的定义\",\"462\":\"80#_2-图的存储与基本操作\",\"463\":\"80#_3-图的遍历\",\"464\":\"80#_4-图的应用\",\"465\":\"80#_5-拓扑排序\",\"466\":\"80#_6-关键路径\",\"467\":\"81\",\"468\":\"81#_1-查找\",\"469\":\"81#_2-b树和b-树\",\"470\":\"81#_3-散列表\",\"471\":\"82\",\"472\":\"82#_1-插入排序\",\"473\":\"82#_2-交换排序\",\"474\":\"82#_3-选择排序\",\"475\":\"82#_4-排序算法总结\",\"476\":\"82#_5-外部排序算法\",\"477\":\"83\",\"478\":\"83#_1-计算机系统概述\",\"479\":\"83#_2-计算机的性能指标\",\"480\":\"84\",\"481\":\"84#_1-数据的表示和运算\",\"482\":\"85\",\"483\":\"85#_1-存储系统\",\"484\":\"85#_2-虚拟存储器\",\"485\":\"86\",\"486\":\"86#_1-指令系统\",\"487\":\"87\",\"488\":\"87#_1-中央处理器\",\"489\":\"88\",\"490\":\"88#_1-总线\",\"491\":\"89\",\"492\":\"89#_1-输入-输出系统\",\"493\":\"90\",\"494\":\"90#_1-操作系统概述\",\"495\":\"90#_2-系统调用\",\"496\":\"90#_3-中断和异常\",\"497\":\"91\",\"498\":\"91#_1-进程管理\",\"499\":\"91#_2-线程管理\",\"500\":\"91#_3-处理机调度\",\"501\":\"91#_4-进程同步\",\"502\":\"91#_5-死锁\",\"503\":\"92\",\"504\":\"92#_1-内存管理\",\"505\":\"93\",\"506\":\"93#_1-文件管理\",\"507\":\"94\",\"508\":\"94#_1-i-o管理\",\"509\":\"95\",\"510\":\"95#_1-计算机网络体系结构\",\"511\":\"95#_2-osi参考模型\",\"512\":\"96\",\"513\":\"96#_1-物理层\",\"514\":\"97\",\"515\":\"97#_1-数据链路层\",\"516\":\"98\",\"517\":\"98#_1-网络层\",\"518\":\"99\",\"519\":\"99#_1-传输层\",\"520\":\"100\",\"521\":\"100#_1-应用层\",\"522\":\"101\",\"523\":\"101#_1-网络安全\",\"524\":\"102\",\"525\":\"103\",\"526\":\"104\",\"527\":\"105\",\"528\":\"106\",\"529\":\"107\",\"530\":\"108\",\"531\":\"109\",\"532\":\"110\",\"533\":\"111\",\"534\":\"112\",\"535\":\"113\",\"536\":\"114\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[2],\"2\":[2],\"3\":[2],\"4\":[2],\"5\":[2],\"6\":[2],\"7\":[2],\"8\":[2],\"9\":[2],\"10\":[2],\"11\":[2],\"12\":[2],\"13\":[2,13],\"14\":[3,23],\"15\":[3,63],\"16\":[2,47],\"17\":[2,25],\"18\":[2,224],\"19\":[2],\"20\":[2,86],\"21\":[2,56],\"22\":[2,3],\"23\":[3,32],\"24\":[3,46],\"25\":[2],\"26\":[3,37],\"27\":[3,66],\"28\":[2,2],\"29\":[4,37],\"30\":[4,72],\"31\":[2],\"32\":[2,16],\"33\":[2,71],\"34\":[3,10],\"35\":[2],\"36\":[3,74],\"37\":[2,36],\"38\":[3,44],\"39\":[3,46],\"40\":[2,16],\"41\":[3,64],\"42\":[2,65],\"43\":[3,71],\"44\":[3,34],\"45\":[2,19],\"46\":[3,102],\"47\":[2,19],\"48\":[3,102],\"49\":[2,19],\"50\":[3,65],\"51\":[3,40],\"52\":[2,5],\"53\":[3,65],\"54\":[3,61],\"55\":[2,9],\"56\":[3,112],\"57\":[2],\"58\":[2,19],\"59\":[2,25],\"60\":[2,19],\"61\":[3,19],\"62\":[3,16],\"63\":[2,70],\"64\":[2,86],\"65\":[2,10],\"66\":[3,31],\"67\":[3,37],\"68\":[3,27],\"69\":[3,79],\"70\":[2,29],\"71\":[3,19],\"72\":[3,49],\"73\":[3,56],\"74\":[2,49],\"75\":[2,72],\"76\":[2,54],\"77\":[2,93],\"78\":[2,31],\"79\":[2,58],\"80\":[2,7],\"81\":[3,118],\"82\":[3,109],\"83\":[3,28],\"84\":[2],\"85\":[3,172],\"86\":[3,121],\"87\":[2,25],\"88\":[3,15],\"89\":[3,32],\"90\":[3,100],\"91\":[2],\"92\":[2,77],\"93\":[3,51],\"94\":[4,55],\"95\":[4,77],\"96\":[3,47],\"97\":[2,23],\"98\":[3,64],\"99\":[2,69],\"100\":[2],\"101\":[3,43],\"102\":[3,54],\"103\":[3,52],\"104\":[4,45],\"105\":[4,43],\"106\":[3,42],\"107\":[3,31],\"108\":[4,50],\"109\":[4,45],\"110\":[4,46],\"111\":[2,64],\"112\":[2],\"113\":[2,62],\"114\":[2,16],\"115\":[2],\"116\":[2],\"117\":[2,37],\"118\":[2,31],\"119\":[3,8],\"120\":[3,64],\"121\":[3],\"122\":[2,20],\"123\":[3,43],\"124\":[3,35],\"125\":[3],\"126\":[2,6],\"127\":[3,18],\"128\":[3,45],\"129\":[3],\"130\":[2],\"131\":[2,12],\"132\":[2,23],\"133\":[2,12],\"134\":[2],\"135\":[2,26],\"136\":[2,47],\"137\":[2],\"138\":[2,31],\"139\":[2,17],\"140\":[3,33],\"141\":[3,27],\"142\":[3,50],\"143\":[3,19],\"144\":[3,23],\"145\":[3,34],\"146\":[2,66],\"147\":[3,36],\"148\":[2,25],\"149\":[3,32],\"150\":[3,33],\"151\":[3,24],\"152\":[2],\"153\":[2,50],\"154\":[2],\"155\":[2,12],\"156\":[2,65],\"157\":[3,56],\"158\":[3,48],\"159\":[2,16],\"160\":[3,76],\"161\":[2,109],\"162\":[2,9],\"163\":[3,115],\"164\":[3,91],\"165\":[2],\"166\":[2,30],\"167\":[2,125],\"168\":[3,63],\"169\":[2,27],\"170\":[3,158],\"171\":[2,9],\"172\":[3,197],\"173\":[2,22],\"174\":[3,22],\"175\":[2,32],\"176\":[3,59],\"177\":[3,64],\"178\":[2,24],\"179\":[2],\"180\":[2,69],\"181\":[2,36],\"182\":[3,32],\"183\":[3,24],\"184\":[3,19],\"185\":[2,10],\"186\":[3,83],\"187\":[4,58],\"188\":[2,8],\"189\":[3,17],\"190\":[3,116],\"191\":[2,18],\"192\":[4,14],\"193\":[3,56],\"194\":[3,72],\"195\":[3,105],\"196\":[2,23],\"197\":[3],\"198\":[4,35],\"199\":[3,51],\"200\":[3,24],\"201\":[4,44],\"202\":[3,44],\"203\":[4,11],\"204\":[4,10],\"205\":[3,45],\"206\":[3,48],\"207\":[3,58],\"208\":[2,26],\"209\":[2,34],\"210\":[2,11],\"211\":[2,75],\"212\":[2,82],\"213\":[2,27],\"214\":[2,82],\"215\":[2,5],\"216\":[3,37],\"217\":[2,31],\"218\":[2,102],\"219\":[2,138],\"220\":[2],\"221\":[2,14],\"222\":[5,10],\"223\":[3,121],\"224\":[5,9],\"225\":[3,93],\"226\":[1],\"227\":[2],\"228\":[2],\"229\":[2],\"230\":[2],\"231\":[2],\"232\":[2],\"233\":[5],\"234\":[2],\"235\":[2],\"236\":[2],\"237\":[4],\"238\":[2],\"239\":[2],\"240\":[2,25],\"241\":[2,42],\"242\":[2],\"243\":[2,31],\"244\":[2,116],\"245\":[4,97],\"246\":[2,132],\"247\":[2],\"248\":[2],\"249\":[2,13],\"250\":[3,40],\"251\":[3,68],\"252\":[3,45],\"253\":[2,3],\"254\":[3,15],\"255\":[2,66],\"256\":[2,5],\"257\":[3,48],\"258\":[3,33],\"259\":[2,59],\"260\":[2],\"261\":[2,92],\"262\":[2,155],\"263\":[2,167],\"264\":[2,69],\"265\":[4,76],\"266\":[2,27],\"267\":[2,64],\"268\":[2],\"269\":[2],\"270\":[2,42],\"271\":[2,51],\"272\":[2,14],\"273\":[2,7],\"274\":[2],\"275\":[2,24],\"276\":[2,89],\"277\":[2,32],\"278\":[2,57],\"279\":[2,36],\"280\":[2,62],\"281\":[2,38],\"282\":[2,17],\"283\":[2,28],\"284\":[2],\"285\":[2,44],\"286\":[2,128],\"287\":[2,93],\"288\":[2,180],\"289\":[2,89],\"290\":[2,24],\"291\":[2,171],\"292\":[2,117],\"293\":[2,73],\"294\":[2,58],\"295\":[2,5],\"296\":[2,3],\"297\":[2,176],\"298\":[2,83],\"299\":[2,61],\"300\":[2],\"301\":[2,79],\"302\":[2,161],\"303\":[2,92],\"304\":[2,132],\"305\":[2,14],\"306\":[2],\"307\":[2],\"308\":[2,33],\"309\":[2,110],\"310\":[2,307],\"311\":[2],\"312\":[2,5],\"313\":[4,76],\"314\":[2,148],\"315\":[2,14],\"316\":[2],\"317\":[2,54],\"318\":[2,115],\"319\":[2,100],\"320\":[2,79],\"321\":[2,152],\"322\":[2],\"323\":[2],\"324\":[2],\"325\":[2,83],\"326\":[3,31],\"327\":[5,72],\"328\":[3,2],\"329\":[2,2],\"330\":[3,184],\"331\":[2,163],\"332\":[3,110],\"333\":[3,26],\"334\":[3,18],\"335\":[2,56],\"336\":[2,6],\"337\":[3,86],\"338\":[3,55],\"339\":[2],\"340\":[2],\"341\":[2],\"342\":[2,31],\"343\":[2],\"344\":[4,280],\"345\":[4,73],\"346\":[2],\"347\":[1],\"348\":[1,227],\"349\":[2],\"350\":[1],\"351\":[1,121],\"352\":[2],\"353\":[1],\"354\":[1,203],\"355\":[2],\"356\":[1],\"357\":[1,166],\"358\":[2],\"359\":[2],\"360\":[1],\"361\":[1,532],\"362\":[2],\"363\":[1],\"364\":[1,91],\"365\":[2],\"366\":[1],\"367\":[1,161],\"368\":[2],\"369\":[1],\"370\":[1,121],\"371\":[2],\"372\":[1],\"373\":[1,188],\"374\":[2],\"375\":[1],\"376\":[1,171],\"377\":[2],\"378\":[1],\"379\":[1,655],\"380\":[2],\"381\":[1],\"382\":[1,147],\"383\":[2],\"384\":[1],\"385\":[2],\"386\":[2],\"387\":[2],\"388\":[3,34],\"389\":[2,75],\"390\":[3,107],\"391\":[3,48],\"392\":[2],\"393\":[2],\"394\":[2],\"395\":[3,46],\"396\":[2,70],\"397\":[3,104],\"398\":[3,62],\"399\":[2],\"400\":[1],\"401\":[2],\"402\":[2],\"403\":[3,116],\"404\":[2,84],\"405\":[2,71],\"406\":[2,118],\"407\":[4],\"408\":[1],\"409\":[2],\"410\":[1],\"411\":[2],\"412\":[1],\"413\":[2],\"414\":[1],\"415\":[2],\"416\":[1],\"417\":[2],\"418\":[1],\"419\":[2],\"420\":[1],\"421\":[2],\"422\":[1],\"423\":[2],\"424\":[1],\"425\":[2],\"426\":[1],\"427\":[2],\"428\":[1],\"429\":[2],\"430\":[1],\"431\":[2],\"432\":[1],\"433\":[2],\"434\":[2],\"435\":[2],\"436\":[3,73],\"437\":[2,35],\"438\":[3,79],\"439\":[3,107],\"440\":[3,125],\"441\":[2,14],\"442\":[2,37],\"443\":[2],\"444\":[2],\"445\":[2],\"446\":[2],\"447\":[2],\"448\":[2],\"449\":[2],\"450\":[2],\"451\":[3],\"452\":[3],\"453\":[2],\"454\":[2],\"455\":[4],\"456\":[4],\"457\":[2],\"458\":[2],\"459\":[2],\"460\":[2],\"461\":[2],\"462\":[2],\"463\":[2],\"464\":[2],\"465\":[2],\"466\":[2],\"467\":[2],\"468\":[2],\"469\":[2],\"470\":[2],\"471\":[2],\"472\":[2],\"473\":[2],\"474\":[2],\"475\":[2],\"476\":[2],\"477\":[2],\"478\":[2],\"479\":[2],\"480\":[2],\"481\":[2],\"482\":[2],\"483\":[2],\"484\":[2],\"485\":[2],\"486\":[2],\"487\":[2],\"488\":[2],\"489\":[2],\"490\":[2],\"491\":[2],\"492\":[3],\"493\":[2],\"494\":[2],\"495\":[2],\"496\":[2],\"497\":[2],\"498\":[2],\"499\":[2],\"500\":[2],\"501\":[2],\"502\":[2],\"503\":[2],\"504\":[2],\"505\":[2],\"506\":[2],\"507\":[2],\"508\":[3],\"509\":[2],\"510\":[2],\"511\":[2],\"512\":[2],\"513\":[2],\"514\":[2],\"515\":[2],\"516\":[2],\"517\":[2],\"518\":[2],\"519\":[2],\"520\":[2],\"521\":[2],\"522\":[2],\"523\":[2],\"524\":[1,3],\"525\":[2],\"526\":[1],\"527\":[2],\"528\":[2],\"529\":[1],\"530\":[2],\"531\":[2],\"532\":[2],\"533\":[1],\"534\":[2],\"535\":[2],\"536\":[2]},\"averageFieldLength\":[2.2569832402234615,58.021362409230086],\"storedFields\":{\"0\":{\"h\":\"主页\"},\"1\":{\"h\":\"算法刷题：数组\"},\"2\":{\"h\":\"算法刷题：动态规划\"},\"3\":{\"h\":\"算法刷题：单调栈\"},\"4\":{\"h\":\"算法刷题：图论\"},\"5\":{\"h\":\"算法刷题：链表\"},\"6\":{\"h\":\"算法刷题：哈希表\"},\"7\":{\"h\":\"算法刷题：字符串\"},\"8\":{\"h\":\"算法刷题：双指针\"},\"9\":{\"h\":\"算法刷题：栈与队列\"},\"10\":{\"h\":\"算法刷题：二叉树\"},\"11\":{\"h\":\"算法刷题：回溯算法\"},\"12\":{\"h\":\"算法刷题：贪心算法\"},\"13\":{\"h\":\"第一章：数据结构\",\"t\":[\"常见的数据结构包括数组、链表、栈、队列、哈希表、树、堆、图，它们可以从“逻辑结构”和“物理结构”两个维度进行分类\"]},\"14\":{\"h\":\"1.逻辑结构：线性与非线性\",\"t\":[\"逻辑结构揭示了数据元素之间的逻辑关系。在数组和链表中，数据按照一定顺序排列，体现了数据之间的线性关系；而在树中，数据从顶部向下按层次排列，表现出“祖先”与“后代”之间的派生关系；图则由节点和边构成，反映了复杂的网络关系\",\"线性数据结构：数组、链表、栈、队列、哈希表，元素之间是一对一的顺序关系非线性数据结构：树、堆、图、哈希表\"]},\"15\":{\"h\":\"2.存储结构：连续与分散\",\"t\":[\"当算法程序运行时，正在处理的数据主要存储在内存中。上图展示了一个计算机内存条，其中每个黑色方块都包含一块内存空间。我们可以将内存想象成一个巨大的 Excel 表格，其中每个单元格都可以存储一定大小的数据\",\"系统通过内存地址来访问目标位置的数据。如上图所示，计算机根据特定规则为表格中的每个单元格分配编号，确保每个内存空间都有唯一的内存地址。有了这些地址，程序便可以访问内存中的数据\",\"内存是所有程序的共享资源，当某块内存被某个程序占用时，则无法被其他程序同时使用了。因此在数据结构与算法的设计中，内存资源是一个重要的考虑因素。比如，算法所占用的内存峰值不应超过系统剩余空闲内存；如果缺少连续大块的内存空间，那么所选用的数据结构必须能够存储在分散的内存空间内\",\"如图上图，物理结构反映了数据在计算机内存中的存储方式，可分为连续空间存储（数组）和分散空间存储（链表）。物理结构从底层决定了数据的访问、更新、增删等操作方法，两种物理结构在时间效率和空间效率方面呈现出互补的特点\",\"值得说明的是，所有数据结构都是基于数组、链表或二者的组合实现的。例如，栈和队列既可以使用数组实现，也可以使用链表实现；而哈希表的实现可能同时包含数组和链表\",\"基于数组可实现：栈、队列、哈希表、树、堆、图、矩阵、张量（维度的数组）等\",\"基于链表可实现：栈、队列、哈希表、树、堆、图等\",\"链表在初始化后，仍可以在程序运行过程中对其长度进行调整，因此也称“动态数据结构”。数组在初始化后长度不可变，因此也称“静态数据结构”。值得注意的是，数组可通过重新分配内存实现长度变化，从而具备一定的“动态性\"]},\"16\":{\"h\":\"3.基本数据类型\",\"t\":[\"当谈及计算机中的数据时，我们会想到文本、图片、视频、语音、3D 模型等各种形式。尽管这些数据的组织形式各异，但它们都由各种基本数据类型构成\",\"基本数据类型是 CPU 可以直接进行运算的类型，在算法中直接被使用，主要包括以下几种：\",\"1.整数类型 byte、short、int、long 2.浮点数类型 float、double ，用于表示小数 3.字符类型 char ，用于表示各种语言的字母、标点符号甚至表情符号等 4.布尔类型 bool ，用于表示“是”与“否”判断 \",\"基本数据类型以二进制的形式存储在计算机中。一个二进制位即为 1比特。在绝大多数现代操作系统中，1字节（byte）由 8比特（bit）组成\"]},\"17\":{\"h\":\"4.数字编码\",\"t\":[\"（1）原码、补码、反码首先需要指出，数字是以“补码”的形式存储在计算机中的。在分析这样做的原因之前，首先给出三者的定义\",\"原码：我们将数字的二进制表示的最高位视为符号位，其中0表示正数，1表示负数，其余位表示数字的值\",\"反码：正数的反码与其原码相同，负数的反码是对其原码除符号位外的所有位取反\",\"补码：正数的补码与其原码相同，负数的补码是在其反码的基础上加1\",\"计算机使用补码的原因：基于补码表示，计算机可以用同样的电路和操作来处理正数和负数的加法，不需要设计特殊的硬件电路来处理减法，并且无须特别处理正负零的歧义问题。这大大简化了硬件设计，提高了运算效率\"]},\"18\":{\"h\":\"5.字符编码\",\"t\":[\"在计算机中，所有数据都是以二进制数的形式存储的，字符 char 也不例外。为了表示字符，我们需要建立一套“字符集”，规定每个字符和二进制数之间的一一对应关系。有了字符集之后，计算机就可以通过查表完成二进制数到字符的转换\",\"（1）ASCII字符集\",\"ASCII 码是最早出现的字符集，其全称为 American Standard Code for Information Interchange（美国标准信息交换代码）。它使用 7 位二进制数（一个字节的低 7 位）表示一个字符，最多能够表示 128 个不同的字符。如图上图所示，ASCII 码包括英文字母的大小写、数字 0 ~ 9、一些标点符号，以及一些控制字符（如换行符和制表符然而，ASCII 码仅能够表示英文。随着计算机的全球化，诞生了一种能够表示更多语言的 EASCII 字符集。它在 ASCII 的 7 位基础上扩展到 8 位，能够表示 256 个不同的字符在世界范围内，陆续出现了一批适用于不同地区的 EASCII 字符集。这些字符集的前 128 个字符统一为 ASCII 码，后 128 个字符定义不同，以适应不同语言的需求\",\"（2）GBK字符集\",\"后来人们发现，EASCII 码仍然无法满足许多语言的字符数量要求。比如汉字有近十万个，光日常使用的就有几千个。中国国家标准总局于 1980 年发布了 GB2312 字符集，其收录了 6763 个汉字，基本满足了汉字的计算机处理需要然而，GB2312 无法处理部分罕见字和繁体字。GBK 字符集是在 GB2312 的基础上扩展得到的，它共收录了 21886 个汉字。在 GBK 的编码方案中，ASCII 字符使用一个字节表示，汉字使用两个字节表示\",\"（3）Unicode字符集\",\"随着计算机技术的蓬勃发展，字符集与编码标准百花齐放，而这带来了许多问题。一方面，这些字符集一般只定义了特定语言的字符，无法在多语言环境下正常工作。另一方面，同一种语言存在多种字符集标准，如果两台计算机使用的是不同的编码标准，则在信息传递时就会出现乱码那个时代的研究人员就在想：如果推出一个足够完整的字符集，将世界范围内的所有语言和符号都收录其中，不就可以解决跨语言环境和乱码问题了吗？在这种想法的驱动下，一个大而全的字符集 Unicode 应运而生Unicode 的中文名称为“统一码”，理论上能容纳 100 多万个字符。它致力于将全球范围内的字符纳入统一的字符集之中，提供一种通用的字符集来处理和显示各种语言文字，减少因为编码标准不同而产生的乱码问题自 1991 年发布以来，Unicode 不断扩充新的语言与字符。截至 2022 年 9 月，Unicode 已经包含 149186 个字符，包括各种语言的字符、符号甚至表情符号等。在庞大的 Unicode 字符集中，常用的字符占用 2 字节，有些生僻的字符占用 3 字节甚至 4 字节Unicode 是一种通用字符集，本质上是给每个字符分配一个编号（称为“码点”），但它并没有规定在计算机中如何存储这些字符码点。我们不禁会问：当多种长度的 Unicode 码点同时出现在一个文本中时，系统如何解析字符？例如给定一个长度为 2 字节的编码，系统如何确认它是一个 2 字节的字符还是两个 1 字节的字符？对于以上问题，一种直接的解决方案是将所有字符存储为等长的编码，然而 ASCII 码已经向我们证明，编码英文只需 1 字节。若采用上述方案，英文文本占用空间的大小将会是 ASCII 编码下的两倍，非常浪费内存空间。因此，我们需要一种更加高效的 Unicode 编码方法\",\"（4）UTF-8编码\",\"目前，UTF-8 已成为国际上使用最广泛的 Unicode 编码方法。它是一种可变长度的编码，使用 1 到 4 字节来表示一个字符，根据字符的复杂性而变。ASCII 字符只需 1 字节，拉丁字母和希腊字母需要 2 字节，常用的中文字符需要 3 字节，其他的一些生僻字符需要 4 字节\",\"UTF-8 的编码规则并不复杂，分为以下两种情况：\",\"对于长度为 1 字节的字符，将最高位设置为0，其余 7 位设置为 Unicode 码点。值得注意的是，ASCII 字符在 Unicode 字符集中占据了前 128 个码点。也就是说，UTF-8 编码可以向下兼容 ASCII 码。这意味着我们可以使用 UTF-8 来解析年代久远的 ASCII 码文本 对于长度为n字节的字符，将首个字节的高位n都设置为1，第n+1位设置为0；从第二个字节开始，将每个字节的高2位都设置为10；其余所有位用于填充字符的 Unicode码点\",\"除了 UTF-8 之外，常见的编码方式还包括以下两种：\",\"UTF-16 编码：使用 2 或 4 字节来表示一个字符。所有的 ASCII 字符和常用的非英文字符，都用 2 字节表示；少数字符需要用到 4 字节表示。对于 2 字节的字符，UTF-16 编码与 Unicode 码点相等\",\"UTF-32 编码：每个字符都使用 4 字节。这意味着 UTF-32 比 UTF-8 和 UTF-16 更占用空间，特别是对于 ASCII 字符占比较高的文本\",\"从存储空间占用的角度看，使用 UTF-8 表示英文字符非常高效，因为它仅需 1 字节；使用 UTF-16 编码某些非英文字符（例如中文）会更加高效，因为它仅需 2 字节，而 UTF-8 可能需要 3 字节\",\"从兼容性的角度看，UTF-8 的通用性最佳，许多工具和库优先支持UTF-8\"]},\"19\":{\"h\":\"第十章：搜索\"},\"20\":{\"h\":\"1.二分查找\",\"t\":[\"二分查找（binary search）是一种基于分治策略的高效搜索算法。它利用数据的有序性，每轮缩小一半搜索范围，直至找到目标元素或搜索区间为空为止\",\"如上图所示，我们先初始化指针i=0和j=n-1，分别指向数组首元素和尾元素，代表搜索区间[0,n-1]。请注意，中括号表示闭区间，其包含边界值本身\",\"时间复杂度为O(logn)：在二分循环中，区间每轮缩小一半，因此循环次数为logn空间复杂度为O(1)：指针i和j使用常数大小空间\",\"接下来，循环执行以下两步：\",\"计算中点索引m=[(i+j)/2]（向下取整）\",\"判断 nums[m] 和 target 的大小关系，分为以下三种情况\",\"当 nums[m] < target 时，说明 target 在区间[m+1，j]中，因此执行i=m+1\",\"当 nums[m] > target 时，说明 target 在区间[i，m-1]中，因此执行j=m-1\",\"当 nums[m] = target 时，说明找到 target ，因此返回索引m\",\"若数组不包含目标元素，搜索区间最终会缩小为空。此时返回-1\",\"二分查找流程如下：\",\"值得注意的是，由于i和j都是int类型，因此i+j可能超出int类型的取值范围。为了避免大数越界，我们通常采用公式m=[i+(j-i)/2]来计算中点\",\"/* 二分查找（双闭区间） */ int binarySearch(int *nums, int len, int target) { // 初始化双闭区间 [0, n-1] ，即 i, j 分别指向数组首元素、尾元素 int i = 0, j = len - 1; // 循环，当搜索区间为空时跳出（当 i > j 时为空） while (i <= j) { int m = i + (j - i) / 2; // 计算中点索引 m if (nums[m] < target) // 此情况说明 target 在区间 [m+1, j] 中 i = m + 1; else if (nums[m] > target) // 此情况说明 target 在区间 [i, m-1] 中 j = m - 1; else // 找到目标元素，返回其索引 return m; } // 未找到目标元素，返回 -1 return -1; } \"]},\"21\":{\"h\":\"2.二分查找的区间表示方法\",\"t\":[\"除了上述双闭区间外，常见的区间表示还有“左闭右开”区间，定义为[0,n)，即左边界包含自身，右边界不包含自身。在该表示下，区间[i,j)在i=j时为空\",\"我们可以基于该表示实现具有相同功能的二分查找算法：\",\"/* 二分查找（左闭右开区间） */ int binarySearchLCRO(int *nums, int len, int target) { // 初始化左闭右开区间 [0, n) ，即 i, j 分别指向数组首元素、尾元素+1 int i = 0, j = len; // 循环，当搜索区间为空时跳出（当 i = j 时为空） while (i < j) { int m = i + (j - i) / 2; // 计算中点索引 m if (nums[m] < target) // 此情况说明 target 在区间 [m+1, j) 中 i = m + 1; else if (nums[m] > target) // 此情况说明 target 在区间 [i, m) 中 j = m; else // 找到目标元素，返回其索引 return m; } // 未找到目标元素，返回 -1 return -1; } \",\"由于“双闭区间”表示中的左右边界都被定义为闭区间，因此通过指针i和指针j缩小区间的操作也是对称的。这样更不容易出错，因此一般建议采用“双闭区间”的写法\"]},\"22\":{\"h\":\"3.二分查找插入点\",\"t\":[\"二分查找不仅可用于搜索目标元素，还可用于解决许多变种问题，比如搜索目标元素的插入位置\"]},\"23\":{\"h\":\"3.1 无重复元素的情况\",\"t\":[\"/* 二分查找插入点（无重复元素） */ int binarySearchInsertionSimple(int *nums, int numSize, int target) { int i = 0, j = numSize - 1; // 初始化双闭区间 [0, n-1] while (i <= j) { int m = i + (j - i) / 2; // 计算中点索引 m if (nums[m] < target) { i = m + 1; // target 在区间 [m+1, j] 中 } else if (nums[m] > target) { j = m - 1; // target 在区间 [i, m-1] 中 } else { return m; // 找到 target ，返回插入点 m } } // 未找到 target ，返回插入点 i return i; } \"]},\"24\":{\"h\":\"3.2 存在重复元素情况\",\"t\":[\"假设数组中存在多个 target ，则普通二分查找只能返回其中一个 target 的索引，而无法确定该元素的左边和右边还有多少 target\",\"观察以下代码，判断分支 nums[m] > target 和 nums[m] == target 的操作相同，因此两者可以合并\",\"即便如此，我们仍然可以将判断条件保持展开，因为其逻辑更加清晰、可读性更好\",\"/* 二分查找插入点（存在重复元素） */ int binarySearchInsertion(int *nums, int numSize, int target) { int i = 0, j = numSize - 1; // 初始化双闭区间 [0, n-1] while (i <= j) { int m = i + (j - i) / 2; // 计算中点索引 m if (nums[m] < target) { i = m + 1; // target 在区间 [m+1, j] 中 } else if (nums[m] > target) { j = m - 1; // target 在区间 [i, m-1] 中 } else { j = m - 1; // 首个小于 target 的元素在区间 [i, m-1] 中 } } // 返回插入点 i return i; } \"]},\"25\":{\"h\":\"4.二分查找边界\"},\"26\":{\"h\":\"4.1 查找左边界\",\"t\":[\"回忆二分查找插入点的方法，搜索完成后i指向最左一个 target ，因此查找插入点本质上是在查找最左一个 target 的索引\",\"考虑通过查找插入点的函数实现查找左边界。请注意，数组中可能不包含 target ，这种情况可能导致以下两种结果：\",\"插入点的索引i越界\",\"元素nums[i] 与 target 不相等\",\"当遇到以上两种情况时，直接返回-1即可，代码如下所示：\",\"/* 二分查找最左一个 target */ int binarySearchLeftEdge(int *nums, int numSize, int target) { // 等价于查找 target 的插入点 int i = binarySearchInsertion(nums, numSize, target); // 未找到 target ，返回 -1 if (i == numSize || nums[i] != target) { return -1; } // 找到 target ，返回索引 i return i; } \"]},\"27\":{\"h\":\"4.2 查找右边界\",\"t\":[\"（1）方法一：复用查找左边界\",\"实际上，我们可以利用查找最左元素的函数来查找最右元素，具体方法为：将查找最右一个 target 转化为查找最左一个 target + 1\",\"如下图所示，查找完成后，指针i指向最左一个 target + 1（如果存在），而j指向最右一个 target ，因此返回j即可\",\"请注意，返回的插入点是i，因此需要将其减1，从而获得j：\",\"/* 二分查找最右一个 target */ int binarySearchRightEdge(int *nums, int numSize, int target) { // 转化为查找最左一个 target + 1 int i = binarySearchInsertion(nums, numSize, target + 1); // j 指向最右一个 target ，i 指向首个大于 target 的元素 int j = i - 1; // 未找到 target ，返回 -1 if (j == -1 || nums[j] != target) { return -1; } // 找到 target ，返回索引 j return j; } \",\"（2）方法二：转化为查找元素\",\"我们知道，当数组不包含 target 时，最终i和j会分别指向首个大于、小于 target 的元素\",\"因此，如下图所示，我们可以构造一个数组中不存在的元素，用于查找左右边界：\",\"查找最左一个 target ：可以转化为查找 target - 0.5 ，并返回指针i\",\"查找最右一个 target ：可以转化为查找 target + 0.5 ，并返回指针j\",\"代码在此省略，以下两点值得注意：\",\"给定数组不包含小数，这意味着我们无须关心如何处理相等的情况\",\"因为该方法引入了小数，所以需要将函数中的变量 target 改为浮点数类型\"]},\"28\":{\"h\":\"5.哈希优化策略\",\"t\":[\"在算法题中，我们常通过将线性查找替换为哈希查找来降低算法的时间复杂度\"]},\"29\":{\"h\":\"5.1 线性查找：以时间换空间\",\"t\":[\"考虑直接遍历所有可能的组合。如下图所示，我们开启一个两层循环，在每轮中判断两个整数的和是否为 target ，若是，则返回它们的索引\",\"此方法的时间复杂度为O（n^2），空间复杂度为O(1)，在大数据量下非常耗时\",\"/* 方法一：暴力枚举 */ int *twoSumBruteForce(int *nums, int numsSize, int target, int *returnSize) { for (int i = 0; i < numsSize; ++i) { for (int j = i + 1; j < numsSize; ++j) { if (nums[i] + nums[j] == target) { int *res = malloc(sizeof(int) * 2); res[0] = i, res[1] = j; *returnSize = 2; return res; } } } *returnSize = 0; return NULL; } \"]},\"30\":{\"h\":\"5.2 哈希查找：以空间换时间\",\"t\":[\"考虑借助一个哈希表，键值对分别为数组元素和元素索引。循环遍历数组，每轮执行图如下所示：\",\"此方法通过哈希查找将时间复杂度从O(n^2)降至O(n)，大幅提升运行效率由于需要维护一个额外的哈希表，因此空间复杂度为O(n)\",\"判断数字 target - nums[i] 是否在哈希表中，若是，则直接返回这两个元素的索引\",\"将键值对 nums[i] 和索引 i 添加进哈希表\",\"实现代码如下所示，仅需单层循环即可：\",\"/* 哈希表 */ typedef struct { int key; int val; UT_hash_handle hh; // 基于 uthash.h 实现 } HashTable; /* 哈希表查询 */ HashTable *find(HashTable *h, int key) { HashTable *tmp; HASH_FIND_INT(h, &key, tmp); return tmp; } /* 哈希表元素插入 */ void insert(HashTable *h, int key, int val) { HashTable *t = find(h, key); if (t == NULL) { HashTable *tmp = malloc(sizeof(HashTable)); tmp->key = key, tmp->val = val; HASH_ADD_INT(h, key, tmp); } else { t->val = val; } } /* 方法二：辅助哈希表 */ int *twoSumHashTable(int *nums, int numsSize, int target, int *returnSize) { HashTable *hashtable = NULL; for (int i = 0; i < numsSize; i++) { HashTable *t = find(hashtable, target - nums[i]); if (t != NULL) { int *res = malloc(sizeof(int) * 2); res[0] = t->val, res[1] = i; *returnSize = 2; return res; } insert(hashtable, nums[i], i); } *returnSize = 0; return NULL; } \"]},\"31\":{\"h\":\"第十一章：排序\"},\"32\":{\"h\":\"1.排序算法概念\",\"t\":[\"排序算法（sorting algorithm）用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理\",\"如下图所示，排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则\"]},\"33\":{\"h\":\"1.1 排序算法评价维度\",\"t\":[\"（1）运行效率：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要\",\"（2）就地性：顾名思义，原地排序通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快\",\"（3）稳定性：稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变\",\"稳定排序是多级排序场景的必要条件。假设我们有一个存储学生信息的表格，第 1 列和第 2 列分别是姓名和年龄。在这种情况下，非稳定排序可能导致输入数据的有序性丧失：\",\"# 输入数据是按照姓名排序好的 # (name, age) ('A', 19) ('B', 18) ('C', 21) ('D', 19) ('E', 23) # 假设使用非稳定排序算法按年龄排序列表， # 结果中 ('D', 19) 和 ('A', 19) 的相对位置改变， # 输入数据按姓名排序的性质丢失 ('B', 18) ('D', 19) ('A', 19) ('C', 21) ('E', 23) \",\"（4）自适应性：自适应排序的时间复杂度会受输入数据的影响，即最佳时间复杂度、最差时间复杂度、平均时间复杂度并不完全相等\",\"自适应性需要根据具体情况来评估。如果最差时间复杂度差于平均时间复杂度，说明排序算法在某些数据下性能可能劣化，因此被视为负面属性；而如果最佳时间复杂度优于平均时间复杂度，则被视为正面属性\",\"（5）是否基于比较：基于比较的排序依赖比较运算符（<、=、>）来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为O(nlogn)。而非比较排序不使用比较运算符，时间复杂度可达O(n)，但其通用性相对较差\"]},\"34\":{\"h\":\"1.2 理想的排序算法\",\"t\":[\"运行快、原地、稳定、正向自适应、通用性好。显然，迄今为止尚未发现兼具以上所有特性的排序算法。因此，在选择排序算法时，需要根据具体的数据特点和问题需求来决定\"]},\"35\":{\"h\":\"2.选择排序算法\"},\"36\":{\"h\":\"2.1 选择排序原理\",\"t\":[\"选择排序（selection sort）的工作原理非常简单：开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾\",\"设数组的长度为n，选择排序的算法流程如图下图所示：\",\"初始状态下，所有元素未排序，即未排序（索引）区间为[0，n-1]\",\"选取区间[0，n-1]中的最小元素，将其与索引0处的元素交换。完成后，数组前1个元素已排序\",\"选取区间[1，n-1]中的最小元素，将其与索引1处的元素交换。完成后，数组前2个元素已排序\",\"以此类推。经过n-1轮选择与交换后，数组前n-1个元素已排序\",\"仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成\",\"在代码中，我们用k来记录未排序区间内的最小元素：\",\"/* 选择排序 */ void selectionSort(int nums[], int n) { // 外循环：未排序区间为 [i, n-1] for (int i = 0; i < n - 1; i++) { // 内循环：找到未排序区间内的最小元素 int k = i; for (int j = i + 1; j < n; j++) { if (nums[j] < nums[k]) k = j; // 记录最小元素的索引 } // 将该最小元素与未排序区间的首个元素交换 int temp = nums[i]; nums[i] = nums[k]; nums[k] = temp; } } \",\"时间复杂度为O(n^2)、非自适应排序：外循环共n-1轮，第一轮的未排序区间长度为n，最后一轮的未排序区间长度为2，即各轮外循环分别包含n、n-1、...、3、2轮内循环，求和为(n-1)(n+2)/2空间复杂度为O(1)、原地排序：指针i和j使用常数大小的额外空间非稳定排序：如下图所示，元素 nums[i] 有可能被交换至与其相等的元素的右边，导致两者的相对顺序发生改变\"]},\"37\":{\"h\":\"3.冒泡排序算法\",\"t\":[\"冒泡排序（bubble sort）通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序\",\"时间复杂度为O(n^2)、自适应排序：各轮“冒泡”遍历的数组长度依次为n-1、n-2、...、2、1，总和为(n-1)/2。在引入 flag 优化后，最佳时间复杂度可达到O(n)空间复杂度为O(1)、原地排序：指针i和j使用常数大小的额外空间稳定排序：由于在“冒泡”中遇到相等元素不交换\",\"如下图所示，冒泡过程可以利用元素交换操作来模拟：从数组最左端开始向右遍历，依次比较相邻元素大小，如果“左元素 > 右元素”就交换二者。遍历完成后，最大的元素会被移动到数组的最右端\"]},\"38\":{\"h\":\"3.1 冒牌排序算法流程\",\"t\":[\"设数组的长度n，冒泡排序的步骤如下图所示：\",\"首先，对n个元素执行“冒泡”，将数组的最大元素交换至正确位置\",\"接下来，对剩余n-1个元素执行“冒泡”，将第二大元素交换至正确位置\",\"以此类推，经过n-1轮“冒泡”后，前n-1大的元素都被交换至正确位置\",\"仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成\",\"示例代码如下：\",\"/* 冒泡排序 */ void bubbleSort(int nums[], int size) { // 外循环：未排序区间为 [0, i] for (int i = size - 1; i > 0; i--) { // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端 for (int j = 0; j < i; j++) { if (nums[j] > nums[j + 1]) { int temp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp; } } } } \"]},\"39\":{\"h\":\"3.2 冒泡排序效率优化\",\"t\":[\"我们发现，如果某轮“冒泡”中没有执行任何交换操作，说明数组已经完成排序，可直接返回结果。因此，可以增加一个标志位 flag 来监测这种情况，一旦出现就立即返回\",\"经过优化，冒泡排序的最差时间复杂度和平均时间复杂度仍为O(n^2)；但当输入数组完全有序时，可达到最佳时间复杂度O(n)\",\"/* 冒泡排序（标志优化）*/ void bubbleSortWithFlag(int nums[], int size) { // 外循环：未排序区间为 [0, i] for (int i = size - 1; i > 0; i--) { bool flag = false; // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端 for (int j = 0; j < i; j++) { if (nums[j] > nums[j + 1]) { int temp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = temp; flag = true; } } if (!flag) break; } } \"]},\"40\":{\"h\":\"4.插入排序算法\",\"t\":[\"插入排序（insertion sort）是一种简单的排序算法，它的工作原理与手动整理一副牌的过程非常相似\",\"具体来说，我们在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置\",\"下图展示了数组插入元素的操作流程。设基准元素为 base ，我们需要将从目标索引到 base 之间的所有元素向右移动一位，然后将 base 赋值给目标索引\"]},\"41\":{\"h\":\"4.1 插入排序算法流程\",\"t\":[\"插入排序的整体流程如下图所示：\",\"初始状态下，数组的第 1 个元素已完成排序\",\"选取数组的第 2 个元素作为 base ，将其插入到正确位置后，数组的前 2 个元素已排序\",\"选取第 3 个元素作为 base ，将其插入到正确位置后，数组的前 3 个元素已排序\",\"以此类推，在最后一轮中，选取最后一个元素作为 base ，将其插入到正确位置后，所有元素均已排序\",\"时间复杂度为O(n^ 2)、自适应排序：在最差情况下，每次插入操作分别需要循环n-1、n-2、...、2、1次，求和得到(n-1)n/2，因此时间复杂度为O(n^2) 。在遇到有序数据时，插入操作会提前终止。当输入数组完全有序时，插入排序达到最佳时间复杂度O(n)空间复杂度为O(1)、原地排序：指针i和j使用常数大小的额外空间稳定排序：在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序\",\"/* 插入排序 */ void insertionSort(int nums[], int size) { // 外循环：已排序区间为 [0, i-1] for (int i = 1; i < size; i++) { int base = nums[i], j = i - 1; // 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置 while (j >= 0 && nums[j] > base) { // 将 nums[j] 向右移动一位 nums[j + 1] = nums[j]; j--; } // 将 base 赋值到正确位置 nums[j + 1] = base; } } \"]},\"42\":{\"h\":\"5.快速排序算法\",\"t\":[\"快速排序（quick sort）是一种基于分治策略的排序算法，运行高效，应用广泛\",\"快速排序的核心操作是“哨兵划分”，其目标是：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。具体来说，哨兵划分的流程如下图所示\",\"选取数组最左端元素作为基准数，初始化两个指针i和j分别指向数组的两端\",\"设置一个循环，在每轮中使用 i（j）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素\",\"循环执行步骤2，直到 i 和 j 相遇时停止，最后将基准数交换至两个子数组的分界线\",\"哨兵划分完成后，原数组被划分成三部分：左子数组、基准数、右子数组，且满足“左子数组任意元素 ≤ 基准数 ≤右子数组任意元素”。因此，我们接下来只需对这两个子数组进行排序\",\"/* 元素交换 */ void swap(int nums[], int i, int j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } /* 快速排序类 */ // 快速排序类-哨兵划分 int partition(int nums[], int left, int right) { // 以 nums[left] 为基准数 int i = left, j = right; while (i < j) { while (i < j && nums[j] >= nums[left]) { // 从右向左找首个小于基准数的元素 j--; } while (i < j && nums[i] <= nums[left]) { // 从左向右找首个大于基准数的元素 i++; } // 交换这两个元素 swap(nums, i, j); } // 将基准数交换至两子数组的分界线 swap(nums, i, left); // 返回基准数的索引 return i; } \"]},\"43\":{\"h\":\"5.1 快速排序算法流程\",\"t\":[\"快速排序的整体流程如下图所示：\",\"首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组\",\"然后，对左子数组和右子数组分别递归执行“哨兵划分”\",\"持续递归，直至子数组长度为 1 时终止，从而完成整个数组的排序\",\"时间复杂度为O(nlogn)、自适应排序：在平均情况下，哨兵划分的递归层数为logn，每层中的总循环数为n，总体使用O(nlogn)时间。在最差情况下，每轮哨兵划分操作都将长度为n的数组划分为长度为0和n-1的两个子数组，此时递归层数达到n，每层中的循环数为n，总体使用O(n^2)时间空间复杂度为O(n)、原地排序：在输入数组完全倒序的情况下，达到最差递归深度n，使用O(n)栈帧空间。排序操作是在原数组上进行的，未借助额外数组非稳定排序：在哨兵划分的最后一步，基准数可能会被交换至相等元素的右侧\",\"/* 快速排序类 */ // 快速排序类-哨兵划分 int partition(int nums[], int left, int right) { // 以 nums[left] 为基准数 int i = left, j = right; while (i < j) { while (i < j && nums[j] >= nums[left]) { // 从右向左找首个小于基准数的元素 j--; } while (i < j && nums[i] <= nums[left]) { // 从左向右找首个大于基准数的元素 i++; } // 交换这两个元素 swap(nums, i, j); } // 将基准数交换至两子数组的分界线 swap(nums, i, left); // 返回基准数的索引 return i; } // 快速排序类-快速排序 void quickSort(int nums[], int left, int right) { // 子数组长度为 1 时终止递归 if (left >= right) { return; } // 哨兵划分 int pivot = partition(nums, left, right); // 递归左子数组、右子数组 quickSort(nums, left, pivot - 1); quickSort(nums, pivot + 1, right); } \"]},\"44\":{\"h\":\"5.2 快速排序为什么快\",\"t\":[\"从名称上就能看出，快速排序在效率方面应该具有一定的优势。尽管快速排序的平均时间复杂度与“归并排序”和“堆排序”相同，但通常快速排序的效率更高，主要有以下原因\",\"出现最差情况的概率很低：虽然快速排序的最差时间复杂度为O(n^2)，没有归并排序稳定，但在绝大多数情况下，快速排序能在O(nlogn)的时间复杂度下运行\",\"缓存使用效率高：在执行哨兵划分操作时，系统可将整个子数组加载到缓存，因此访问元素的效率较高。而像“堆排序”这类算法需要跳跃式访问元素，从而缺乏这一特性\",\"复杂度的常数系数小：在上述三种算法中，快速排序的比较、赋值、交换等操作的总数量最少。这与“插入排序”比“冒泡排序”更快的原因类似\"]},\"45\":{\"h\":\"6.归并排序算法\",\"t\":[\"归并排序（merge sort）是一种基于分治策略的排序算法，包含图下图所示的“划分”和“合并”阶段\",\"划分阶段：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题\",\"合并阶段：当子数组长度为 1 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束\"]},\"46\":{\"h\":\"6.1 归并排序算法流程\",\"t\":[\"如下图所示，“划分阶段”从顶至底递归地将数组从中点切分为两个子数组：\",\"计算数组中点 mid ，递归划分左子数组（区间 [left, mid] ）和右子数组（区间 [mid + 1, right] ）\",\"递归执行步骤 1 ，直至子数组区间长度为 1 时终止\",\"时间复杂度为O(nlogn)、非自适应排序：划分产生高度为logn的递归树，每层合并的总操作数量为n，因此总体时间复杂度为O(nlogn)空间复杂度为O(1)、非原地排序：递归深度为logn，使用O(logn)大小的栈帧空间。合并操作需要借助辅助数组实现，使用O(n) 大小的额外空间稳定排序：在合并过程中，相等元素的次序保持不变\",\"“合并阶段”从底至顶地将左子数组和右子数组合并为一个有序数组。需要注意的是，从长度为 1 的子数组开始合并，合并阶段中的每个子数组都是有序的\",\"观察发现，归并排序与二叉树后序遍历的递归顺序是一致的\",\"后序遍历：先递归左子树，再递归右子树，最后处理根节点\",\"归并排序：先递归左子数组，再递归右子数组，最后处理合并\",\"归并排序的实现如以下代码所示。请注意，nums 的待合并区间为 [left, right] ，而 tmp 的对应区间为 [0, right - left]\",\"/* 合并左子数组和右子数组 */ void merge(int *nums, int left, int mid, int right) { // 左子数组区间为 [left, mid], 右子数组区间为 [mid+1, right] // 创建一个临时数组 tmp ，用于存放合并后的结果 int tmpSize = right - left + 1; int *tmp = (int *)malloc(tmpSize * sizeof(int)); // 初始化左子数组和右子数组的起始索引 int i = left, j = mid + 1, k = 0; // 当左右子数组都还有元素时，进行比较并将较小的元素复制到临时数组中 while (i <= mid && j <= right) { if (nums[i] <= nums[j]) { tmp[k++] = nums[i++]; } else { tmp[k++] = nums[j++]; } } // 将左子数组和右子数组的剩余元素复制到临时数组中 while (i <= mid) { tmp[k++] = nums[i++]; } while (j <= right) { tmp[k++] = nums[j++]; } // 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间 for (k = 0; k < tmpSize; ++k) { nums[left + k] = tmp[k]; } // 释放内存 free(tmp); } /* 归并排序 */ void mergeSort(int *nums, int left, int right) { // 终止条件 if (left >= right) return; // 当子数组长度为 1 时终止递归 // 划分阶段 int mid = (left + right) / 2; // 计算中点 mergeSort(nums, left, mid); // 递归左子数组 mergeSort(nums, mid + 1, right); // 递归右子数组 // 合并阶段 merge(nums, left, mid, right); } \"]},\"47\":{\"h\":\"7.堆排序算法\",\"t\":[\"堆排序（heap sort）是一种基于堆数据结构实现的高效排序算法。我们可以利用已经学过的“建堆操作”和“元素出堆操作”实现堆排序\",\"输入数组并建立小顶堆，此时最小元素位于堆顶\",\"不断执行出堆操作，依次记录出堆元素，即可得到从小到大排序的序列\",\"以上方法虽然可行，但需要借助一个额外数组来保存弹出的元素，比较浪费空间。在实际中，我们通常使用一种更加优雅的实现方式\"]},\"48\":{\"h\":\"7.1 堆排序算法流程\",\"t\":[\"设数组的长度为n，堆排序的流程如下图所示：\",\"输入数组并建立大顶堆。完成后，最大元素位于堆顶\",\"将堆顶元素（第一个元素）与堆底元素（最后一个元素）交换。完成交换后，堆的长度减1，已排序元素数量加1\",\"从堆顶元素开始，从顶到底执行堆化操作（sift down）。完成堆化后，堆的性质得到修复\",\"循环执行第 2 步和第 3 步。循环n-1轮后，即可完成数组排序\",\"时间复杂度为O(nlogn)、非自适应排序：建堆操作使用O(n)时间。从堆中提取最大元素的时间复杂度为O(logn)，共循环n-1轮空间复杂度为O(1)、原地排序：几个指针变量使用O(1)空间。元素交换和堆化操作都是在原数组上进行的非稳定排序：在交换堆顶元素和堆底元素时，相等元素的相对位置可能发生变化\",\"在代码实现中，我们使用了与“堆”章节相同的从顶至底堆化 sift_down() 函数。值得注意的是，由于堆的长度会随着提取最大元素而减小，因此我们需要给 sift_down() 函数添加一个长度参数n，用于指定堆的当前有效长度。代码如下所示：\",\"/* 堆的长度为 n ，从节点 i 开始，从顶至底堆化 */ void siftDown(int nums[], int n, int i) { while (1) { // 判断节点 i, l, r 中值最大的节点，记为 ma int l = 2 * i + 1; int r = 2 * i + 2; int ma = i; if (l < n && nums[l] > nums[ma]) ma = l; if (r < n && nums[r] > nums[ma]) ma = r; // 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出 if (ma == i) { break; } // 交换两节点 int temp = nums[i]; nums[i] = nums[ma]; nums[ma] = temp; // 循环向下堆化 i = ma; } } /* 堆排序 */ void heapSort(int nums[], int n) { // 建堆操作：堆化除叶节点以外的其他所有节点 for (int i = n / 2 - 1; i >= 0; --i) { siftDown(nums, n, i); } // 从堆中提取最大元素，循环 n-1 轮 for (int i = n - 1; i > 0; --i) { // 交换根节点与最右叶节点（交换首元素与尾元素） int tmp = nums[0]; nums[0] = nums[i]; nums[i] = tmp; // 以根节点为起点，从顶至底进行堆化 siftDown(nums, i, 0); } } \"]},\"49\":{\"h\":\"8.桶排序算法\",\"t\":[\"前述几种排序算法都属于“基于比较的排序算法”，它们通过比较元素间的大小来实现排序。此类排序算法的时间复杂度无法超越O(nlogn)。接下来，我们将探讨几种“非比较排序算法”，它们的时间复杂度可以达到线性阶。\",\"桶排序（bucket sort）是分治策略的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并\"]},\"50\":{\"h\":\"8.1 桶排序算法流程\",\"t\":[\"考虑一个长度为n的数组，其元素是范围[0，1)内的浮点数。桶排序的流程如下图：\",\"初始化k个桶，将n个元素分配到k个桶中\",\"对每个桶分别执行排序（这里采用编程语言的内置排序函数）\",\"按照桶从小到大的顺序合并结果\",\"/* 桶排序 */ void bucketSort(float nums[], int size) { // 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素 int k = size / 2; float **buckets = calloc(k, sizeof(float *)); for (int i = 0; i < k; i++) { // 每个桶最多可以分配 size 个元素 buckets[i] = calloc(size, sizeof(float)); } // 1. 将数组元素分配到各个桶中 for (int i = 0; i < size; i++) { // 输入数据范围为 [0, 1)，使用 num * k 映射到索引范围 [0, k-1] int bucket_idx = nums[i] * k; int j = 0; // 如果桶中有数据且数据小于当前值 nums[i], 要将其放到当前桶的后面，相当于 cpp 中的 push_back while (buckets[bucket_idx][j] > 0 && buckets[bucket_idx][j] < nums[i]) { j++; } float temp = nums[i]; while (j < size && buckets[bucket_idx][j] > 0) { swap(&temp, &buckets[bucket_idx][j]); j++; } buckets[bucket_idx][j] = temp; } // 2. 对各个桶执行排序 for (int i = 0; i < k; i++) { qsort(buckets[i], size, sizeof(float), compare_float); } // 3. 遍历桶合并结果 for (int i = 0, j = 0; j < k; j++) { for (int l = 0; l < size; l++) { if (buckets[j][l] > 0) { nums[i++] = buckets[j][l]; } } } // 释放上述分配的内存 for (int i = 0; i < k; i++) { free(buckets[i]); } free(buckets); } \"]},\"51\":{\"h\":\"8.2 如何实现平均分配\",\"t\":[\"桶排序的时间复杂度理论上可以达到O(n)，关键在于将元素均匀分配到各个桶中，因为实际数据往往不是均匀分布的。例如，我们想要将淘宝上的所有商品按价格范围平均分配到 10 个桶中，但商品价格分布不均，低于 100 元的非常多，高于 1000 元的非常少。若将价格区间平均划分为 10 个，各个桶中的商品数量差距会非常大\",\"为实现平均分配，我们可以先设定一条大致的分界线，将数据粗略地分到 3 个桶中。分配完毕后，再将商品较多的桶继续划分为 3 个桶，直至所有桶中的元素数量大致相等\",\"如下图所示，这种方法本质上是创建一棵递归树，目标是让叶节点的值尽可能平均。当然，不一定要每轮将数据划分为 3 个桶，具体划分方式可根据数据特点灵活选择\",\"如果我们提前知道商品价格的概率分布，则可以根据数据概率分布设置每个桶的价格分界线。值得注意的是，数据分布并不一定需要特意统计，也可以根据数据特点采用某种概率模型进行近似\",\"如下图所示，我们假设商品价格服从正态分布，这样就可以合理地设定价格区间，从而将商品平均分配到各个桶中\"]},\"52\":{\"h\":\"9.计数排序算法\",\"t\":[\"计数排序（counting sort）通过统计元素数量来实现排序，通常应用于整数数组\"]},\"53\":{\"h\":\"9.1 计数排序算法的简单实现\",\"t\":[\"先来看一个简单的例子。给定一个长度为n的数组 nums ，其中的元素都是“非负整数”，计数排序的整体流程如下图所示：\",\"遍历数组，找出其中的最大数字，记为m，然后创建一个长度为m+1的辅助数组 counter\",\"借助 counter 统计 nums 中各数字的出现次数，其中 counter[num] 对应数字 num 的出现次数。统计方法很简单，只需遍历 nums（设当前数字为 num），每轮将 counter[num] 增加1即可\",\"由于 counter 的各个索引天然有序，因此相当于所有数字已经排序好了。接下来，我们遍历 counter ，根据各数字出现次数从小到大的顺序填入 nums 即可\",\"/* 计数排序 */ // 简单实现，无法用于排序对象 void countingSortNaive(int nums[], int size) { // 1. 统计数组最大元素 m int m = 0; for (int i = 0; i < size; i++) { if (nums[i] > m) { m = nums[i]; } } // 2. 统计各数字的出现次数 // counter[num] 代表 num 的出现次数 int *counter = calloc(m + 1, sizeof(int)); for (int i = 0; i < size; i++) { counter[nums[i]]++; } // 3. 遍历 counter ，将各元素填入原数组 nums int i = 0; for (int num = 0; num < m + 1; num++) { for (int j = 0; j < counter[num]; j++, i++) { nums[i] = num; } } // 4. 释放内存 free(counter); } \"]},\"54\":{\"h\":\"9.2 计数排序算法的完整实现\",\"t\":[\"/* 计数排序 */ // 完整实现，可排序对象，并且是稳定排序 void countingSort(int nums[], int size) { // 1. 统计数组最大元素 m int m = 0; for (int i = 0; i < size; i++) { if (nums[i] > m) { m = nums[i]; } } // 2. 统计各数字的出现次数 // counter[num] 代表 num 的出现次数 int *counter = calloc(m, sizeof(int)); for (int i = 0; i < size; i++) { counter[nums[i]]++; } // 3. 求 counter 的前缀和，将“出现次数”转换为“尾索引” // 即 counter[num]-1 是 num 在 res 中最后一次出现的索引 for (int i = 0; i < m; i++) { counter[i + 1] += counter[i]; } // 4. 倒序遍历 nums ，将各元素填入结果数组 res // 初始化数组 res 用于记录结果 int *res = malloc(sizeof(int) * size); for (int i = size - 1; i >= 0; i--) { int num = nums[i]; res[counter[num] - 1] = num; // 将 num 放置到对应索引处 counter[num]--; // 令前缀和自减 1 ，得到下次放置 num 的索引 } // 使用结果数组 res 覆盖原数组 nums memcpy(nums, res, size * sizeof(int)); // 5. 释放内存 free(counter); } \"]},\"55\":{\"h\":\"10.基数排序算法\",\"t\":[\"基数排序（radix sort）的核心思想与计数排序一致，也通过统计个数来实现排序。在此基础上，基数排序利用数字各位之间的递进关系，依次对每一位进行排序，从而得到最终的排序结果\"]},\"56\":{\"h\":\"10.1 基数排序算法流程\",\"t\":[\"以学号数据为例，假设数字的最低位是第1位，最高位是第8位，基数排序的流程如下所示：\",\"初始化位数k=1\",\"对学号的第k位执行“计数排序”。完成后，数据会根据第k位从小到大排序\",\"将k增加1，然后返回步骤 2 继续迭代，直到所有位都排序完成后结束\",\"时间复杂度为O(nk)：设数据量为n、据为d进制、最大位数为k，则对某一位执行计数排序使用O(n+d)时间，排序所有k位使用O((n+d)k)时间。通常情况下，d和k都相对较小，时间复杂度趋向O(n)空间复杂度为O(n+d)、非原地排序：与计数排序相同，基数排序需要借助长度为n和d的数组 res 和 counter稳定排序：当计数排序稳定时，基数排序也稳定；当计数排序不稳定时，基数排序无法保证得到正确的排序结果\",\"/* 获取元素 num 的第 k 位，其中 exp = 10^(k-1) */ int digit(int num, int exp) { // 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算 return (num / exp) % 10; } /* 计数排序（根据 nums 第 k 位排序） */ void countingSortDigit(int nums[], int size, int exp) { // 十进制的位范围为 0~9 ，因此需要长度为 10 的桶数组 int *counter = (int *)malloc((sizeof(int) * 10)); // 统计 0~9 各数字的出现次数 for (int i = 0; i < size; i++) { // 获取 nums[i] 第 k 位，记为 d int d = digit(nums[i], exp); // 统计数字 d 的出现次数 counter[d]++; } // 求前缀和，将“出现个数”转换为“数组索引” for (int i = 1; i < 10; i++) { counter[i] += counter[i - 1]; } // 倒序遍历，根据桶内统计结果，将各元素填入 res int *res = (int *)malloc(sizeof(int) * size); for (int i = size - 1; i >= 0; i--) { int d = digit(nums[i], exp); int j = counter[d] - 1; // 获取 d 在数组中的索引 j res[j] = nums[i]; // 将当前元素填入索引 j counter[d]--; // 将 d 的数量减 1 } // 使用结果覆盖原数组 nums for (int i = 0; i < size; i++) { nums[i] = res[i]; } } /* 基数排序 */ void radixSort(int nums[], int size) { // 获取数组的最大元素，用于判断最大位数 int max = INT32_MIN; for (size_t i = 0; i < size - 1; i++) { if (nums[i] > max) { max = nums[i]; } } // 按照从低位到高位的顺序遍历 for (int exp = 1; max >= exp; exp *= 10) // 对数组元素的第 k 位执行计数排序 // k = 1 -> exp = 1 // k = 2 -> exp = 10 // 即 exp = 10^(k-1) countingSortDigit(nums, size, exp); } \"]},\"57\":{\"h\":\"第十二章：分治\"},\"58\":{\"h\":\"1.分治基本概念\",\"t\":[\"分治（divide and conquer），全称分而治之，是一种非常重要且常见的算法策略。分治通常基于递归实现，包括“分”和“治”两个步骤\",\"分（划分阶段）：递归地将原问题分解为两个或多个子问题，直至到达最小子问题时终止\",\"治（合并阶段）：从已知解的最小子问题开始，从底至顶地将子问题的解进行合并，从而构建出原问题的解\"]},\"59\":{\"h\":\"2.如何判断分治问题\",\"t\":[\"一个问题是否适合使用分治解决，通常可以参考以下几个判断依据：\",\"问题可以分解：原问题可以分解成规模更小、类似的子问题，以及能够以相同方式递归地进行划分\",\"子问题是独立的：子问题之间没有重叠，互不依赖，可以独立解决\",\"子问题的解可以合并：原问题的解通过合并子问题的解得来\",\"显然，归并排序满足以上三个判断依据：\",\"问题可以分解：递归地将数组（原问题）划分为两个子数组（子问题）\",\"子问题是独立的：每个子数组都可以独立地进行排序（子问题可以独立进行求解）\",\"子问题的解可以合并：两个有序子数组（子问题的解）可以合并为一个有序数组（原问题的解）\"]},\"60\":{\"h\":\"3.通过分治提高效率\",\"t\":[\"分治不仅可以有效地解决算法问题，往往还可以提升算法效率。在排序算法中，快速排序、归并排序、堆排序相较于选择、冒泡、插入排序更快，就是因为它们应用了分治策略\",\"那么，我们不禁发问：为什么分治可以提升算法效率，其底层逻辑是什么？换句话说，将大问题分解为多个子问题、解决子问题、将子问题的解合并为原问题的解，这几步的效率为什么比直接解决原问题的效率更高？这个问题可以从操作数量和并行计算两方面来讨论\"]},\"61\":{\"h\":\"3.1 操作数量优化\",\"t\":[\"以“冒泡排序”为例，其处理一个长度为n的数组需要O(n^2)时间。假设我们按照下图所示的方式，将数组从中点处分为两个子数组，则划分需要O(n)时间，排序每个子数组需要O((n/2) ^2)时间，合并两个子数组需要O(n)时间，总体时间复杂度为：\",\"接下来，我们计算以下不等式，其左边和右边分别为划分前和划分后的操作总数：\"]},\"62\":{\"h\":\"3.2 并行计算优化\",\"t\":[\"我们知道，分治生成的子问题是相互独立的，因此通常可以并行解决。也就是说，分治不仅可以降低算法的时间复杂度，还有利于操作系统的并行优化\",\"并行优化在多核或多处理器的环境中尤其有效，因为系统可以同时处理多个子问题，更加充分地利用计算资源，从而显著减少总体的运行时间\",\"比如在下图所示的“桶排序”中，我们将海量的数据平均分配到各个桶中，则可所有桶的排序任务分散到各个计算单元，完成后再合并结果\"]},\"63\":{\"h\":\"4.分治的常见应用\",\"t\":[\"一方面，分治可以用来解决许多经典算法问题：\",\"寻找最近点对：该算法首先将点集分成两部分，然后分别找出两部分中的最近点对，最后找出跨越两部分的最近点对\",\"大整数乘法：例如 Karatsuba 算法，它将大整数乘法分解为几个较小的整数的乘法和加法\",\"矩阵乘法：例如 Strassen 算法，它将大矩阵乘法分解为多个小矩阵的乘法和加法\",\"汉诺塔问题：汉诺塔问题可以通过递归解决，这是典型的分治策略应用\",\"求解逆序对：在一个序列中，如果前面的数字大于后面的数字，那么这两个数字构成一个逆序对。求解逆序对问题可以利用分治的思想，借助归并排序进行求解\",\"另一方面，分治在算法和数据结构的设计中应用得非常广泛：\",\"二分查找：二分查找是将有序数组从中点索引处分为两部分，然后根据目标值与中间元素值比较结果，决定排除哪一半区间，并在剩余区间执行相同的二分操作\",\"归并排序：本节开头已介绍，不再赘述\",\"快速排序：快速排序是选取一个基准值，然后把数组分为两个子数组，一个子数组的元素比基准值小，另一子数组的元素比基准值大，再对这两部分进行相同的划分操作，直至子数组只剩下一个元素\",\"桶排序：桶排序的基本思想是将数据分散到多个桶，然后对每个桶内的元素进行排序，最后将各个桶的元素依次取出，从而得到一个有序数组\",\"树：例如二叉搜索树、AVL 树、红黑树、B 树、B+ 树等，它们的查找、插入和删除等操作都可以视为分治策略的应用\",\"堆：堆是一种特殊的完全二叉树，其各种操作，如插入、删除和堆化，实际上都隐含了分治的思想\",\"哈希表：虽然哈希表并不直接应用分治，但某些哈希冲突解决方案间接应用了分治策略，例如，链式地址中的长链表会被转化为红黑树，以提升查询效率\",\"可以看出，分治是一种“润物细无声”的算法思想，隐含在各种算法与数据结构之中\"]},\"64\":{\"h\":\"5.分治搜索策略\",\"t\":[\"我们已经学过，搜索算法分为两大类：\",\"暴力搜索：它通过遍历数据结构实现，时间复杂度为O(n)\",\"自适应搜索：它利用特有的数据组织形式或先验信息，时间复杂度可达到O(logn)，甚至O(1)\",\"实际上，时间复杂度为O(logn)的搜索算法通常是基于分治策略实现的，例如二分查找和树\",\"二分查找的每一步都将问题（在数组中搜索目标元素）分解为一个小问题（在数组的一半中搜索目标元素），这个过程一直持续到数组为空或找到目标元素为止\",\"树是分治思想的代表，在二叉搜索树、AVL 树、堆等数据结构中，各种操作的时间复杂度皆为O(logn)\",\"二分查找的分治策略如下所示:\",\"问题可以分解：二分查找递归地将原问题（在数组中进行查找）分解为子问题（在数组的一半中进行查找），这是通过比较中间元素和目标元素来实现的\",\"子问题是独立的：在二分查找中，每轮只处理一个子问题，它不受其他子问题的影响\",\"子问题的解无须合并：二分查找旨在查找一个特定元素，因此不需要将子问题的解进行合并。当子问题得到解决时，原问题也会同时得到解决\",\"分治能够提升搜索效率，本质上是因为暴力搜索每轮只能排除一个选项，而分治搜索每轮可以排除一半选项\",\"在之前的章节中，二分查找是基于递推（迭代）实现的。现在我们基于分治（递归）来实现它\",\"在实现代码中，我们声明一个递归函数 dfs() 来求解问题f(i,j)：\",\"/* 二分查找：问题 f(i, j) */ int dfs(int nums[], int target, int i, int j) { // 若区间为空，代表无目标元素，则返回 -1 if (i > j) { return -1; } // 计算中点索引 m int m = (i + j) / 2; if (nums[m] < target) { // 递归子问题 f(m+1, j) return dfs(nums, target, m + 1, j); } else if (nums[m] > target) { // 递归子问题 f(i, m-1) return dfs(nums, target, i, m - 1); } else { // 找到目标元素，返回其索引 return m; } } /* 二分查找 */ int binarySearch(int nums[], int target, int numsSize) { int n = numsSize; // 求解问题 f(0, n-1) return dfs(nums, target, 0, n - 1); } \"]},\"65\":{\"h\":\"6.构建树问题\",\"t\":[\"问题：给定一棵二叉树的前序遍历 preorder 和中序遍历 inorder ，请从中构建二叉树，返回二叉树的根节点。假设二叉树中没有值重复的节点（如图下图）\"]},\"66\":{\"h\":\"6.1 判断是否为分治问题\",\"t\":[\"问题定义为从 preorder 和 inorder 构建二叉树，是一个典型的分治问题\",\"问题可以分解：从分治的角度切入，我们可以将原问题划分为两个子问题：构建左子树、构建右子树，加上一步操作：初始化根节点。而对于每棵子树（子问题），我们仍然可以复用以上划分方法，将其划分为更小的子树（子问题），直至达到最小子问题（空子树）时终止\",\"子问题是独立的：左子树和右子树是相互独立的，它们之间没有交集。在构建左子树时，我们只需关注中序遍历和前序遍历中与左子树对应的部分。右子树同理\",\"子问题的解可以合并：一旦得到了左子树和右子树（子问题的解），我们就可以将它们链接到根节点上，得到原问题的解\"]},\"67\":{\"h\":\"6.2 如何划分子树\",\"t\":[\"根据以上分析，这道题可以使用分治来求解，但如何通过前序遍历 preorder 和中序遍历 inorder 来划分左子树和右子树呢？\",\"根据定义，preorder 和 inorder 都可以划分为三个部分：\",\"前序遍历：[ 根节点 | 左子树 | 右子树 ] ，例如上图的树对应 [ 3 | 9 | 2 1 7 ]\",\"中序遍历：[ 左子树 | 根节点 ｜ 右子树 ] ，例如上图的树对应 [ 9 | 3 | 1 2 7 ]\",\"以上图数据为例，我们可以通过下图所示的步骤得到划分结果：\",\"前序遍历的首元素 3 是根节点的值\",\"查找根节点 3 在 inorder 中的索引，利用该索引可将 inorder 划分为 [ 9 | 3 ｜ 1 2 7 ]\",\"根据 inorder 的划分结果，易得左子树和右子树的节点数量分别为 1 和 3 ，从而可将 preorder 划分为 [ 3 | 9 | 2 1 7 ]\"]},\"68\":{\"h\":\"6.3 基于变量描述子树区间\",\"t\":[\"根据以上划分方法，我们已经得到根节点、左子树、右子树在 preorder 和 inorder 中的索引区间。而为了描述这些索引区间，我们需要借助几个指针变量\",\"将当前树的根节点在 preorder 中的索引记为i\",\"将当前树的根节点在 inorder 中的索引记为m\",\"将当前树在 inorder 中的索引区间记为[l,r]\",\"通过以上变量即可表示根节点在 preorder 中的索引，以及子树在 inorder 中的索引区间\",\"请注意，右子树根节点索引中的(m-l)的含义是“左子树的节点数量”，建议结合下图理解：\"]},\"69\":{\"h\":\"6.4 构建树问题代码实现\",\"t\":[\"为了提升查询m的效率，我们借助一个哈希表 hmap 来存储数组 inorder 中元素到索引的映射：\",\"下图展示了构建二叉树的递归过程，各个节点是在向下“递”的过程中建立的，而各条边（引用）是在向上“归”的过程中建立的\",\"每个递归函数内的前序遍历 preorder 和中序遍历 inorder 的划分结果如下图所示\",\"设树的节点数量为n，初始化每一个节点（执行一个递归函数 dfs() ）使用 O(1)时间。因此总体时间复杂度为O(n) 哈希表存储 inorder 元素到索引的映射，空间复杂度为O(n)。在最差情况下，即二叉树退化为链表时，递归深度达到n，使用O(n)的栈帧空间。因此总体空间复杂度为O(n) \",\"/* 构建二叉树：分治 */ TreeNode *dfs(int *preorder, int *inorderMap, int i, int l, int r, int size) { // 子树区间为空时终止 if (r - l < 0) return NULL; // 初始化根节点 TreeNode *root = (TreeNode *)malloc(sizeof(TreeNode)); root->val = preorder[i]; root->left = NULL; root->right = NULL; // 查询 m ，从而划分左右子树 int m = inorderMap[preorder[i]]; // 子问题：构建左子树 root->left = dfs(preorder, inorderMap, i + 1, l, m - 1, size); // 子问题：构建右子树 root->right = dfs(preorder, inorderMap, i + 1 + m - l, m + 1, r, size); // 返回根节点 return root; } /* 构建二叉树 */ TreeNode *buildTree(int *preorder, int preorderSize, int *inorder, int inorderSize) { // 初始化哈希表，存储 inorder 元素到索引的映射 int *inorderMap = (int *)malloc(sizeof(int) * MAX_SIZE); for (int i = 0; i < inorderSize; i++) { inorderMap[inorder[i]] = i; } TreeNode *root = dfs(preorder, inorderMap, 0, 0, inorderSize - 1, inorderSize); free(inorderMap); return root; } \"]},\"70\":{\"h\":\"7.汉诺塔问题\",\"t\":[\"在归并排序和构建二叉树中，我们都是将原问题分解为两个规模为原问题一半的子问题。然而对于汉诺塔问题，我们采用不同的分解策略\",\"问题：\",\"给定三根柱子，记为 A、B 和 C 。起始状态下，柱子 A 上套着n个圆盘，它们从上到下按照从小到大的顺序排列。我们的任务是要把这n个圆盘移到柱子 C 上，并保持它们的原有顺序不变（如图下图所示）。在移动圆盘的过程中，需要遵守以下规则 1.圆盘只能从一根柱子顶部拿出，从另一根柱子顶部放入。 2.每次只能移动一个圆盘。 3.小圆盘必须时刻位于大圆盘之上。 \"]},\"71\":{\"h\":\"7.1 考虑基本情况\",\"t\":[\"如下图所示，对于问题f(1)，即当只有一个圆盘时，我们将它直接从 A 移动至 C 即可\",\"如下图所示，对于问题f(2)，即当有两个圆盘时，由于要时刻满足小圆盘在大圆盘之上，因此需要借助 B 来完成移动\",\"先将上面的小圆盘从 A 移至 B\",\"再将大圆盘从 A 移至 C\",\"最后将小圆盘从 B 移至 C\"]},\"72\":{\"h\":\"7.2 子问题分解\",\"t\":[\"对于问题f(3)，即当有三个圆盘时，情况变得稍微复杂了一些\",\"因为已知f(1)、f(2)的解，所以我们可从分治角度思考，将 A 顶部的两个圆盘看作一个整体，执行下图所示的步骤。这样三个圆盘就被顺利地从 A 移至 C 了\",\"B 为目标柱、C 为缓冲柱，将两个圆盘从 A 移至 B\",\"将 A 中剩余的一个圆盘从 A 直接移动至 C\",\"令 C 为目标柱、A 为缓冲柱，将两个圆盘从 B 移至 C\",\"从本质上看，我们将问题f(3)划分为两个子问题f(2)、f(1)。按顺序解决这三个子问题之后，原问题随之得到解决。这说明子问题是独立的，而且解可以合并\",\"至此，我们可总结出图下图所示的解决汉诺塔问题的分治策略：将原问题f(n)划分为两个子问题f(n-1)和一个子问题f(1)，并按照以下顺序解决这三个子问题\",\"将n-1个圆盘借助 C 从 A 移至 B\",\"将剩余1个圆盘从 A 直接移至 C\",\"将n-1个圆盘借助 A 从 B 移至 C\",\"对于这两个子问题f(n-1) ，可以通过相同的方式进行递归划分，直至达到最小子问题f(1)。而f(1)的解是已知的，只需一次移动操作即可\"]},\"73\":{\"h\":\"7.3 汉诺塔问题代码实现\",\"t\":[\"在代码中，我们声明一个递归函数 dfs(i, src, buf, tar) ，它的作用是将柱 src 顶部的i个圆盘借助缓冲柱 buf 移动至目标柱 tar ：\",\"如下图所示，汉诺塔问题形成一棵高度为n的递归树，每个节点代表一个子问题，对应一个开启的 dfs() 函数，因此时间复杂度为O(2^n)，空间复杂度为O(n)\",\"/* 移动一个圆盘 */ void move(int *src, int *srcSize, int *tar, int *tarSize) { // 从 src 顶部拿出一个圆盘 int pan = src[*srcSize - 1]; src[*srcSize - 1] = 0; (*srcSize)--; // 将圆盘放入 tar 顶部 tar[*tarSize] = pan; (*tarSize)++; } /* 求解汉诺塔问题 f(i) */ void dfs(int i, int *src, int *srcSize, int *buf, int *bufSize, int *tar, int *tarSize) { // 若 src 只剩下一个圆盘，则直接将其移到 tar if (i == 1) { move(src, srcSize, tar, tarSize); return; } // 子问题 f(i-1) ：将 src 顶部 i-1 个圆盘借助 tar 移到 buf dfs(i - 1, src, srcSize, tar, tarSize, buf, bufSize); // 子问题 f(1) ：将 src 剩余一个圆盘移到 tar move(src, srcSize, tar, tarSize); // 子问题 f(i-1) ：将 buf 顶部 i-1 个圆盘借助 src 移到 tar dfs(i - 1, buf, bufSize, src, srcSize, tar, tarSize); } /* 求解汉诺塔问题 */ void solveHanota(int *A, int *ASize, int *B, int *BSize, int *C, int *CSize) { // 将 A 顶部 n 个圆盘借助 B 移到 C dfs(*ASize, A, ASize, B, BSize, C, CSize); } \"]},\"74\":{\"h\":\"第十三章：回溯\",\"t\":[\"回溯算法（backtracking algorithm）是一种通过穷举来解决问题的方法，它的核心思想是从一个初始状态出发，暴力搜索所有可能的解决方案，当遇到正确的解则将其记录，直到找到解或者尝试了所有可能的选择都无法找到解为止\",\"回溯算法通常采用“深度优先搜索”来遍历解空间。在“二叉树”章节中，我们提到前序、中序和后序遍历都属于深度优先搜索。接下来，我们利用前序遍历构造一个回溯问题，逐步了解回溯算法的工作原理\",\"问题：给定一棵二叉树，搜索并记录所有值为8的节点，请返回节点列表\",\"对于此题，我们前序遍历这棵树，并判断当前节点的值是否为7，若是，则将该节点的值加入结果列表 res 之中。相关过程实现如下图和以下代码所示：\",\"/* 前序遍历：例题一 */ void preOrder(TreeNode *root) { if (root == NULL) { return; } if (root->val == 7) { // 记录解 res[resSize++] = root; } preOrder(root->left); preOrder(root->right); } \"]},\"75\":{\"h\":\"1.尝试与回退\",\"t\":[\"之所以称之为回溯算法，是因为该算法在搜索解空间时会采用“尝试”与“回退”的策略。当算法在搜索过程中遇到某个状态无法继续前进或无法得到满足条件的解时，它会撤销上一步的选择，退回到之前的状态，并尝试其他可能的选择\",\"对于例题一，访问每个节点都代表一次“尝试”，而越过叶节点或返回父节点的 return 则表示“回退”\",\"值得说明的是，回退并不仅仅包括函数返回。为解释这一点，我们对例题一稍作拓展\",\"问题2：在二叉树中搜索所有值为7的节点，请返回根节点到这些节点的路径\",\"在例题一代码的基础上，我们需要借助一个列表 path 记录访问过的节点路径。当访问到值为7的节点时，则复制 path 并添加进结果列表 res 。遍历完成后，res 中保存的就是所有的解。代码如下所示：\",\"/* 前序遍历：例题二 */ void preOrder(TreeNode *root) { if (root == NULL) { return; } // 尝试 path[pathSize++] = root; if (root->val == 7) { // 记录解 for (int i = 0; i < pathSize; ++i) { res[resSize][i] = path[i]; } resSize++; } preOrder(root->left); preOrder(root->right); // 回退 pathSize--; } \",\"在每次“尝试”中，我们通过将当前节点添加进 path 来记录路径；而在“回退”前，我们需要将该节点从 path 中弹出，以恢复本次尝试之前的状态\",\"观察下图所示的过程，我们可以将尝试和回退理解为“前进”与“撤销”，两个操作互为逆向\"]},\"76\":{\"h\":\"2.剪枝\",\"t\":[\"复杂的回溯问题通常包含一个或多个约束条件，约束条件通常可用于“剪枝”\",\"问题3：在二叉树中搜索所有值为7的节点，请返回根节点到这些节点的路径，并要求路径中不包含值为3的节点\",\"为了满足以上约束条件，我们需要添加剪枝操作：在搜索过程中，若遇到值为3的节点，则提前返回，不再继续搜索。代码如下所示：\",\"“剪枝”是一个非常形象的名词。如下图所示，在搜索过程中，我们“剪掉”了不满足约束条件的搜索分支，避免许多无意义的尝试，从而提高了搜索效率\",\"/* 前序遍历：例题三 */ void preOrder(TreeNode *root) { // 剪枝 if (root == NULL || root->val == 3) { return; } // 尝试 path[pathSize++] = root; if (root->val == 7) { // 记录解 for (int i = 0; i < pathSize; i++) { res[resSize][i] = path[i]; } resSize++; } preOrder(root->left); preOrder(root->right); // 回退 pathSize--; } \"]},\"77\":{\"h\":\"3.框架代码\",\"t\":[\"接下来，我们尝试将回溯的“尝试、回退、剪枝”的主体框架提炼出来，提升代码的通用性\",\"以下框架代码中，state 表示问题的当前状态，choices 表示当前状态下可以做出的选择：\",\"/* 回溯算法框架 */ void backtrack(State *state, Choice *choices, int numChoices, State *res, int numRes) { // 判断是否为解 if (isSolution(state)) { // 记录解 recordSolution(state, res, numRes); // 不再继续搜索 return; } // 遍历所有选择 for (int i = 0; i < numChoices; i++) { // 剪枝：判断选择是否合法 if (isValid(state, &choices[i])) { // 尝试：做出选择，更新状态 makeChoice(state, &choices[i]); backtrack(state, choices, numChoices, res, numRes); // 回退：撤销选择，恢复到之前的状态 undoChoice(state, &choices[i]); } } } \",\"接下来，我们基于框架代码来解决例题三。状态 state 为节点遍历路径，选择 choices 为当前节点的左子节点和右子节点，结果 res 是路径列表：\",\"根据题意，我们在找到值为7的节点后应该继续搜索，因此需要将记录解之后的 return 语句删除。下图对比了保留或删除 return 语句的搜索过程\",\"相比基于前序遍历的代码实现，基于回溯算法框架的代码实现虽然显得啰唆，但通用性更好。实际上，许多回溯问题可以在该框架下解决。我们只需根据具体问题来定义 state 和 choices ，并实现框架中的各个方法即可\",\"/* 判断当前状态是否为解 */ bool isSolution(void) { return pathSize > 0 && path[pathSize - 1]->val == 7; } /* 记录解 */ void recordSolution(void) { for (int i = 0; i < pathSize; i++) { res[resSize][i] = path[i]; } resSize++; } /* 判断在当前状态下，该选择是否合法 */ bool isValid(TreeNode *choice) { return choice != NULL && choice->val != 3; } /* 更新状态 */ void makeChoice(TreeNode *choice) { path[pathSize++] = choice; } /* 恢复状态 */ void undoChoice(void) { pathSize--; } /* 回溯算法：例题三 */ void backtrack(TreeNode *choices[2]) { // 检查是否为解 if (isSolution()) { // 记录解 recordSolution(); } // 遍历所有选择 for (int i = 0; i < 2; i++) { TreeNode *choice = choices[i]; // 剪枝：检查选择是否合法 if (isValid(choice)) { // 尝试：做出选择，更新状态 makeChoice(choice); // 进行下一轮选择 TreeNode *nextChoices[2] = {choice->left, choice->right}; backtrack(nextChoices); // 回退：撤销选择，恢复到之前的状态 undoChoice(); } } } \"]},\"78\":{\"h\":\"4.优点与缺点\",\"t\":[\"回溯算法本质上是一种深度优先搜索算法，它尝试所有可能的解决方案直到找到满足条件的解。这种方法的优点在于能够找到所有可能的解决方案，而且在合理的剪枝操作下，具有很高的效率\",\"然而，在处理大规模或者复杂问题时，回溯算法的运行效率可能难以接受\",\"时间：回溯算法通常需要遍历状态空间的所有可能，时间复杂度可以达到指数阶或阶乘阶\",\"空间：在递归调用中需要保存当前的状态（例如路径、用于剪枝的辅助变量等），当深度很大时，空间需求可能会变得很大\",\"即便如此，回溯算法仍然是某些搜索问题和约束满足问题的最佳解决方案。对于这些问题，由于无法预测哪些选择可生成有效的解，因此我们必须对所有可能的选择进行遍历。在这种情况下，关键是如何优化效率，常见的效率优化方法有两种\",\"剪枝：避免搜索那些肯定不会产生解的路径，从而节省时间和空间\",\"启发式搜索：在搜索过程中引入一些策略或者估计值，从而优先搜索最有可能产生有效解的路径\"]},\"79\":{\"h\":\"5.回溯算法经典例题\",\"t\":[\"回溯算法可用于解决许多搜索问题、约束满足问题和组合优化问题\",\"搜索问题：这类问题的目标是找到满足特定条件的解决方案\",\"全排列问题：给定一个集合，求出其所有可能的排列组合\",\"子集和问题：给定一个集合和一个目标和，找到集合中所有和为目标和的子集\",\"汉诺塔问题：给定三根柱子和一系列大小不同的圆盘，要求将所有圆盘从一根柱子移动到另一根柱子，每次只能移动一个圆盘，且不能将大圆盘放在小圆盘上\",\"约束满足问题：这类问题的目标是找到满足所有约束条件的解\",\"n皇后：在nxn 的棋盘上放置n个皇后，使得它们互不攻击\",\"数独：在9x9的网格中填入数字1~9，使得每行、每列和每个3x3子网格中的数字不重复\",\"图着色问题：给定一个无向图，用最少的颜色给图的每个顶点着色，使得相邻顶点颜色不同\",\"组合优化问题：这类问题的目标是在一个组合空间中找到满足某些条件的最优解\",\"0-1 背包问题：给定一组物品和一个背包，每个物品有一定的价值和重量，要求在背包容量限制内，选择物品使得总价值最大\",\"旅行商问题：在一个图中，从一个点出发，访问所有其他点恰好一次后返回起点，求最短路径\",\"最大团问题：给定一个无向图，找到最大的完全子图，即子图中的任意两个顶点之间都有边相连\",\"请注意，对于许多组合优化问题，回溯不是最优解决方案\",\"0-1 背包问题通常使用动态规划解决，以达到更高的时间效率\",\"旅行商是一个著名的 NP-Hard 问题，常用解法有遗传算法和蚁群算法等\",\"最大团问题是图论中的一个经典问题，可用贪心算法等启发式算法来解决\"]},\"80\":{\"h\":\"6.全排列问题\",\"t\":[\"全排列问题是回溯算法的一个典型应用。它的定义是在给定一个集合（如一个数组或字符串）的情况下，找出其中元素的所有可能的排列\",\"下图列举了几个示例数据，包括输入数组和对应的所有排列\"]},\"81\":{\"h\":\"6.1 无相等元素的情况\",\"t\":[\"问题：输入一个整数数组，其中不包含重复元素，返回所有可能的排列\",\"从回溯算法的角度看，我们可以把生成排列的过程想象成一系列选择的结果。假设输入数组为[1,2,3]，如果我们先选择1，再选择3，最后选择2，则获得排列[1,3,2]。回退表示撤销一个选择，之后继续尝试其他选择\",\"从回溯代码的角度看，候选集合 choices 是输入数组中的所有元素，状态 state 是直至目前已被选择的元素。请注意，每个元素只允许被选择一次，因此 state 中的所有元素都应该是唯一的\",\"如下图所示，我们可以将搜索过程展开成一棵递归树，树中的每个节点代表当前状态 state 。从根节点开始，经过三轮选择后到达叶节点，每个叶节点都对应一个排列\",\"（1）重新选择剪枝\",\"为了实现每个元素只被选择一次，我们考虑引入一个布尔型数组 selected ，其中 selected[i] 表示 choices[i] 是否已被选择，并基于它实现以下剪枝操作\",\"在做出选择 choice[i] 后，我们就将 selected[i] 赋值为True，代表它已被选择\",\"遍历选择列表 choices 时，跳过所有已被选择的节点，即剪枝\",\"如下图所示，假设我们第一轮选择 1 ，第二轮选择 3 ，第三轮选择 2 ，则需要在第二轮剪掉元素 1 的分支，在第三轮剪掉元素 1 和元素 3 的分支\",\"观察上图发现，该剪枝操作将搜索空间大小从O(n^n)减小至O(n!)\",\"（2）代码实现\",\"想清楚以上信息之后，我们就可以在框架代码中做“完形填空”了。为了缩短整体代码，我们不单独实现框架代码中的各个函数，而是将它们展开在 backtrack() 函数中：\",\"/* 回溯算法：全排列 I */ void backtrack(int *state, int stateSize, int *choices, int choicesSize, bool *selected, int **res, int *resSize) { // 当状态长度等于元素数量时，记录解 if (stateSize == choicesSize) { res[*resSize] = (int *)malloc(choicesSize * sizeof(int)); for (int i = 0; i < choicesSize; i++) { res[*resSize][i] = state[i]; } (*resSize)++; return; } // 遍历所有选择 for (int i = 0; i < choicesSize; i++) { int choice = choices[i]; // 剪枝：不允许重复选择元素 if (!selected[i]) { // 尝试：做出选择，更新状态 selected[i] = true; state[stateSize] = choice; // 进行下一轮选择 backtrack(state, stateSize + 1, choices, choicesSize, selected, res, resSize); // 回退：撤销选择，恢复到之前的状态 selected[i] = false; } } } /* 全排列 I */ int **permutationsI(int *nums, int numsSize, int *returnSize) { int *state = (int *)malloc(numsSize * sizeof(int)); bool *selected = (bool *)malloc(numsSize * sizeof(bool)); for (int i = 0; i < numsSize; i++) { selected[i] = false; } int **res = (int **)malloc(MAX_SIZE * sizeof(int *)); *returnSize = 0; backtrack(state, 0, nums, numsSize, selected, res, returnSize); free(state); free(selected); return res; } \"]},\"82\":{\"h\":\"6.2 考虑相等元素情况\",\"t\":[\"问题：输入一个整数数组，数组中可能包含重复元素，返回所有不重复的排列\",\"假设输入数组为[1,1,2]。为了方便区分两个重复元素1，我们将第二个1记为i\",\"如下图所示，上述方法生成的排列有一半是重复的\",\"那么如何去除重复的排列呢？最直接地，考虑借助一个哈希表，直接对排列结果进行去重。然而这样做不够优雅，因为生成重复排列的搜索分支没有必要，应当提前识别并剪枝，这样可以进一步提升算法效率\",\"（1）相等元素剪枝\",\"观察下图，在第一轮中，选择1或选择1^ 是等价的，在这两个选择之下生成的所有排列都是重复的。因此应该把1^ 剪枝\",\"同理，在第一轮选择2之后，第二轮选择中的1和1^ 也会产生重复分支，因此也应将第二轮的1^ 剪枝\",\"从本质上看，我们的目标是在某一轮选择中，保证多个相等的元素仅被选择一次\",\"（2）代码实现\",\"在上一题的代码的基础上，我们考虑在每一轮选择中开启一个哈希表 duplicated ，用于记录该轮中已经尝试过的元素，并将重复元素剪枝：\",\"/* 回溯算法：全排列 II */ void backtrack(int *state, int stateSize, int *choices, int choicesSize, bool *selected, int **res, int *resSize) { // 当状态长度等于元素数量时，记录解 if (stateSize == choicesSize) { res[*resSize] = (int *)malloc(choicesSize * sizeof(int)); for (int i = 0; i < choicesSize; i++) { res[*resSize][i] = state[i]; } (*resSize)++; return; } // 遍历所有选择 bool duplicated[MAX_SIZE] = {false}; for (int i = 0; i < choicesSize; i++) { int choice = choices[i]; // 剪枝：不允许重复选择元素 且 不允许重复选择相等元素 if (!selected[i] && !duplicated[choice]) { // 尝试：做出选择，更新状态 duplicated[choice] = true; // 记录选择过的元素值 selected[i] = true; state[stateSize] = choice; // 进行下一轮选择 backtrack(state, stateSize + 1, choices, choicesSize, selected, res, resSize); // 回退：撤销选择，恢复到之前的状态 selected[i] = false; } } } /* 全排列 II */ int **permutationsII(int *nums, int numsSize, int *returnSize) { int *state = (int *)malloc(numsSize * sizeof(int)); bool *selected = (bool *)malloc(numsSize * sizeof(bool)); for (int i = 0; i < numsSize; i++) { selected[i] = false; } int **res = (int **)malloc(MAX_SIZE * sizeof(int *)); *returnSize = 0; backtrack(state, 0, nums, numsSize, selected, res, returnSize); free(state); free(selected); return res; } \",\"假设元素两两之间互不相同，则n个元素共有n!种排列（阶乘）；在记录结果时，需要复制长度为n的列表，使用O(n) 时间。因此时间复杂度为O(n!n)\",\"最大递归深度为n，使用O(n)栈帧空间。selected 使用O(n)空间。同一时刻最多共有n个duplicated ，使用O(n^ 2)空间。因此空间复杂度为O(n^ 2)\"]},\"83\":{\"h\":\"6.3 两种剪枝对比\",\"t\":[\"请注意，虽然 selected 和 duplicated 都用于剪枝，但两者的目标不同\",\"重复选择剪枝：整个搜索过程中只有一个 selected 。它记录的是当前状态中包含哪些元素，其作用是避免某个元素在 state 中重复出现\",\"相等元素剪枝：每轮选择（每个调用的 backtrack 函数）都包含一个 duplicated 。它记录的是在本轮遍历（for 循环）中哪些元素已被选择过，其作用是保证相等元素只被选择一次\",\"下图展示了两个剪枝条件的生效范围。注意，树中的每个节点代表一个选择，从根节点到叶节点的路径上的各个节点构成一个排列\"]},\"84\":{\"h\":\"7.子集和问题\"},\"85\":{\"h\":\"7.1 无重复元素的情况\",\"t\":[\"问题：给定一个正整数数组 nums 和一个目标正整数 target ，请找出所有可能的组合，使得组合中的元素和等于 target 。给定数组无重复元素，每个元素可以被选取多次。请以列表形式返回这些组合，列表中不应包含重复组合\",\"例如，输入集合{3,4,5}和目标整数9，解为{3,3,3},{4,5}。需要注意两点：\",\"输入集合中的元素可以被无限次重复选取\",\"子集不区分元素顺序，比如{4,5}和{5,4}是同一个子集\",\"（1）参考全排列解法\",\"类似于全排列问题，我们可以把子集的生成过程想象成一系列选择的结果，并在选择过程中实时更新“元素和”，当元素和等于 target 时，就将子集记录至结果列表\",\"而与全排列问题不同的是，本题集合中的元素可以被无限次选取，因此无须借助 selected 布尔列表来记录元素是否已被选择。我们可以对全排列代码进行小幅修改，初步得到解题代码：\",\"/* 回溯算法：子集和 I */ void backtrack(int target, int total, int *choices, int choicesSize) { // 子集和等于 target 时，记录解 if (total == target) { for (int i = 0; i < stateSize; i++) { res[resSize][i] = state[i]; } resColSizes[resSize++] = stateSize; return; } // 遍历所有选择 for (int i = 0; i < choicesSize; i++) { // 剪枝：若子集和超过 target ，则跳过该选择 if (total + choices[i] > target) { continue; } // 尝试：做出选择，更新元素和 total state[stateSize++] = choices[i]; // 进行下一轮选择 backtrack(target, total + choices[i], choices, choicesSize); // 回退：撤销选择，恢复到之前的状态 stateSize--; } } /* 求解子集和 I（包含重复子集） */ void subsetSumINaive(int *nums, int numsSize, int target) { resSize = 0; // 初始化解的数量为0 backtrack(target, 0, nums, numsSize); } \",\"向以上代码输入数组[3,4,5]和目标9，输出结果为[3,3,3],[4,5],[5,4]。虽然成功找出了所有和为9的子集，但其中存在重复的子集[4,5]和[5,4]\",\"这是因为搜索过程是区分选择顺序的，然而子集不区分选择顺序。如下图所示，先选4后选5与先选5后选4是不同的分支，但对应同一个子集\",\"为了去除重复子集，一种直接的思路是对结果列表进行去重。但这个方法效率很低，有两方面原因：\",\"当数组元素较多，尤其是当 target 较大时，搜索过程会产生大量的重复子集\",\"比较子集（数组）的异同非常耗时，需要先排序数组，再比较数组中每个元素的异同\",\"（2）重复子集剪枝\",\"我们考虑在搜索过程中通过剪枝进行去重。观察下图，重复子集是在以不同顺序选择数组元素时产生的，例如以下情况\",\"当第一轮和第二轮分别选择3和4时，会生成包含这两个元素的所有子集，记为[3,4,...]\",\"之后，当第一轮选择4时，则第二轮应该跳过3，因为该选择产生的子集[4,3,...]和第1步中产生的子集完全重复\",\"在搜索过程中，每一层的选择都是从左到右被逐个尝试的，因此越靠右的分支被剪掉的越多\",\"前两轮选择3和5，生成子集[3,5,...]\",\"前两轮选择4和5，生成子集[4,5,...]\",\"若第一轮选择5，则第二轮应该跳过3和4，因为子集[5,3,...]和[5,4,...]与第1步和第2步中描述的子集完全重复\",\"总结来看，给定输入数组[x1,x2,...,xn]，设搜索过程中的选择序列为[xi1,xi2,...,xim]，则该选择序列需要满足i1 ≤ i2 ≤ ... ≤ im，不满足该条件的选择序列都会造成重复，应当剪枝\",\"（3）代码实现\",\"下图所示为将数组[3,4,5]和目标9输入以下代码后的整体回溯效果\",\"/* 回溯算法：子集和 I */ void backtrack(int target, int *choices, int choicesSize, int start) { // 子集和等于 target 时，记录解 if (target == 0) { for (int i = 0; i < stateSize; ++i) { res[resSize][i] = state[i]; } resColSizes[resSize++] = stateSize; return; } // 遍历所有选择 // 剪枝二：从 start 开始遍历，避免生成重复子集 for (int i = start; i < choicesSize; i++) { // 剪枝一：若子集和超过 target ，则直接结束循环 // 这是因为数组已排序，后边元素更大，子集和一定超过 target if (target - choices[i] < 0) { break; } // 尝试：做出选择，更新 target, start state[stateSize] = choices[i]; stateSize++; // 进行下一轮选择 backtrack(target - choices[i], choices, choicesSize, i); // 回退：撤销选择，恢复到之前的状态 stateSize--; } } /* 求解子集和 I */ void subsetSumI(int *nums, int numsSize, int target) { qsort(nums, numsSize, sizeof(int), cmp); // 对 nums 进行排序 int start = 0; // 遍历起始点 backtrack(target, nums, numsSize, start); } \"]},\"86\":{\"h\":\"7.2 考虑重复元素情况\",\"t\":[\"问题：给定一个正整数数组 nums 和一个目标正整数 target ，请找出所有可能的组合，使得组合中的元素和等于 target 。给定数组可能包含重复元素，每个元素只可被选择一次。请以列表形式返回这些组合，列表中不应包含重复组合\",\"相比于上题，本题的输入数组可能包含重复元素，这引入了新的问题。例如，给定数组[4,4^,5]和目标元素9，则现有代码的输出结果为[4,5]，[4 ^,5]，出现了重复子集\",\"造成这种重复的原因是相等元素在某轮中被多次选择。在下图中，第一轮共有三个选择，其中两个都为4，会产生两个重复的搜索分支，从而输出重复子集；同理，第二轮的两个4也会产生重复子集\",\"（1）相等元素剪枝\",\"为解决此问题，我们需要限制相等元素在每一轮中只能被选择一次。实现方式比较巧妙：由于数组是已排序的，因此相等元素都是相邻的。这意味着在某轮选择中，若当前元素与其左边元素相等，则说明它已经被选择过，因此直接跳过当前元素\",\"与此同时，本题规定每个数组元素只能被选择一次。幸运的是，我们也可以利用变量 start 来满足该约束：当做出选择xi后，设定下一轮从索引i+1开始向后遍历。这样既能去除重复子集，也能避免重复选择元素\",\"（2）代码实现\",\"下图展示了数组[4,4,5]和目标元素9的回溯过程，共包含四种剪枝操作。请你将图示与代码注释相结合，理解整个搜索过程，以及每种剪枝操作是如何工作的\",\"/* 回溯算法：子集和 II */ void backtrack(int target, int *choices, int choicesSize, int start) { // 子集和等于 target 时，记录解 if (target == 0) { for (int i = 0; i < stateSize; i++) { res[resSize][i] = state[i]; } resColSizes[resSize++] = stateSize; return; } // 遍历所有选择 // 剪枝二：从 start 开始遍历，避免生成重复子集 // 剪枝三：从 start 开始遍历，避免重复选择同一元素 for (int i = start; i < choicesSize; i++) { // 剪枝一：若子集和超过 target ，则直接跳过 if (target - choices[i] < 0) { continue; } // 剪枝四：如果该元素与左边元素相等，说明该搜索分支重复，直接跳过 if (i > start && choices[i] == choices[i - 1]) { continue; } // 尝试：做出选择，更新 target, start state[stateSize] = choices[i]; stateSize++; // 进行下一轮选择 backtrack(target - choices[i], choices, choicesSize, i + 1); // 回退：撤销选择，恢复到之前的状态 stateSize--; } } /* 求解子集和 II */ void subsetSumII(int *nums, int numsSize, int target) { // 对 nums 进行排序 qsort(nums, numsSize, sizeof(int), cmp); // 开始回溯 backtrack(target, nums, numsSize, 0); } \"]},\"87\":{\"h\":\"8.N皇后问题\",\"t\":[\"问题：根据国际象棋的规则，皇后可以攻击与同处一行、一列或一条斜线上的棋子。给定n个皇后和一个nxn大小的棋盘，寻找使得所有皇后之间无法相互攻击的摆放方案\",\"如下图所示，当n=4时，共可以找到两个解。从回溯算法的角度看，nxn大小的棋盘共有n^2个格子，给出了所有的选择 choices 。在逐个放置皇后的过程中，棋盘状态在不断地变化，每个时刻的棋盘就是状态 state\",\"下图展示了本题的三个约束条件：多个皇后不能在同一行、同一列、同一条对角线上。值得注意的是，对角线分为主对角线 \\\\ 和次对角线 / 两种\"]},\"88\":{\"h\":\"8.1 逐行放置策略\",\"t\":[\"皇后的数量和棋盘的行数都为n，因此我们容易得到一个推论：棋盘每行都允许且只允许放置一个皇后\",\"也就是说，我们可以采取逐行放置策略：从第一行开始，在每行放置一个皇后，直至最后一行结束\",\"下图所示为4皇后问题的逐行放置过程。受画幅限制，下图仅展开了第一行的其中一个搜索分支，并且将不满足列约束和对角线约束的方案都进行了剪枝\",\"从本质上看，逐行放置策略起到了剪枝的作用，它避免了同一行出现多个皇后的所有搜索分支\"]},\"89\":{\"h\":\"8.2 列与对角线剪枝\",\"t\":[\"为了满足列约束，我们可以利用一个长度为n的布尔型数组 cols 记录每一列是否有皇后。在每次决定放置前，我们通过 cols 将已有皇后的列进行剪枝，并在回溯中动态更新 cols 的状态\",\"那么，如何处理对角线约束呢？设棋盘中某个格子的行列索引为(row,col)，选定矩阵中的某条主对角线，我们发现该对角线上所有格子的行索引减列索引都相等，即对角线上所有格子的row-col为恒定值\",\"也就是说，如果两个格子满足row1-col1=row2-col2，则它们一定处在同一条主对角线上。利用该规律，我们可以借助下图所示的数组 diags1 记录每条主对角线上是否有皇后\",\"同理，次对角线上的所有格子的row+col是恒定值。我们同样也可以借助数组 diags2 来处理次对角线约束\"]},\"90\":{\"h\":\"8.3 代码实现\",\"t\":[\"请注意，n维方阵中row-col的范围是[-n+1,n-1]，row+col的范围是[0,2n-2]，所以主对角线和次对角线的数量都为2n-1，即数组diags1 和 diags2 的长度都为2n-1\",\"/* 回溯算法：n 皇后 */ void backtrack(int row, int n, char state[MAX_SIZE][MAX_SIZE], char ***res, int *resSize, bool cols[MAX_SIZE],bool diags1[2 * MAX_SIZE - 1], bool diags2[2 * MAX_SIZE - 1]) { // 当放置完所有行时，记录解 if (row == n) { res[*resSize] = (char **)malloc(sizeof(char *) * n); for (int i = 0; i < n; ++i) { res[*resSize][i] = (char *)malloc(sizeof(char) * (n + 1)); strcpy(res[*resSize][i], state[i]); } (*resSize)++; return; } // 遍历所有列 for (int col = 0; col < n; col++) { // 计算该格子对应的主对角线和次对角线 int diag1 = row - col + n - 1; int diag2 = row + col; // 剪枝：不允许该格子所在列、主对角线、次对角线上存在皇后 if (!cols[col] && !diags1[diag1] && !diags2[diag2]) { // 尝试：将皇后放置在该格子 state[row][col] = 'Q'; cols[col] = diags1[diag1] = diags2[diag2] = true; // 放置下一行 backtrack(row + 1, n, state, res, resSize, cols, diags1, diags2); // 回退：将该格子恢复为空位 state[row][col] = '#'; cols[col] = diags1[diag1] = diags2[diag2] = false; } } } /* 求解 n 皇后 */ char ***nQueens(int n, int *returnSize) { char state[MAX_SIZE][MAX_SIZE]; // 初始化 n*n 大小的棋盘，其中 'Q' 代表皇后，'#' 代表空位 for (int i = 0; i < n; ++i) { for (int j = 0; j < n; ++j) { state[i][j] = '#'; } state[i][n] = '\\\\0'; } bool cols[MAX_SIZE] = {false}; // 记录列是否有皇后 bool diags1[2 * MAX_SIZE - 1] = {false}; // 记录主对角线上是否有皇后 bool diags2[2 * MAX_SIZE - 1] = {false}; // 记录次对角线上是否有皇后 char ***res = (char ***)malloc(sizeof(char **) * MAX_SIZE); *returnSize = 0; backtrack(0, n, state, res, returnSize, cols, diags1, diags2); return res; } \",\"逐行放置n次，考虑列约束，则从第一行到最后一行分别有n、n-1、...、2、1个选择，使用O(n!)时间。当记录解时，需要复制矩阵 state 并添加进 res ，复制操作使用O(n^2)时间。因此，总体时间复杂度为O(n!n ^2) 。实际上，根据对角线约束的剪枝也能够大幅缩小搜索空间，因而搜索效率往往优于以上时间复杂度\",\"数组 state 使用O(n^2)空间，数组 cols、diags1 和 diags2 皆使用O(n)空间。最大递归深度为n，使用O(n)栈帧空间。因此，空间复杂度为O(n^2)\"]},\"91\":{\"h\":\"第十四章：动态规划\"},\"92\":{\"h\":\"1.动态规划问题探索\",\"t\":[\"动态规划（dynamic programming）是一个重要的算法范式，它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率\",\"在本节中，我们从一个经典例题入手，先给出它的暴力回溯解法，观察其中包含的重叠子问题，再逐步导出更高效的动态规划解法\",\"爬楼梯问题：给定一个共有n阶的楼梯，你每步可以上1阶或2阶，请问有多少种方案可以爬到楼顶？\",\"如下图，对于一个3阶楼梯，共有3种方案可以爬到楼顶\",\"本题的目标是求解方案数量，我们可以考虑通过回溯来穷举所有可能性。具体来说，将爬楼梯想象为一个多轮选择的过程：从地面出发，每轮选择上1阶或2阶，每当到达楼梯顶部时就将方案数量加1，当越过楼梯顶部时就将其剪枝。代码如下所示：\",\"/* 回溯 */ void backtrack(int *choices, int state, int n, int *res, int len) { // 当爬到第 n 阶时，方案数量加 1 if (state == n) res[0]++; // 遍历所有选择 for (int i = 0; i < len; i++) { int choice = choices[i]; // 剪枝：不允许越过第 n 阶 if (state + choice > n) continue; // 尝试：做出选择，更新状态 backtrack(choices, state + choice, n, res, len); // 回退 } } /* 爬楼梯：回溯 */ int climbingStairsBacktrack(int n) { int choices[2] = {1, 2}; // 可选择向上爬 1 阶或 2 阶 int state = 0; // 从第 0 阶开始爬 int *res = (int *)malloc(sizeof(int)); *res = 0; // 使用 res[0] 记录方案数量 int len = sizeof(choices) / sizeof(int); backtrack(choices, state, n, res, len); int result = *res; free(res); return result; } \"]},\"93\":{\"h\":\"1.1 方法一：暴力搜索\",\"t\":[\"回溯算法通常并不显式地对问题进行拆解，而是将求解问题看作一系列决策步骤，通过试探和剪枝，搜索所有可能的解\",\"下图展示了该递推关系：\",\"我们可以根据递推公式得到暴力搜索解法。以dp[n]为为起始点，递归地将一个较大问题拆解为两个较小问题的和，直至到达最小子问题dp[1]和dp[2]时返回。其中，最小子问题的解是已知的，即dp[1]=1、dp[2]=2，表示爬到第1、2阶分别有1、2种方案\",\"观察以下代码，它和标准回溯代码都属于深度优先搜索，但更加简洁：\",\"/* 搜索 */ int dfs(int i) { // 已知 dp[1] 和 dp[2] ，返回之 if (i == 1 || i == 2) return i; // dp[i] = dp[i-1] + dp[i-2] int count = dfs(i - 1) + dfs(i - 2); return count; } /* 爬楼梯：搜索 */ int climbingStairsDFS(int n) { return dfs(n); } \",\"下图展示了暴力搜索形成的递归树。对于问题dp[n]，其递归树的深度为n，时间复杂度为O(2^n)。指数阶属于爆炸式增长，如果我们输入一个比较大的n，则会陷入漫长的等待之中\"]},\"94\":{\"h\":\"1.2 方法二：记忆化搜索\",\"t\":[\"为了提升算法效率，我们希望所有的重叠子问题都只被计算一次。为此，我们声明一个数组 mem 来记录每个子问题的解，并在搜索过程中将重叠子问题剪枝\",\"当首次计算dp[i]时，我们将其记录至 mem[i] ，以便之后使用\",\"当再次需要计算dp[i]时，我们便可直接从 mem[i] 中获取结果，从而避免重复计算该子问题\",\"代码如下所示：\",\"/* 记忆化搜索 */ int dfs(int i, int *mem) { // 已知 dp[1] 和 dp[2] ，返回之 if (i == 1 || i == 2) return i; // 若存在记录 dp[i] ，则直接返回之 if (mem[i] != -1) return mem[i]; // dp[i] = dp[i-1] + dp[i-2] int count = dfs(i - 1, mem) + dfs(i - 2, mem); // 记录 dp[i] mem[i] = count; return count; } /* 爬楼梯：记忆化搜索 */ int climbingStairsDFSMem(int n) { // mem[i] 记录爬到第 i 阶的方案总数，-1 代表无记录 int *mem = (int *)malloc((n + 1) * sizeof(int)); for (int i = 0; i <= n; i++) { mem[i] = -1; } int result = dfs(n, mem); free(mem); return result; } \",\"如下图，经过记忆化处理后，所有重叠子问题都只需计算一次，时间复杂度优化至O(n)，这是一个巨大的飞跃\"]},\"95\":{\"h\":\"1.3 方法三：动态规划\",\"t\":[\"记忆化搜索是一种“从顶至底”的方法：我们从原问题（根节点）开始，递归地将较大子问题分解为较小子问题，直至解已知的最小子问题（叶节点）。之后，通过回溯逐层收集子问题的解，构建出原问题的解\",\"与之相反，动态规划是一种“从底至顶”的方法：从最小子问题的解开始，迭代地构建更大子问题的解，直至得到原问题的解\",\"由于动态规划不包含回溯过程，因此只需使用循环迭代实现，无须使用递归。在以下代码中，我们初始化一个数组 dp 来存储子问题的解，它起到了与记忆化搜索中数组 mem 相同的记录作用：\",\"/* 爬楼梯：动态规划 */ int climbingStairsDP(int n) { if (n == 1 || n == 2) return n; // 初始化 dp 表，用于存储子问题的解 int *dp = (int *)malloc((n + 1) * sizeof(int)); // 初始状态：预设最小子问题的解 dp[1] = 1; dp[2] = 2; // 状态转移：从较小子问题逐步求解较大子问题 for (int i = 3; i <= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } int result = dp[n]; free(dp); return result; } \",\"下图模拟了以上代码的执行过程：\",\"与回溯算法一样，动态规划也使用“状态”概念来表示问题求解的特定阶段，每个状态都对应一个子问题以及相应的局部最优解。例如，爬楼梯问题的状态定义为当前所在楼梯阶数i\",\"根据以上内容，我们可以总结出动态规划的常用术语：\",\"将数组 dp 称为 dp 表，dp[i]表示状态i对应子问题的解\",\"将最小子问题对应的状态（第1阶和第2阶楼梯）称为初始状态\",\"将递推公式dp[i]=dp[i-1]+dp[i-2]称为状态转移方程\"]},\"96\":{\"h\":\"1.4 空间优化\",\"t\":[\"细心的读者可能发现了，由于dp[i]只与dp[i-1]和dp[i-2]有关，因此我们无须使用一个数组 dp 来存储所有子问题的解，而只需两个变量滚动前进即可。代码如下所示：\",\"/* 爬楼梯：空间优化后的动态规划 */ int climbingStairsDPComp(int n) { if (n == 1 || n == 2) return n; int a = 1, b = 2; for (int i = 3; i <= n; i++) { int tmp = b; b = a + b; a = tmp; } return b; } \",\"观察以上代码，由于省去了数组 dp 占用的空间，因此空间复杂度从O(n)降低至O(1)\",\"在动态规划问题中，当前状态往往仅与前面有限个状态有关，这时我们可以只保留必要的状态，通过“降维”来节省内存空间。这种空间优化技巧被称为“滚动变量”或“滚动数组”\"]},\"97\":{\"h\":\"2.DP问题特性\",\"t\":[\"我们学习动态规划是如何通过子问题分解来求解原问题的。实际上，子问题分解是一种通用的算法思路，在分治、动态规划、回溯中的侧重点不同\",\"分治算法递归地将原问题划分为多个相互独立的子问题，直至最小子问题，并在回溯中合并子问题的解，最终得到原问题的解\",\"动态规划也对问题进行递归分解，但与分治算法的主要区别是，动态规划中的子问题是相互依赖的，在分解过程中会出现许多重叠子问题\",\"回溯算法在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。原问题的解由一系列决策步骤构成，我们可以将每个决策步骤之前的子序列看作一个子问题\",\"实际上，动态规划常用来求解最优化问题，它们不仅包含重叠子问题，还具有另外两大特性：最优子结构、无后效性\"]},\"98\":{\"h\":\"2.1 最优子结构\",\"t\":[\"我们对爬楼梯问题稍作改动，使之更加适合展示最优子结构概念\",\"爬楼梯做小代价问题：给定一个楼梯，你每步可以上1阶或2阶，每一阶楼梯上都贴有一个非负整数，表示你在该台阶所需要付出的代价。给定一个非负整数数组cost，其中cost[i]表示在第i个台阶需要付出的代价，cost[0]为地面（起始点）。请计算最少需要付出多少代价才能到达顶部？\",\"如下图所示，若第1、2、3阶的代价分别为1、10、1，则从地面爬到第3阶的最小代价为2\",\"/* 爬楼梯最小代价：动态规划 */ int minCostClimbingStairsDP(int cost[], int costSize) { int n = costSize - 1; if (n == 1 || n == 2) return cost[n]; // 初始化 dp 表，用于存储子问题的解 int *dp = calloc(n + 1, sizeof(int)); // 初始状态：预设最小子问题的解 dp[1] = cost[1]; dp[2] = cost[2]; // 状态转移：从较小子问题逐步求解较大子问题 for (int i = 3; i <= n; i++) { dp[i] = myMin(dp[i - 1], dp[i - 2]) + cost[i]; } int res = dp[n]; // 释放内存 free(dp); return res; } \",\"下图展示了以上代码的动态规划过程：\",\"本题也可以进行空间优化，将一维压缩至零维，使得空间复杂度从O(n)降至O(1)：\",\"/* 爬楼梯最小代价：空间优化后的动态规划 */ int minCostClimbingStairsDPComp(int cost[], int costSize) { int n = costSize - 1; if (n == 1 || n == 2) return cost[n]; int a = cost[1], b = cost[2]; for (int i = 3; i <= n; i++) { int tmp = b; b = myMin(a, tmp) + cost[i]; a = tmp; } return b; } \"]},\"99\":{\"h\":\"2.2 无后效性\",\"t\":[\"无后效性是动态规划能够有效解决问题的重要特性之一，其定义为：给定一个确定的状态，它的未来发展只与当前状态有关，而与过去经历的所有状态无关\",\"以爬楼梯问题为例，给定状态i，它会发展出状态i+1和状态i+2，分别对应跳1步和跳2步。在做出这两种选择时，我们无须考虑状态i之前的状态，它们对状态i的未来没有影响\",\"然而，如果我们给爬楼梯问题添加一个约束，情况就不一样了\",\"带约束的爬楼梯问题：给定一个共有n个楼梯，你每步可以上1阶或2阶，但不能连续两轮跳1阶，请问有多少种方案可以爬到楼顶？\",\"如下图所示，爬上3阶仅剩下2种可行方案，其中连续三次跳1阶的方案不满足约束条件，因此被舍弃\",\"最终，返回dp[n,1]+dp[n,2]即可，两者之和代表爬到第n阶的方案总数：\",\"/* 带约束爬楼梯：动态规划 */ int climbingStairsConstraintDP(int n) { if (n == 1 || n == 2) { return 1; } // 初始化 dp 表，用于存储子问题的解 int **dp = malloc((n + 1) * sizeof(int *)); for (int i = 0; i <= n; i++) { dp[i] = calloc(3, sizeof(int)); } // 初始状态：预设最小子问题的解 dp[1][1] = 1; dp[1][2] = 0; dp[2][1] = 0; dp[2][2] = 1; // 状态转移：从较小子问题逐步求解较大子问题 for (int i = 3; i <= n; i++) { dp[i][1] = dp[i - 1][2]; dp[i][2] = dp[i - 2][1] + dp[i - 2][2]; } int res = dp[n][1] + dp[n][2]; // 释放内存 for (int i = 0; i <= n; i++) { free(dp[i]); } free(dp); return res; } \",\"在上面的案例中，由于仅需多考虑前面一个状态，因此我们仍然可以通过扩展状态定义，使得问题重新满足无后效性。然而，某些问题具有非常严重的“有后效性”\"]},\"100\":{\"h\":\"3.DP解题思路\"},\"101\":{\"h\":\"3.1 问题判断\",\"t\":[\"总的来说，如果一个问题包含重叠子问题、最优子结构，并满足无后效性，那么它通常适合用动态规划求解。然而，我们很难从问题描述中直接提取出这些特性。因此我们通常会放宽条件，先观察问题是否适合使用回溯（穷举）解决\",\"适合用回溯解决的问题通常满足“决策树模型”，这种问题可以使用树形结构来描述，其中每一个节点代表一个决策，每一条路径代表一个决策序列\",\"换句话说，如果问题包含明确的决策概念，并且解是通过一系列决策产生的，那么它就满足决策树模型，通常可以使用回溯来解决\",\"在此基础上，动态规划问题还有一些判断的“加分项”：\",\"问题包含最大（小）或最多（少）等最优化描述\",\"问题的状态能够使用一个列表、多维矩阵或树来表示，并且一个状态与其周围的状态存在递推关系\",\"相应地，也存在一些“减分项”：\",\"问题的目标是找出所有可能的解决方案，而不是找出最优解\",\"问题描述中有明显的排列组合的特征，需要返回具体的多个方案\",\"如果一个问题满足决策树模型，并具有较为明显的“加分项”，我们就可以假设它是一个动态规划问题，并在求解过程中验证它\"]},\"102\":{\"h\":\"3.2 问题求解步骤\",\"t\":[\"动态规划的解题流程会因问题的性质和难度而有所不同，但通常遵循以下步骤：描述决策，定义状态，建立dp表，推导状态转移方程，确定边界条件等\",\"为了更形象地展示解题步骤，我们使用一个经典问题“最小路径和”来举例\",\"问题：给定一个nxm的二维网络grid，网格中的每个单元格包含一个非负整数，表示该单元格的代价。机器人以左上角单元格为起始点，每次只能向下或者向右移动一步，直至到达右下角单元格。请返回从左上角到右下角的最小路径和\",\"下图展示了一个例子，给定网格的最小路径和为13\",\"本题的每一轮的决策就是从当前格子向下或向右走一步。设当前格子的行列索引为[i,j]，则向下或向右走一步后，索引变为[i+1,j]或[i,j+1] 。因此，状态应包含行索引和列索引两个变量，记为[i,j]状态[i,h]对应的子问题是：从起始点[0,0]走到[i,j]的最小路径和，解记为dp[i,j]自此，我们就得到了下图所示的二维dp矩阵，其尺寸与输入网格grid相同\",\"在本题中，处在首行的状态只能从其左边的状态得来，处在首列的状态只能从其上边的状态得来，因此首行i=0和首列j=0 是边界条件\",\"如下图所示，由于每个格子是由其左方格子和上方格子转移而来，因此我们使用循环来遍历矩阵，外循环遍历各行，内循环遍历各列\"]},\"103\":{\"h\":\"3.3 方法一：暴力搜索\",\"t\":[\"/* 最小路径和：暴力搜索 */ int minPathSumDFS(int grid[MAX_SIZE][MAX_SIZE], int i, int j) { // 若为左上角单元格，则终止搜索 if (i == 0 && j == 0) { return grid[0][0]; } // 若行列索引越界，则返回 +∞ 代价 if (i < 0 || j < 0) { return INT_MAX; } // 计算从左上角到 (i-1, j) 和 (i, j-1) 的最小路径代价 int up = minPathSumDFS(grid, i - 1, j); int left = minPathSumDFS(grid, i, j - 1); // 返回从左上角到 (i, j) 的最小路径代价 return myMin(left, up) != INT_MAX ? myMin(left, up) + grid[i][j] : INT_MAX; } \",\"下图给出了以dp[2,1]为根节点的递归树，其中包含一些重叠子问题，其数量会随着网格 grid 的尺寸变大而急剧增多\",\"从本质上看，造成重叠子问题的原因为：存在多条路径可以从左上角到达某一单元格\",\"每个状态都有向下和向右两种选择，从左上角走到右下角总共需要m+n-2步，所以最差时间复杂度为O(2^ m+2)。请注意，这种计算方式未考虑临近网格边界的情况，当到达网络边界时只剩下一种选择，因此实际的路径数量会少一些\"]},\"104\":{\"h\":\"3.4 方法二：记忆化搜索\",\"t\":[\"我们引入一个和网格 grid 相同尺寸的记忆列表 mem ，用于记录各个子问题的解，并将重叠子问题进行剪枝：\",\"/* 最小路径和：记忆化搜索 */ int minPathSumDFSMem(int grid[MAX_SIZE][MAX_SIZE], int mem[MAX_SIZE][MAX_SIZE], int i, int j) { // 若为左上角单元格，则终止搜索 if (i == 0 && j == 0) { return grid[0][0]; } // 若行列索引越界，则返回 +∞ 代价 if (i < 0 || j < 0) { return INT_MAX; } // 若已有记录，则直接返回 if (mem[i][j] != -1) { return mem[i][j]; } // 左边和上边单元格的最小路径代价 int up = minPathSumDFSMem(grid, mem, i - 1, j); int left = minPathSumDFSMem(grid, mem, i, j - 1); // 记录并返回左上角到 (i, j) 的最小路径代价 mem[i][j] = myMin(left, up) != INT_MAX ? myMin(left, up) + grid[i][j] : INT_MAX; return mem[i][j]; } \",\"如下图所示，在引入记忆化后，所有子问题的解只需计算一次，因此时间复杂度取决于状态总数，即网格尺寸O(mn)\"]},\"105\":{\"h\":\"3.5 方法三：动态规划\",\"t\":[\"基于迭代实现动态规划解法，代码如下所示：\",\"/* 最小路径和：动态规划 */ int minPathSumDP(int grid[MAX_SIZE][MAX_SIZE], int n, int m) { // 初始化 dp 表 int **dp = malloc(n * sizeof(int *)); for (int i = 0; i < n; i++) { dp[i] = calloc(m, sizeof(int)); } dp[0][0] = grid[0][0]; // 状态转移：首行 for (int j = 1; j < m; j++) { dp[0][j] = dp[0][j - 1] + grid[0][j]; } // 状态转移：首列 for (int i = 1; i < n; i++) { dp[i][0] = dp[i - 1][0] + grid[i][0]; } // 状态转移：其余行和列 for (int i = 1; i < n; i++) { for (int j = 1; j < m; j++) { dp[i][j] = myMin(dp[i][j - 1], dp[i - 1][j]) + grid[i][j]; } } int res = dp[n - 1][m - 1]; // 释放内存 for (int i = 0; i < n; i++) { free(dp[i]); } return res; } \",\"下图展示了最小路径和的状态转移过程，其遍历了整个网格，因此时间复杂度为O(nm)，数组dp大小为nxm，因此空间复杂度为O(nm)\"]},\"106\":{\"h\":\"3.6 空间优化\",\"t\":[\"由于每个格子只与其左边和上边的格子有关，因此我们可以只用一个单行数组来实现dp表\",\"请注意，因为数组 dp 只能表示一行的状态，所以我们无法提前初始化首列状态，而是在遍历每行时更新它：\",\"/* 最小路径和：空间优化后的动态规划 */ int minPathSumDPComp(int grid[MAX_SIZE][MAX_SIZE], int n, int m) { // 初始化 dp 表 int *dp = calloc(m, sizeof(int)); // 状态转移：首行 dp[0] = grid[0][0]; for (int j = 1; j < m; j++) { dp[j] = dp[j - 1] + grid[0][j]; } // 状态转移：其余行 for (int i = 1; i < n; i++) { // 状态转移：首列 dp[0] = dp[0] + grid[i][0]; // 状态转移：其余列 for (int j = 1; j < m; j++) { dp[j] = myMin(dp[j - 1], dp[j]) + grid[i][j]; } } int res = dp[m - 1]; // 释放内存 free(dp); return res; } \"]},\"107\":{\"h\":\"4.0-1背包问题\",\"t\":[\"背包问题是一个非常好的动态规划入门题目，是动态规划中最常见的问题形式。其具有很多变种，例如 0-1 背包问题、完全背包问题、多重背包问题等\",\"在本节中，我们先来求解最常见的 0-1 背包问题\",\"问题：给定n个物品，第i个物品的重量为wgt[i-1]、价值为val[i-1]，和一个容量为cap的背包。每个物品只能选择一次，问在限定背包容量下能放入物品的最大价值\",\"如下图，由于物品编号i从1开始计数，数组索引从0开始计数，因此物品i对应重量wgt[i-1]和价值val[i-1]\",\"我们可以将 0-1 背包问题看作一个由n轮决策组成的过程，对于每个物体都有不放入和放入两种决策，因此该问题满足决策树模型\",\"该问题的目标是求解“在限定背包容量下能放入物品的最大价值”，因此较大概率是一个动态规划问题\"]},\"108\":{\"h\":\"4.1 方法一：暴力搜索\",\"t\":[\"搜索代码包含以下要素：\",\"递归参数：状态[i,c]\",\"返回值：子问题的解dp[i,c]\",\"终止条件：当物品编号越界i=0或背包剩余容量为0时，终止递归并返回价值0\",\"剪枝：若当前物品重量超出背包剩余容量，则只能选择不放入背包\",\"/* 0-1 背包：暴力搜索 */ int knapsackDFS(int wgt[], int val[], int i, int c) { // 若已选完所有物品或背包无剩余容量，则返回价值 0 if (i == 0 || c == 0) { return 0; } // 若超过背包容量，则只能选择不放入背包 if (wgt[i - 1] > c) { return knapsackDFS(wgt, val, i - 1, c); } // 计算不放入和放入物品 i 的最大价值 int no = knapsackDFS(wgt, val, i - 1, c); int yes = knapsackDFS(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1]; // 返回两种方案中价值更大的那一个 return myMax(no, yes); } \",\"如下图所示，由于每个物品都会产生不选和选两条搜索分支，因此时间复杂度为O(2^n)\",\"观察递归树，容易发现其中存在重叠子问题，例如dp[1,10]等。而当物品较多、背包容量较大，尤其是相同重量的物品较多时，重叠子问题的数量将会大幅增多\"]},\"109\":{\"h\":\"4.2 方法二：记忆化搜索\",\"t\":[\"为了保证重叠子问题只被计算一次，我们借助记忆列表 mem 来记录子问题的解，其中 mem[i][c] 对应dp[i,c]\",\"引入记忆化之后，时间复杂度取决于子问题数量，也就是O(n x cap)。实现代码如下\",\"/* 0-1 背包：记忆化搜索 */ int knapsackDFSMem(int wgt[], int val[], int memCols, int **mem, int i, int c) { // 若已选完所有物品或背包无剩余容量，则返回价值 0 if (i == 0 || c == 0) { return 0; } // 若已有记录，则直接返回 if (mem[i][c] != -1) { return mem[i][c]; } // 若超过背包容量，则只能选择不放入背包 if (wgt[i - 1] > c) { return knapsackDFSMem(wgt, val, memCols, mem, i - 1, c); } // 计算不放入和放入物品 i 的最大价值 int no = knapsackDFSMem(wgt, val, memCols, mem, i - 1, c); int yes = knapsackDFSMem(wgt, val, memCols, mem, i - 1, c - wgt[i - 1]) + val[i - 1]; // 记录并返回两种方案中价值更大的那一个 mem[i][c] = myMax(no, yes); return mem[i][c]; } \",\"下图展示了在记忆化搜索中被剪掉的搜索分支：\"]},\"110\":{\"h\":\"4.3 方法三：动态规划\",\"t\":[\"动态规划实质上就是在状态转移中填充dp表的过程，代码如下所示：\",\"/* 0-1 背包：动态规划 */ int knapsackDP(int wgt[], int val[], int cap, int wgtSize) { int n = wgtSize; // 初始化 dp 表 int **dp = malloc((n + 1) * sizeof(int *)); for (int i = 0; i <= n; i++) { dp[i] = calloc(cap + 1, sizeof(int)); } // 状态转移 for (int i = 1; i <= n; i++) { for (int c = 1; c <= cap; c++) { if (wgt[i - 1] > c) { // 若超过背包容量，则不选物品 i dp[i][c] = dp[i - 1][c]; } else { // 不选和选物品 i 这两种方案的较大值 dp[i][c] = myMax(dp[i - 1][c], dp[i - 1][c - wgt[i - 1]] + val[i - 1]); } } } int res = dp[n][cap]; // 释放内存 for (int i = 0; i <= n; i++) { free(dp[i]); } return res; } \",\"如下图所示，时间复杂度和空间复杂度都由数组 dp 大小决定，即O(n x cap)\"]},\"111\":{\"h\":\"4.4 空间优化\",\"t\":[\"由于每个状态都只与其上一行的状态有关，因此我们可以使用两个数组滚动前进，将空间复杂度从O(n^2)降至O(n)\",\"进一步思考，我们能否仅用一个数组实现空间优化呢？观察可知，每个状态都是由正上方或左上方的格子转移过来的。假设只有一个数组，当开始遍历第i行时，该数组存储的仍然是第i-1行的状态\",\"如果采取正序遍历，那么遍历到dp[i,j]时，左上方dp[i-1,1]~dp[i-1,j-1]值可能已经被覆盖，此时就无法得到正确的状态转移结果\",\"如果采取倒序遍历，则不会发生覆盖问题，状态转移可以正确进行\",\"下图展示了在单个数组下从第i=1行转换至第i=2行的过程\",\"在代码实现中，我们仅需将数组 dp 的第一维i直接删除，，并且把内循环更改为倒序遍历即可：\",\"/* 0-1 背包：空间优化后的动态规划 */ int knapsackDPComp(int wgt[], int val[], int cap, int wgtSize) { int n = wgtSize; // 初始化 dp 表 int *dp = calloc(cap + 1, sizeof(int)); // 状态转移 for (int i = 1; i <= n; i++) { // 倒序遍历 for (int c = cap; c >= 1; c--) { if (wgt[i - 1] <= c) { // 不选和选物品 i 这两种方案的较大值 dp[c] = myMax(dp[c], dp[c - wgt[i - 1]] + val[i - 1]); } } } int res = dp[cap]; // 释放内存 free(dp); return res; } \"]},\"112\":{\"h\":\"第十五章：贪心\"},\"113\":{\"h\":\"1.贪心算法\",\"t\":[\"贪心算法（greedy algorithm）是一种常见的解决优化问题的算法，其基本思想是在问题的每个决策阶段，都选择当前看起来最优的选择，即贪心地做出局部最优的决策，以期获得全局最优解。贪心算法简洁且高效，在许多实际问题中有着广泛的应用\",\"贪心算法和动态规划都常用于解决优化问题。它们之间存在一些相似之处，比如都依赖最优子结构性质，但工作原理不同\",\"动态规划会根据之前阶段的所有决策来考虑当前决策，并使用过去子问题的解来构建当前子问题的解\",\"贪心算法不会考虑过去的决策，而是一路向前地进行贪心选择，不断缩小问题范围，直至问题被解决\",\"问题：给定n种硬币，第i种硬币的面值为coins[i-1]，目标金额为amt，每种硬币可以重复选取，问能够凑出目标金额的最少硬币数量。如果无法凑出目标金额，则返回-1\",\"本题采取的贪心策略如下图所示。给定目标金额，我们贪心地选择不大于且最接近它的硬币，不断循环该步骤，直至凑出目标金额为止\",\"实现代码如下所示：\",\"/* 零钱兑换：贪心 */ int coinChangeGreedy(int *coins, int size, int amt) { // 假设 coins 列表有序 int i = size - 1; int count = 0; // 循环进行贪心选择，直到无剩余金额 while (amt > 0) { // 找到小于且最接近剩余金额的硬币 while (i > 0 && coins[i] > amt) { i--; } // 选择 coins[i] amt -= coins[i]; count++; } // 若未找到可行方案，则返回 -1 return amt == 0 ? count : -1; } \",\"你可能会不由地发出感叹：So clean ！贪心算法仅用约十行代码就解决了零钱兑换问题\"]},\"114\":{\"h\":\"2.贪心算法的优点与缺点\",\"t\":[\"也就是说，对于零钱兑换问题，贪心算法无法保证找到全局最优解，并且有可能找到非常差的解。它更适合用动态规划解决\",\"一般情况下，贪心算法的适用情况分以下两种：\",\"可以保证找到最优解：贪心算法在这种情况下往往是最优选择，因为它往往比回溯、动态规划更高效\",\"可以找到近似最优解：贪心算法在这种情况下也是可用的。对于很多复杂问题来说，寻找全局最优解非常困难，能以较高效率找到次优解也是非常不错的\"]},\"115\":{\"h\":\"3.贪心算法特征\"},\"116\":{\"h\":\"4.贪心算法解题步骤\"},\"117\":{\"h\":\"5.贪心算法经典问题\",\"t\":[\"贪心算法常常应用在满足贪心选择性质和最优子结构的优化问题中，以下列举了一些典型的贪心算法问题\",\"硬币找零问题：在某些硬币组合下，贪心算法总是可以得到最优解\",\"区间调度问题：假设你有一些任务，每个任务在一段时间内进行，你的目标是完成尽可能多的任务。如果每次都选择结束时间最早的任务，那么贪心算法就可以得到最优解\",\"分数背包问题：给定一组物品和一个载重量，你的目标是选择一组物品，使得总重量不超过载重量，且总价值最大。如果每次都选择性价比最高（价值 / 重量）的物品，那么贪心算法在一些情况下可以得到最优解\",\"股票买卖问题：给定一组股票的历史价格，你可以进行多次买卖，但如果你已经持有股票，那么在卖出之前不能再买，目标是获取最大利润\",\"霍夫曼编码：霍夫曼编码是一种用于无损数据压缩的贪心算法。通过构建霍夫曼树，每次选择出现频率最低的两个节点合并，最后得到的霍夫曼树的带权路径长度（编码长度）最小\",\"Dijkstra 算法：它是一种解决给定源顶点到其余各顶点的最短路径问题的贪心算法\"]},\"118\":{\"h\":\"6.分数背包问题\",\"t\":[\"问题：给定n个物品，第i个物品的重量为wgt[i-1]、价值为val[i-1]，和一个容量为cap的背包。每个物品只能选择一次，但可以选择物品的一部分，价值根据选择的重量比例计算，问在限定背包容量下背包中物品的最大价值。如下图所示：\",\"分数背包问题和 0-1 背包问题整体上非常相似，状态包含当前物品i和容量c，目标是求限定背包容量下的最大价值\",\"不同点在于，本题允许只选择物品的一部分。如下图所示，我们可以对物品任意地进行切分，并按照重量比例来计算相应价值\",\"对于物品i，它在单位重量下的价值为val[i-1]/wgt[i-1]，简称单位价值\",\"假设放入一部分物品i，重量为w，则背包增加的价值为w x val[i-1] / wgt[i-1]\"]},\"119\":{\"h\":\"6.1 贪心策略确定\",\"t\":[\"最大化背包内物品总价值，本质上是最大化单位重量下的物品价值。由此便可推理出下图所示的贪心策略\",\"将物品按照单位价值从高到低进行排序\",\"遍历所有物品，每轮贪心地选择单位价值最高的物品\",\"若剩余背包容量不足，则使用当前物品的一部分填满背包\"]},\"120\":{\"h\":\"6.2 代码实现\",\"t\":[\"我们建立了一个物品类 Item ，以便将物品按照单位价值进行排序。循环进行贪心选择，当背包已满时跳出并返回解：\",\"/* 物品 */ typedef struct { int w; // 物品重量 int v; // 物品价值 } Item; /* 分数背包：贪心 */ float fractionalKnapsack(int wgt[], int val[], int itemCount, int cap) { // 创建物品列表，包含两个属性：重量、价值 Item *items = malloc(sizeof(Item) * itemCount); for (int i = 0; i < itemCount; i++) { items[i] = (Item){.w = wgt[i], .v = val[i]}; } // 按照单位价值 item.v / item.w 从高到低进行排序 qsort(items, (size_t)itemCount, sizeof(Item), sortByValueDensity); // 循环贪心选择 float res = 0.0; for (int i = 0; i < itemCount; i++) { if (items[i].w <= cap) { // 若剩余容量充足，则将当前物品整个装进背包 res += items[i].v; cap -= items[i].w; } else { // 若剩余容量不足，则将当前物品的一部分装进背包 res += (float)cap / items[i].w * items[i].v; cap = 0; break; } } free(items); return res; } \",\"除排序之外，在最差情况下，需要遍历整个物品列表，因此时间复杂度为O(n)，其中n为物品数量\",\"由于初始化了一个 Item 对象列表，因此空间复杂度为O(n)\"]},\"121\":{\"h\":\"6.3 正确性证明\"},\"122\":{\"h\":\"7.最大容量问题\",\"t\":[\"问题： 输入一个数组 \\\\(ht\\\\) ，其中的每个元素代表一个垂直隔板的高度。数组中的任意两个隔板，以及它们之间的空间可以组成一个容器 容器的容量等于高度和宽度的乘积（面积），其中高度由较短的隔板决定，宽度是两个隔板的数组索引之差 请在数组中选择两个隔板，使得组成的容器的容量最大，返回最大容量。如下图所示 \",\"容器由任意两个隔板围成，因此本题的状态为两个隔板的索引，记为[i,j]\"]},\"123\":{\"h\":\"7.1 贪心策略确定\",\"t\":[\"这道题还有更高效率的解法。如下图所示，现选取一个状态[i,j]，其满足索引i < j 且高度ht[i] < ht[j]，即i为短板、j为长版\",\"如下图所示，若此时将长板j向短板i靠近，则容量一定变小\",\"这是因为在移动长板j后，宽度j-i肯定变小；而高度由短板决定，因此高度只可能不变（i仍为短板）或变小（移动后的j成为短板）\",\"反向思考，我们只有向内收缩短板i，才有可能使容量变大。因为虽然宽度一定变小，但高度可能会变大（移动后的短板i可能会变长）。例如在下图中，移动短板后面积变大\",\"由此便可推出本题的贪心策略：初始化两指针，使其分列容器两端，每轮向内收缩短板对应的指针，直至两指针相遇\",\"下图展示了贪心策略的执行过程：\",\"初始状态下，指针i和j分列数组两端\",\"计算当前状态的容量cap[i,j]，并更新最大容量\",\"比较板i和板j的高度，并将短板向内移动一格\",\"循环执行第2步和第3步，直至i和j相遇时结束\"]},\"124\":{\"h\":\"7.2 代码实现\",\"t\":[\"代码循环最多n轮，因此时间复杂度为0(n)\",\"变量i、j、res使用常数大小的额外空间，因此空间复杂度为O(1)\",\"/* 最大容量：贪心 */ int maxCapacity(int ht[], int htLength) { // 初始化 i, j，使其分列数组两端 int i = 0; int j = htLength - 1; // 初始最大容量为 0 int res = 0; // 循环贪心选择，直至两板相遇 while (i < j) { // 更新最大容量 int capacity = myMin(ht[i], ht[j]) * (j - i); res = myMax(res, capacity); // 向内移动短板 if (ht[i] < ht[j]) { i++; } else { j--; } } return res; } \"]},\"125\":{\"h\":\"7.3 正确性证明\"},\"126\":{\"h\":\"8.最大切分乘积问题\",\"t\":[\"问题：给定一个正整数n，将其切分为至少两个正整数的和，求切分后所有整数的乘积最大是多少，如下图所示：\"]},\"127\":{\"h\":\"8.1 贪心策略确定\",\"t\":[\"接下来思考哪个因子是最优的。在1、2、3这三个因子中，显然1是最差的，因为1 x (n-1) < n 恒成立，即切分出1反而会导致乘积减少\",\"如下图所示，当n=6时，有3x3 > 2x2x2。这意味着切分出的3比切分出2更优\"]},\"128\":{\"h\":\"8.2 代码实现\",\"t\":[\"如下图所示，我们无须通过循环来切分整数，而可以利用向下整除运算得到3的个数a，用取模运算得到余数b，此时有：n=3a+b\",\"请注意：对于n ≤ 3的边界情况，必须拆分出一个1，乘积为1 x (n-1)\",\"/* 最大切分乘积：贪心 */ int maxProductCutting(int n) { // 当 n <= 3 时，必须切分出一个 1 if (n <= 3) { return 1 * (n - 1); } // 贪心地切分出 3 ，a 为 3 的个数，b 为余数 int a = n / 3; int b = n % 3; if (b == 1) { // 当余数为 1 时，将一对 1 * 3 转化为 2 * 2 return pow(3, a - 1) * 2 * 2; } if (b == 2) { // 当余数为 2 时，不做处理 return pow(3, a) * 2; } // 当余数为 0 时，不做处理 return pow(3, a); } \",\"时间复杂度取决于编程语言的幂运算的实现方法\",\"变量a和b使用常数大小的额外空间，因此空间复杂度为O(1)\"]},\"129\":{\"h\":\"8.3 正确性证明\"},\"130\":{\"h\":\"第二章：算法\"},\"131\":{\"h\":\"1.算法的定义\",\"t\":[\"算法（algorithm）是在有限时间内解决特定问题的一组指令或操作步骤，它具有以下特性：\",\"问题是明确的，包含清晰的输入和输出定义\",\"具有可行性，能够在有限步骤、时间和内存空间下完成\",\"各步骤都有确定的含义，在相同的输入和运行条件下，输出始终相同\"]},\"132\":{\"h\":\"2.数据结构定义\",\"t\":[\"数据结构（data structure）是计算机中组织和存储数据的方式，具有以下设计目标\",\"空间占用尽量少，以节省计算机内存\",\"数据操作尽可能快速，涵盖数据访问、添加、删除、更新等\",\"提供简洁的数据表示和逻辑信息，以便算法高效运行\",\"数据结构设计是一个充满权衡的过程。如果想在某方面取得提升，往往需要在另一方面作出妥协。下面举两个例子\",\"链表相较于数组，在数据添加和删除操作上更加便捷，但牺牲了数据访问速度图相较于链表，提供了更丰富的逻辑信息，但需要占用更大的内存空间\"]},\"133\":{\"h\":\"3.数据结构与算法的关系\",\"t\":[\"数据结构与算法高度相关、紧密结合，具体表现在以下三个方面：\",\"数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及操作数据的方法\",\"算法是数据结构发挥作用的舞台。数据结构本身仅存储数据信息，结合算法才能解决特定问题\",\"算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键\"]},\"134\":{\"h\":\"第三章：复杂度分析\"},\"135\":{\"h\":\"1.算法效率评估\",\"t\":[\"在算法设计中，我们先后追求以下两个层面的目标：\",\"找到问题解法：算法需要在规定的输入范围内可靠地求得问题的正确解\",\"寻求最优解法：同一个问题可能存在多种解法，我们希望找到尽可能高效的算法\",\"也就是说，在能够解决问题的前提下，算法效率已成为衡量算法优劣的主要评价指标，它包括以下两个维度：\",\"时间效率：算法运行速度的快慢\",\"空间效率：算法占用内存空间的大小\",\"简而言之，我们的目标是设计“既快又省”的数据结构与算法。而有效地评估算法效率至关重要，因为只有这样，我们才能将各种算法进行对比，进而指导算法设计与优化过程\",\"效率评估方法主要分为两种：实际测试、理论估算\"]},\"136\":{\"h\":\"2.迭代与递归\",\"t\":[\"在算法中，重复执行某个任务是很常见的，它与复杂度分析息息相关。因此，在介绍时间复杂度和空间复杂度之前，我们先来了解如何在程序中实现重复执行任务，即两种基本的程序控制结构：迭代、递归\",\"迭代一般分为：for、while、嵌套循环递归一般分为：调用栈、尾递归、递归树\",\"迭代（iteration）是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足\",\"递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段\",\"递：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”\",\"归：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果\",\"迭代：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成递归：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）\"]},\"137\":{\"h\":\"第四章：数组与链表\"},\"138\":{\"h\":\"1.数组\",\"t\":[\"数组（array）是一种线性数据结构，其将相同类型的元素存储在连续的内存空间中。我们将元素在数组中的位置称为该元素的索引（index）。如上图展示了数组的主要概念和存储方式\",\"优点：\",\"空间效率高：数组为数据分配了连续的内存块，无须额外的结构开销\",\"支持随机访问：数组允许在O（1）时间内访问任何元素\",\"缓存局部性：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度\",\"缺点：\",\"插入与删除效率低：当数组中元素较多时，插入与删除操作需要移动大量的元素\",\"长度不可变：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大\",\"空间浪费：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了\"]},\"139\":{\"h\":\"1.1 初始化数组\",\"t\":[\"我们可以根据需求选用数组的两种初始化方式：无初始值、给定初始值。在未指定初始值的情况下，大多数编程语言会将数组元素初始化为0：\",\"/* 初始化数组 */ int arr[5] = { 0 }; // { 0, 0, 0, 0, 0 } int nums[5] = { 1, 3, 2, 5, 4 }; \"]},\"140\":{\"h\":\"1.2 访问元素\",\"t\":[\"数组元素被存储在连续的内存空间中，这意味着计算数组元素的内存地址非常容易。给定数组内存地址（首元素内存地址）和某个元素的索引，我们可以使用上图所示的公式计算得到该元素的内存地址，从而直接访问该元素\",\"我们发现数组首个元素的索引为0，这似乎有些反直觉，因为从1开始计数会更自然。但从地址计算公式的角度看，索引本质上是内存地址的偏移量。首个元素的地址偏移量是0，因此它的索引为0是合理的\",\"在数组中访问元素非常高效，我们可以在O（1）时间内随机访问数组中任何一个元素\",\"/* 随机访问元素 */ int randomAccess(int *nums, int size) { // 在区间 [0, size) 中随机抽取一个数字 int randomIndex = rand() % size; // 获取并返回随机元素 int randomNum = nums[randomIndex]; return randomNum; } \"]},\"141\":{\"h\":\"1.3 插入元素\",\"t\":[\"数组元素在内存中是“紧挨着的”，它们之间没有空间再存放任何数据。如图上图所示，如果想在数组中间插入一个元素，则需要将该元素之后的所有元素都向后移动一位，之后再把元素赋值给该索引\",\"/* 在数组的索引 index 处插入元素 num */ void insert(int *nums, int size, int num, int index) { // 把索引 index 以及之后的所有元素向后移动一位 for (int i = size - 1; i > index; i--) { nums[i] = nums[i - 1]; } // 将 num 赋给 index 处的元素 nums[index] = num; } \"]},\"142\":{\"h\":\"1.4 删除元素\",\"t\":[\"同理，如上图所示，要删除索引i处的元素，则需要把索引i之后的元素都往前移动一位\",\"请注意，删除元素完成后，原先末尾的元素变得“无意义”了，所以我们无须特意去修改它\",\"/* 删除索引 index 处的元素 */ // 注意：stdio.h 占用了 remove 关键词 void removeItem(int *nums, int size, int index) { // 把索引 index 之后的所有元素向前移动一位 for (int i = index; i < size - 1; i++) { nums[i] = nums[i + 1]; } } \",\"总的来看，数组的插入与删除操作有以下缺点：\",\"时间复杂度高：数组的插入和删除的平均时间复杂度均为O（n），其中n为数组长度\",\"丢失元素：由于数组的长度不可变，因此在插入元素后，超出数组长度范围的元素会丢失\",\"内存浪费：我们可以初始化一个比较长的数组，只用前面一部分，这样在插入数据时，丢失的末尾元素都是“无意义”的，但这样做会造成部分内存空间浪费\"]},\"143\":{\"h\":\"1.5 遍历数组\",\"t\":[\"在大多数编程语言中，我们既可以通过索引遍历数组，也可以直接遍历获取数组中的每个元素：\",\"/* 遍历数组 */ void traverse(int *nums, int size) { int count = 0; // 通过索引遍历数组 for (int i = 0; i < size; i++) { count += nums[i]; } } \"]},\"144\":{\"h\":\"1.6 查找元素\",\"t\":[\"在数组中查找指定元素需要遍历数组，每轮判断元素值是否匹配，若匹配则输出对应索引\",\"因为数组是线性数据结构，所以上述查找操作被称为“线性查找”\",\"/* 在数组中查找指定元素 */ int find(int *nums, int size, int target) { for (int i = 0; i < size; i++) { if (nums[i] == target) return i; } return -1; } \"]},\"145\":{\"h\":\"1.7 扩容数组\",\"t\":[\"在复杂的系统环境中，程序难以保证数组之后的内存空间是可用的，从而无法安全地扩展数组容量。因此在大多数编程语言中，数组的长度是不可变的\",\"如果我们希望扩容数组，则需重新建立一个更大的数组，然后把原数组元素依次复制到新数组。这是一个O（n）的操作，在数组很大的情况下非常耗时\",\"/* 扩展数组长度 */ int *extend(int *nums, int size, int enlarge) { // 初始化一个扩展长度后的数组 int *res = (int *)malloc(sizeof(int) * (size + enlarge)); // 将原数组中的所有元素复制到新数组 for (int i = 0; i < size; i++) { res[i] = nums[i]; } // 初始化扩展后的空间 for (int i = size; i < size + enlarge; i++) { res[i] = 0; } // 返回扩展后的新数组 return res; } \"]},\"146\":{\"h\":\"2.链表\",\"t\":[\"链表（linked list）是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过“引用”相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点\",\"链表的设计使得各个节点可以分散存储在内存各处，它们的内存地址无须连续\",\"链表的组成单位是节点（node）对象。每个节点都包含两项数据：节点的“值”和指向下一节点的“引用”\",\"链表的首个节点被称为“头节点”，最后一个节点被称为“尾节点”\",\"尾节点指向的是“空”，它在 Java、C++ 和 Python 中分别被记为 null、nullptr 和 None\",\"在 C、C++、Go 和 Rust 等支持指针的语言中，上述“引用”应被替换为“指针”\",\"链表节点 ListNode 除了包含值，还需额外保存一个引用（指针）。因此在相同数据量下，链表比数组占用更多的内存空间\",\"/* 链表节点结构体 */ typedef struct ListNode { int val; // 节点值 struct ListNode *next; // 指向下一节点的指针 } ListNode; /* 构造函数 */ ListNode *newListNode(int val) { ListNode *node; node = (ListNode *) malloc(sizeof(ListNode)); node->val = val; node->next = NULL; return node; } \"]},\"147\":{\"h\":\"2.1 初始化链表\",\"t\":[\"建立链表分为两步，第一步是初始化各个节点对象，第二步是构建节点之间的引用关系。初始化完成后，我们就可以从链表的头节点出发，通过引用指向 next 依次访问所有节点\",\"/* 初始化链表 1 -> 3 -> 2 -> 5 -> 4 */ // 初始化各个节点 ListNode* n0 = newListNode(1); ListNode* n1 = newListNode(3); ListNode* n2 = newListNode(2); ListNode* n3 = newListNode(5); ListNode* n4 = newListNode(4); // 构建节点之间的引用 n0->next = n1; n1->next = n2; n2->next = n3; n3->next = n4; \",\"数组整体是一个变量，比如数组 nums 包含元素 nums[0] 和 nums[1] 等，而链表是由多个独立的节点对象组成的。我们通常将头节点当作链表的代称，比如以上代码中的链表可记作链表 n0\"]},\"148\":{\"h\":\"2.2 插入结点\",\"t\":[\"在链表中插入节点非常容易。如上图所示，假设我们想在相邻的两个节点 n0 和 n1 之间插入一个新节点 P ，则只需改变两个节点引用（指针）即可，时间复杂度为O（1）\",\"相比之下，在数组中插入元素的时间复杂度为O（n），在大数据量下的效率较低\",\"/* 在链表的节点 n0 之后插入节点 P */ void insert(ListNode *n0, ListNode *P) { ListNode *n1 = n0->next; P->next = n1; n0->next = P; } \"]},\"149\":{\"h\":\"2.3 删除结点\",\"t\":[\"在链表中删除节点也非常方便，只需改变一个节点的引用（指针）即可，请注意，尽管在删除操作完成后节点 P 仍然指向 n1 ，但实际上遍历此链表已经无法访问到 P ，这意味着 P 已经不再属于该链表了\",\"/* 删除链表的节点 n0 之后的首个节点 */ // 注意：stdio.h 占用了 remove 关键词 void removeItem(ListNode *n0) { if (!n0->next) return; // n0 -> P -> n1 ListNode *P = n0->next; ListNode *n1 = P->next; n0->next = n1; // 释放内存 free(P); } \"]},\"150\":{\"h\":\"2.4 访问结点\",\"t\":[\"在链表中访问节点的效率较低。如上一节所述，我们可以在O（1）时间下访问数组中的任意元素。链表则不然，程序需要从头节点出发，逐个向后遍历，直至找到目标节点。也就是说，访问链表的第i个节点需要循环i-1轮，时间复杂度为O（n）\",\"/* 访问链表中索引为 index 的节点 */ ListNode *access(ListNode *head, int index) { for (int i = 0; i < index; i++) { if (head == NULL) return NULL; head = head->next; } return head; } \"]},\"151\":{\"h\":\"2.5 查找结点\",\"t\":[\"遍历链表，查找其中值为 target 的节点，输出该节点在链表中的索引。此过程也属于线性查找\",\"/* 在链表中查找值为 target 的首个节点 */ int find(ListNode *head, int target) { int index = 0; while (head) { if (head->val == target) return index; head = head->next; index++; } return -1; } \"]},\"152\":{\"h\":\"3.数组与链表的对比\"},\"153\":{\"h\":\"4.常见链表类型\",\"t\":[\"常见的链表类型包括三种：\",\"单向链表：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 None\",\"环形链表：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点\",\"双向链表：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间\",\"/* 双向链表节点结构体 */ typedef struct ListNode { int val; // 节点值 struct ListNode *next; // 指向后继节点的指针 struct ListNode *prev; // 指向前驱节点的指针 } ListNode; /* 构造函数 */ ListNode *newListNode(int val) { ListNode *node; node = (ListNode *) malloc(sizeof(ListNode)); node->val = val; node->next = NULL; node->prev = NULL; return node; } \"]},\"154\":{\"h\":\"第五章：栈与队列\"},\"155\":{\"h\":\"1.栈\",\"t\":[\"栈（stack）是一种遵循后进先出逻辑的线性数据结构\",\"我们把堆叠元素的顶部称为“栈顶”，底部称为“栈底”。将把元素添加到栈顶的操作叫作“入栈”，删除栈顶元素的操作叫作“出栈”\"]},\"156\":{\"h\":\"1.1 栈的链式实现\",\"t\":[\"使用链表实现栈时，我们可以将链表的头节点视为栈顶，尾节点视为栈底\",\"对于入栈操作，我们只需将元素插入链表头部，这种节点插入方法被称为“头插法”。而对于出栈操作，只需将头节点从链表中删除即可\",\"/* 基于链表实现的栈 */ typedef struct { ListNode *top; // 将头节点作为栈顶 int size; // 栈的长度 } LinkedListStack; /* 构造函数 */ LinkedListStack *newLinkedListStack() { LinkedListStack *s = malloc(sizeof(LinkedListStack)); s->top = NULL; s->size = 0; return s; } /* 析构函数 */ void delLinkedListStack(LinkedListStack *s) { while (s->top) { ListNode *n = s->top->next; free(s->top); s->top = n; } free(s); } /* 获取栈的长度 */ int size(LinkedListStack *s) { return s->size; } /* 判断栈是否为空 */ bool isEmpty(LinkedListStack *s) { return size(s) == 0; } /* 入栈 */ void push(LinkedListStack *s, int num) { ListNode *node = (ListNode *)malloc(sizeof(ListNode)); node->next = s->top; // 更新新加节点指针域 node->val = num; // 更新新加节点数据域 s->top = node; // 更新栈顶 s->size++; // 更新栈大小 } /* 访问栈顶元素 */ int peek(LinkedListStack *s) { if (s->size == 0) { printf(\\\"栈为空\\\\n\\\"); return INT_MAX; } return s->top->val; } /* 出栈 */ int pop(LinkedListStack *s) { int val = peek(s); ListNode *tmp = s->top; s->top = s->top->next; // 释放内存 free(tmp); s->size--; return val; } \"]},\"157\":{\"h\":\"1.2 栈的顺序实现\",\"t\":[\"使用数组实现栈时，我们可以将数组的尾部作为栈顶。如上图所示，入栈与出栈操作分别对应在数组尾部添加元素与删除元素，时间复杂度都为 O(1)\",\"由于入栈的元素可能会源源不断地增加，因此我们可以使用动态数组，这样就无须自行处理数组扩容问题\",\"/* 基于数组实现的栈 */ typedef struct { int *data; int size; } ArrayStack; /* 构造函数 */ ArrayStack *newArrayStack() { ArrayStack *stack = malloc(sizeof(ArrayStack)); // 初始化一个大容量，避免扩容 stack->data = malloc(sizeof(int) * MAX_SIZE); stack->size = 0; return stack; } /* 析构函数 */ void delArrayStack(ArrayStack *stack) { free(stack->data); free(stack); } /* 获取栈的长度 */ int size(ArrayStack *stack) { return stack->size; } /* 判断栈是否为空 */ bool isEmpty(ArrayStack *stack) { return stack->size == 0; } /* 入栈 */ void push(ArrayStack *stack, int num) { if (stack->size == MAX_SIZE) { printf(\\\"栈已满\\\\n\\\"); return; } stack->data[stack->size] = num; stack->size++; } /* 访问栈顶元素 */ int peek(ArrayStack *stack) { if (stack->size == 0) { printf(\\\"栈为空\\\\n\\\"); return INT_MAX; } return stack->data[stack->size - 1]; } /* 出栈 */ int pop(ArrayStack *stack) { int val = peek(stack); stack->size--; return val; } \"]},\"158\":{\"h\":\"1.3 栈的两种实现对比\",\"t\":[\"支持操作：\",\"两种实现都支持栈定义中的各项操作。数组实现额外支持随机访问，但这已超出了栈的定义范畴，因此一般不会用到\",\"时间效率：\",\"在基于数组的实现中，入栈和出栈操作都在预先分配好的连续内存中进行，具有很好的缓存本地性，因此效率较高。然而，如果入栈时超出数组容量，会触发扩容机制，导致该次入栈操作的时间复杂度变为O（n）在基于链表的实现中，链表的扩容非常灵活，不存在上述数组扩容时效率降低的问题。但是，入栈操作需要初始化节点对象并修改指针，因此效率相对较低。不过，如果入栈元素本身就是节点对象，那么可以省去初始化步骤，从而提高效率\",\"我们可以得出以下结论：\",\"基于数组实现的栈在触发扩容时效率会降低，但由于扩容是低频操作，因此平均效率更高\",\"基于链表实现的栈可以提供更加稳定的效率表现\",\"空间效率：\",\"在初始化列表时，系统会为列表分配“初始容量”，该容量可能超出实际需求；并且，扩容机制通常是按照特定倍率（例如 2 倍）进行扩容的，扩容后的容量也可能超出实际需求。因此，基于数组实现的栈可能造成一定的空间浪费然而，由于链表节点需要额外存储指针，因此链表节点占用的空间相对较大综上，我们不能简单地确定哪种实现更加节省内存，需要针对具体情况进行分析\"]},\"159\":{\"h\":\"2.队列\",\"t\":[\"队列（queue）是一种遵循先进先出规则的线性数据结构。顾名思义，队列模拟了排队现象，即新来的人不断加入队列尾部，而位于队列头部的人逐个离开\",\"我们将队列头部称为“队首”，尾部称为“队尾”，将把元素加入队尾的操作称为“入队”，删除队首元素的操作称为“出队”\"]},\"160\":{\"h\":\"2.1 队列的链式实现\",\"t\":[\"我们可以将链表的“头节点”和“尾节点”分别视为“队首”和“队尾”，规定队尾仅可添加节点，队首仅可删除节点\",\"/* 基于链表实现的队列 */ typedef struct { ListNode *front, *rear; int queSize; } LinkedListQueue; /* 构造函数 */ LinkedListQueue *newLinkedListQueue() { LinkedListQueue *queue = (LinkedListQueue *)malloc(sizeof(LinkedListQueue)); queue->front = NULL; queue->rear = NULL; queue->queSize = 0; return queue; } /* 析构函数 */ void delLinkedListQueue(LinkedListQueue *queue) { // 释放所有节点 while (queue->front != NULL) { ListNode *tmp = queue->front; queue->front = queue->front->next; free(tmp); } // 释放 queue 结构体 free(queue); } /* 获取队列的长度 */ int size(LinkedListQueue *queue) { return queue->queSize; } /* 判断队列是否为空 */ bool empty(LinkedListQueue *queue) { return (size(queue) == 0); } /* 入队 */ void push(LinkedListQueue *queue, int num) { // 尾节点处添加 node ListNode *node = newListNode(num); // 如果队列为空，则令头、尾节点都指向该节点 if (queue->front == NULL) { queue->front = node; queue->rear = node; } // 如果队列不为空，则将该节点添加到尾节点后 else { queue->rear->next = node; queue->rear = node; } queue->queSize++; } /* 访问队首元素 */ int peek(LinkedListQueue *queue) { assert(size(queue) && queue->front); return queue->front->val; } /* 出队 */ int pop(LinkedListQueue *queue) { int num = peek(queue); ListNode *tmp = queue->front; queue->front = queue->front->next; free(tmp); queue->queSize--; return num; } /* 打印队列 */ void printLinkedListQueue(LinkedListQueue *queue) { int *arr = malloc(sizeof(int) * queue->queSize); // 拷贝链表中的数据到数组 int i; ListNode *node; for (i = 0, node = queue->front; i < queue->queSize; i++) { arr[i] = node->val; node = node->next; } printArray(arr, queue->queSize); free(arr); } \"]},\"161\":{\"h\":\"2.2 队列的顺序实现\",\"t\":[\"在数组中删除首元素的时间复杂度为O（n），这会导致出队操作效率较低。然而，我们可以采用以下巧妙方法来避免这个问题\",\"我们可以使用一个变量 front 指向队首元素的索引，并维护一个变量 size 用于记录队列长度。定义 rear = front + size ，这个公式计算出的 rear 指向队尾元素之后的下一个位置\",\"基于此设计，数组中包含元素的有效区间为 [front, rear - 1]，各种操作的实现方法如下图所示：\",\"入队操作：将输入元素赋值给 rear 索引处，并将 size 增加 1\",\"出队操作：只需将 front 增加 1 ，并将 size 减少 1\",\"可以看到，入队和出队操作都只需进行一次操作，时间复杂度均为O（1）\",\"你可能会发现一个问题：在不断进行入队和出队的过程中，front 和 rear 都在向右移动，当它们到达数组尾部时就无法继续移动了。为了解决此问题，我们可以将数组视为首尾相接的“环形数组”\",\"对于环形数组，我们需要让 front 或 rear 在越过数组尾部时，直接回到数组头部继续遍历。这种周期性规律可以通过“取余操作”来实现，如下代码：\",\"/* 基于环形数组实现的队列 */ typedef struct { int *nums; // 用于存储队列元素的数组 int front; // 队首指针，指向队首元素 int queSize; // 尾指针，指向队尾 + 1 int queCapacity; // 队列容量 } ArrayQueue; /* 构造函数 */ ArrayQueue *newArrayQueue(int capacity) { ArrayQueue *queue = (ArrayQueue *)malloc(sizeof(ArrayQueue)); // 初始化数组 queue->queCapacity = capacity; queue->nums = (int *)malloc(sizeof(int) * queue->queCapacity); queue->front = queue->queSize = 0; return queue; } /* 析构函数 */ void delArrayQueue(ArrayQueue *queue) { free(queue->nums); free(queue); } /* 获取队列的容量 */ int capacity(ArrayQueue *queue) { return queue->queCapacity; } /* 获取队列的长度 */ int size(ArrayQueue *queue) { return queue->queSize; } /* 判断队列是否为空 */ bool empty(ArrayQueue *queue) { return queue->queSize == 0; } /* 访问队首元素 */ int peek(ArrayQueue *queue) { assert(size(queue) != 0); return queue->nums[queue->front]; } /* 入队 */ void push(ArrayQueue *queue, int num) { if (size(queue) == capacity(queue)) { printf(\\\"队列已满\\\\r\\\\n\\\"); return; } // 计算队尾指针，指向队尾索引 + 1 // 通过取余操作实现 rear 越过数组尾部后回到头部 int rear = (queue->front + queue->queSize) % queue->queCapacity; // 将 num 添加至队尾 queue->nums[rear] = num; queue->queSize++; } /* 出队 */ int pop(ArrayQueue *queue) { int num = peek(queue); // 队首指针向后移动一位，若越过尾部，则返回到数组头部 queue->front = (queue->front + 1) % queue->queCapacity; queue->queSize--; return num; } \"]},\"162\":{\"h\":\"3.双向队列\",\"t\":[\"在队列中，我们仅能删除头部元素或在尾部添加元素。如上图所示，双向队列（double-ended queue）提供了更高的灵活性，允许在头部和尾部执行元素的添加或删除操作\"]},\"163\":{\"h\":\"3.1 双向队列的链式实现\",\"t\":[\"对于双向队列而言，头部和尾部都可以执行入队和出队操作。换句话说，双向队列需要实现另一个对称方向的操作。为此，我们采用“双向链表”作为双向队列的底层数据结构\",\"我们将双向链表的头节点和尾节点视为双向队列的队首和队尾，同时实现在两端添加和删除节点的功能\",\"/* 双向链表节点 */ typedef struct DoublyListNode { int val; // 节点值 struct DoublyListNode *next; // 后继节点 struct DoublyListNode *prev; // 前驱节点 } DoublyListNode; /* 构造函数 */ DoublyListNode *newDoublyListNode(int num) { DoublyListNode *new = (DoublyListNode *)malloc(sizeof(DoublyListNode)); new->val = num; new->next = NULL; new->prev = NULL; return new; } /* 析构函数 */ void delDoublyListNode(DoublyListNode *node) { free(node); } /* 基于双向链表实现的双向队列 */ typedef struct { DoublyListNode *front, *rear; // 头节点 front ，尾节点 rear int queSize; // 双向队列的长度 } LinkedListDeque; /* 构造函数 */ LinkedListDeque *newLinkedListDeque() { LinkedListDeque *deque = (LinkedListDeque *)malloc(sizeof(LinkedListDeque)); deque->front = NULL; deque->rear = NULL; deque->queSize = 0; return deque; } /* 析构函数 */ void delLinkedListdeque(LinkedListDeque *deque) { // 释放所有节点 for (int i = 0; i < deque->queSize && deque->front != NULL; i++) { DoublyListNode *tmp = deque->front; deque->front = deque->front->next; free(tmp); } // 释放 deque 结构体 free(deque); } /* 获取队列的长度 */ int size(LinkedListDeque *deque) { return deque->queSize; } /* 判断队列是否为空 */ bool empty(LinkedListDeque *deque) { return (size(deque) == 0); } /* 入队 */ void push(LinkedListDeque *deque, int num, bool isFront) { DoublyListNode *node = newDoublyListNode(num); // 若链表为空，则令 front 和 rear 都指向node if (empty(deque)) { deque->front = deque->rear = node; } // 队首入队操作 else if (isFront) { // 将 node 添加至链表头部 deque->front->prev = node; node->next = deque->front; deque->front = node; // 更新头节点 } // 队尾入队操作 else { // 将 node 添加至链表尾部 deque->rear->next = node; node->prev = deque->rear; deque->rear = node; } deque->queSize++; // 更新队列长度 } /* 队首入队 */ void pushFirst(LinkedListDeque *deque, int num) { push(deque, num, true); } /* 队尾入队 */ void pushLast(LinkedListDeque *deque, int num) { push(deque, num, false); } /* 访问队首元素 */ int peekFirst(LinkedListDeque *deque) { assert(size(deque) && deque->front); return deque->front->val; } /* 访问队尾元素 */ int peekLast(LinkedListDeque *deque) { assert(size(deque) && deque->rear); return deque->rear->val; } /* 出队 */ int pop(LinkedListDeque *deque, bool isFront) { if (empty(deque)) return -1; int val; // 队首出队操作 if (isFront) { val = peekFirst(deque); // 暂存头节点值 DoublyListNode *fNext = deque->front->next; if (fNext) { fNext->prev = NULL; deque->front->next = NULL; } delDoublyListNode(deque->front); deque->front = fNext; // 更新头节点 } // 队尾出队操作 else { val = peekLast(deque); // 暂存尾节点值 DoublyListNode *rPrev = deque->rear->prev; if (rPrev) { rPrev->next = NULL; deque->rear->prev = NULL; } delDoublyListNode(deque->rear); deque->rear = rPrev; // 更新尾节点 } deque->queSize--; // 更新队列长度 return val; } /* 队首出队 */ int popFirst(LinkedListDeque *deque) { return pop(deque, true); } /* 队尾出队 */ int popLast(LinkedListDeque *deque) { return pop(deque, false); } /* 打印队列 */ void printLinkedListDeque(LinkedListDeque *deque) { int *arr = malloc(sizeof(int) * deque->queSize); // 拷贝链表中的数据到数组 int i; DoublyListNode *node; for (i = 0, node = deque->front; i < deque->queSize; i++) { arr[i] = node->val; node = node->next; } printArray(arr, deque->queSize); free(arr); } \"]},\"164\":{\"h\":\"3.2 双向队列的顺序实现\",\"t\":[\"与基于数组实现队列类似，我们也可以使用环形数组来实现双向队列\",\"在队列的实现基础上，仅需增加“队首入队”和“队尾出队”的方法：\",\"/* 基于环形数组实现的双向队列 */ typedef struct { int *nums; // 用于存储队列元素的数组 int front; // 队首指针，指向队首元素 int queSize; // 尾指针，指向队尾 + 1 int queCapacity; // 队列容量 } ArrayDeque; /* 构造函数 */ ArrayDeque *newArrayDeque(int capacity) { ArrayDeque *deque = (ArrayDeque *)malloc(sizeof(ArrayDeque)); // 初始化数组 deque->queCapacity = capacity; deque->nums = (int *)malloc(sizeof(int) * deque->queCapacity); deque->front = deque->queSize = 0; return deque; } /* 析构函数 */ void delArrayDeque(ArrayDeque *deque) { free(deque->nums); free(deque); } /* 获取双向队列的容量 */ int capacity(ArrayDeque *deque) { return deque->queCapacity; } /* 获取双向队列的长度 */ int size(ArrayDeque *deque) { return deque->queSize; } /* 判断双向队列是否为空 */ bool empty(ArrayDeque *deque) { return deque->queSize == 0; } /* 计算环形数组索引 */ int dequeIndex(ArrayDeque *deque, int i) { // 通过取余操作实现数组首尾相连 // 当 i 越过数组尾部时，回到头部 // 当 i 越过数组头部后，回到尾部 return ((i + capacity(deque)) % capacity(deque)); } /* 队首入队 */ void pushFirst(ArrayDeque *deque, int num) { if (deque->queSize == capacity(deque)) { printf(\\\"双向队列已满\\\\r\\\\n\\\"); return; } // 队首指针向左移动一位 // 通过取余操作实现 front 越过数组头部回到尾部 deque->front = dequeIndex(deque, deque->front - 1); // 将 num 添加到队首 deque->nums[deque->front] = num; deque->queSize++; } /* 队尾入队 */ void pushLast(ArrayDeque *deque, int num) { if (deque->queSize == capacity(deque)) { printf(\\\"双向队列已满\\\\r\\\\n\\\"); return; } // 计算队尾指针，指向队尾索引 + 1 int rear = dequeIndex(deque, deque->front + deque->queSize); // 将 num 添加至队尾 deque->nums[rear] = num; deque->queSize++; } /* 访问队首元素 */ int peekFirst(ArrayDeque *deque) { // 访问异常：双向队列为空 assert(empty(deque) == 0); return deque->nums[deque->front]; } /* 访问队尾元素 */ int peekLast(ArrayDeque *deque) { // 访问异常：双向队列为空 assert(empty(deque) == 0); int last = dequeIndex(deque, deque->front + deque->queSize - 1); return deque->nums[last]; } /* 队首出队 */ int popFirst(ArrayDeque *deque) { int num = peekFirst(deque); // 队首指针向后移动一位 deque->front = dequeIndex(deque, deque->front + 1); deque->queSize--; return num; } /* 队尾出队 */ int popLast(ArrayDeque *deque) { int num = peekLast(deque); deque->queSize--; return num; } \"]},\"165\":{\"h\":\"第六章：哈希表\"},\"166\":{\"h\":\"1.哈希表\",\"t\":[\"哈希表（hash table），又称散列表，它通过建立键 key 与值 value 之间的映射，实现高效的元素查询。具体而言，我们向哈希表中输入一个键 key ，则可以在 O（1）时间内获取对应的值value\",\"在哈希表中进行增删查改的时间复杂度都是 O（1），非常高效\",\"比如，给定n个学生，每个学生都有“姓名”和“学号”两项数据。假如我们希望实现“输入一个学号，返回对应的姓名”的查询功能，则可以采用下图所示的哈希表来实现\"]},\"167\":{\"h\":\"1.1 哈希表的简单实现\",\"t\":[\"我们先考虑最简单的情况，仅用一个数组来实现哈希表。在哈希表中，我们将数组中的每个空位称为桶（bucket），每个桶可存储一个键值对。因此，查询操作就是找到 key 对应的桶，并在桶中获取 value\",\"那么，如何基于 key 定位对应的桶呢？这是通过哈希函数（hash function）实现的。哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间。在哈希表中，输入空间是所有 key ，输出空间是所有桶（数组索引）。换句话说，输入一个 key ，我们可以通过哈希函数得到该 key 对应的键值对在数组中的存储位置\",\"输入一个 key ，哈希函数的计算过程分为以下两步：\",\"通过某种哈希算法 hash() 计算得到哈希值\",\"将哈希值对桶数量（数组长度）capacity 取模，从而获取该 key 对应的数组索引 index\",\"index = hash(key) % capacity \",\"随后，我们就可以利用 index 在哈希表中访问对应的桶，从而获取 value\",\"设数组长度 capacity = 100、哈希算法 hash(key) = key ，易得哈希函数为 key % 100 。如下图以 key 学号和 value 姓名为例，展示了哈希函数的工作原理\",\"以下代码实现了一个简单哈希表。其中，我们将 key 和 value 封装成一个类 Pair ，以表示键值对\",\"/* 键值对 int->string */ typedef struct { int key; char *val; } Pair; /* 基于数组实现的哈希表 */ typedef struct { Pair *buckets[HASHTABLE_CAPACITY]; } ArrayHashMap; /* 构造函数 */ ArrayHashMap *newArrayHashMap() { ArrayHashMap *hmap = malloc(sizeof(ArrayHashMap)); return hmap; } /* 析构函数 */ void delArrayHashMap(ArrayHashMap *hmap) { for (int i = 0; i < HASHTABLE_CAPACITY; i++) { if (hmap->buckets[i] != NULL) { free(hmap->buckets[i]->val); free(hmap->buckets[i]); } } free(hmap); } /* 添加操作 */ void put(ArrayHashMap *hmap, const int key, const char *val) { Pair *Pair = malloc(sizeof(Pair)); Pair->key = key; Pair->val = malloc(strlen(val) + 1); strcpy(Pair->val, val); int index = hashFunc(key); hmap->buckets[index] = Pair; } /* 删除操作 */ void removeItem(ArrayHashMap *hmap, const int key) { int index = hashFunc(key); free(hmap->buckets[index]->val); free(hmap->buckets[index]); hmap->buckets[index] = NULL; } /* 获取所有键值对 */ void pairSet(ArrayHashMap *hmap, MapSet *set) { Pair *entries; int i = 0, index = 0; int total = 0; /* 统计有效键值对数量 */ for (i = 0; i < HASHTABLE_CAPACITY; i++) { if (hmap->buckets[i] != NULL) { total++; } } entries = malloc(sizeof(Pair) * total); for (i = 0; i < HASHTABLE_CAPACITY; i++) { if (hmap->buckets[i] != NULL) { entries[index].key = hmap->buckets[i]->key; entries[index].val = malloc(strlen(hmap->buckets[i]->val) + 1); strcpy(entries[index].val, hmap->buckets[i]->val); index++; } } set->set = entries; set->len = total; } /* 获取所有键 */ void keySet(ArrayHashMap *hmap, MapSet *set) { int *keys; int i = 0, index = 0; int total = 0; /* 统计有效键值对数量 */ for (i = 0; i < HASHTABLE_CAPACITY; i++) { if (hmap->buckets[i] != NULL) { total++; } } keys = malloc(total * sizeof(int)); for (i = 0; i < HASHTABLE_CAPACITY; i++) { if (hmap->buckets[i] != NULL) { keys[index] = hmap->buckets[i]->key; index++; } } set->set = keys; set->len = total; } /* 获取所有值 */ void valueSet(ArrayHashMap *hmap, MapSet *set) { char **vals; int i = 0, index = 0; int total = 0; /* 统计有效键值对数量 */ for (i = 0; i < HASHTABLE_CAPACITY; i++) { if (hmap->buckets[i] != NULL) { total++; } } vals = malloc(total * sizeof(char *)); for (i = 0; i < HASHTABLE_CAPACITY; i++) { if (hmap->buckets[i] != NULL) { vals[index] = hmap->buckets[i]->val; index++; } } set->set = vals; set->len = total; } /* 打印哈希表 */ void print(ArrayHashMap *hmap) { int i; MapSet set; pairSet(hmap, &set); Pair *entries = (Pair *)set.set; for (i = 0; i < set.len; i++) { printf(\\\"%d -> %s\\\\n\\\", entries[i].key, entries[i].val); } free(set.set); } \"]},\"168\":{\"h\":\"1.2 哈希冲突与扩容\",\"t\":[\"从本质上看，哈希函数的作用是将所有 key 构成的输入空间映射到数组所有索引构成的输出空间，而输入空间往往远大于输出空间。因此，理论上一定存在“多个输入对应相同输出”的情况\",\"对于上述示例中的哈希函数，当输入的 key 后两位相同时，哈希函数的输出结果也相同。例如，查询学号为 12836 和 20336 的两个学生时，我们得到：\",\"12836 % 100 = 36 20336 % 100 = 36 \",\"比如，两个学号指向了同一个姓名，这显然是不对的。我们将这种多个输入对应同一输出的情况称为哈希冲突（hash collision）\",\"容易想到，哈希表容量n越大，多个 key 被分配到同一个桶中的概率就越低，冲突就越少。因此，我们可以通过扩容哈希表来减少哈希冲突\",\"比如，扩容前键值对 (136, A) 和 (236, D) 发生冲突，扩容后冲突消失\",\"类似于数组扩容，哈希表扩容需将所有键值对从原哈希表迁移至新哈希表，非常耗时；并且由于哈希表容量 capacity 改变，我们需要通过哈希函数来重新计算所有键值对的存储位置，这进一步增加了扩容过程的计算开销。为此，编程语言通常会预留足够大的哈希表容量，防止频繁扩容\",\"负载因子（load factor）是哈希表的一个重要概念，其定义为哈希表的元素数量除以桶数量，用于衡量哈希冲突的严重程度，也常作为哈希表扩容的触发条件，例如当负载因子超过0.75时，系统会将哈希表扩容至原先的2倍\"]},\"169\":{\"h\":\"2.哈希冲突\",\"t\":[\"通常情况下哈希函数的输入空间远大于输出空间，因此理论上哈希冲突是不可避免的。比如，输入空间为全体整数，输出空间为数组容量大小，则必然有多个整数映射至同一桶索引\",\"哈希冲突会导致查询结果错误，严重影响哈希表的可用性。为了解决该问题，每当遇到哈希冲突时，我们就进行哈希表扩容，直至冲突消失为止。此方法简单粗暴且有效，但效率太低，因为哈希表扩容需要进行大量的数据搬运与哈希值计算。为了提升效率，我们可以采用以下策略\",\"改良哈希表数据结构，使得哈希表可以在出现哈希冲突时正常工作\",\"仅在必要时，即当哈希冲突比较严重时，才执行扩容操作\",\"哈希表的结构改良方法主要包括“链式地址”和“开放寻址”\"]},\"170\":{\"h\":\"2.1 链式地址\",\"t\":[\"在原始哈希表中，每个桶仅能存储一个键值对。链式地址（separate chaining）将单个元素转换为链表，将键值对作为链表节点，将所有发生冲突的键值对都存储在同一链表中。图下图展示了一个链式地址哈希表的例子\",\"基于链式地址实现的哈希表的操作方法发生了以下变化：\",\"查询元素：输入 key ，经过哈希函数得到桶索引，即可访问链表头节点，然后遍历链表并对比 key 以查找目标键值对\",\"添加元素：首先通过哈希函数访问链表头节点，然后将节点（键值对）添加到链表中\",\"删除元素：根据哈希函数的结果访问链表头部，接着遍历链表以查找目标节点并将其删除\",\"链式地址存在以下局限性：\",\"占用空间增大：链表包含节点指针，它相比数组更加耗费内存空间\",\"查询效率降低：因为需要线性遍历链表来查找对应元素\",\"以下代码给出了链式地址哈希表的简单实现，需要注意两点：\",\"使用列表（动态数组）代替链表，从而简化代码。在这种设定下，哈希表（数组）包含多个桶，每个桶都是一个列表\",\"以下实现包含哈希表扩容方法。当负载因子超过0.75时，我们将哈希表扩容至原先的2倍\",\"/* 链表节点 */ typedef struct Node { Pair *pair; struct Node *next; } Node; /* 链式地址哈希表 */ typedef struct { int size; // 键值对数量 int capacity; // 哈希表容量 double loadThres; // 触发扩容的负载因子阈值 int extendRatio; // 扩容倍数 Node **buckets; // 桶数组 } HashMapChaining; /* 构造函数 */ HashMapChaining *newHashMapChaining() { HashMapChaining *hashMap = (HashMapChaining *)malloc(sizeof(HashMapChaining)); hashMap->size = 0; hashMap->capacity = 4; hashMap->loadThres = 0.75; hashMap->extendRatio = 2; hashMap->buckets = (Node **)malloc(hashMap->capacity * sizeof(Node *)); for (int i = 0; i < hashMap->capacity; i++) { hashMap->buckets[i] = NULL; } return hashMap; } /* 析构函数 */ void delHashMapChaining(HashMapChaining *hashMap) { for (int i = 0; i < hashMap->capacity; i++) { Node *cur = hashMap->buckets[i]; while (cur) { Node *tmp = cur; cur = cur->next; free(tmp->pair); free(tmp); } } free(hashMap->buckets); free(hashMap); } /* 哈希函数 */ int hashFunc(HashMapChaining *hashMap, int key) { return key % hashMap->capacity; } /* 负载因子 */ double loadFactor(HashMapChaining *hashMap) { return (double)hashMap->size / (double)hashMap->capacity; } /* 查询操作 */ char *get(HashMapChaining *hashMap, int key) { int index = hashFunc(hashMap, key); // 遍历桶，若找到 key ，则返回对应 val Node *cur = hashMap->buckets[index]; while (cur) { if (cur->pair->key == key) { return cur->pair->val; } cur = cur->next; } return \\\"\\\"; // 若未找到 key ，则返回空字符串 } /* 添加操作 */ void put(HashMapChaining *hashMap, int key, const char *val) { // 当负载因子超过阈值时，执行扩容 if (loadFactor(hashMap) > hashMap->loadThres) { extend(hashMap); } int index = hashFunc(hashMap, key); // 遍历桶，若遇到指定 key ，则更新对应 val 并返回 Node *cur = hashMap->buckets[index]; while (cur) { if (cur->pair->key == key) { strcpy(cur->pair->val, val); // 若遇到指定 key ，则更新对应 val 并返回 return; } cur = cur->next; } // 若无该 key ，则将键值对添加至链表头部 Pair *newPair = (Pair *)malloc(sizeof(Pair)); newPair->key = key; strcpy(newPair->val, val); Node *newNode = (Node *)malloc(sizeof(Node)); newNode->pair = newPair; newNode->next = hashMap->buckets[index]; hashMap->buckets[index] = newNode; hashMap->size++; } /* 扩容哈希表 */ void extend(HashMapChaining *hashMap) { // 暂存原哈希表 int oldCapacity = hashMap->capacity; Node **oldBuckets = hashMap->buckets; // 初始化扩容后的新哈希表 hashMap->capacity *= hashMap->extendRatio; hashMap->buckets = (Node **)malloc(hashMap->capacity * sizeof(Node *)); for (int i = 0; i < hashMap->capacity; i++) { hashMap->buckets[i] = NULL; } hashMap->size = 0; // 将键值对从原哈希表搬运至新哈希表 for (int i = 0; i < oldCapacity; i++) { Node *cur = oldBuckets[i]; while (cur) { put(hashMap, cur->pair->key, cur->pair->val); Node *temp = cur; cur = cur->next; // 释放内存 free(temp->pair); free(temp); } } free(oldBuckets); } /* 删除操作 */ void removeItem(HashMapChaining *hashMap, int key) { int index = hashFunc(hashMap, key); Node *cur = hashMap->buckets[index]; Node *pre = NULL; while (cur) { if (cur->pair->key == key) { // 从中删除键值对 if (pre) { pre->next = cur->next; } else { hashMap->buckets[index] = cur->next; } // 释放内存 free(cur->pair); free(cur); hashMap->size--; return; } pre = cur; cur = cur->next; } } /* 打印哈希表 */ void print(HashMapChaining *hashMap) { for (int i = 0; i < hashMap->capacity; i++) { Node *cur = hashMap->buckets[i]; printf(\\\"[\\\"); while (cur) { printf(\\\"%d -> %s, \\\", cur->pair->key, cur->pair->val); cur = cur->next; } printf(\\\"]\\\\n\\\"); } } \",\"值得注意的是，当链表很长时，查询效率O（n）很差，此时可以将链表转换为AVL树或红黑树，从而将查询操作的时间复杂度优化至O(logn)\"]},\"171\":{\"h\":\"2.2 开放寻址\",\"t\":[\"开放寻址（open addressing）不引入额外的数据结构，而是通过“多次探测”来处理哈希冲突，探测方式主要包括线性探测、平方探测和多次哈希等\"]},\"172\":{\"h\":\"2.2.1 线性探测\",\"t\":[\"线性探测采用固定步长的线性搜索来进行探测，其操作方法与普通哈希表有所不同\",\"插入元素：通过哈希函数计算桶索引，若发现桶内已有元素，则从冲突位置向后线性遍历（步长通常为1 ），直至找到空桶，将元素插入其中\",\"查找元素：若发现哈希冲突，则使用相同步长向后进行线性遍历，直到找到对应元素，返回 value 即可；如果遇到空桶，说明目标元素不在哈希表中，返回 None\",\"上图展示了开放寻址（线性探测）哈希表的键值对分布。根据此哈希函数，最后两位相同的 key 都会被映射到相同的桶。而通过线性探测，它们被依次存储在该桶以及之下的桶中\",\"然而，线性探测容易产生“聚集现象”。具体来说，数组中连续被占用的位置越长，这些连续位置发生哈希冲突的可能性越大，从而进一步促使该位置的聚堆生长，形成恶性循环，最终导致增删查改操作效率劣化\",\"值得注意的是，我们不能在开放寻址哈希表中直接删除元素。这是因为删除元素会在数组内产生一个空桶 None ，而当查询元素时，线性探测到该空桶就会返回，因此在该空桶之下的元素都无法再被访问到，程序可能误判这些元素不存在，如下图所示：\",\"为了解决该问题，我们可以采用懒删除（lazy deletion）机制：它不直接从哈希表中移除元素，而是利用一个常量 TOMBSTONE 来标记这个桶。在该机制下，None 和 TOMBSTONE 都代表空桶，都可以放置键值对。但不同的是，线性探测到 TOMBSTONE 时应该继续遍历，因为其之下可能还存在键值对\",\"然而，懒删除可能会加速哈希表的性能退化。这是因为每次删除操作都会产生一个删除标记，随着 TOMBSTONE 的增加，搜索时间也会增加，因为线性探测可能需要跳过多个 TOMBSTONE 才能找到目标元素\",\"为此，考虑在线性探测中记录遇到的首个 TOMBSTONE 的索引，并将搜索到的目标元素与该 TOMBSTONE 交换位置。这样做的好处是当每次查询或添加元素时，元素会被移动至距离理想位置（探测起始点）更近的桶，从而优化查询效率\",\"以下代码实现了一个包含懒删除的开放寻址（线性探测）哈希表。为了更加充分地使用哈希表的空间，我们将哈希表看作一个“环形数组”，当越过数组尾部时，回到头部继续遍历\",\"/* 开放寻址哈希表 */ typedef struct { int size; // 键值对数量 int capacity; // 哈希表容量 double loadThres; // 触发扩容的负载因子阈值 int extendRatio; // 扩容倍数 Pair **buckets; // 桶数组 Pair *TOMBSTONE; // 删除标记 } HashMapOpenAddressing; /* 构造函数 */ HashMapOpenAddressing *newHashMapOpenAddressing() { HashMapOpenAddressing *hashMap = (HashMapOpenAddressing *)malloc(sizeof(HashMapOpenAddressing)); hashMap->size = 0; hashMap->capacity = 4; hashMap->loadThres = 2.0 / 3.0; hashMap->extendRatio = 2; hashMap->buckets = (Pair **)malloc(sizeof(Pair *) * hashMap->capacity); hashMap->TOMBSTONE = (Pair *)malloc(sizeof(Pair)); hashMap->TOMBSTONE->key = -1; hashMap->TOMBSTONE->val = \\\"-1\\\"; return hashMap; } /* 析构函数 */ void delHashMapOpenAddressing(HashMapOpenAddressing *hashMap) { for (int i = 0; i < hashMap->capacity; i++) { Pair *pair = hashMap->buckets[i]; if (pair != NULL && pair != hashMap->TOMBSTONE) { free(pair->val); free(pair); } } free(hashMap->buckets); free(hashMap->TOMBSTONE); free(hashMap); } /* 哈希函数 */ int hashFunc(HashMapOpenAddressing *hashMap, int key) { return key % hashMap->capacity; } /* 负载因子 */ double loadFactor(HashMapOpenAddressing *hashMap) { return (double)hashMap->size / (double)hashMap->capacity; } /* 搜索 key 对应的桶索引 */ int findBucket(HashMapOpenAddressing *hashMap, int key) { int index = hashFunc(hashMap, key); int firstTombstone = -1; // 线性探测，当遇到空桶时跳出 while (hashMap->buckets[index] != NULL) { // 若遇到 key ，返回对应的桶索引 if (hashMap->buckets[index]->key == key) { // 若之前遇到了删除标记，则将键值对移动至该索引处 if (firstTombstone != -1) { hashMap->buckets[firstTombstone] = hashMap->buckets[index]; hashMap->buckets[index] = hashMap->TOMBSTONE; return firstTombstone; // 返回移动后的桶索引 } return index; // 返回桶索引 } // 记录遇到的首个删除标记 if (firstTombstone == -1 && hashMap->buckets[index] == hashMap->TOMBSTONE) { firstTombstone = index; } // 计算桶索引，越过尾部则返回头部 index = (index + 1) % hashMap->capacity; } // 若 key 不存在，则返回添加点的索引 return firstTombstone == -1 ? index : firstTombstone; } /* 查询操作 */ char *get(HashMapOpenAddressing *hashMap, int key) { // 搜索 key 对应的桶索引 int index = findBucket(hashMap, key); // 若找到键值对，则返回对应 val if (hashMap->buckets[index] != NULL && hashMap->buckets[index] != hashMap->TOMBSTONE) { return hashMap->buckets[index]->val; } // 若键值对不存在，则返回空字符串 return \\\"\\\"; } /* 添加操作 */ void put(HashMapOpenAddressing *hashMap, int key, char *val) { // 当负载因子超过阈值时，执行扩容 if (loadFactor(hashMap) > hashMap->loadThres) { extend(hashMap); } // 搜索 key 对应的桶索引 int index = findBucket(hashMap, key); // 若找到键值对，则覆盖 val 并返回 if (hashMap->buckets[index] != NULL && hashMap->buckets[index] != hashMap->TOMBSTONE) { free(hashMap->buckets[index]->val); hashMap->buckets[index]->val = (char *)malloc(sizeof(strlen(val) + 1)); strcpy(hashMap->buckets[index]->val, val); hashMap->buckets[index]->val[strlen(val)] = '\\\\0'; return; } // 若键值对不存在，则添加该键值对 Pair *pair = (Pair *)malloc(sizeof(Pair)); pair->key = key; pair->val = (char *)malloc(sizeof(strlen(val) + 1)); strcpy(pair->val, val); pair->val[strlen(val)] = '\\\\0'; hashMap->buckets[index] = pair; hashMap->size++; } /* 删除操作 */ void removeItem(HashMapOpenAddressing *hashMap, int key) { // 搜索 key 对应的桶索引 int index = findBucket(hashMap, key); // 若找到键值对，则用删除标记覆盖它 if (hashMap->buckets[index] != NULL && hashMap->buckets[index] != hashMap->TOMBSTONE) { Pair *pair = hashMap->buckets[index]; free(pair->val); free(pair); hashMap->buckets[index] = hashMap->TOMBSTONE; hashMap->size--; } } /* 扩容哈希表 */ void extend(HashMapOpenAddressing *hashMap) { // 暂存原哈希表 Pair **bucketsTmp = hashMap->buckets; int oldCapacity = hashMap->capacity; // 初始化扩容后的新哈希表 hashMap->capacity *= hashMap->extendRatio; hashMap->buckets = (Pair **)malloc(sizeof(Pair *) * hashMap->capacity); hashMap->size = 0; // 将键值对从原哈希表搬运至新哈希表 for (int i = 0; i < oldCapacity; i++) { Pair *pair = bucketsTmp[i]; if (pair != NULL && pair != hashMap->TOMBSTONE) { put(hashMap, pair->key, pair->val); free(pair->val); free(pair); } } free(bucketsTmp); } /* 打印哈希表 */ void print(HashMapOpenAddressing *hashMap) { for (int i = 0; i < hashMap->capacity; i++) { Pair *pair = hashMap->buckets[i]; if (pair == NULL) { printf(\\\"NULL\\\\n\\\"); } else if (pair == hashMap->TOMBSTONE) { printf(\\\"TOMBSTONE\\\\n\\\"); } else { printf(\\\"%d -> %s\\\\n\\\", pair->key, pair->val); } } } \"]},\"173\":{\"h\":\"2.2.2 平方探测\",\"t\":[\"平方探测与线性探测类似，都是开放寻址的常见策略之一。当发生冲突时，平方探测不是简单地跳过一个固定的步数，而是跳过“探测次数的平方”的步数，即1，4，9，...步\",\"平方探测主要具有以下优势：\",\"平方探测通过跳过探测次数平方的距离，试图缓解线性探测的聚集效应\",\"平方探测会跳过更大的距离来寻找空位置，有助于数据分布得更加均匀\",\"然而，平方探测并不是完美的仍然存在聚集现象，即某些位置比其他位置更容易被占用由于平方的增长，平方探测可能不会探测整个哈希表，这意味着即使哈希表中有空桶，平方探测也可能无法访问到它\"]},\"174\":{\"h\":\"2.2.3 多次哈希\",\"t\":[\"顾名思义，多次哈希方法使用多个哈希函数f1(x)、f2(x)、f3(x)...进行探测\",\"插入元素：若哈希函数f1(x)出现冲突，则尝试f2(x)，以此类推，直到找到空位后插入元素\",\"查找元素：在相同的哈希函数顺序下进行查找，直到找到目标元素时返回；若遇到空位或已尝试所有哈希函数，说明哈希表中不存在该元素，则返回 None\",\"与线性探测相比，多次哈希方法不易产生聚集，但多个哈希函数会带来额外的计算量\"]},\"175\":{\"h\":\"3.哈希算法\",\"t\":[\"前面介绍了哈希表的工作原理和哈希冲突的处理方法。然而无论是开放寻址还是链式地址，它们只能保证哈希表可以在发生冲突时正常工作，而无法减少哈希冲突的发生\",\"如果哈希冲突过于频繁，哈希表的性能则会急剧劣化。如图下图所示，对于链式地址哈希表，理想情况下键值对均匀分布在各个桶中，达到最佳查询效率；最差情况下所有键值对都存储到同一个桶中，时间复杂度退化至O(n)\",\"键值对的分布情况由哈希函数决定。回忆哈希函数的计算步骤，先计算哈希值，再对数组长度取模：\",\"index = hash(key) % capacity \",\"观察以上公式，当哈希表容量 capacity 固定时，哈希算法 hash() 决定了输出值，进而决定了键值对在哈希表中的分布情况\",\"这意味着，为了降低哈希冲突的发生概率，我们应当将注意力集中在哈希算法 hash() 的设计上\"]},\"176\":{\"h\":\"3.1 哈希算法的目标\",\"t\":[\"为了实现“既快又稳”的哈希表数据结构，哈希算法应具备以下特点：\",\"确定性：对于相同的输入，哈希算法应始终产生相同的输出。这样才能确保哈希表是可靠的\",\"效率高：计算哈希值的过程应该足够快。计算开销越小，哈希表的实用性越高\",\"均匀分布：哈希算法应使得键值对均匀分布在哈希表中。分布越均匀，哈希冲突的概率就越低\",\"实际上，哈希算法除了可以用于实现哈希表，还广泛应用于其他领域中\",\"密码存储：为了保护用户密码的安全，系统通常不会直接存储用户的明文密码，而是存储密码的哈希值。当用户输入密码时，系统会对输入的密码计算哈希值，然后与存储的哈希值进行比较。如果两者匹配，那么密码就被视为正确\",\"数据完整性检查：数据发送方可以计算数据的哈希值并将其一同发送；接收方可以重新计算接收到的数据的哈希值，并与接收到的哈希值进行比较。如果两者匹配，那么数据就被视为完整\",\"对于密码学的相关应用，为了防止从哈希值推导出原始密码等逆向工程，哈希算法需要具备更高等级的安全特性\",\"单向性：无法通过哈希值反推出关于输入数据的任何信息\",\"抗碰撞性：应当极难找到两个不同的输入，使得它们的哈希值相同\",\"雪崩效应：输入的微小变化应当导致输出的显著且不可预测的变化\",\"请注意，“均匀分布”与“抗碰撞性”是两个独立的概念，满足均匀分布不一定满足抗碰撞性。例如，在随机输入 key 下，哈希函数 key % 100 可以产生均匀分布的输出。然而该哈希算法过于简单，所有后两位相等的 key 的输出都相同，因此我们可以很容易地从哈希值反推出可用的 key ，从而破解密码\"]},\"177\":{\"h\":\"3.2 哈希算法的设计\",\"t\":[\"哈希算法的设计是一个需要考虑许多因素的复杂问题。然而对于某些要求不高的场景，我们也能设计一些简单的哈希算法\",\"加法哈希：对输入的每个字符的 ASCII 码进行相加，将得到的总和作为哈希值\",\"乘法哈希：利用乘法的不相关性，每轮乘以一个常数，将各个字符的 ASCII 码累积到哈希值中\",\"异或哈希：将输入数据的每个元素通过异或操作累积到一个哈希值中\",\"旋转哈希：将每个字符的 ASCII 码累积到一个哈希值中，每次累积之前都会对哈希值进行旋转操作\",\"/* 加法哈希 */ int addHash(char *key) { long long hash = 0; const int MODULUS = 1000000007; for (int i = 0; i < strlen(key); i++) { hash = (hash + (unsigned char)key[i]) % MODULUS; } return (int)hash; } /* 乘法哈希 */ int mulHash(char *key) { long long hash = 0; const int MODULUS = 1000000007; for (int i = 0; i < strlen(key); i++) { hash = (31 * hash + (unsigned char)key[i]) % MODULUS; } return (int)hash; } /* 异或哈希 */ int xorHash(char *key) { int hash = 0; const int MODULUS = 1000000007; for (int i = 0; i < strlen(key); i++) { hash ^= (unsigned char)key[i]; } return hash & MODULUS; } /* 旋转哈希 */ int rotHash(char *key) { long long hash = 0; const int MODULUS = 1000000007; for (int i = 0; i < strlen(key); i++) { hash = ((hash << 4) ^ (hash >> 28) ^ (unsigned char)key[i]) % MODULUS; } return (int)hash; } \",\"观察发现，每种哈希算法的最后一步都是对大质数1000000007取模，以确保哈希值在合适的范围内。值得思考的是，为什么要强调对质数取模，或者说对合数取模的弊端是什么？这是一个有趣的问题先抛出结论：使用大质数作为模数，可以最大化地保证哈希值的均匀分布。因为质数不与其他数字存在公约数，可以减少因取模操作而产生的周期性模式，从而避免哈希冲突总而言之，我们通常选取质数作为模数，并且这个质数最好足够大，以尽可能消除周期性模式，提升哈希算法的稳健性\"]},\"178\":{\"h\":\"3.3 常见哈希算法\",\"t\":[\"不难发现，以上介绍的简单哈希算法都比较“脆弱”，远远没有达到哈希算法的设计目标。例如，由于加法和异或满足交换律，因此加法哈希和异或哈希无法区分内容相同但顺序不同的字符串，这可能会加剧哈希冲突，并引起一些安全问题\",\"在实际中，我们通常会用一些标准哈希算法，例如 MD5、SHA-1、SHA-2 和 SHA-3 等。它们可以将任意长度的输入数据映射到恒定长度的哈希值\",\"近一个世纪以来，哈希算法处在不断升级与优化的过程中。一部分研究人员努力提升哈希算法的性能，另一部分研究人员和黑客则致力于寻找哈希算法的安全性问题。下图展示了在实际应用中常见的哈希算法\"]},\"179\":{\"h\":\"第七章：树\"},\"180\":{\"h\":\"1.二叉树的基本概念\",\"t\":[\"二叉树（binary tree）是一种非线性数据结构，代表“祖先”与“后代”之间的派生关系，体现了“一分为二”的分治逻辑。与链表类似，二叉树的基本单元是节点，每个节点包含值、左子节点引用和右子节点引用\",\"每个节点都有两个引用（指针），分别指向左子节点（left-child node）和右子节点（right-child node），该节点被称为这两个子节点的父节点（parent node）。当给定一个二叉树的节点时，我们将该节点的左子节点及其以下节点形成的树称为该节点的左子树（left subtree），同理可得右子树（right subtree）\",\"在二叉树中，除叶节点外，其他所有节点都包含子节点和非空子树。如图下图所示，如果将“节点 2”视为父节点，则其左子节点和右子节点分别是“节点 4”和“节点 5”，左子树是“节点 4 及其以下节点形成的树”，右子树是“节点 5 及其以下节点形成的树”\",\"/* 二叉树节点结构体 */ typedef struct TreeNode { int val; // 节点值 int height; // 节点高度 struct TreeNode *left; // 左子节点指针 struct TreeNode *right; // 右子节点指针 } TreeNode; /* 构造函数 */ TreeNode *newTreeNode(int val) { TreeNode *node; node = (TreeNode *)malloc(sizeof(TreeNode)); node->val = val; node->height = 0; node->left = NULL; node->right = NULL; return node; } \"]},\"181\":{\"h\":\"1.1 二叉树常见术语\",\"t\":[\"二叉树的常用术语如下所示：\",\"根节点（root node）：位于二叉树顶层的节点，没有父节点\",\"叶节点（leaf node）：没有子节点的节点，其两个指针均指向 None\",\"边（edge）：连接两个节点的线段，即节点引用（指针）\",\"节点所在的层（level）：从顶至底递增，根节点所在层为 1\",\"节点的度（degree）：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2\",\"二叉树的高度（height）：从根节点到最远叶节点所经过的边的数量\",\"节点的深度（depth）：从根节点到该节点所经过的边的数量\",\"节点的高度（height）：从距离该节点最远的叶节点到该节点所经过的边的数量\"]},\"182\":{\"h\":\"1.2 二叉树基本操作\",\"t\":[\"（1）初始化二叉树\",\"与链表类似，首先初始化节点，然后构建引用（指针）\",\"/* 初始化二叉树 */ // 初始化节点 TreeNode *n1 = newTreeNode(1); TreeNode *n2 = newTreeNode(2); TreeNode *n3 = newTreeNode(3); TreeNode *n4 = newTreeNode(4); TreeNode *n5 = newTreeNode(5); // 构建节点之间的引用（指针） n1->left = n2; n1->right = n3; n2->left = n4; n2->right = n5; \",\"（2）插入与删除节点\",\"与链表类似，在二叉树中插入与删除节点可以通过修改指针来实现。下图给出了一个示例：\",\"/* 插入与删除节点 */ TreeNode *P = newTreeNode(0); // 在 n1 -> n2 中间插入节点 P n1->left = P; P->left = n2; // 删除节点 P n1->left = n2; \"]},\"183\":{\"h\":\"1.3 常见二叉树类型\",\"t\":[\"（1）满二叉树\",\"满二叉树（也叫完美二叉树）所有层的节点都被完全填满。在满二叉树中，叶节点的度为0，其余所有节点的度都为2；若树的高度为h，则节点总数为2^(h+1)-1，呈现标准的指数级关系，反映了自然界中常见的细胞分裂现象\",\"（2）完全二叉树\",\"完全二叉树（complete binary tree）只有最底层的节点未被填满，且最底层节点尽量靠左填充\",\"（3）平衡二叉树\",\"平衡二叉树（balanced binary tree）中任意节点的左子树和右子树的高度之差的绝对值不超过 1\"]},\"184\":{\"h\":\"1.4 二叉树的退化\",\"t\":[\"下图展示了二叉树的理想结构与退化结构。当二叉树的每层节点都被填满时，达到“完美二叉树”；而当所有节点都偏向一侧时，二叉树退化为“链表”\",\"满二叉树是理想情况，可以充分发挥二叉树“分治”的优势\",\"链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化至O(n)\",\"在最佳结构和最差结构下，二叉树的叶节点数量、节点总数、高度等达到极大值或极小值\"]},\"185\":{\"h\":\"2.二叉树的遍历\",\"t\":[\"从物理结构的角度来看，树是一种基于链表的数据结构，因此其遍历方式是通过指针逐个访问节点。然而，树是一种非线性数据结构，这使得遍历树比遍历链表更加复杂，需要借助搜索算法来实现\",\"二叉树常见的遍历方式包括层序遍历、前序遍历、中序遍历和后序遍历等\"]},\"186\":{\"h\":\"2.1 层序遍历\",\"t\":[\"层序遍历（level-order traversal）从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点\",\"层序遍历本质上属于广度优先遍历（breadth-first traversal），也称广度优先搜索（breadth-first search, BFS），它体现了一种“一圈一圈向外扩展”的逐层遍历方式\",\"时间复杂度为O(n)：所有结点被访问一次，使用O(n)时间，其中n为结点数量空间复杂度为O(n)：在最差情况下，即满二叉树时，遍历到最底层之前，队列中最多同时存在(n+1)/2个结点，占用O(n)空间\",\"广度优先遍历通常借助“队列”来实现。队列遵循“先进先出”的规则，而广度优先遍历则遵循“逐层推进”的规则，两者背后的思想是一致的。实现代码如下：\",\"/* 层序遍历 */ int *levelOrder(TreeNode *root, int *size) { /* 辅助队列 */ int front, rear; int index, *arr; TreeNode *node; TreeNode **queue; /* 辅助队列 */ queue = (TreeNode **)malloc(sizeof(TreeNode *) * MAX_SIZE); // 队列指针 front = 0, rear = 0; // 加入根节点 queue[rear++] = root; // 初始化一个列表，用于保存遍历序列 /* 辅助数组 */ arr = (int *)malloc(sizeof(int) * MAX_SIZE); // 数组指针 index = 0; while (front < rear) { // 队列出队 node = queue[front++]; // 保存节点值 arr[index++] = node->val; if (node->left != NULL) { // 左子节点入队 queue[rear++] = node->left; } if (node->right != NULL) { // 右子节点入队 queue[rear++] = node->right; } } // 更新数组长度的值 *size = index; arr = realloc(arr, sizeof(int) * (*size)); // 释放辅助数组空间 free(queue); return arr; } \"]},\"187\":{\"h\":\"2.2 前序、中序、后序遍历\",\"t\":[\"相应地，前序、中序和后序遍历都属于深度优先遍历（depth-first traversal），也称深度优先搜索（depth-first search, DFS），它体现了一种“先走到尽头，再回溯继续”的遍历方式\",\"时间复杂度为O(n)：所有结点被访问一次，使用O(n)时间空间复杂度为O(n)：在最差情况下，即树退化为链表时，递归深度达到n，系统占用O(n)栈帧空间\",\"下图展示了对二叉树进行深度优先遍历的工作原理。深度优先遍历就像是绕着整棵二叉树的外围“走”一圈，在每个节点都会遇到三个位置，分别对应前序遍历、中序遍历和后序遍历\",\"深度优先搜索通常基于递归实现：\",\"/* 前序遍历 */ void preOrder(TreeNode *root, int *size) { if (root == NULL) return; // 访问优先级：根节点 -> 左子树 -> 右子树 arr[(*size)++] = root->val; preOrder(root->left, size); preOrder(root->right, size); } /* 中序遍历 */ void inOrder(TreeNode *root, int *size) { if (root == NULL) return; // 访问优先级：左子树 -> 根节点 -> 右子树 inOrder(root->left, size); arr[(*size)++] = root->val; inOrder(root->right, size); } /* 后序遍历 */ void postOrder(TreeNode *root, int *size) { if (root == NULL) return; // 访问优先级：左子树 -> 右子树 -> 根节点 postOrder(root->left, size); postOrder(root->right, size); arr[(*size)++] = root->val; } \"]},\"188\":{\"h\":\"3.二叉树的数组表示\",\"t\":[\"在链表表示下，二叉树的存储单元为节点 TreeNode ，节点之间通过指针相连接。上一节介绍了链表表示下的二叉树的各项基本操作\",\"那么，我们能否用数组来表示二叉树呢？答案是肯定的\"]},\"189\":{\"h\":\"3.1 表示满二叉树\",\"t\":[\"先分析一个简单案例。给定一棵满二叉树，我们将所有节点按照层序遍历的顺序存储在一个数组中，则每个节点都对应唯一的数组索引\",\"根据层序遍历的特性，我们可以推导出父节点索引与子节点索引之间的“映射公式”：若某节点的索引为i，则该节点的左子节点索引为2i+1，右子节点索引为2i+2，如下图所示：\",\"映射公式的角色相当于链表中的节点引用（指针）。给定数组中的任意一个节点，我们都可以通过映射公式来访问它的左（右）子节点\"]},\"190\":{\"h\":\"3.2 表示任意二叉树\",\"t\":[\"满二叉树是一个特例，在二叉树的中间层通常存在许多 None 。由于层序遍历序列并不包含这些 None ，因此我们无法仅凭该序列来推测 None 的数量和分布位置。这意味着存在多种二叉树结构都符合该层序遍历序列\",\"如图下图所示，给定一棵非完美二叉树，上述数组表示方法已经失效：\",\"为了解决此问题，我们可以考虑在层序遍历序列中显式地写出所有 None 。如图下图所示，这样处理后，层序遍历序列就可以唯一表示二叉树了。示例代码如下：\",\"/* 二叉树的数组表示 */ // 使用 int 最大值标记空位，因此要求节点值不能为 INT_MAX int tree[] = {1, 2, 3, 4, INT_MAX, 6, 7, 8, 9, INT_MAX, INT_MAX, 12, INT_MAX, INT_MAX, 15}; \",\"值得说明的是，完全二叉树非常适合使用数组来表示。回顾完全二叉树的定义，None 只出现在最底层且靠右的位置，因此所有 None 一定出现在层序遍历序列的末尾\",\"这意味着使用数组表示完全二叉树时，可以省略存储所有 None ，非常方便。下图给出了一个例子：\",\"以下代码实现了一棵基于数组表示的二叉树，包括以下几种操作:\",\"给定某节点，获取它的值、左（右）子节点、父节点\",\"获取前序遍历、中序遍历、后序遍历、层序遍历序列\",\"/* 数组表示下的二叉树结构体 */ typedef struct { int *tree; int size; } ArrayBinaryTree; /* 构造函数 */ ArrayBinaryTree *newArrayBinaryTree(int *arr, int arrSize) { ArrayBinaryTree *abt = (ArrayBinaryTree *)malloc(sizeof(ArrayBinaryTree)); abt->tree = malloc(sizeof(int) * arrSize); memcpy(abt->tree, arr, sizeof(int) * arrSize); abt->size = arrSize; return abt; } /* 析构函数 */ void delArrayBinaryTree(ArrayBinaryTree *abt) { free(abt->tree); free(abt); } /* 列表容量 */ int size(ArrayBinaryTree *abt) { return abt->size; } /* 获取索引为 i 节点的值 */ int val(ArrayBinaryTree *abt, int i) { // 若索引越界，则返回 INT_MAX ，代表空位 if (i < 0 || i >= size(abt)) return INT_MAX; return abt->tree[i]; } /* 层序遍历 */ int *levelOrder(ArrayBinaryTree *abt, int *returnSize) { int *res = (int *)malloc(sizeof(int) * size(abt)); int index = 0; // 直接遍历数组 for (int i = 0; i < size(abt); i++) { if (val(abt, i) != INT_MAX) res[index++] = val(abt, i); } *returnSize = index; return res; } /* 深度优先遍历 */ void dfs(ArrayBinaryTree *abt, int i, char *order, int *res, int *index) { // 若为空位，则返回 if (val(abt, i) == INT_MAX) return; // 前序遍历 if (strcmp(order, \\\"pre\\\") == 0) res[(*index)++] = val(abt, i); dfs(abt, left(i), order, res, index); // 中序遍历 if (strcmp(order, \\\"in\\\") == 0) res[(*index)++] = val(abt, i); dfs(abt, right(i), order, res, index); // 后序遍历 if (strcmp(order, \\\"post\\\") == 0) res[(*index)++] = val(abt, i); } /* 前序遍历 */ int *preOrder(ArrayBinaryTree *abt, int *returnSize) { int *res = (int *)malloc(sizeof(int) * size(abt)); int index = 0; dfs(abt, 0, \\\"pre\\\", res, &index); *returnSize = index; return res; } /* 中序遍历 */ int *inOrder(ArrayBinaryTree *abt, int *returnSize) { int *res = (int *)malloc(sizeof(int) * size(abt)); int index = 0; dfs(abt, 0, \\\"in\\\", res, &index); *returnSize = index; return res; } /* 后序遍历 */ int *postOrder(ArrayBinaryTree *abt, int *returnSize) { int *res = (int *)malloc(sizeof(int) * size(abt)); int index = 0; dfs(abt, 0, \\\"post\\\", res, &index); *returnSize = index; return res; } \"]},\"191\":{\"h\":\"3.3 优点与缺点\",\"t\":[\"二叉树的数组表示主要有以下优点：\",\"数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快\",\"不需要存储指针，比较节省空间\",\"允许随机访问节点\",\"然而，数组表示也存在一些局限性：\",\"数组存储需要连续内存空间，因此不适合存储数据量过大的树\",\"增删节点需要通过数组插入与删除操作实现，效率较低\",\"当二叉树中存在大量 None 时，数组中包含的节点数据比重较低，空间利用率较低\"]},\"192\":{\"h\":\"4.二叉搜索树(BST树)\",\"t\":[\"如图下图所示，二叉搜索树（binary search tree）满足以下条件：\",\"对于根节点，左子树中所有节点的值 < 根节点的值 < 右子树中所有节点的值\",\"任意节点的左、右子树也是二叉搜索树，即同样满足条件1\"]},\"193\":{\"h\":\"4.1 查找结点\",\"t\":[\"给定目标节点值 num ，可以根据二叉搜索树的性质来查找。如下图所示，我们声明一个节点 cur ，从二叉树的根节点 root 出发，循环比较节点值 cur.val 和 num 之间的大小关系\",\"若 cur.val < num ，说明目标节点在 cur 的右子树中，因此执行 cur = cur.right\",\"若 cur.val > num ，说明目标节点在 cur 的左子树中，因此执行 cur = cur.left\",\"若 cur.val = num ，说明找到目标节点，跳出循环并返回该节点\",\"二叉搜索树的查找操作与二分查找算法的工作原理一致，都是每轮排除一半情况。循环次数最多为二叉树的高度，当二叉树平衡时，使用O(logn)时间，实例代码如下：\",\"/* 查找节点 */ TreeNode *search(BinarySearchTree *bst, int num) { TreeNode *cur = bst->root; // 循环查找，越过叶节点后跳出 while (cur != NULL) { if (cur->val < num) { // 目标节点在 cur 的右子树中 cur = cur->right; } else if (cur->val > num) { // 目标节点在 cur 的左子树中 cur = cur->left; } else { // 找到目标节点，跳出循环 break; } } // 返回目标节点 return cur; } \"]},\"194\":{\"h\":\"4.2 插入结点\",\"t\":[\"给定一个待插入元素 num ，为了保持二叉搜索树“左子树 < 根节点 < 右子树”的性质，插入操作流程如下图所示：\",\"查找插入位置：与查找操作相似，从根节点出发，根据当前节点值和 num 的大小关系循环向下搜索，直到越过叶节点（遍历至 None ）时跳出循环\",\"在该位置插入节点：初始化节点 num ，将该节点置于 None 的位置\",\"与查找节点相同，插入节点使用O(logn)时间\",\"在代码实现中，需要注意以下两点:\",\"二叉搜索树不允许存在重复节点，否则将违反其定义。因此，若待插入节点在树中已存在，则不执行插入，直接返回\",\"为了实现插入节点，我们需要借助节点 pre 保存上一轮循环的节点。这样在遍历至 None 时，我们可以获取到其父节点，从而完成节点插入操作\",\"/* 插入节点 */ void insert(BinarySearchTree *bst, int num) { // 若树为空，则初始化根节点 if (bst->root == NULL) { bst->root = newTreeNode(num); return; } TreeNode *cur = bst->root, *pre = NULL; // 循环查找，越过叶节点后跳出 while (cur != NULL) { // 找到重复节点，直接返回 if (cur->val == num) { return; } pre = cur; if (cur->val < num) { // 插入位置在 cur 的右子树中 cur = cur->right; } else { // 插入位置在 cur 的左子树中 cur = cur->left; } } // 插入节点 TreeNode *node = newTreeNode(num); if (pre->val < num) { pre->right = node; } else { pre->left = node; } } \"]},\"195\":{\"h\":\"4.3 删除结点\",\"t\":[\"先在二叉树中查找到目标节点，再将其删除。与插入节点类似，我们需要保证在删除操作完成后，二叉搜索树的“左子树 < 根节点 < 右子树”的性质仍然满足。因此，我们根据目标节点的子节点数量，分 0、1 和 2 三种情况，执行对应的删除节点操作\",\"如下图所示，当待删除节点的度为0时，表示该节点是叶节点，可以直接删除\",\"如下图所示，当待删除节点的度为1时，将待删除节点替换为其子节点即可\",\"当待删除节点的度为2时，我们无法直接删除它，而需要使用一个节点替换该节点。由于要保持二叉搜索树“左子树 < 根节点 < 右子树”的性质，因此这个节点可以是右子树的最小节点或左子树的最大节点\",\"假设我们选择右子树的最小节点（中序遍历的下一个节点），则删除操作流程如下图所示：\",\"找到待删除节点在“中序遍历序列”中的下一个节点，记为 tmp\",\"用 tmp 的值覆盖待删除节点的值，并在树中递归删除节点 tmp\",\"删除节点操作同样使用O(logn)时间，其中查找待删除节点需要O(logn)时间，获取中序遍历后继节点需要O(logn)时间，示例代码如下：\",\"/* 删除节点 */ // 由于引入了 stdio.h ，此处无法使用 remove 关键词 void removeItem(BinarySearchTree *bst, int num) { // 若树为空，直接提前返回 if (bst->root == NULL) return; TreeNode *cur = bst->root, *pre = NULL; // 循环查找，越过叶节点后跳出 while (cur != NULL) { // 找到待删除节点，跳出循环 if (cur->val == num) break; pre = cur; if (cur->val < num) { // 待删除节点在 root 的右子树中 cur = cur->right; } else { // 待删除节点在 root 的左子树中 cur = cur->left; } } // 若无待删除节点，则直接返回 if (cur == NULL) return; // 判断待删除节点是否存在子节点 if (cur->left == NULL || cur->right == NULL) { /* 子节点数量 = 0 or 1 */ // 当子节点数量 = 0 / 1 时， child = nullptr / 该子节点 TreeNode *child = cur->left != NULL ? cur->left : cur->right; // 删除节点 cur if (pre->left == cur) { pre->left = child; } else { pre->right = child; } // 释放内存 free(cur); } else { /* 子节点数量 = 2 */ // 获取中序遍历中 cur 的下一个节点 TreeNode *tmp = cur->right; while (tmp->left != NULL) { tmp = tmp->left; } int tmpVal = tmp->val; // 递归删除节点 tmp removeItem(bst, tmp->val); // 用 tmp 覆盖 cur cur->val = tmpVal; } } \"]},\"196\":{\"h\":\"4.4 中序遍历有序\",\"t\":[\"如下图所示，二叉树的中序遍历遵循“左 -> 根 -> 右”的遍历顺序，而二叉搜索树满足“左子节点 < 根节点 < 右子节点”的大小关系\",\"这意味着在二叉搜索树中进行中序遍历时，总是会优先遍历下一个最小节点，从而得出一个重要性质：二叉搜索树的中序遍历序列是升序的\",\"利用中序遍历升序的性质，我们在二叉搜索树中获取有序数据仅需O(n)时间，无须进行额外的排序操作，非常高效\"]},\"197\":{\"h\":\"4.5 二叉搜索树的效率\"},\"198\":{\"h\":\"5.平衡二叉树(AVL树)\",\"t\":[\"AVL 树既是二叉搜索树，也是平衡二叉树，同时满足这两类二叉树的所有性质，因此是一种平衡二叉搜索树（balanced binary search tree）\",\"由于 AVL 树的相关操作需要获取节点高度，因此我们需要为节点类添加 height 变量：\",\"/* AVL 树节点结构体 */ TreeNode struct TreeNode { int val; int height; struct TreeNode *left; struct TreeNode *right; } TreeNode; /* 构造函数 */ TreeNode *newTreeNode(int val) { TreeNode *node; node = (TreeNode *)malloc(sizeof(TreeNode)); node->val = val; node->height = 0; node->left = NULL; node->right = NULL; return node; } \"]},\"199\":{\"h\":\"5.1 AVL树的常见术语\",\"t\":[\"（1）节点高度\",\"“节点高度”是指从该节点到它的最远叶节点的距离，即所经过的“边”的数量。需要特别注意的是，叶节点的高度为0，而空节点的高度为-1。我们将创建两个工具函数，分别用于获取和更新节点的高度：\",\"/* 获取节点高度 */ int height(TreeNode *node) { // 空节点高度为 -1 ，叶节点高度为 0 if (node != NULL) { return node->height; } return -1; } /* 更新节点高度 */ void updateHeight(TreeNode *node) { int lh = height(node->left); int rh = height(node->right); // 节点高度等于最高子树高度 + 1 if (lh > rh) { node->height = lh + 1; } else { node->height = rh + 1; } } \",\"（2）节点平衡因子\",\"节点的平衡因子（balance factor）定义为节点左子树的高度减去右子树的高度，同时规定空节点的平衡因子为0。我们同样将获取节点平衡因子的功能封装成函数，方便后续使用：\",\"/* 获取平衡因子 */ int balanceFactor(TreeNode *node) { // 空节点平衡因子为 0 if (node == NULL) { return 0; } // 节点平衡因子 = 左子树高度 - 右子树高度 return height(node->left) - height(node->right); } \"]},\"200\":{\"h\":\"5.2 AVL树的旋转\",\"t\":[\"AVL 树的特点在于“旋转”操作，它能够在不影响二叉树的中序遍历序列的前提下，使失衡节点重新恢复平衡。换句话说，旋转操作既能保持“二叉搜索树”的性质，也能使树重新变为“平衡二叉树”\",\"我们将平衡因子绝对值 > 1 的节点称为“失衡节点”。根据节点失衡情况的不同，旋转操作分为四种：右旋、左旋、先右旋后左旋、先左旋后右旋。下面详细介绍这些旋转操作\"]},\"201\":{\"h\":\"5.2.1 右旋\",\"t\":[\"如下图所示，节点下方为平衡因子。从底至顶看，二叉树中首个失衡节点是“节点 3”。我们关注以该失衡节点为根节点的子树，将该节点记为 node ，其左子节点记为 child ，执行“右旋”操作。完成右旋后，子树恢复平衡，并且仍然保持二叉搜索树的性质\",\"如下图所示，当节点 child 有右子节点（记为 grand_child ）时，需要在右旋中添加一步：将 grand_child 作为 node 的左子节点\",\"“向右旋转”是一种形象化的说法，实际上需要通过修改节点指针来实现，代码如下所示：\",\"/* 右旋操作 */ TreeNode *rightRotate(TreeNode *node) { TreeNode *child, *grandChild; child = node->left; grandChild = child->right; // 以 child 为原点，将 node 向右旋转 child->right = node; node->left = grandChild; // 更新节点高度 updateHeight(node); updateHeight(child); // 返回旋转后子树的根节点 return child; } \"]},\"202\":{\"h\":\"5.2.2 左旋\",\"t\":[\"相应地，如果考虑上述失衡二叉树的“镜像”，则需要执行下图所示的“左旋”操作\",\"同理，如下图所示，当节点 child 有左子节点（记为 grand_child ）时，需要在左旋中添加一步：将 grand_child 作为 node 的右子节点\",\"可以观察到，右旋和左旋操作在逻辑上是镜像对称的，它们分别解决的两种失衡情况也是对称的。基于对称性，我们只需将右旋的实现代码中的所有的 left 替换为 right ，将所有的 right 替换为 left ，即可得到左旋的实现代码：\",\"/* 左旋操作 */ TreeNode *leftRotate(TreeNode *node) { TreeNode *child, *grandChild; child = node->right; grandChild = child->left; // 以 child 为原点，将 node 向左旋转 child->left = node; node->right = grandChild; // 更新节点高度 updateHeight(node); updateHeight(child); // 返回旋转后子树的根节点 return child; } \"]},\"203\":{\"h\":\"5.2.3 先左旋再右旋\",\"t\":[\"对于下图中的失衡节点 3 ，仅使用左旋或右旋都无法使子树恢复平衡。此时需要先对 child 执行“左旋”，再对 node 执行“右旋”\"]},\"204\":{\"h\":\"5.2.4 先右旋再左旋\",\"t\":[\"如下图所示，对于上述失衡二叉树的镜像情况，需要先对 child 执行“右旋”，再对 node 执行“左旋”\"]},\"205\":{\"h\":\"5.2.5 旋转的选择\",\"t\":[\"下图展示的四种失衡情况与上述案例逐个对应，分别需要采用右旋、先左旋后右旋、先右旋后左旋、左旋的操作\",\"我们通过判断失衡节点的平衡因子以及较高一侧子节点的平衡因子的正负号，来确定失衡节点属于哪种情况:\",\"为了便于使用，我们将旋转操作封装成一个函数。有了这个函数，我们就能对各种失衡情况进行旋转，使失衡节点重新恢复平衡。代码如下所示：\",\"/* 执行旋转操作，使该子树重新恢复平衡 */ TreeNode *rotate(TreeNode *node) { // 获取节点 node 的平衡因子 int bf = balanceFactor(node); // 左偏树 if (bf > 1) { if (balanceFactor(node->left) >= 0) { // 右旋 return rightRotate(node); } else { // 先左旋后右旋 node->left = leftRotate(node->left); return rightRotate(node); } } // 右偏树 if (bf < -1) { if (balanceFactor(node->right) <= 0) { // 左旋 return leftRotate(node); } else { // 先右旋后左旋 node->right = rightRotate(node->right); return leftRotate(node); } } // 平衡树，无须旋转，直接返回 return node; } \"]},\"206\":{\"h\":\"5.3 AVL树插入节点\",\"t\":[\"AVL 树的节点插入操作与二叉搜索树在主体上类似。唯一的区别在于，在 AVL 树中插入节点后，从该节点到根节点的路径上可能会出现一系列失衡节点。因此，我们需要从这个节点开始，自底向上执行旋转操作，使所有失衡节点恢复平衡。代码如下所示：\",\"/* 插入节点 */ void insert(AVLTree *tree, int val) { tree->root = insertHelper(tree->root, val); } /* 递归插入节点（辅助函数） */ TreeNode *insertHelper(TreeNode *node, int val) { if (node == NULL) { return newTreeNode(val); } /* 1. 查找插入位置并插入节点 */ if (val < node->val) { node->left = insertHelper(node->left, val); } else if (val > node->val) { node->right = insertHelper(node->right, val); } else { // 重复节点不插入，直接返回 return node; } // 更新节点高度 updateHeight(node); /* 2. 执行旋转操作，使该子树重新恢复平衡 */ node = rotate(node); // 返回子树的根节点 return node; } \"]},\"207\":{\"h\":\"5.4 AVL树删除节点\",\"t\":[\"类似地，在二叉搜索树的删除节点方法的基础上，需要从底至顶执行旋转操作，使所有失衡节点恢复平衡。代码如下所示：\",\"/* 删除节点 */ // 由于引入了 stdio.h ，此处无法使用 remove 关键词 void removeItem(AVLTree *tree, int val) { TreeNode *root = removeHelper(tree->root, val); } /* 递归删除节点（辅助函数） */ TreeNode *removeHelper(TreeNode *node, int val) { TreeNode *child, *grandChild; if (node == NULL) { return NULL; } /* 1. 查找节点并删除 */ if (val < node->val) { node->left = removeHelper(node->left, val); } else if (val > node->val) { node->right = removeHelper(node->right, val); } else { if (node->left == NULL || node->right == NULL) { child = node->left; if (node->right != NULL) { child = node->right; } // 子节点数量 = 0 ，直接删除 node 并返回 if (child == NULL) { return NULL; } else { // 子节点数量 = 1 ，直接删除 node node = child; } } else { // 子节点数量 = 2 ，则将中序遍历的下个节点删除，并用该节点替换当前节点 TreeNode *temp = node->right; while (temp->left != NULL) { temp = temp->left; } int tempVal = temp->val; node->right = removeHelper(node->right, temp->val); node->val = tempVal; } } // 更新节点高度 updateHeight(node); /* 2. 执行旋转操作，使该子树重新恢复平衡 */ node = rotate(node); // 返回子树的根节点 return node; } \"]},\"208\":{\"h\":\"第八章：堆\",\"t\":[\"堆（heap）是一种满足特定条件的完全二叉树，主要可分为两种类型：\",\"小顶堆（min heap）：任意节点的值 ≤ 其子节点的值\",\"大顶堆（max heap）：任意节点的值 ≥ 其子节点的值\",\"堆作为完全二叉树的一个特例，具有以下特性:\",\"最底层节点靠左填充，其他层的节点都被填满\",\"我们将二叉树的根节点称为“堆顶”，将底层最靠右的节点称为“堆底”\",\"对于大顶堆（小顶堆），堆顶元素（根节点）的值是最大（最小）的\"]},\"209\":{\"h\":\"1.堆的存储与表示\",\"t\":[\"二叉树”章节讲过，完全二叉树非常适合用数组来表示。由于堆正是一种完全二叉树，因此我们将采用数组来存储堆\",\"当使用数组表示二叉树时，元素代表节点值，索引代表节点在二叉树中的位置。节点指针通过索引映射公式来实现\",\"如下图所示，给定索引i，其左子节点的索引为2i+1，右子节点的索引为2i+2，父节点的索引为(i-1)/2（向下整除）。当索引越界时，表示空节点或节点不存在\",\"我们可以将索引映射公式封装成函数，方便后续使用：\",\"/* 获取左子节点的索引 */ int left(MaxHeap *maxHeap, int i) { return 2 * i + 1; } /* 获取右子节点的索引 */ int right(MaxHeap *maxHeap, int i) { return 2 * i + 2; } /* 获取父节点的索引 */ int parent(MaxHeap *maxHeap, int i) { return (i - 1) / 2; } \"]},\"210\":{\"h\":\"2.访问堆顶元素\",\"t\":[\"堆顶元素即为二叉树的根节点，也就是列表的首个元素：\",\"/* 访问堆顶元素 */ int peek(MaxHeap *maxHeap) { return maxHeap->data[0]; } \"]},\"211\":{\"h\":\"3.元素入堆\",\"t\":[\"给定元素 val ，我们首先将其添加到堆底。添加之后，由于 val 可能大于堆中其他元素，堆的成立条件可能已被破坏，因此需要修复从插入节点到根节点的路径上的各个节点，这个操作被称为堆化（heapify）\",\"考虑从入堆节点开始，从底至顶执行堆化。如下图所示，我们比较插入节点与其父节点的值，如果插入节点更大，则将它们交换。然后继续执行此操作，从底至顶修复堆中的各个节点，直至越过根节点或遇到无须交换的节点时结束\",\"设节点总数为n，则树的高度为O(logn)。由此可知，堆化操作的循环轮数最多为O(logn)，元素入堆操作的时间复杂度为O(logn)。代码如下所示：\",\"/* 元素入堆 */ void push(MaxHeap *maxHeap, int val) { // 默认情况下，不应该添加这么多节点 if (maxHeap->size == MAX_SIZE) { printf(\\\"heap is full!\\\"); return; } // 添加节点 maxHeap->data[maxHeap->size] = val; maxHeap->size++; // 从底至顶堆化 siftUp(maxHeap, maxHeap->size - 1); } /* 从节点 i 开始，从底至顶堆化 */ void siftUp(MaxHeap *maxHeap, int i) { while (true) { // 获取节点 i 的父节点 int p = parent(maxHeap, i); // 当“越过根节点”或“节点无须修复”时，结束堆化 if (p < 0 || maxHeap->data[i] <= maxHeap->data[p]) { break; } // 交换两节点 swap(maxHeap, i, p); // 循环向上堆化 i = p; } } \"]},\"212\":{\"h\":\"4.堆顶元素出堆\",\"t\":[\"堆顶元素是二叉树的根节点，即列表首元素。如果我们直接从列表中删除首元素，那么二叉树中所有节点的索引都会发生变化，这将使得后续使用堆化进行修复变得困难。为了尽量减少元素索引的变动，我们采用以下操作步骤：\",\"交换堆顶元素与堆底元素（交换根节点与最右叶节点）\",\"交换完成后，将堆底从列表中删除（注意，由于已经交换，因此实际上删除的是原来的堆顶元素）\",\"从根节点开始，从顶至底执行堆化\",\"如下图所示，“从顶至底堆化”的操作方向与“从底至顶堆化”相反，我们将根节点的值与其两个子节点的值进行比较，将最大的子节点与根节点交换。然后循环执行此操作，直到越过叶节点或遇到无须交换的节点时结束\",\"与元素入堆操作相似，堆顶元素出堆操作的时间复杂度也为O(logn)，代码如下：\",\"/* 元素出堆 */ int pop(MaxHeap *maxHeap) { // 判空处理 if (isEmpty(maxHeap)) { printf(\\\"heap is empty!\\\"); return INT_MAX; } // 交换根节点与最右叶节点（交换首元素与尾元素） swap(maxHeap, 0, size(maxHeap) - 1); // 删除节点 int val = maxHeap->data[maxHeap->size - 1]; maxHeap->size--; // 从顶至底堆化 siftDown(maxHeap, 0); // 返回堆顶元素 return val; } /* 从节点 i 开始，从顶至底堆化 */ void siftDown(MaxHeap *maxHeap, int i) { while (true) { // 判断节点 i, l, r 中值最大的节点，记为 max int l = left(maxHeap, i); int r = right(maxHeap, i); int max = i; if (l < size(maxHeap) && maxHeap->data[l] > maxHeap->data[max]) { max = l; } if (r < size(maxHeap) && maxHeap->data[r] > maxHeap->data[max]) { max = r; } // 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出 if (max == i) { break; } // 交换两节点 swap(maxHeap, i, max); // 循环向下堆化 i = max; } } \"]},\"213\":{\"h\":\"第九章：图\",\"t\":[\"图（graph）是一种非线性数据结构，由顶点（vertex）和边（edge）组成。我们可以将图G抽象地表示为一组顶点V和一组边E的集合。以下示例展示了一个包含 5 个顶点和 7 条边的图：\",\"如果将顶点看作节点，将边看作连接各个节点的引用（指针），我们就可以将图看作一种从链表拓展而来的数据结构。如图 下图所示，相较于线性关系（链表）和分治关系（树），网络关系（图）的自由度更高，因而更为复杂\"]},\"214\":{\"h\":\"1.图的常见类型与术语\",\"t\":[\"根据边是否具有方向，可分为无向图（undirected graph）和有向图（directed graph），如下图所示\",\"在无向图中，边表示两顶点之间的“双向”连接关系，例如微信或 QQ 中的“好友关系”\",\"在有向图中，边具有方向性，即A->B 和 B->A两个方向的边是相互独立的，例如微博或抖音上的“关注”与“被关注”关系\",\"根据所有顶点是否连通，可分为连通图（connected graph）和非连通图（disconnected graph），如下图所示\",\"对于连通图，从某个顶点出发，可以到达其余任意顶点\",\"对于非连通图，从某个顶点出发，至少有一个顶点无法到达\",\"我们还可以为边添加“权重”变量，从而得到如下图所示的有权图（weighted graph）。例如在《王者荣耀》等手游中，系统会根据共同游戏时间来计算玩家之间的“亲密度”，这种亲密度网络就可以用有权图来表示\",\"图数据结构包含以下常用术语：\",\"邻接（adjacency）：当两顶点之间存在边相连时，称这两顶点“邻接”。在上图中，顶点 1 的邻接顶点为顶点 2、3、5\",\"路径（path）：从顶点 A 到顶点 B 经过的边构成的序列被称为从 A 到 B 的“路径”。在上图中，边序列 1-5-2-4 是顶点 1 到顶点 4 的一条路径\",\"度（degree）：一个顶点拥有的边数。对于有向图，入度（in-degree）表示有多少条边指向该顶点，出度（out-degree）表示有多少条边从该顶点指出\"]},\"215\":{\"h\":\"2.图的表示\",\"t\":[\"图的常用表示方式包括“邻接矩阵”和“邻接表”。以下使用无向图进行举例\"]},\"216\":{\"h\":\"2.1 邻接矩阵\",\"t\":[\"设图的顶点数量为n，邻接矩阵（adjacency matrix）使用一个nxn大小的矩阵来表示图，每一行（列）代表一个顶点，矩阵元素代表边，用1或0表示两个顶点之间是否存在边\",\"如下图所示，设邻接矩阵为M、顶点列表为V，那么矩阵元素M[i,j]=1表示顶点V[i]到顶点V[j]之间存在边，反之M[i,j]=0表示两顶点之间无边\",\"邻接矩阵具有以下特性:\",\"顶点不能与自身相连，因此邻接矩阵主对角线元素没有意义\",\"对于无向图，两个方向的边等价，此时邻接矩阵关于主对角线对称\",\"将邻接矩阵的元素从1和0替换为权重，则可表示有权图\",\"使用邻接矩阵表示图时，我们可以直接访问矩阵元素以获取边，因此增删查改操作的效率很高，时间复杂度均为O(1)，然而矩阵的空间复杂度为O(n^2)，内存占用较多\"]},\"217\":{\"h\":\"2.2 邻接表\",\"t\":[\"邻接表（adjacency list）使用n个链表来表示图，链表节点表示顶点。第i个链表对应顶点i，其中存储了该顶点的所有邻接顶点（与该顶点相连的顶点）。下图展示了一个使用邻接表存储的图的示例\",\"邻接表仅存储实际存在的边，而边的总数通常远小于n^2，因此它更加节省空间。然而，在邻接表中需要通过遍历链表来查找边，因此其时间效率不如邻接矩阵\",\"邻接表结构与哈希表中的“链式地址”非常相似，因此我们也可以采用类似的方法来优化效率。比如当链表较长时，可以将链表转化为 AVL 树或红黑树，从而将时间效率从O(n)优化至O(logn)；还可以把链表转换为哈希表，从而将时间复杂度降至O(1)\"]},\"218\":{\"h\":\"3.图基于邻接矩阵的实现\",\"t\":[\"给定一个顶点数量为n的无向图，则各种操作的实现方式如下图所示：\",\"添加或删除边：直接在邻接矩阵中修改指定的边即可，使用O(1)时间。而由于是无向图，因此需要同时更新两个方向的边\",\"添加顶点：在邻接矩阵的尾部添加一行一列，并全部填0即可，使用O(n)时间\",\"删除顶点：在邻接矩阵中删除一行一列。当删除首行首列时达到最差情况，需要将(n-1)^2 个元素“向左上移动”，从而使用O(n^2)时间\",\"初始化：传入n个顶点，初始化长度为n的顶点列表 vertices ，使用O(n)时间；初始化 nxn大小的邻接矩阵 adjMat ，使用O(n^2)时间\",\"（1）初始化邻接矩阵\",\"（2）添加边\",\"（3）删除边\",\"（4）添加顶点\",\"（5）删除顶点\",\"以下是基于邻接矩阵表示图的实现代码：\",\"/* 基于邻接矩阵实现的无向图结构体 */ typedef struct { int vertices[MAX_SIZE]; int adjMat[MAX_SIZE][MAX_SIZE]; int size; } GraphAdjMat; /* 构造函数 */ GraphAdjMat *newGraphAdjMat() { GraphAdjMat *graph = (GraphAdjMat *)malloc(sizeof(GraphAdjMat)); graph->size = 0; for (int i = 0; i < MAX_SIZE; i++) { for (int j = 0; j < MAX_SIZE; j++) { graph->adjMat[i][j] = 0; } } return graph; } /* 析构函数 */ void delGraphAdjMat(GraphAdjMat *graph) { free(graph); } /* 添加顶点 */ void addVertex(GraphAdjMat *graph, int val) { if (graph->size == MAX_SIZE) { fprintf(stderr, \\\"图的顶点数量已达最大值\\\\n\\\"); return; } // 添加第 n 个顶点，并将第 n 行和列置零 int n = graph->size; graph->vertices[n] = val; for (int i = 0; i <= n; i++) { graph->adjMat[n][i] = graph->adjMat[i][n] = 0; } graph->size++; } /* 删除顶点 */ void removeVertex(GraphAdjMat *graph, int index) { if (index < 0 || index >= graph->size) { fprintf(stderr, \\\"顶点索引越界\\\\n\\\"); return; } // 在顶点列表中移除索引 index 的顶点 for (int i = index; i < graph->size - 1; i++) { graph->vertices[i] = graph->vertices[i + 1]; } // 在邻接矩阵中删除索引 index 的行 for (int i = index; i < graph->size - 1; i++) { for (int j = 0; j < graph->size; j++) { graph->adjMat[i][j] = graph->adjMat[i + 1][j]; } } // 在邻接矩阵中删除索引 index 的列 for (int i = 0; i < graph->size; i++) { for (int j = index; j < graph->size - 1; j++) { graph->adjMat[i][j] = graph->adjMat[i][j + 1]; } } graph->size--; } /* 添加边 */ // 参数 i, j 对应 vertices 元素索引 void addEdge(GraphAdjMat *graph, int i, int j) { if (i < 0 || j < 0 || i >= graph->size || j >= graph->size || i == j) { fprintf(stderr, \\\"边索引越界或相等\\\\n\\\"); return; } graph->adjMat[i][j] = 1; graph->adjMat[j][i] = 1; } /* 删除边 */ // 参数 i, j 对应 vertices 元素索引 void removeEdge(GraphAdjMat *graph, int i, int j) { if (i < 0 || j < 0 || i >= graph->size || j >= graph->size || i == j) { fprintf(stderr, \\\"边索引越界或相等\\\\n\\\"); return; } graph->adjMat[i][j] = 0; graph->adjMat[j][i] = 0; } /* 打印邻接矩阵 */ void printGraphAdjMat(GraphAdjMat *graph) { printf(\\\"顶点列表 = \\\"); printArray(graph->vertices, graph->size); printf(\\\"邻接矩阵 =\\\\n\\\"); for (int i = 0; i < graph->size; i++) { printArray(graph->adjMat[i], graph->size); } } \"]},\"219\":{\"h\":\"4.图基于邻接表的实现\",\"t\":[\"设无向图的顶点总数为n、边总数为m，则可根据下图所示的方法实现各种操作：\",\"添加边：在顶点对应链表的末尾添加边即可，使用O(1)时间。因为是无向图，所以需要同时添加两个方向的边\",\"删除边：在顶点对应链表中查找并删除指定边，使用O(m)时间。在无向图中，需要同时删除两个方向的边\",\"添加顶点：在邻接表中添加一个链表，并将新增顶点作为链表头节点，使用O(1)时间\",\"删除顶点：需遍历整个邻接表，删除包含指定顶点的所有边，使用O(n+m)\",\"初始化：在邻接表中创建n个顶点和2m条边，使用O(n+m)时间\",\"（1）初始化邻接表\",\"（2）添加边\",\"（3）删除边\",\"（4）添加顶点\",\"（5）删除顶点\",\"以下是邻接表的代码实现。对上图 ，实际代码有以下不同：\",\"为了方便添加与删除顶点，以及简化代码，我们使用列表（动态数组）来代替链表\",\"使用哈希表来存储邻接表，key 为顶点实例，value 为该顶点的邻接顶点列表（链表）\",\"另外，我们在邻接表中使用 Vertex 类来表示顶点，这样做的原因是：如果与邻接矩阵一样，用列表索引来区分不同顶点，那么假设要删除索引为i的顶点，则需遍历整个邻接表，将所有大于i的索引全部减1，效率很低。而如果每个顶点都是唯一的 Vertex 实例，删除某一顶点之后就无须改动其他顶点了\",\"/* 节点结构体 */ typedef struct AdjListNode { Vertex *vertex; // 顶点 struct AdjListNode *next; // 后继节点 } AdjListNode; /* 查找顶点对应的节点 */ AdjListNode *findNode(GraphAdjList *graph, Vertex *vet) { for (int i = 0; i < graph->size; i++) { if (graph->heads[i]->vertex == vet) { return graph->heads[i]; } } return NULL; } /* 添加边辅助函数 */ void addEdgeHelper(AdjListNode *head, Vertex *vet) { AdjListNode *node = (AdjListNode *)malloc(sizeof(AdjListNode)); node->vertex = vet; // 头插法 node->next = head->next; head->next = node; } /* 删除边辅助函数 */ void removeEdgeHelper(AdjListNode *head, Vertex *vet) { AdjListNode *pre = head; AdjListNode *cur = head->next; // 在链表中搜索 vet 对应节点 while (cur != NULL && cur->vertex != vet) { pre = cur; cur = cur->next; } if (cur == NULL) return; // 将 vet 对应节点从链表中删除 pre->next = cur->next; // 释放内存 free(cur); } /* 基于邻接表实现的无向图类 */ typedef struct { AdjListNode *heads[MAX_SIZE]; // 节点数组 int size; // 节点数量 } GraphAdjList; /* 构造函数 */ GraphAdjList *newGraphAdjList() { GraphAdjList *graph = (GraphAdjList *)malloc(sizeof(GraphAdjList)); if (!graph) { return NULL; } graph->size = 0; for (int i = 0; i < MAX_SIZE; i++) { graph->heads[i] = NULL; } return graph; } /* 析构函数 */ void delGraphAdjList(GraphAdjList *graph) { for (int i = 0; i < graph->size; i++) { AdjListNode *cur = graph->heads[i]; while (cur != NULL) { AdjListNode *next = cur->next; if (cur != graph->heads[i]) { free(cur); } cur = next; } free(graph->heads[i]->vertex); free(graph->heads[i]); } free(graph); } /* 查找顶点对应的节点 */ AdjListNode *findNode(GraphAdjList *graph, Vertex *vet) { for (int i = 0; i < graph->size; i++) { if (graph->heads[i]->vertex == vet) { return graph->heads[i]; } } return NULL; } /* 添加边 */ void addEdge(GraphAdjList *graph, Vertex *vet1, Vertex *vet2) { AdjListNode *head1 = findNode(graph, vet1); AdjListNode *head2 = findNode(graph, vet2); assert(head1 != NULL && head2 != NULL && head1 != head2); // 添加边 vet1 - vet2 addEdgeHelper(head1, vet2); addEdgeHelper(head2, vet1); } /* 删除边 */ void removeEdge(GraphAdjList *graph, Vertex *vet1, Vertex *vet2) { AdjListNode *head1 = findNode(graph, vet1); AdjListNode *head2 = findNode(graph, vet2); assert(head1 != NULL && head2 != NULL); // 删除边 vet1 - vet2 removeEdgeHelper(head1, head2->vertex); removeEdgeHelper(head2, head1->vertex); } /* 添加顶点 */ void addVertex(GraphAdjList *graph, Vertex *vet) { assert(graph != NULL && graph->size < MAX_SIZE); AdjListNode *head = (AdjListNode *)malloc(sizeof(AdjListNode)); head->vertex = vet; head->next = NULL; // 在邻接表中添加一个新链表 graph->heads[graph->size++] = head; } /* 删除顶点 */ void removeVertex(GraphAdjList *graph, Vertex *vet) { AdjListNode *node = findNode(graph, vet); assert(node != NULL); // 在邻接表中删除顶点 vet 对应的链表 AdjListNode *cur = node, *pre = NULL; while (cur) { pre = cur; cur = cur->next; free(pre); } // 遍历其他顶点的链表，删除所有包含 vet 的边 for (int i = 0; i < graph->size; i++) { cur = graph->heads[i]; pre = NULL; while (cur) { pre = cur; cur = cur->next; if (cur && cur->vertex == vet) { pre->next = cur->next; free(cur); break; } } } // 将该顶点之后的顶点向前移动，以填补空缺 int i; for (i = 0; i < graph->size; i++) { if (graph->heads[i] == node) break; } for (int j = i; j < graph->size - 1; j++) { graph->heads[j] = graph->heads[j + 1]; } graph->size--; free(vet); } \"]},\"220\":{\"h\":\"5.邻接矩阵与邻接表的效率对比\"},\"221\":{\"h\":\"6.图的遍历\",\"t\":[\"树代表的是“一对多”的关系，而图则具有更高的自由度，可以表示任意的“多对多”关系。因此，我们可以把树看作图的一种特例。显然，树的遍历操作也是图的遍历操作的一种特例\",\"图和树都需要应用搜索算法来实现遍历操作。图的遍历方式也可分为两种：广度优先遍历和深度优先遍历\"]},\"222\":{\"h\":\"6.1 广度优先遍历(BFS)\",\"t\":[\"广度优先遍历是一种由近及远的遍历方式，从某个节点出发，始终优先访问距离最近的顶点，并一层层向外扩张\",\"如下图所示，从左上角顶点出发，首先遍历该顶点的所有邻接顶点，然后遍历下一个顶点的所有邻接顶点，以此类推，直至所有顶点访问完毕\"]},\"223\":{\"h\":\"6.2 BFS的算法实现\",\"t\":[\"BFS 通常借助队列来实现，代码如下所示。队列具有“先入先出”的性质，这与 BFS 的“由近及远”的思想异曲同工\",\"将遍历起始顶点 startVet 加入队列，并开启循环\",\"在循环的每轮迭代中，弹出队首顶点并记录访问，然后将该顶点的所有邻接顶点加入到队列尾部\",\"循环步骤2 ，直到所有顶点被访问完毕后结束\",\"时间复杂度：所有顶点都会入队并出队一次，使用O(|V|)时间；在遍历邻接顶点的过程中，由于是无向图，因此所有边都会被访问2次，使用O(2|E|)时间；总体使用O(|V|+|E|)时间空间复杂度：列表 res ，哈希表 visited ，队列 que 中的顶点数量最多为|V|，使用O(|V|)空间\",\"代码相对抽象，建议对照下图来加深理解：\",\"为了防止重复遍历顶点，我们需要借助一个哈希表 visited 来记录哪些节点已被访问：\",\"/* 节点队列结构体 */ typedef struct { Vertex *vertices[MAX_SIZE]; int front, rear, size; } Queue; /* 构造函数 */ Queue *newQueue() { Queue *q = (Queue *)malloc(sizeof(Queue)); q->front = q->rear = q->size = 0; return q; } /* 判断队列是否为空 */ int isEmpty(Queue *q) { return q->size == 0; } /* 入队操作 */ void enqueue(Queue *q, Vertex *vet) { q->vertices[q->rear] = vet; q->rear = (q->rear + 1) % MAX_SIZE; q->size++; } /* 出队操作 */ Vertex *dequeue(Queue *q) { Vertex *vet = q->vertices[q->front]; q->front = (q->front + 1) % MAX_SIZE; q->size--; return vet; } /* 检查顶点是否已被访问 */ int isVisited(Vertex **visited, int size, Vertex *vet) { // 遍历查找节点，使用 O(n) 时间 for (int i = 0; i < size; i++) { if (visited[i] == vet) return 1; } return 0; } /* 广度优先遍历 */ // 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点 void graphBFS(GraphAdjList *graph, Vertex *startVet, Vertex **res, int *resSize, Vertex **visited, int *visitedSize) { // 队列用于实现 BFS Queue *queue = newQueue(); enqueue(queue, startVet); visited[(*visitedSize)++] = startVet; // 以顶点 vet 为起点，循环直至访问完所有顶点 while (!isEmpty(queue)) { Vertex *vet = dequeue(queue); // 队首顶点出队 res[(*resSize)++] = vet; // 记录访问顶点 // 遍历该顶点的所有邻接顶点 AdjListNode *node = findNode(graph, vet); while (node != NULL) { // 跳过已被访问的顶点 if (!isVisited(visited, *visitedSize, node->vertex)) { enqueue(queue, node->vertex); // 只入队未访问的顶点 visited[(*visitedSize)++] = node->vertex; // 标记该顶点已被访问 } node = node->next; } } // 释放内存 free(queue); } \"]},\"224\":{\"h\":\"6.3 深度优先遍历(DFS)\",\"t\":[\"深度优先遍历是一种优先走到底、无路可走再回头的遍历方式。如下图所示，从左上角顶点出发，访问当前顶点的某个邻接顶点，直到走到尽头时返回，再继续走到尽头并返回，以此类推，直至所有顶点遍历完成\"]},\"225\":{\"h\":\"6.4 DFS的算法实现\",\"t\":[\"这种“走到尽头再返回”的算法范式通常基于递归来实现。与广度优先遍历类似，在深度优先遍历中，我们也需要借助一个哈希表 visited 来记录已被访问的顶点，以避免重复访问顶点\",\"时间复杂度：所有顶点都会被访问1次，使用O(|V|)时间；所有边都会被访问2次，使用O(2|E|)时间；总体使用O(|V|+|E|)时间空间复杂度：列表 res ，哈希表 visited 顶点数量最多为|V|，递归深度最大为|V|，因此使用O(|V|)空间\",\"注意：深度优先遍历的序列是否唯一？ 与广度优先遍历类似，深度优先遍历序列的顺序也不是唯一的。给定某顶点，先往哪个方向探索都可以，即邻接顶点的顺序可以任意打乱，都是深度优先遍历 以树的遍历为例，“根 -> 左 -> 右” “左-> 根 -> 右\\\" \\\"左 -> 右 -> 根\\\"分别对应前序、中序、后序遍历，它们展示了三种遍历优先级，然而这三者都属于深度优先遍历 \",\"深度优先遍历的算法流程如图下图所示：\",\"直虚线代表向下递推，表示开启了一个新的递归方法来访问新顶点\",\"曲虚线代表向上回溯，表示此递归方法已经返回，回溯到了开启此方法的位置\",\"/* 检查顶点是否已被访问 */ int isVisited(Vertex **res, int size, Vertex *vet) { // 遍历查找节点，使用 O(n) 时间 for (int i = 0; i < size; i++) { if (res[i] == vet) { return 1; } } return 0; } /* 深度优先遍历辅助函数 */ void dfs(GraphAdjList *graph, Vertex **res, int *resSize, Vertex *vet) { // 记录访问顶点 res[(*resSize)++] = vet; // 遍历该顶点的所有邻接顶点 AdjListNode *node = findNode(graph, vet); while (node != NULL) { // 跳过已被访问的顶点 if (!isVisited(res, *resSize, node->vertex)) { // 递归访问邻接顶点 dfs(graph, res, resSize, node->vertex); } node = node->next; } } /* 深度优先遍历 */ // 使用邻接表来表示图，以便获取指定顶点的所有邻接顶点 void graphDFS(GraphAdjList *graph, Vertex *startVet, Vertex **res, int *resSize) { dfs(graph, res, resSize, startVet); } \"]},\"226\":{\"h\":\"复习思维导图\"},\"227\":{\"h\":\"1.分支与循环语句\"},\"228\":{\"h\":\"2.函数\"},\"229\":{\"h\":\"3.数组\"},\"230\":{\"h\":\"4.操作符\"},\"231\":{\"h\":\"5.指针\"},\"232\":{\"h\":\"6.字符与字符串\"},\"233\":{\"h\":\"7.结构体、枚举、联合体、位段\"},\"234\":{\"h\":\"8.数据存储\"},\"235\":{\"h\":\"9.动态内存分配\"},\"236\":{\"h\":\"10.文件\"},\"237\":{\"h\":\"11.程序的编译、链接、预处理\"},\"238\":{\"h\":\"第一章：C语言概述\"},\"239\":{\"h\":\"1.什么是程序\"},\"240\":{\"h\":\"2.计算机语言简史\",\"t\":[\"第一代：机器语言，使用二进制表示，例如：0000,0000,000000010000 代表 LOAD A, 16第二代：汇编语言，使用助记符表示，例如：add 2,3,result第三代：高级语言，使用指令编写程序，接近自然语言，比如：int num = 10;\"]},\"241\":{\"h\":\"3.C语言的发行版本\",\"t\":[\"K&R C（1978年）： 由柯尼汉和里奇合写的《C 程序设计语言》成为公认标准，简称为K&R C\",\"ANSI C（C89/C90，1989年）： 第一个ISO标准，也叫ANSI C，规范了K&R C，确保了可移植性\",\"C99（1999年）： 第一次大修订，引入许多特性如//注释、可变长度数组等，成为最流行版本\",\"C11（2011年）： 再次修订，增加_Generic、static_assert等功能，跟进新技术\",\"C17（2018年）： C11在2017年修补，2018年发布的C17只解决了C11的缺陷，未加入新功能\",\"C23（2023年）： 2023年发布的C23计划增强安全性、消除实现定义行为、引入模块化语言等，提升安全和可靠性\"]},\"242\":{\"h\":\"第七章：数组\"},\"243\":{\"h\":\"1.数组的概念\",\"t\":[\"（1）什么是数组\",\"数组（Array），是多个相同类型数据按一定顺序排列的集合，并使用一个标识符命名，并通过编号（索引，也称为下标）的方式对这些数据进行统一管理\",\"（2）数组相关概念\",\"数组名：本质上是一个标识符常量，命名需要符合标识符规范元素：同一个数组中的元素必须是相同的数据类型下标（索引、角标）：从0开始的连续数字数组的长度：表示元素的个数\",\"（3）数组的特点\",\"创建数组时会在内存中开辟一整块连续的空间，占据的空间的大小，取决于数组的长度和数组中元素的类型数组中的元素在内存中是依次紧密排列的且有序的数组一旦初始化完成，其长度就是确定的，数组的长度一旦确定，就不能修改我们可以直接通过索引（下标）获取指定位置的元素，速度很快\"]},\"244\":{\"h\":\"2.数组的操作\",\"t\":[\"（1）数组的定义方法一：先指定元素的个数和类型，再进行初始化\",\"// 定义数组，数组名字是 arr1，元素类型是 int，元素个数是 3 个 int arr1[3]; // 定义完成后再给元素赋值 arr1[0] = 100; arr1[1] = 200; arr1[2] = 300; \",\"方法二：指定元素的类型和个数并同时进行初始化\",\"// 定义完数组直接进行初始化 int arr2[3] = {4,5,6}; \",\"方法三：指定元素的类型，不指定元素个数，同时进行初始化\",\"// 没有指定元素个数，系统会自动计算 int arr3[] = {7,8,9,10}; \",\"(2)访问数组元素\",\"通过“数组名[下标]”可以访问数组中的元素\",\"#include <stdio.h> int main() { // 定义 4 个元素的数组 int nums[4] = {10, 20, 30, 40}; // 修改第二个元素的值 nums[1] += 100; // 读取元素的值 printf(\\\"第一个元素的值：%d\\\\n\\\", nums[0]); // 第一个元素的值：10 printf(\\\"第二个元素的值：%d\\\\n\\\", nums[1]); // 第一个元素的值：120 printf(\\\"第三个元素的值：%d\\\\n\\\", nums[2]); // 第一个元素的值：30 printf(\\\"第四个元素的值：%d\\\\n\\\", nums[3]); // 第一个元素的值：40 /* 第一个元素的值：10 第二个元素的值：120 第三个元素的值：30 第四个元素的值：40 */ return 0; } \",\"（3）数组越界\",\"数组下标必须在指定范围内使用，超出范围视为越界\",\"#include <stdio.h> int main() { // 定义数组 没有指定长度 int nums[5] = {10,20,30,40,50}; printf(\\\"下标是0的元素：%d\\\\n\\\", nums[0]); // 10 printf(\\\"下标是4的元素：%d\\\\n\\\", nums[4]); // 50 printf(\\\"下标是-1的元素：%d\\\\n\\\", nums[-1]);// 得到的是不确定结果 printf(\\\"下标是5的元素：%d\\\\n\\\", nums[5]); // 得到的是不确定结果 /* 下标是0的元素：10 下标是4的元素：50 下标是-1的元素：0 下标是5的元素：0 */ return 0; } \",\"（4）计算数组长度数组长度（元素个数）是在数组定义时明确指定且固定的，我们不能在运行时直接获取数组长度，但是，我们可以通过sizeof 运算符间接计算出数组长度，计算步骤如下：\",\"使用sizeof运算符计算出整个数组的字节长度，由于数组成员是同一类型，每个元素字节长度相等，用整个数组的字节长度除以单个元素的字节长度就可以得到数组的长度\",\"#include <stdio.h> int main() { // 定义数组 没有指定长度 int nums[] = {10, 20, 30, 40, 50, 60, 70}; // 计算数组总的字节长度 int arrByteLen = sizeof nums; // 用总字节长度除以单个元素的字节长度 int arrLen = arrByteLen / sizeof nums[0]; printf(\\\"数组的长度：%d\\\", arrLen); // 数组的长度：7 //数组的长度：7 return 0; } \",\"（5）遍历数组遍历数组是指按顺序访问数组中的每个元素，以便读取或修改它们，编程中一般使用循环结构对数组进行遍历\",\"#include <stdio.h> int main() { // 定义数组 int arr[10] = {12, 2, 31, 24, 15, 36, 67, 108, 29, 51}; // 计算数组长度 int len = sizeof arr / sizeof arr[0]; // 遍历数组中的元素 printf(\\\"遍历数组中的元素：\\\\n\\\"); for (int i = 0; i < len; i++) { printf(\\\"%d: %d \\\\n\\\", i, arr[i]); } /* 遍历数组中的元素： 0: 12 1: 2 2: 31 3: 24 4: 15 5: 36 6: 67 7: 108 8: 29 9: 51 */ return 0; } \"]},\"245\":{\"h\":\"3.字符数组(字符串)\",\"t\":[\"（1）字符数组的介绍用来存放字符的数组称为字符数组，也可以称为字符串。字符串的输入输出格式占位符是 %s\",\"字符串结尾，会自动添加一个 \\\\0 作为字符串结束的标志，所以字符数组最后一个元素必须是 \\\\0\\\\0 是ASCII码表中的第0个字符，用NUL表示，称为空字符，该字符既不能显示，也不是控制字符，输出该字符不会有任何效果，它在C语言中仅作为字符串的结束标志\",\"（2）字符数组的定义方法一：最后一个元素设置成 \\\\0\",\"在给某个字符数组赋值时，赋值的元素个数小于字符数组的长度，则会自动在后面加 '\\\\0', 表示字符串结束； 赋值的元素的个数等于该数组的长度（或不指定数组长度），则不会自动添加 '\\\\0'\",\"#include <stdio.h> int main() { char str1[12] = {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd', '\\\\0'}; // 显式地设值 \\\\0 char str2[4] = {'t', 'o', 'm'}; // 后面自动添加 \\\\0 char str3[] = {'j', 'a', 'c', 'k'}; // 不会自动添加 \\\\0 printf(\\\"str1=%s \\\\n\\\", str1); printf(\\\"str2=%s \\\\n\\\", str2); printf(\\\"str3=%s \\\\n\\\", str3); // 由于没有结束标识，会包括相邻内存的数据，直到遇到结束标记 /* str1=Hello World str2=tom str3=jacktom */ return 0; } \",\"方法二：简化写法\",\"#include <stdio.h> int main() { char str1[] = {\\\"I am happy\\\"}; // 后面自动添加 \\\\0 char str2[] = \\\"I am happy\\\"; // 省略{}号,后面自动添加 \\\\0 printf(\\\"\\\\n str1=%s\\\", str1); printf(\\\"\\\\n str2=%s\\\", str2); /* str1=I am happy str2=I am happy */ return 0; } \",\"（3）字符数组的访问和遍历字符数组（字符串）的访问和遍历，按照一般数组的方式访问和遍历即可\",\"#include <stdio.h> int main() { // 定义字符串 char greeting[] = \\\"Hello\\\"; // 计算字符串长度 int len = sizeof greeting / sizeof greeting[0]; printf(\\\"%s \\\\n\\\", greeting); printf(\\\"数组长度：%d \\\\n\\\", len); printf(\\\"第3个字符: %c \\\\n\\\", greeting[2]); printf(\\\"\\\\n\\\"); // 遍历字符串 for (int i = 0; i < len; i++) { printf(\\\"%c \\\\n\\\", greeting[i]); } /* Hello 数组长度：6 第3个字符: l H e l l o */ return 0; } \"]},\"246\":{\"h\":\"4.多维数组\",\"t\":[\"（1）多维数组的介绍\",\"如果数组的元素还是数组，这样的数组就称为多维数组。这种多层次的结构允许我们以表格或矩阵的方式组织数据，其中每个维度都对应于不同的行、列或更多的维度，使数据更加结构化和有组织多维数组可以分为二维数组、三维数组、四维数组 …… 等，这里我们以二维数组为例进行演示\",\"（2）二位数组的定义方法一：先定义再初始化\",\"// 定义一个4行6列的二维数组 int a[4][6]; // 进行初始化赋值 a[0][0] = 10 a[0][1] = 20; a[0][2] = 30; a[0][3] = 40; a[0][4] = 50; a[0][5] = 60; a[1][0] = 100; a[1][1] = 200; …… \",\"方法二：直接定义并初始化\",\"// 定义一个4行6列的二维数组，以为矩阵的形式初始化 int a[4][6] = { {10, 20, 30, 30, 40, 60}, {100, 200, 300, 400, 500, 600}, {1000, 2000, 3000, 4000, 5000, 6000}, {10000, 20000, 30000, 40000, 50000, 60000} }; // 定义一个4行6列的二维数组, 会自动匹配到各行各列 int b[4][6] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24}; // 如果所赋值的数量可以与元素数量对应，第一维的数组长度可以不给出 int b[][6] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24}; \",\"（3）二维数组的访问和遍历\",\"访问二维数组的元素，需要使用两个下标（索引），一个用于访问行（第一维），另一个用于访问列（第二维），我们通常称为行下标（行索引）或列下标（列索引）遍历二维数组，需要使用双层循环结构\",\"#include <stdio.h> int main() { // 定义一个 3 行 4 列的数组 int map[3][4] = { {1, 2, 3, 4}, {11, 12, 13, 14}, {21, 22, 23, 24}}; // 计算第一维度的长度 int rows = sizeof(map) / sizeof(map[0]); // 计算第二维度的长度 int cols = sizeof(map[0]) / sizeof(int); // 遍历输出每个元素 for (int i = 0; i < rows; i++) { for (int j = 0; j < cols; j++) { printf(\\\"%d\\\\t\\\", map[i][j]); // \\\\t 可以输出得更加整齐 } printf(\\\"\\\\n\\\"); } // 计算所有元素的和 int sum = 0; for (int i = 0; i < rows; i++) { for (int j = 0; j < cols; j++) { sum += map[i][j]; } } printf(\\\"所有元素的和：%d\\\", sum); // 所有元素的和：150 /* 1 2 3 4 11 12 13 14 21 22 23 24 所有元素的和：150 */ return 0; } \",\"（4）二维数组的内存分析\",\"用矩阵形式（如3行4列形式）表示二维数组，是逻辑上的概念，能形象地表示出行列关系。而在内存中，各元素是连续存放的，不是二维的，是线性的C语言中，二维数组中元素排列的顺序是按行存放的。即：先顺序存放第一行的元素，再存放第二行的元素\"]},\"247\":{\"h\":\"第三章：变量和常量\"},\"248\":{\"h\":\"1.变量\"},\"249\":{\"h\":\"1.1 变量的概念\",\"t\":[\"（1）变量是内存中的一个存储区域，该区域的数据可以在同一类型范围内不断变化（2）通过变量名，可以引用这块内存区域，获取里面存储的值（3）变量的构成包含三个要素：数据类型、变量名、存储的值\"]},\"250\":{\"h\":\"1.2 变量的声明和使用\",\"t\":[\"（1）变量必须先声明，后使用 （2）可以先声明变量再赋值，也可以在声明变量的同时进行赋值 （3）变量的值可以在同一类型范围内不断变化\",\"#include <stdio.h> int main() { // 声明一个整型变量，取名为 a int a; // 对变量 a 进行赋值 a = 100; // 声明一个整型变量，取名为 b，并直接赋值 int b = 200; // 修改变量 b 的值， 将变量 a 的值赋值给 b b = a; // 同时声明多个整型变量并赋值 int c1 = 10, c2 = 20, c3 = 30; //不推荐一行声明多个变量，建议分开声明，这是一种不好的代码风格 return 0; } \"]},\"251\":{\"h\":\"1.3 输出变量\",\"t\":[\"printf 的标准含义是格式化输出文本，printf 名称来源于 \\\"print formatted\\\"（格式化打印）的缩写，标准语法规则如下：\",\"（1）格式化字符串是用双引号括起来的一个字符串，里面包括格式占位符和普通字符（2）格式占位符，也叫格式声明符，由“%”和格式字符组成，作用是将输出的数据转换为指定的格式后输出，这里“%d”表示整数，更多的格式占位符后续会进行讲解（3）输出列表是程序需要输出的一些数据，可以是常量、变量或表达式，与格式占位符一一对应\",\"#include <stdio.h> int main() { // 声明一个整型变量，取名为 a int a; // 对变量 a 进行赋值 a = 100; // 声明一个整型变量，取名为 b，并直接赋值 int b = 200; // 输出变量的值 printf(\\\"a=%d \\\\n\\\", a); // 使用输出语句，把变量a 值输出， %d 表示输出的形式为整数 printf(\\\"b=%d \\\\n\\\", b); // 使用输出语句，把变量b 值输出， %d 表示输出的形式为整数 // 修改变量 b 的值， 将变量 a 的值赋值给 b b = a; // 输出变量的值 printf(\\\"b=%d \\\\n\\\", b); // 使用输出语句，把变量b 值输出， %d 表示输出的形式为整数 // 同时声明多个整型变量并赋值 int c1 = 10, c2 = 20, c3 = 30; printf(\\\"%d %d %d\\\", c1, c2, c3); // 10 20 30 /* 输出结果： a=100 b=200 b=100 10 20 30 */ return 0; } \"]},\"252\":{\"h\":\"1.4 输入赋值变量\",\"t\":[\"scanf主要用于从标准输入（通常是键盘）读取数据并将其存储到指定的变量中（变量需要提前声明），同printf一样，位于头文件 <stdio.h> 中\",\"#include <stdio.h> int main() { int num; printf(\\\"Please Input A Number: \\\"); scanf(\\\"%d\\\", &num); // 从标准输入读取整数，并将其存储到变量 num 中 printf(\\\"Your Number Is: %d\\\\n\\\", num); int num1, num2, num3; printf(\\\"PLeaase Input Three Number: \\\"); scanf(\\\"%d %d %d\\\", &num1, &num2, &num3); // 从标准输入读取3个整数，使用空格分隔，并将分别将其存储到变量 num1、num2、num31 中 printf(\\\"Numbers: %d, %d, %d\\\", num1, num2, num3); return 0; } \",\"需要注意的是，scanf中，变量名前面需要添加 & 符号，该符号称为取地址符，没有它就没法正确读取值。与printf相同，scanf也可以通过不同格式占位符为不同类型的变量获取值\"]},\"253\":{\"h\":\"2.常量\",\"t\":[\"程序运行时，其值不能改变的量，即为常量\"]},\"254\":{\"h\":\"2.1 常量的分类\",\"t\":[\"（1）字面量常量，直接使用的常量，不需要定义或声明，包括整数常量、浮点数常量、字符常量 （2）标识符常量，使用标识符作为常量名，包括 #define 定义的标识符常量和const 关键字定义的标识符常量以及枚举常量\"]},\"255\":{\"h\":\"2.2 常量的定义\",\"t\":[\"常量的定义方法主要有：①使用#define定义常量、②使用const关键字\",\"（1）使用#define定义常量：\",\"#define 来定义常量，也叫作宏定义，就是用一个标识符来表示一个常量值，如果在后面的代码中出现了该标识符，那么编译时就全部替换成指定的常量值，即用宏体替换所有宏名，简称宏替换#define定义常量的格式：注意：不要用分号结尾，分号会成为常量值的一部分，会出现;;这种情况。#define必须写在main函数外面\",\"#include <stdio.h> #define PI 3.14 // 定义常量 PI，常量值 3.14 int main() { double area; double r = 1.2; area = PI * r * r; printf(\\\"面积 : %.2f\\\", area); //面积：4.52 return 0; } \",\"（2）const关键字\",\"跟使用 #define定义宏常量相比，const定义的常量有详细的数据类型，而且会在编译阶段进行安全检查，在运行时才完成替换，所以会更加安全和方便const定义常量的格式：;\",\"#include <stdio.h> const double PI = 3.14; // const 定义常量时，需要加分号 int main() { double area; double r = 1.2; area = PI * r * r; printf(\\\"面积 : %.2f\\\", area); //面积：4.52 return 0; } \",\"（3）#define和const定义常量的区别\",\"1.执行时机：#define是预处理指令，在编译之前执行；const是关键字，在编译过程中执行2.类型检查：#define定义常量不用指定类型，不进行类型检查，只是简单地文本替换；const定义常量需指定数据类型，会进行类型检查，类型安全性更强\"]},\"256\":{\"h\":\"3.标识符\",\"t\":[\"C语言中变量、函数、数组名、结构体等要素命名时使用的字符序列，称为标识符\"]},\"257\":{\"h\":\"3.1 标识符命名规范\",\"t\":[\"强制规范 （1）只能由大小写组成 （2） （3） （4），不同编译器和平台会有所不同，一般限制在63个字符内 （5）。比如：Hello、hello是不同的标识符\",\"合法标识符举例： a、BOOK_sun、MAX_SIZE、Mouse、student23、Football、FOOTBALL、max、_add、num_1、sum_of_numbers 非法标识符举例： $zj、3sum、ab#cd、23student、Foot-baii、s.com、b＆c、j**p、book-1、tax rate、don't \"]},\"258\":{\"h\":\"3.2 规范命名风格\",\"t\":[\"（1）为了提高阅读性，使用有意义的单词，见名知意，如：sum，name，max，year等 （2）使用下划线连接多个单词组成的标识符，如：max_classes_per_student （3）多个单词组成的标识符，除了使用下划线连接，也可以使用小驼峰命名法，除第一个单词外，后续单词的首字母大写，如 myVariableName、maxClassesPerStudent （4）不要出现仅靠大小写区分不同的标识符，如：name、Name容易混淆 （5）系统内部使用了一些下划线开头的标识符，比如，C99标准添加的类型 _Bool，为防止冲突，建议开发者尽量避免使用下划线开头的标识符\"]},\"259\":{\"h\":\"3.3 关键字\",\"t\":[\"关键字是一些具有特殊含义的保留单词\",\"类型\",\"具体关键字\",\"控制语句关键字(12)个\",\"break, case, continue, default, do, else, for, goto, if, return, switch, while\",\"数据类型关键字(12)个\",\"char, enum, double, long, float, int, short, signed, struct, unsigned, union, void\",\"存储类型关键字(4)个\",\"auto, extern, register, static\",\"其他关键字(4)个\",\"const, sizeof, typedef, volatile\",\"C99标准增加了5个关键字：inline、restrict、_Bool、_Complex和_Imaginary\\nC11标准增加了7个关键字：_Alignas、_Alignof、_Atomic、_Static_assert、_Noreturn、_Thread_local和_Generic。\"]},\"260\":{\"h\":\"第九章：指针\"},\"261\":{\"h\":\"1.指针的理解\",\"t\":[\"（1）变量的访问方式\",\"内存是电脑上特别重要的存储器，计算机中程序的运行都是在内存中进行的 ，为了有效的使用内存，就把内存划分成一个个小的内存单元，每个内存单元通常占用1个字节\",\"变量在内存中分配空间，不同类型的变量占用不同大小的空间，那如何访问内存中的变量数据呢？有两种方式：\",\"直接访问，直接使用变量名进行的访问，以前的程序中都是采用这种方式间接访问，通过指针来实现\",\"（2）内存地址\",\"为了能够有效地访问到每个内存单元，就给内存单元进行了编号，这些编号被称为内存地址，因为每个内存单元都有地址，所以变量也是有地址的\",\"假设有 int 型变量 num，其在内存中会占用4个字节，也就是占用4个内存单元，第一个内存单元的地址即是变量 num 的地址。如图；\",\"在32位系统中，内存地址通常是32位二进制数字，即4个字节，这允许寻址2^32（大约 4GB）个内存位置在64位系统中，内存地址通常是64位二进制数字，即8个字节，这允许寻址2^64个内存位置，这个数量相当大，远远超过了通常需要的内存大小\",\"（3）什么是指针\",\"如果一个变量专门用来存放内存地址，则它称为指针变量，通常简称为指针。我们可以通过指针间接访问内存中另一个数据\",\"如图，指针里面存储的是变量 num 的地址，我们可以说该指针指向变量 num，通过该指针可以间接访问变量 num\",\"（4）指针的定义\",\"一般格式：数据类型 * 指针变量名 [=初始地址值]; *的放置位置：靠近数据类型，放左边，一行定义一个指针，防止出问题\",\"数据类型是指针所指向的地址处的数据类型，如 int、char、float 等符号 * 用于通知系统，这里定义的是一个指针变量，通常跟在类型关键字的后面，表示指针指向的是什么类型的值。比如，char * 表示一个指向字符的指针，float * 表示一个指向浮点数的指针\",\"（5）取址运算符和取值运算符\",\"取址运算符，使用 & 符号表示，作用是取出变量的内存地址。如果要格式化输出地址，需使用格式占位符 %p取值运算符，使用 * 符号表示，作用是取出指针指向的内存地址处的数据值，也称为解引用运算符或间接引用运算符\",\"（6）指针的大小\",\"指针大小一般为：4/8字节。指针大小只与地址线有关\"]},\"262\":{\"h\":\"2.指针的运算\",\"t\":[\"（1）指针加减整数\",\"指针与整数的加减运算，表示指针所指向的内存地址的移动（加，向后移动；减，向前移动），指针移动多少，与指针指向的数据类型有关，数据类型占据多少个字节，每单位就移动多少个字节，比如一个 int 类型指针，+1 向后移动 4 个字节，-2 向前移动 8 个字节由于数组的元素在内存中连续存储的，我们通过数组元素来演示指针加减整数的情况\",\"#include <stdio.h> int main() { // 创建数组 int nums[] = {10, 20, 30, 40, 50}; // 创建指针并指向数组第一个元素的地址 int *ptr = &nums[0]; // 打印指针的值和指向的值 printf(\\\"ptr=%p, *ptr=%d \\\\n\\\", ptr, *ptr); // 指针加3, 指针指向int类型，每个占4个字节，此时指针会向后移动12个字节 ptr += 3; printf(\\\"ptr=%p, *ptr=%d \\\\n\\\", ptr, *ptr); // 指针-2，此时指针会向前移动8个字节 ptr -= 2; printf(\\\"ptr=%p, *ptr=%d \\\\n\\\", ptr, *ptr); /* ptr=000000000061FE00, *ptr=10 ptr=000000000061FE0C, *ptr=40 ptr=000000000061FE04, *ptr=20 */ return 0; } \",\"（2）指针自增自减\",\"指针自增、自减本质上就是指针加减整数，自增地址后移，自减地址前移。下面我们利用指针的自增自减实现数组的遍历，代码如下：\",\"#include <stdio.h> int main() { // 创建数组，元素都是short类型，占据2个字节 short nums[] = {10, 20, 30, 40, 50}; // 定义常量记录数组长度 const int len = 5; // 利用指针自增遍历数组元素 // 创建指针并指向数组第一个元素的地址 short *ptr = &nums[0]; // 循环 for (int i = 0; i < len; i++) { printf(\\\"元素索引：%d, 元素地址：%p, 元素值：%d \\\\n\\\", i, ptr, *ptr); ptr++; // 指针自增 } printf(\\\"\\\\n\\\"); // 利用指针自减再次遍历数组 // 此时指针超出数组界限，需先自减一次 for (int i = len - 1; i >= 0; i--) { ptr--; // 指针自减 printf(\\\"元素索引：%d, 元素地址：%p, 元素值：%d \\\\n\\\", i, ptr, *ptr); } /* 元素索引：0, 元素地址：0000000e1efffe02, 元素值：10 元素索引：1, 元素地址：0000000e1efffe04, 元素值：20 元素索引：2, 元素地址：0000000e1efffe06, 元素值：30 元素索引：3, 元素地址：0000000e1efffe08, 元素值：40 元素索引：4, 元素地址：0000000e1efffe0a, 元素值：50 元素索引：4, 元素地址：0000000e1efffe0a, 元素值：50 元素索引：3, 元素地址：0000000e1efffe08, 元素值：40 元素索引：2, 元素地址：0000000e1efffe06, 元素值：30 元素索引：1, 元素地址：0000000e1efffe04, 元素值：20 元素索引：0, 元素地址：0000000e1efffe02, 元素值：10 */ return 0; } \",\"（3）同类型指针相减\",\"相同类型的指针可以进行减法运算，返回它们之间的距离，即相隔多少个数据单位。高位地址减去低位地址，返回的是正值；低位地址减去高位地址，返回的是负值同类型指针相减的结果是一个 ptrdiff_t 类型数据，ptrdiff_t 类型是一个带符号的整数，格式输出中对应的格式占位符是 %td，相关案例如下：\",\"#include <stdio.h> int main() { // 创建数组 int nums[] = {10, 20, 30, 40, 50}; // 创建指针并指向数组第一个元素的地址 int *ptr1 = &nums[0]; // 创建指针并指向数组第四个元素的地址 int *ptr2 = &nums[3]; printf(\\\"ptr2-ptr1=%td \\\\n\\\", ptr2 - ptr1); // ptr2-ptr1=3 printf(\\\"ptr1-ptr2=%td \\\\n\\\", ptr1 - ptr2); // ptr1-ptr2=-3 // 再创建两个指针进行相减 double d1 = 1.0; double d2 = 2.0; double *p1 = &d1, *p2 = &d2; printf(\\\"p1-p2=%td \\\\n\\\", p1 - p2); // p1-p2=1 printf(\\\"p2-p1=%td \\\\n\\\", p2 - p1); // p2-p1=-1 /* ptr2-ptr1=3 ptr1-ptr2=-3 p1-p2=1 p2-p1=-1 内存示意 */ return 0; } \",\"（4）指针的比较运算\",\"指针之间可以进行比较运算，如 ==、<、 <= 、 >、 >=，比较的是各自指向的内存地址的大小，返回值是 int 类型整数 1 （true）或 0 （false）。案例演示如下：\",\"#include <stdio.h> int main() { // 创建数组 int nums[] = {10, 20, 30, 40, 50}; double n = 1.0; // 创建指针并指向数组第一个元素的地址 int *ptr1 = &nums[0]; // 创建指针并指向数组第四个元素的地址 int *ptr2 = &nums[3]; // 创建指针也向数组第一个元素的地址 int *ptr3 = &nums[0]; // 创建指针指向变量n的地址 double *ptr4 = &n; // 输出指针指向的地址 printf(\\\"ptr1=%p\\\\n\\\", ptr1); printf(\\\"ptr2=%p\\\\n\\\", ptr2); printf(\\\"ptr3=%p\\\\n\\\", ptr3); printf(\\\"ptr4=%p\\\\n\\\\n\\\", ptr4); // 进行比较 printf(\\\"ptr1>ptr2: %d \\\\n\\\", ptr1 > ptr2); printf(\\\"ptr1<ptr2: %d \\\\n\\\", ptr1 < ptr2); printf(\\\"ptr1==ptr3: %d \\\\n\\\", ptr1 == ptr3); printf(\\\"ptr4>ptr1: %d \\\\n\\\", ptr4 > ptr1); // 由于是不同类型的指针进行比较，所以会有一个警告 /* ptr1=000000d4385ffd10 ptr2=000000d4385ffd1c ptr3=000000d4385ffd10 ptr4=000000d4385ffd08 ptr1>ptr2: 0 ptr1<ptr2: 1 ptr1==ptr3: 1 ptr4>ptr1: 0 */ return 0; } \"]},\"263\":{\"h\":\"3.指针和数组\",\"t\":[\"（1）数组名\",\"数组名在大多数情况下会被隐式地转换为指向数组第一个元素的指针，在特定情况下数组名可以被视为一个指针，具有一些指针的特性\",\"但是，数组名与真正的指针是不同的，主要有以下几点区别\",\"使用 sizeof 运算符，数组名得到的是整个数组的大小；指针得到的是本身的大小数组名不能进行自增、自减运算数组名的指向不可更改\",\"#include <stdio.h> int main() { // 创建数组 int nums[5] = {10, 20, 30, 40, 50}; // 创建指针指向数组的第一个元素 int *ptr = &nums[0]; // 数组名中存储了第一个元素的地址 printf(\\\"%p, %d \\\\n\\\", nums, *nums); printf(\\\"%p, %d \\\\n\\\", ptr, *ptr); // nums 和 ptr 比较 if (nums == ptr) { printf(\\\"nums 和 ptr 相等 \\\\n\\\\n\\\"); } else { printf(\\\"nums 和 ptr 不相等 \\\\n\\\\n\\\"); } // 数组名与真正的指针存在差别 // 1. sizeof 运算符返回的是整个数组的大小，而指针返回的是本身的大小 printf(\\\"%zu, %zu \\\\n\\\", sizeof nums, sizeof ptr); // 2. 数组名不能进行自增、自减运算 // nums ++; // 报错 ptr++; // 地址指向下一个元素 printf(\\\"%p, %d \\\\n\\\", ptr, *ptr); // 3. 数组名的指向不可修改 int n = 100; // nums = &n; // 报错 ptr = &n; printf(\\\"%p, %d \\\\n\\\", ptr, *ptr); /* 0000000cdb5ffe60, 10 0000000cdb5ffe60, 10 nums 和 ptr 相等 20, 8 0000000cdb5ffe64, 20 0000000cdb5ffe5c, 100 */ return 0; } \",\"（2）指针数组指针数组（Pointer Array）是一个数组，其中的每个元素都是指针\",\"语法规则：数据类型 * 指针数组名[长度];\",\"#include <stdio.h> int main() { // 创建三个变量 int num1 = 10, num2 = 20, num3 = 30; // 创建一个长度为3的指针数组 int *ptrArr[3]; // 指针数组的每个元素指向不同的整数 ptrArr[0] = &num1; ptrArr[1] = &num2; ptrArr[2] = &num3; // 遍历指针数组 for (int i = 0; i < 3; i++) { printf(\\\"%d, %p, %d \\\\n\\\", i, ptrArr[i], *ptrArr[i]); } /* 0, 0000009c22fff898, 10 1, 0000009c22fff894, 20 2, 0000009c22fff890, 30 */ return 0; } \",\"（3）数组指针数组指针（Array Pointer）是一个指针，它指向一个数组。注意，数组指针指向的是整个数组的地址而不是第一个元素的地址，虽然二者值是相同的，但在运算中会表现出不同\",\"语法规则：数据类型 ( * 数组指针名)[长度];\",\"#include <stdio.h> int main() { // 创建整数数组 int arr[5] = {10, 20, 30, 40, 50}; // 创建指针指向数组arr &arr表示整个数组的地址 int(*ptr)[5] = &arr; // int (*ptr)[5] = arr; // 会有警告, arr 的类是 int *, ptr 类型是 int (*)[5] // 二者值是相同的 printf(\\\"arr=%p \\\\n\\\", arr); printf(\\\"ptr=%p \\\\n\\\\n\\\", ptr); // 数组指针指向的是数组的地址，而不是第一个元素的地址 // 数组指针+1会向后移动4*5=20个字节；数组+1会向后移动4个字节 printf(\\\"arr+1=%p \\\\n\\\", arr + 1); printf(\\\"ptr+1=%p \\\\n\\\\n\\\", ptr + 1); // 使用数组指针遍历数组 for (int i = 0; i < 5; i++) { printf(\\\"%d \\\\n\\\", (*ptr)[i]); } /* arr=000000f6d35ff9c0 ptr=000000f6d35ff9c0 arr+1=000000f6d35ff9c4 ptr+1=000000f6d35ff9d4 10 20 30 40 50 */ return 0; } \",\"数组指针和数组名的区别：\",\"①指向不同：数组名指向元素首地址，数组指针指向数组的地址 ②类型不同：上面案例中，arr 的类型是 int[5],；ptr 的类型是 int(*)[5] ③可变性：数组名通常是不可变的；数组指针是可变的，你可以将它指向不同的数组 ④初始化：数组名不需要显式初始化，它会自动指向数组的首元素；数组指针需要显式初始化，指定它将指向的数组 ⑤访问元素：数组名访问数组元素不需要解引用；数组指针通常需要解引用才能访问数组元素 \",\"（4）字符指针字符指针变量（简称字符指针）是C语言中的一种指针类型，它用于指向字符或字符串（字符数组），通常用于处理字符串（字符数组）\",\"用字符指针指向一个字符串：char * pStr= \\\"hello tom\\\";\",\"C语言对字符串\\\" hello tom\\\"是按字符数组处理的，在内存中开辟了一个字符数组用来存放字符串，程序在定义字符串指针pStr时只是把字符串首地址（即存放字符串的字符数组的首地址）赋给pStr\",\"字符数组名和字符指针表示字符串的区别:\",\"对字符数组只能对各个元素赋值，不能对字符数组名重新赋值\",\"char str[14]; str=\\\" hello tom\\\"; //错误 str[0] = 'i'; //ok \",\"字符指针是可变的，允许使用下面方法重新赋值，指向新的字符串\",\"char *a = \\\"hello tom\\\"; a = \\\"tom\\\"; \"]},\"264\":{\"h\":\"4.指针和函数\",\"t\":[\"（1）传递指针给函数当函数的形参类型是指针类型时，使用该函数时，需要传递指针、地址或者数组给该形参\",\"传地址或指针给函数\",\"#include <stdio.h> // 函数原型 void func(int *); int main() { int num = 100; int *ptr = &num; // 调用函数,传地址 func(&num); printf(\\\"num = %d\\\\n\\\", num); // 调用函数,传指针 func(ptr); printf(\\\"num = %d\\\\n\\\", num); /* num = 101 num = 102 */ return 0; } // 函数声明 void func(int *p) { *p += 1; } \",\"（2）传数组给函数数组名本身就代表数组首地址，因此传数组的本质就是传地址\",\"#include <stdio.h> /* 函数声明 */ double getAverage(int *arr, int size); int main() { /* 带有 5 个元素的整型数组 */ int balance[5] = {1000, 2, 3, 17, 50}; double avg; /* 传递一个指向数组的指针作为参数 */ avg = getAverage(balance, 5); /* 输出返回值 */ printf(\\\"Average value is: %f\\\\n\\\", avg); /* arr存放的地址:000000f47adff850 arr存放的地址:000000f47adff854 arr存放的地址:000000f47adff858 arr存放的地址:000000f47adff85c arr存放的地址:000000f47adff860 Average value is: 214.400000 */ return 0; } // 函数定义 double getAverage(int *arr, int size) { int sum = 0; double avg; for (int i = 0; i < size; ++i) { sum += *arr; printf(\\\"arr存放的地址:%p \\\\n\\\", arr); arr++; } avg = (double)sum / size; return avg; } \"]},\"265\":{\"h\":\"5.多级指针(指向指针的指针)\",\"t\":[\"（1）多级指针基本介绍指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置\",\"（2）多级指针的定义与使用\",\"声明多级指针时，需要使用多个星号来表示指针的级别\",\"int *ptr; // 一级指针 int **pptr; // 二级指针 int ***ppptr; // 三级指针 \",\"初始化多级指针时，你需要逐级给指针赋值，确保每个级别的指针指向正确的目标\",\"int var; int *ptr = &var; // 一级指针指向 var int **pptr = &ptr; // 二级指针指向 ptr int ***ppptr = &pptr; // 三级指针指向 pptr \",\"解引用多级指针时，需要根据指针的级别使用适当数量的星号解引用操作\",\"printf(\\\"Value of var: %d\\\\n\\\", var); printf(\\\"Value of ptr: %d\\\\n\\\", *ptr); // 解引用一次 printf(\\\"Value of pptr: %d\\\\n\\\", **pptr); // 解引用两次 printf(\\\"Value of ppptr: %d\\\\n\\\", ***ppptr); // 解引用三次 \",\"使用案例：\",\"#include <stdio.h> int main() { int var; int *ptr; // 一级指针 int **pptr; // 二级指针 int ***ppptr; // 三级指针 var = 3000; ptr = &var; // var 变量的地址赋给 ptr pptr = &ptr; // 表示将 ptr 存放的地址，赋给 pptr ppptr = &pptr; // 表示将 pptr 存放的地址，赋给 ppptr printf(\\\"var`s address is %p \\\\nvar`s value is %d \\\\n\\\\n\\\", &var, var); printf(\\\"ptr`s adddress is %p \\\\nptr`s value is %p \\\\n*ptr=%d \\\\n\\\\n\\\", &ptr, ptr, *ptr); printf(\\\"pptr`s address is %p \\\\npptr`s value is %p \\\\n*pptr=%p \\\\n**pptr=%d \\\\n\\\\n\\\", &pptr, pptr, *pptr, **pptr); printf(\\\"ppptr`s address is %p \\\\nppptr`s value is %p \\\\n*ppptr=%p \\\\n**ppptr=%p \\\\n***ppptr=%d \\\\n\\\\n\\\", &ppptr, ppptr, *ppptr, **ppptr, ***ppptr); /* var`s address is 0000000cffbffdec var`s value is 3000 ptr`s adddress is 0000000cffbffde0 ptr`s value is 0000000cffbffdec *ptr=3000 pptr`s address is 0000000cffbffdd8 pptr`s value is 0000000cffbffde0 *pptr=0000000cffbffdec **pptr=3000 ppptr`s address is 0000000cffbffdd0 ppptr`s value is 0000000cffbffdd8 *ppptr=0000000cffbffde0 **ppptr=0000000cffbffdec ***ppptr=3000 */ return 0; } \"]},\"266\":{\"h\":\"7.空指针\",\"t\":[\"赋为NULL 值的指针被称为空指针，NULL 是一个定义在标准库 <stdio.h>中的值为零的宏常量\",\"声明指针变量的时候，如果没有确切的地址赋值，为指针变量赋一个NULL 值是好的编程习惯\",\"#include <stdio.h> int main() { int *p = NULL; int num = 34; p = &num; printf(\\\"p=%p\\\\n\\\", p); printf(\\\"*p=%d\\\\n\\\", *p); /* p=000000000061FE14 *p=34 */ return 0; } \"]},\"267\":{\"h\":\"8.野指针\",\"t\":[\"（1）什么是野指针\",\"野指针就是指针指向的位置是不可知（随机性，不正确，没有明确限制的）\",\"（2）野指针的成因\",\"指针使用前未初始化\",\"//指针变量在定义时如果未初始化，其值是随机的，此时操作指针就是去访问一个不确定的地址，所以结果是不可知的。此时p就为野指针 int *p; printf(\\\"%d\\\\n\\\", *p); //在没有给指针变量显式初始化的情况下，一系列的操作(包括修改指向内存的数据的值)也是错误的 int *p; *p = 10; \",\"指针越界访问\",\"//当 p += 4之后，此时 *p 访问的内存空间不在数组有效范围内，此时 *p 就属于非法访问内存空间，p为野指针 int arr[4] = {10,20,30,40}; int *p = arr; p += 4; printf(\\\"%d\\\", *p); // 此时 *p 即为越界访问 \",\"指针指向已释放的空间\",\"//调用test()函数将返回值赋给p，test函数的返回值是局部变量a的地址，函数调用结束局部变量会被销毁，其所占用的内存空间会被释放，p 指向的是已经释放的内存空间，所以 p 是野指针 #include <stdio.h> int *test() { int a = 10; return &a; //&a=0x0012ff40 } int main() { int *p = test(); printf(\\\"%d\\\", *p); return 0; } \",\"（3）如何避免野指针\",\"指针初始化如果没有确切的地址赋值，为指针变量赋一个 NULL 值是好的编程习惯小心指针越界避免返回指向局部变量的指针指针使用之前检查指针是否为 NULL\"]},\"268\":{\"h\":\"9.指针的描述\"},\"269\":{\"h\":\"第二章：C语言开发环境\"},\"270\":{\"h\":\"1.开发工具选择\",\"t\":[\"Visual Studio：Visual Studio（简称 VS）是由微软公司发布的集成开发环境，它包括了整个软件生命周期中所需要的大部分工具，如UML工具、代码管控工具、集成开发环境（IDE）等\",\"Code::Block：Code::Block是一个免费的跨平台IDE，它支持C、C++和Fortan程序的开发，Code::Block的最大特点是它支持通过插件的方式对IDE自身功能进行扩展，这使得Code::Block具有很强的灵活性，方便用户使用\",\"Clion：CLion是一款由JetBrains推出的跨平台C/C++集成开发环境（IDE），它具有智能编辑器、CMake构建支持、调试器、单元测试、代码分析等功能,可以极大提高C/C++开发效率\",\"Vscode：Visual Studio Code（简称VS Code）是一款由Microsoft开发的免费、开源的代码编辑器，它是一种轻量级但功能强大的集成开发环境（IDE），VS Code旨在提供一种优秀的编码体验，适用于各种编程语言和应用程序开发任务\",\"注意：Windows环境需要安装MinGW-64、Linux环境需要安装Gcc、G++等工具\"]},\"271\":{\"h\":\"2.C程序执行流程\",\"t\":[\"（1）编写：编写C语言源程序代码，并以文件的形式存储到磁盘中，源代码文件以“.c”作为扩展名，如本项目中 文件（2）预处理：在编译之前，预处理器会处理源代码文件，主要进行一些文本上的处理，包括去掉多余的空格和注释，处理预处理指令，生成经过处理的源代码文件，通常带有扩展名（3）编译：编译器接受预处理后的源代码文件，并将其翻译成汇编代码，生成汇编文件，通常带有扩展名（4）汇编：汇编器将汇编代码翻译成机器码并生成一个或多个目标文件，目标文件是二进制文件，通常带有（在Windows上）（5）链接：链接器将多个目标文件（如果有的话）合并在一起，包括C标准库文件和其他库文件，生成最终的可执行的二进制程序（ 程序）（6）运行：执行该.exe文件得到程序的运行结果说明：库文件是由系统提供，里面包括内置的标准函数和数据结构集合等，我们代码中使用的 <stdio.h> 就是标准库提供的，里面定义 printf 这个函数\"]},\"272\":{\"h\":\"3.C语言开发注意事项\",\"t\":[\"（1）C程序源文件以\\\"c\\\"为扩展名 （2）C程序的执行入口是main() 函数 （3）C语言严格区分大小写 （4）C程序由一条条语句构成，每个语句以 \\\";\\\" 结束\"]},\"273\":{\"h\":\"4.C语言注释\",\"t\":[\"（1）//单行注释：用来注释一行内容 （2）/* 多行注释：用来注释一块内容 */ \"]},\"274\":{\"h\":\"第五章：运算符\"},\"275\":{\"h\":\"1.运算符基础\",\"t\":[\"运算符：是一种特殊的符号，用以用于数据的运算、赋值和比较等表达式：是一组运算数、运算符的组合，表达式一定具有值，一个变量或一个常量就是一个表达式，变量、常量与运算符也可以组成复杂一些的表达式\",\"运算符分类：\",\"按操作数个数分类： ①一元运算符（一目运算符） ②二元运算符（二目运算符） ③三元运算符（三目运算符）按功能分类： ①算术运算符 ②赋值运算符 ③关系运算符 ④逻辑运算符 ⑤位运算符\"]},\"276\":{\"h\":\"2.算术运算符\",\"t\":[\"算术运算符是对数值类型的变量进行运算的，在C程序中使用的非常多\",\"①%操作符只能用于整数，余数正负只看被除数的正负②/操作符，两个操作数都是整数执行整数除法，有浮点数执行浮点数除法\",\"（1）正号和负号\",\"#include <stdio.h> int main() { int x = 12; int x1 = -x, x2 = +x; int y = -67; int y1 = -y, y2 = +y; printf(\\\"x1=%d, x2=%d \\\\n\\\", x1, x2); printf(\\\"y1=%d, y2=%d \\\\n\\\", y1, y2); /* x1=-12, x2=12 y1=67, y2=-67 */ return 0; } \",\"（2）加、减、乘、除\",\"注意：整数之间做除法时，结果只保留整数部分而舍弃小数部分\",\"#include <stdio.h> int main() { int a = 5 + 2.5; printf(\\\"%d\\\\n\\\", a * a); double b = 6 / 4; printf(\\\"%f\\\\n\\\", b); // 输出 1.000000 double c = 6.0 / 4; printf(\\\"%f\\\\n\\\", c); // 输出 1.500000 /* 49 1.000000 1.500000 */ return 0; } \",\"（3）取模\",\"注意：运算结果的符号与被模数也就是第一个操作数相同\",\"#include <stdio.h> int main() { int res1 = 10 % 3; printf(\\\"%d\\\\n\\\", res1); int res2 = -10 % 3; printf(\\\"%d\\\\n\\\", res2); int res3 = 10 % -3; printf(\\\"%d\\\\n\\\", res3); int res4 = -10 % -3; printf(\\\"%d\\\\n\\\", res4); /* 1 -1 1 -1 */ return 0; } \",\"（4）自增和自减\",\"自增、自减运算符可以写在操作数的前面也可以写在操作数后面，不论前面还是后面，对操作数的副作用是一致的++i：先自增，再使用i；--i：先自减，再使用ii++：先使用，再自增；i--：先使用i，再自减\",\"#include <stdio.h> int main() { int i1 = 10, i2 = 20; int i = i1++; printf(\\\"%d\\\\n\\\", i); // 10 printf(\\\"%d\\\\n\\\", i1); // 11 i = ++i1; printf(\\\"%d\\\\n\\\", i); // 12 printf(\\\"%d\\\\n\\\", i1); // 12 i = i2--; printf(\\\"%d\\\\n\\\", i); // 20 printf(\\\"%d\\\\n\\\", i2); // 19 i = --i2; printf(\\\"%d\\\\n\\\", i); // 18 printf(\\\"%d\\\\n\\\", i2); // 18 /* 10 11 12 12 20 19 18 18 */ return 0; } \"]},\"277\":{\"h\":\"3.关系运算符\",\"t\":[\"关系运算符返回值是布尔类型bool值，即true(1)、false(0)\",\"#include <stdio.h> int main() { int a = 8; int b = 7; printf(\\\"a>b的值：%d \\\\n\\\", a > b); printf(\\\"a>=b的值：%d \\\\n\\\", a >= b); printf(\\\"a<b的值：%d \\\\n\\\", a < b); printf(\\\"a<=b的值：%d \\\\n\\\", a <= b); printf(\\\"a==b的值：%d \\\\n\\\", a == b); printf(\\\"a!=b的值：%d \\\\n\\\", a != b); /* a>b的值：1 a>=b的值：1 a<b的值：0z a<=b的值：0 a==b的值：0 a!=b的值：1 */ return 0;; } \"]},\"278\":{\"h\":\"4.逻辑运算符\",\"t\":[\"注意：逻辑操作符关注的是真假，位操作符关注的是二进制C语言中：0为假，非0为真逻辑与(&&)：两个操作数都为真，那么表达式的值为真，否则为假逻辑或(||)：只要有一个操作数为真，表达式的值就为真；两个操作数都为假，表达式的值为假逻辑非(！)：操作数状态取反作为表达式的值\",\"#include <stdio.h> int main() { double score = 70; // 成绩 if (score >= 60 && score <= 80) { printf(\\\"ok1 \\\\n\\\"); } else { printf(\\\"ok2 \\\\n\\\"); } //ok1 int res = score > 99; if (res) { printf(\\\"hello, tom \\\\n\\\"); } if (!res) { printf(\\\"hello,jack \\\\n\\\"); } //hello,jack int a = 10, b = 99; // 短路现象 if (a < 2 && ++b > 99) { printf(\\\"ok100\\\"); } printf(\\\"b=%d\\\\n\\\", b); //b=99 //短路现象 if (a > 5 || b++ > 100) { printf(\\\"ok100 \\\\n\\\"); } //ok100 return 0; } \"]},\"279\":{\"h\":\"5.赋值运算符\",\"t\":[\"赋值运算符的第一个操作数（左值）必须是变量的形式，第二个操作数可以是任何形式的表达式赋值运算符的副作用针对第一个操作数\",\"#include <stdio.h> int main() { int a = 10, b = 20, c = 30; c += 3; // 等价于 c = c + 3; 计算后c的值变为33 c += b; // 等价于 c = c + b; 计算后c的值变为53 a += 1.7; // 等价于 a = a + 1.7 计算后a的值变为11 printf(\\\"a=%d b=%d c=%d\\\", a, b, c); //a=11 b=20 c=53 return 0; } \"]},\"280\":{\"h\":\"6.位运算符\",\"t\":[\"操作数进行位运算的时候，以它的补码形式进行运算\",\"（1）按位与、按位或、按位异或\",\"使用口诀：同真为真，同假为假，相同为假\",\"#include <stdio.h> int main() { int a = 17; int b = -12; printf(\\\"a&b=%d\\\\n\\\", a & b); // a&b=16 printf(\\\"a|b=%d\\\\n\\\", a | b); // a|b=-11 printf(\\\"a^b=%d\\\\n\\\", a ^ b); // a^b=-27 /* a&b=16 a|b=-11 a^b=-27 */ return 0; } \",\"计算过程分析：\",\"（2）按位取反\",\"#include <stdio.h> int main() { int a = 17; int b = -12; // 按位非 printf(\\\"~a=%d\\\\n\\\", ~a); printf(\\\"~b=%d\\\\n\\\", ~b); /* ~a=-18 ~b=11 */ return 0; } \",\"计算过程分析：\",\"（3）按位左移、按位右移\",\"左移操作符(<<)：左边抛弃，右边补0 右移操作符(>>)：右边抛弃，左边补符号位 \",\"#include <stdio.h> int main() { int a = 17; int b = -12; // 按位左移 printf(\\\"a<<2=%d\\\\n\\\", a << 2); // a<<2=68 printf(\\\"b<<2=%d\\\\n\\\", b << 2); // b<<2=-48 // 按位右移 printf(\\\"a>>3=%d\\\\n\\\", a >> 3); // a>>3=2 printf(\\\"b>>3=%d\\\\n\\\", b >> 3); // b>>3=-2 /* a<<2=68 b<<2=-48 a>>3=2 b>>3=-2 */ return 0; } \",\"计算过程分析：\"]},\"281\":{\"h\":\"7.三目运算符\",\"t\":[\"基本语法：条件表达式? 表达式1: 表达式2；（1）如果条件表达式为非0（真），整个表达式的值是表达式1； （2）如果条件表达式为0（假），整个表达式的值是表达式2；\",\"#include <stdio.h> int main() { int a = 10; int b = 99; int res = a > b ? a++ : b--; int n1 = a > b ? 1.1 : 1.2; printf(\\\"a=%d \\\\n\\\", a); printf(\\\"b=%d \\\\n\\\", b); printf(\\\"res=%d \\\\n\\\", res); /* a=10 b=98 res=99 */ return 0; } \"]},\"282\":{\"h\":\"8.逗号表达式\",\"t\":[\"逗号表达式形式：expr1, expr2, ..., exprN\",\"赋值语句中的逗号表达式：int num = 1, b=2, c=3;函数调用中同时传递多个参数：function(arg1, arg2, arg3);\"]},\"283\":{\"h\":\"9.运算符优先级\",\"t\":[\"很复杂，详细了解建议查文档，记住最重要的就行了。一般用小括号来保证优先级\",\"运算符优先级总结： （1）不要过多的依赖运算的优先级来控制表达式的执行顺序，这样可读性太差，尽量使用小括号来控制表达式的执行顺序 （2）不要把一个表达式写得过于复杂，如果一个表达式过于复杂，则把它分成几步来完成 （3）总体上：一元运算符 > 算术运算符 > 关系运算符 > 逻辑运算符 > 三元运算符 > 赋值运算符 （4）特殊记忆：() > [] > ++ -- > * > + - 用于判断数组指针与指针数组 \"]},\"284\":{\"h\":\"第八章：函数\"},\"285\":{\"h\":\"1.函数基本概念\",\"t\":[\"（1）什么是函数\",\"函数是一种可重复使用的代码块，用于执行特定的任务或操作函数允许我们将代码逻辑组织成独立的单元，从而提高了代码的可读性、可维护性和重用性一个C程序可以由一个或多个源文件构成（C文件扩展名是“.c”），一个源文件是一个编译单位。一个源文件可以由若干个函数构成，函数之间可以相互调用。也就是说，函数是C程序基本的组成单位注意：C程序中的所有函数都是互相独立的，一个函数并不从属于另一个函数，即函数不能嵌套声明\",\"（2）函数的功能\",\"封装功能，将一个完整的功能封装成函数，提高代码的结构化和复用性代码模块化，将程序按照功能拆分成若干模块单元,有助于降低复杂度增强可维护性，如果需要修改某项功能，只需要调整对应的函数代码隔离细节，通过函数调用可以隐藏实现细节，只关心输入输出\",\"（3）函数的分类C语言中，从使用的角度，函数可以分类两类：库函数、自定义函数\",\"库函数，也称为标准函数，是由C系统提供的，用户不必自己定义，可直接使用它们，一般用#include<...>自定义函数，解决具体需求而自己定义的函数，需先定义再使用，一般用#include\\\"...\\\"\"]},\"286\":{\"h\":\"2.函数基本语法\",\"t\":[\"（1）声明函数语法\",\"函数名：函数被调用时使用的名字，函数名要符合标识符规范函数体：函数中所包含的代码块，用于实现函数的具体功能和操作参数：用于接收调用函数时传递进来的值返回值：函数执行完毕后，从函数传回到调用点的值，返回值的类型要与函数名前面的返回类型对应，如果没有返回值，返回类型可以写 void\",\"#include <stdio.h> // 声明函数 void func() { printf(\\\"hello func\\\\n\\\"); } // 实现两个数字相减 int minus(int m, int n) { return m - n; } // 取两个数字中的最大值 int max(int a, int b) { int c; c = a > b ? a : b; return c; } // 主函数 int main() { return 0; } \",\"（2）调用函数\",\"函数名后面加上圆括号即是函数的调用，参数写在小括号中，函数每调用一次，函数体语句都会执行一遍\",\"#include <stdio.h> // 声明函数 void func() { printf(\\\"hello func\\\\n\\\"); } // 实现两个数字相减 int minus(int m, int n) { return m - n; } // 取两个数字中的最大值 int max(int a, int b) { int c; c = a > b ? a : b; return c; } // 主函数 int main() { // 函数的调用 func(); func(); printf(\\\"17-90的结果：%d\\\\n\\\", minus(17, 90)); printf(\\\"21-180的结果：%d\\\\n\\\", minus(21, 180)); printf(\\\"12和16之间较大的是：%d\\\\n\\\", max(12, 16)); printf(\\\"45和31之间较大的是：%d\\\\n\\\", max(45, 31)); /* hello func hello func 17-90的结果：-73 21-180的结果：-159 12和16之间较大的是：16 45和31之间较大的是：45 */ return 0; } \",\"（3）函数的返回值\",\"函数调用后数能得到一个确定的值，这就是函数的返回值，返回值常常是一个计算的结果，或是用来作为判断函数执行状态的标记\",\"函数返回值分为以下三种情况：\",\"无返回值类型：针对函数无返回值或明确不需返回值的情况，使用void（即空类型）表示有返回值类型：指明具体的类型，比如，int、float、char等。需要在函数体内与return语句搭配使用如果返回值类型不是void，但函数中没有return语句，则函数会返回一个不确定的值\",\"#include <stdio.h> // 无返回值 void fun01() { printf(\\\"fun01\\\\n\\\"); } // 有明确的返回值 double fun02() { return 3.14; } // 函数返回一个不确定的值 int fun03() { 10 + 20; } // 返回类型与return的值类型不一致，可能造成精度损失 int fun04() { return 20.89; } int main() { fun01(); printf(\\\"%f \\\\n\\\", fun02()); printf(\\\"%d \\\\n\\\", fun03()); // 返回一个不确定的值 printf(\\\"%d \\\\n\\\", fun04()); // 返回值有精度损失 /* fun01 3.140000 10 20 */ return 0; } \",\"（4）函数的参数函数的参数分为形参与实参：\",\"形参：在定义函数时，函数名后面括号()中声明的变量称为形式参数，简称形参实参： 在调用函数时，函数名后面括号()中的使用的常量、变量、表达式称为实际参数，简称实参参数作用域：形参的改变不影响实参，形参出了作用域就销毁了，需要传形参的地址与实参建立真正的变量联系注意：实参的数量要与形参的数量一致，否则报错\",\"#include <stdio.h> // x 和 y 即为形参 int func(int x, int y) { return x + y; } int main() { // 3 和 5 即为实参 int sum = func(3, 5); printf(\\\"%d \\\\n\\\", sum); // 8; // 如果实参数量如形参不一致 会报错 // func(100, 299, 300); // func(100); return 0; } \"]},\"287\":{\"h\":\"3.主函数与函数原型\",\"t\":[\"（1）主函数的作用：\",\"主函数是程序的入口函数，即所有的程序一定要包含一个主函数，程序总是从这个函数开始执行，如果没有该函数，程序就无法启动主函数中可以调用其它函数，但其它函数不能反过来调用主函数，主函数也不能调用自己\",\"（2）主函数的返回值：\",\"C语言约定，主函数返回值0表示运行成功，如果返回其它非零整数，就表示运行失败。默认情况下，如果主函数里面省略return 0 这一行，编译器会自动加上，即 main() 的默认返回值为0。但是为了保持统一的代码风格，不建议省略\",\"（3）主函数的参数：\",\"主函数的声明中可以带有两个参数，格式如下：\",\"int main(int argc, char *argv[]) { // 函数体 } \",\"其中，形参argc，全称是argument count，表示传给程序的参数个数，其值至少是1；而argv，全称是argument value，argv[]是一个指针数组，我们可以暂时将 argv 理解为是一个数组，数组的每个元素都是字符串通过这种方式可以通过命令行的方式执行源代码，并接收指定的字符串传给参数argv\",\"我们创建一个名为 demo.c 的源文件，代码如下：\",\"#include <stdio.h> int main(int argc, char *argv[]) { printf(\\\"argc = %d\\\\n\\\", argc); // 函数体 for (int i = 0; i < argc; i++) { printf(\\\"%s\\\\n\\\", argv[i]); } return 0; } \",\"在 demo.c 所在的目录下打开命令行工具，使用 gcc 命令进行编译，如下所示：\",\"（4）函数原型\",\"默认情况下，函数必须先声明，后使用。由于程序总是先运行main() 函数，导致所有其它函数都必须在main() 函数之前声明如果想将函数声明写在后面，可以在程序开头处给出函数原型。函数原型，就是提前告诉编译器，每个函数的返回类型和参数类型。其它信息都不需要，也不用包括函数体，具体的函数实现可以后面再补上\",\"#include <stdio.h> // 使用函数原型进行声明 int twice(int); // 主函数 int main() { printf(\\\"%d\\\\n\\\", twice(100)); //200 return 0; } // 函数定义 int twice(int num) { return 2 * num; } \"]},\"288\":{\"h\":\"4.函数作用域\",\"t\":[\"（1）函数作用域的概念\",\"作用域用于确定在代码中某个标识符（如变量、标识符常量、数组等）的可见性和访问范围，它决定了在程序的哪些部分可以引用或访问该标识符作用域可以分为全局作用域、局部作用域、块级作用域同一个作用域中不能声明同名的标识符\",\"（2）全局作用域\",\"在函数和代码块（分支语句、循环语句等）以外定义的变量、标识符常量、数组等具有全局作用域，在程序的任何地方都可以被访问，通常称它们为全局变量、全局常量、全局数组等\",\"#include <stdio.h> // 全局变量 double money = 1.1; // 全局常量 const double PI = 3.14; // 全局数组 char msg[] = \\\"Hello World\\\"; // 全局函数 void func() { printf(\\\"func 函数中使用全局数据：\\\\n\\\"); printf(\\\"money=%.2f \\\\n\\\", money); printf(\\\"PI=%.2f \\\\n\\\", PI); printf(\\\"msg=%s \\\\n\\\", msg); printf(\\\"\\\\n\\\"); money += 100; } // 主函数 int main() { // 调用 func() func(); printf(\\\"主函数中使用全局数据：\\\\n\\\"); printf(\\\"money=%.2f \\\\n\\\", money); printf(\\\"PI=%.2f \\\\n\\\", PI); printf(\\\"msg=%s \\\\n\\\", msg); printf(\\\"\\\\n\\\"); // 调用 func() func(); /* func 函数中使用全局数据： money=1.10 PI=3.14 msg=Hello World 主函数中使用全局数据： money=101.10 PI=3.14 msg=Hello World func 函数中使用全局数据： money=101.10 PI=3.14 msg=Hello World */ return 0; } \",\"对于全局变量，如果没有显式指定初始值，它们将自动初始化为零值对于全局数组，如果没有显式初始化它们，它们的元素将自动初始化为零值，字符数组，将初始化为空字符 \\\\0\",\"#include <stdio.h> // 定义全局变量不进行初始化赋值 int a; // 自动初始化为0 double b; // 自动初始化为0.0 char c; // 自动初始化为空字符 \\\\0 // 定义全局数组不进行初始化 int arr[5]; // 所有元素自动初始化为0 char msg[6]; // 所有元素自动初始化为空字符 \\\\0 // 主函数 int main() { // 输出全局变量 printf(\\\"a=%d \\\\n\\\", a); // a=0 printf(\\\"b=%f \\\\n\\\", b); // b=0.000000 printf(\\\"c=%c \\\\n\\\", c); // c= printf(\\\"\\\\n\\\"); // 计算数组长度 int len = sizeof arr / sizeof arr[0]; // 遍历数组 arr for (int i = 0; i < len; i++) { printf(\\\"%d \\\", arr[i]); } printf(\\\"\\\\n\\\\n\\\"); printf(\\\"字符数组：%s\\\", msg); // 字符数组： /* a=0 b=0.000000 c= 0 0 0 0 0 字符数组： */ return 0; } \",\"（3）局部作用域\",\"在函数内定义的变量、标识符常量、数组等具有局部作用域，只有在该函数内部才能被访问，通常称它们为局部变量、局部常量、局部数组等。需要注意的是，函数的形参也是局部变量\",\"#include <stdio.h> void add(int a) { // 局部变量 int b = 20; // 局部常量 const double PI = 3.14; // 局部数组 int nums[] = {10, 20, 30}; printf(\\\"(a+b+nums[0])*PI=%f \\\\n\\\", (a + b + nums[0]) * PI); } int main() { // 调用函数 add add(100); // (a + b + nums[0]) * PI = 408.200000 // add 函数外部使用局部变量 // printf(\\\"%d \\\\n\\\", a); // 报错 'a' undeclared // printf(\\\"%d \\\\n\\\", b); //报错 'b' undeclared // printf(\\\"%f \\\\n\\\", PI); // 报错 'PI' undeclared // printf(\\\"%d \\\\n\\\", nums[0]); // 报错 'nums' undeclared return 0; } \",\"如果局部作用域中定义了与全局作用域中同名的标识符，优先使用本作用域中定义的数据，相关代码示例如下：\",\"#include <stdio.h> // 全局变量 int a = 100; int b = 200; void add() { int a = 300; a += 10; b += 10; printf(\\\"函数 add 内部： a=%d, b=%d \\\\n\\\", a, b); } int main() { // 调用函数 add add(); // 函数 add 内部： a=310, b=210 printf(\\\"函数 add 外部： a=%d, b=%d \\\\n\\\", a, b); // 函数 add 外部： a=100, b=210 /* 函数 add 内部： a=310, b=210 函数 add 外部： a=100, b=210 */ return 0; } \",\"与全局变量和全局数组不同，局部变量和局部数组如果没有显式初始化，它们的初始值是机器垃圾值，即系统之前分配给这块空间的值。所以不对局部变量、局部数组初始化是不安全且强烈不建议的\",\"#include <stdio.h> int main() { // 定义局部变量不进行初始化赋值 int a; // 定义局部数组不进行初始化 int arr[5]; // 输出局部变量 printf(\\\"a=%d \\\\n\\\", a); // 计算数组长度 int len = sizeof arr / sizeof arr[0]; // 遍历数组 arr for (int i = 0; i < len; i++) { printf(\\\"%d \\\", arr[i]); } /* a=16 130611760 130611760 130611760 130611760 130611760 */ return 0; } \",\"（4）块级作用域\",\"块级作用域是C99标准引入的概念，在代码块（分支语句、循环语句等）中定义的变量、标识符常量、数组等具有块级作用域，只有在该代码块内部才能被访问，代码块通常具有花括号 {} 结构这些被称为块级变量、块级常量、块级数组等，同时也可以被称为局部变量、局部常量、局部数组，且与函数中的局部变量、局部常量、局部数组具有相同的特性\",\"#include <stdio.h> int main() { // 该代码块中具有块级作用域 { // 块级变量 int a = 20; // 块级常量 const double PI = 3.14; printf(\\\"a*PI=%f \\\\n\\\", a * PI); } // 分支语句体具有块级作用域 if (1) { // 局部数组 int nums[] = {10, 20, 30}; printf(\\\"%d %d %d \\\\n\\\", nums[0], nums[1], nums[2]); } // 循环语句中的标记变量i是块级变量 for (int i = 0; i < 5; i++) { printf(\\\"%d \\\", i); } // printf(\\\"%d \\\\n\\\", a); // 报错 'a' undeclared // printf(\\\"%f \\\\n\\\", PI); // 报错 'PI' undeclared // printf(\\\"%d \\\\n\\\", nums[0]); // 报错 'nums' undeclared // printf(\\\"%d \\\\n\\\", i); // 报错 'i' undeclared /* a*PI=62.800000 10 20 30 0 1 2 3 4 */ return 0; } \",\"（5）作用域和内存\",\"栈区域：局部变量、局部数组等通常存储在栈（Stack）区，这些局部数据的内存分配和释放是自动管理的，它们的生命周期受限于其定义的函数或块级作用域，当函数返回或块级作用域结束时，这些变量的内存会被自动释放函数每调用一次就创建一次局部数据，调用结束就销毁；下次调用再创建新的局部数据\",\"全局静态区域：全局变量、全局数组等存储在全局静态区，这些全局的数据在程序的整个生命周期内都存在，它们在程序启动时被分配，在程序结束时才被释放\"]},\"289\":{\"h\":\"5.static关键字\",\"t\":[\"static关键字可以声明静态变量和静态函数，以控制变量和函数的作用范围和生存周期\",\"（1）静态局部变量使用static关键字修饰的局部变量，称为静态局部变量，静态局部变量与全局变量一样存储在内存中的全局静态区。静态局部变量具有如下特点：\",\"静态局部变量只在函数第一次调用时初始化一次并将生命周期延长到整个程序的执行期间静态局部变量如果声明时没有初始赋值，系统会自动初始化为零，同全局变量的初始化规则一致\",\"#include <stdio.h> void fn() { int n = 10; int a; printf(\\\"n=%d, a=%d \\\\n\\\", n, a); n++; printf(\\\"n++=%d \\\\n\\\", n); printf(\\\" \\\\n\\\"); } void fn_static() { static int n = 10; static int a; printf(\\\"static n=%d, a=%d\\\\n\\\", n, a); n++; printf(\\\"static n++=%d \\\\n\\\", n); printf(\\\" \\\\n\\\"); } int main() { int a = 100; fn(); fn_static(); fn(); fn_static(); /* n=10, a=16 n++=11 static n=10, a=0 static n++=11 n=10, a=0 n++=11 static n=11, a=0 static n++=12 */ return 0; } \",\"（2）静态全局变量\",\"使用 static 关键字修饰的全局变量称为静态全局变量普通全局变量对整个工程可见，其他文件中，使用extern外部声明后，可以直接使用。静态全局变量仅对当前文件可见，其他文件不可访问，其他文件中可以定义与其同名的变量，两者互不影响静态全局变量对需要编译多个源代码文件的程序，能够有效地降低源文件之间的耦合，避免不同文件同名变量的冲突此外static关键字还可以修饰函数（静态函数）、全局数组、全局常量等，功能作用与静态全局变量一致\",\"下面演示一个静态全局变量的案例，创建两个源文件，分别命名为file01.c和 file02.c，源文件代码如下：\",\"//file01.c #include <stdio.h> int num01 = 100; static int num02 = 200; const double PI01 = 3.14; static const double PI02 = 3.15; char msg01[] = \\\"Hello msg01\\\"; static char msg02[] = \\\"Hello msg02\\\"; void fn01() { printf(\\\"function fn01 \\\\n\\\"); } static void fn02() { printf(\\\"function fn01 \\\\n\\\"); } \",\"//file02.c #include <stdio.h> // 外部声明 file02.c 中定义的全局变量 extern int num01; extern const double PI01; extern char msg01[]; extern void fn01(); // 外部声明 file01.c 中定义的静态全局变量会报错 extern int num02; extern const double PI02; extern char msg02[]; extern void fn02(); int main() { // 使用 file02.c 中定义的数据 printf(\\\"%d \\\\n\\\", num01); printf(\\\"%f \\\\n\\\", PI01); printf(\\\"%s \\\\n\\\", msg01); fn01(); printf(\\\"\\\\n\\\"); // 报错 无法获取 file01.c 中定义的全局变量 // printf(\\\"%d \\\\n\\\", num02); // printf(\\\"%d \\\\n\\\", PI02); // printf(\\\"%s \\\\n\\\", msg02); // fn02(); return 0; } \"]},\"290\":{\"h\":\"6.递归函数\",\"t\":[\"一个函数在函数体内又调用了本身，我们称为递归调用，这样的函数就是递归函数\",\"递归函数成功执行需满足以下两个条件：\",\"必须有一个明显的结束条件必须有一个趋近于结束条件的趋势\",\"#include <stdio.h> void test(int n) { printf(\\\"%d\\\\n\\\", n); if (n > 1) { test(n - 1); } printf(\\\"%d\\\\n\\\", n); } int main() { // 调用函数 test(3); /* 3 2 1 1 2 3 */ return 0; } \"]},\"291\":{\"h\":\"7.常用系统函数\",\"t\":[\"（1）格式化输入输出函数：#include<stdio.h>中的函数：\",\"sprintf()：用于将格式化数据写入字符串。相比于 printf()，多了一个参数，第一个参数是要写入的字符串，后面参数与 printf() 一致。简单地讲，sprintf() 是将内容写入字符串而不是输出sscanf()：用于从一个字符串中按照指定的格式提取数据。相比于 scanf()，多了一个参数，第一个参数是要提取数据的字符串，后面参数与 scanf() 一致。简单地讲，sscanf() 是从字符串中提取数据而不是从用户输入提取数据\",\"#include <stdio.h> int main() { // ------------- sprintf 的使用 --------------- int age = 12; double score = 65.5; char name[] = \\\"张三\\\"; char outputString[100]; // 字符数组，用于存储格式化后的字符串 // 使用 sprintf 将数据格式化为字符串 sprintf(outputString, \\\"我叫%s,今年%d岁,成绩%.2f分\\\", name, age, score); // 输出格式化后的字符串 printf(\\\"%s\\\\n\\\", outputString); // ------------- sscanf 的使用 --------------- char inputString[] = \\\"张三成绩:44,孙悟空成绩:65.5,张飞成绩:89\\\"; float score1, score2, score3; // 使用 sscanf 从字符串中提取数据 sscanf(inputString, \\\"张三成绩:%f,孙悟空成绩:%f,张飞成绩:%f\\\", &score1, &score2, &score3); // 输出提取的数据 printf(\\\"score1=%.2f, score2=%.2f, score3=%.2f\\\", score1, score2, score3); /* 我叫张三,今年12岁,成绩65.50分 score1=44.00, score2=65.50, score3=89.00 */ return 0; } \",\"（2）日期时间相关函数#include<time.h>头文件中的函数：\",\"time_t 是C语言用于表示时间值的数据类型，它通常是一个整数类型（int 或 long 或 long long），用于存储时间戳时间戳是指从1970年1月1日（通常称为UNIX纪元）零时零分零秒（UTC时间）起至某一特定时刻所经过的秒数\",\"#include <stdio.h> #include <time.h> //该头文件中，声明和日期和时间相关的函数 int main() { // time() 获取当前的时间 time_t curr_time; time(&curr_time); printf(\\\"当前时间戳：%lld \\\\n\\\", curr_time); // ctime() 将时间值转为字符串 printf(\\\"当前时间字符串：%s \\\\n\\\", ctime(&curr_time)); /* 当前时间戳：1697221633 当前时间字符串：Sat Oct 14 02:27:13 2023 */ return 0; } \",\"接下来，我们使用 difftime() 函数来统计程序的执行时间，代码如下：\",\"#include <stdio.h> #include <time.h> // 该头文件中，声明和日期和时间相关的函数 int fn() { int sum = 0; for (int i = 0; i < 10000000; i++) { sum = 0; for (int j = 1; j <= 100; j++) { sum += j; } } return sum; } int main() { time_t start_t, end_t; time_t diff_t; // 存放时间差 time(&start_t); // 得到起始时间 fn(); // 运行 fn 函数，看看执行花费时间 time(&end_t); // 函数执行结束后得到时间 // 计算两个时间值的差 diff_t = difftime(end_t, start_t); printf(\\\"执行 fn() 函数耗用了 %lld 秒\\\", diff_t); //执行 fn() 函数耗用了 2 秒 return 0; } \",\"（3）数学相关函数#include<math.h>头文件中函数：\",\"#include <stdio.h> #include <math.h> int main() { printf(\\\"2的绝对值：%.0f, -12.34的绝对值：%.2f \\\\n\\\", fabs(2.0), fabs(-12.34)); printf(\\\"10的平方根：%f \\\\n\\\", sqrt(10)); printf(\\\"8的立方根：%.f \\\\n\\\", cbrt(8)); printf(\\\"3的12次方：%.f \\\\n\\\", pow(3, 12)); printf(\\\"12.31向上取整：%.f，-12.31向上取整：%.f \\\\n\\\", ceil(12.31), ceil(-12.31)); printf(\\\"12.51向下取整：%.f，-12.51向下取整：%.f \\\\n\\\", floor(12.51), floor(-12.51)); printf(\\\"12.51四舍五入：%.f，-12.51四舍五入：%.f \\\\n\\\", round(12.51), round(-12.51)); printf(\\\"12.51截断小数：%.f，-12.51截断小数：%.f \\\\n\\\", trunc(12.51), trunc(-12.51)); /* 2的绝对值：2, -12.34的绝对值：12.34 10的平方根：3.162278 8的立方方根：2 3的12次方：531441 12.31向上取整：13，-12.31向上取整：-12 12.51向下取整：12，-12.51向下取整：-13 12.51四舍五入：13，-12.51四舍五入：-13 12.51截断小数：12，-12.51截断小数：-12 */ return 0; } \"]},\"292\":{\"h\":\"8.常用字符串函数\",\"t\":[\"常用字符串函数汇总：\",\"函数名\",\"函数原型\",\"函数功能\",\"strlen\",\"size_t strlen(const char *str)\",\"求字符串长度\",\"strnlen\",\"size_t strnlen(const char *str, size_t maxlen)\",\"长度可控求字符串长度\",\"strcpy\",\"char *strcpy( char *str1, char *str2)\",\"拷贝字符串\",\"strncpy\",\"char *strncpy(char *str1, char *str2, size_t n)\",\"长度可控拷贝字符串\",\"strcat\",\"char *strcat(char *str1, char *str2)\",\"追加字符串\",\"strncat\",\"char *strncat(char *str1, char *str2, int n)\",\"长度可控追加字符串\",\"strcmp\",\"int strcmp(const char *str1, const char *str2)\",\"比较字符串\",\"strstr\",\"char *strstr(char *str, char *srch_term)\",\"查找字符串\",\"strtok\",\"char *strtok(char *dest, const char *delim)\",\"切割字符串\",\"strerror\",\"char *strerror(int errnum)\",\"错误信号报告\",\"atoi\",\"int atoi(const char *string)\",\"字符串转整数\",\"sizeof和strlen的区别\",\"sizeof是一个操作符，所有类型都可以使用，只关注空间大小，包含\\\\0。sizeof()里的计算式不执行strlen是一个库函数，只用于字符串，返回\\\\0前的元素个数\",\"字符串函数的例子：\",\"#include <stdio.h> #include <string.h> int main() { char str1[20] = \\\"Hello\\\"; char str2[20] = \\\"World\\\"; char str3[20]; // strlen - 计算字符串的长度 printf(\\\"Length of str1: %d\\\\n\\\", (int)strlen(str1)); // strnlen - 计算字符串的长度，但限制最大长度 printf(\\\"Length of str2 up to 5 characters: %d\\\\n\\\", (int)strnlen(str2, 5)); // strcpy - 复制字符串 strcpy(str3, str1); printf(\\\"str3 after strcpy: %s\\\\n\\\", str3); // strncpy - 复制字符串，但限制最大长度 strncpy(str3, str2, 3); str3[3] = '\\\\0'; // Ensure null-terminated string printf(\\\"str3 after strncpy: %s\\\\n\\\", str3); // strcat - 将一个字符串附加到另一个字符串 strcat(str1, str2); printf(\\\"str1 after strcat: %s\\\\n\\\", str1); // strncat - 将一个字符串附加到另一个字符串，但限制最大长度 strncat(str1, \\\"!!!\\\", 2); printf(\\\"str1 after strncat: %s\\\\n\\\", str1); // strcmp - 比较两个字符串 printf(\\\"Comparison of str1 and str2: %d\\\\n\\\", strcmp(str1, str2)); // strstr - 在一个字符串中查找另一个字符串 char *ptr = strstr(str1, \\\"Wo\\\"); if (ptr != NULL) printf(\\\"Found 'Wo' in str1 at position: %ld\\\\n\\\", ptr - str1); else printf(\\\"'Wo' not found in str1\\\\n\\\"); // strtok - 分解字符串为子字符串 char sentence[] = \\\"This is a sentence.\\\"; char *token = strtok(sentence, \\\" \\\"); while (token != NULL) { printf(\\\"%s\\\\n\\\", token); token = strtok(NULL, \\\" \\\"); } // strerror - 返回错误码对应的描述字符串 printf(\\\"Error message for error code 2: %s\\\\n\\\", strerror(2)); // atoi - 将字符串转换为整数 char str1[] = \\\"123\\\"; int num1 = atoi(str1); printf(\\\"num1: %d\\\\n\\\", num1); return 0; } \"]},\"293\":{\"h\":\"9.常用字符函数\",\"t\":[\"常用字符函数汇总：\",\"函数名\",\"函数原型\",\"函数功能\",\"tolower\",\"int tolower(int ch)\",\"大写字符转小写\",\"toupper\",\"int toupper(int ch)\",\"小写字符转大写\",\"islower\",\"int islower(int ch)\",\"判断是否为小写\",\"isupper\",\"int isupper(int ch)\",\"判断是否为大写\",\"isalpha\",\"int isalpha(int ch)\",\"判断是否为字母\",\"isdigit\",\"int isdigit(int ch)\",\"判断是否为数字\",\"isspace\",\"int isspace(int ch)\",\"判断是否为空白符\",\"空白符指：空格('')、换页('\\\\f')、换行('\\\\n')、回车('\\\\r')、水平制表符('\\\\t')、垂直制表符('\\\\v')\",\"字符函数的例子：\",\"#include <stdio.h> #include <ctype.h> int main() { char ch = 'A'; // tolower - 将字符转换为小写 printf(\\\"Lowercase of %c: %c\\\\n\\\", ch, tolower(ch)); // toupper - 将字符转换为大写 ch = 'b'; printf(\\\"Uppercase of %c: %c\\\\n\\\", ch, toupper(ch)); // islower - 检查字符是否为小写字母 ch = 'c'; if (islower(ch)) printf(\\\"%c is a lowercase letter.\\\\n\\\", ch); else printf(\\\"%c is not a lowercase letter.\\\\n\\\", ch); // isupper - 检查字符是否为大写字母 ch = 'D'; if (isupper(ch)) printf(\\\"%c is an uppercase letter.\\\\n\\\", ch); else printf(\\\"%c is not an uppercase letter.\\\\n\\\", ch); // isalpha - 检查字符是否为字母 ch = '5'; if (isalpha(ch)) printf(\\\"%c is an alphabet character.\\\\n\\\", ch); else printf(\\\"%c is not an alphabet character.\\\\n\\\", ch); // isdigit - 检查字符是否为数字 ch = '9'; if (isdigit(ch)) printf(\\\"%c is a digit.\\\\n\\\", ch); else printf(\\\"%c is not a digit.\\\\n\\\", ch); // isspace - 检查字符是否为空格字符 ch = ' '; if (isspace(ch)) printf(\\\"%c is a whitespace character.\\\\n\\\", ch); else printf(\\\"%c is not a whitespace character.\\\\n\\\", ch); return 0; } \"]},\"294\":{\"h\":\"10.常用内存操作函数\",\"t\":[\"常用内存操作函数汇总：\",\"函数名\",\"函数原型\",\"函数功能\",\"memcpy\",\"void *memcpy(void *dest, const void *src, size_t num)\",\"拷贝内存数据\",\"memmove\",\"void *memmove(void *dest, const void *src, size_t num)\",\"移动内存数据\",\"memset\",\"void *memset(void *dest, int ch, size_t num)\",\"设置指定字符\",\"memcmp\",\"int memcmp(const void *dest, const void *src, size_t num)\",\"比较内存内容\",\"内存操作函数的例子：\",\"#include <stdio.h> #include <string.h> int main() { char src[] = \\\"Hello, world!\\\"; char dest[20]; // memcpy - 将源内存中的数据复制到目标内存中 memcpy(dest, src, strlen(src) + 1); printf(\\\"After memcpy: %s\\\\n\\\", dest); // memmove - 将内存块中的数据移动到另一个内存块中，即使它们重叠 memmove(dest + 7, dest, strlen(dest) + 1); printf(\\\"After memmove: %s\\\\n\\\", dest); // memset - 将内存块的前几个字节设置为指定的值 memset(dest, '-', 6); printf(\\\"After memset: %s\\\\n\\\", dest); // memcmp - 比较两个内存块的前几个字节是否相等 char cmp1[] = \\\"Hello!\\\"; char cmp2[] = \\\"Hello!\\\"; if (memcmp(cmp1, cmp2, strlen(cmp1) + 1) == 0) { printf(\\\"memcmp: cmp1 and cmp2 are equal\\\\n\\\"); } else { printf(\\\"memcmp: cmp1 and cmp2 are not equal\\\\n\\\"); } return 0; } \"]},\"295\":{\"h\":\"第六章：程序控制语句\",\"t\":[\"主要有三大流程控制语句：顺序控制、分支控制、循环控制语句非主要控制语句：跳转控制语句\"]},\"296\":{\"h\":\"1.顺序控制语句\",\"t\":[\"程序从上到下逐行地执行，表达式语句都是顺序执行的。并且上一行对某个变量的修改对下一行会产生影响\"]},\"297\":{\"h\":\"2.分支控制语句\",\"t\":[\"（1）单向分支\",\"if (条件表达式) { 执行代码块； } \",\"当条件表达式为真（非0时，就会执行代码块语句，条件表达式为假（0）时，不会执行代码块\",\"//输入年龄，如果是未成年，则提示 “未成年人请在家长陪同下访问! #include <stdio.h> int main() { int age = 0; printf(\\\"请输入年龄\\\"); scanf(\\\"%d\\\", &age); // 根据age的值来处理 if (age < 18) { printf(\\\"未成年人请在家长陪同下访问！\\\"); } printf(\\\"欢迎继续访问！\\\"); return 0; } \",\"（2）双向分支\",\"if (条件表达式) { 执行代码块1； } else { 执行代码块2; } \",\"当条件表达式成立（为真），执行代码块1，否则执行代码块2\",\"//输入年龄，如果大于18岁，则输出 “你年龄大于18，要对自己的行为负责!”，否则，输出”你的年龄不大这次放过你了 #include <stdio.h> int main() { int age = 0; printf(\\\"请输入年龄\\\"); scanf(\\\"%d\\\", &age); if (age > 18) { printf(\\\"\\\\n你年龄大于18，要对自己的行为负责!\\\"); } else { printf(\\\"\\\\n你的年龄不大，这次放过你了\\\"); } return 0; } \",\"（3）多向分支：else if\",\"//当条件表达式1成立时，即执行代码块1，如果表达式1不成立，才去判断表达式2是否成立，如果表达式2成立，就执行代码块2，以此类推如果所有的表达式都不成立，则执行else 的代码块 if (条件表达式1) { 执行代码块1; } else if (条件表达式2) { 执行代码块2; } ... else { 执行代码块n; } \",\"//张三参加考试，他和父亲达成协议，如果成绩不到 60 分没有任何奖励；如果成绩 60分（含）到80分，奖励一个肉夹馍；如果成绩80分（含）到90分，奖励一个 ipad；如果成绩90分及以上，奖励一部华为mate60 pro #include <stdio.h> int main() { // 定义变量记录成绩 double score; printf(\\\"请输入你的成绩：\\\"); scanf(\\\"%lf\\\", &score); // 根据成绩进行判断 if (score < 60) { printf(\\\"你的成绩不及格，没有任何奖励！\\\"); } else if (score < 80) { printf(\\\"奖励你一个肉夹馍\\\"); } else if (score < 90) { printf(\\\"奖励你一个ipad\\\"); } else if (score >= 90) { printf(\\\"奖励你一部华为 mate60 pro,遥遥领先！\\\"); } else { printf(\\\"输入无效！\\\"); } return 0; } \",\"（4）多向分支：switch\",\"switch (表达式) { case 常量值1: 语句块1; break; case 常量值2: 语句块2; break; … case 常量值n: 语句块n; break; default: 语句块n + 1; } \",\"说明：switch后面表达式的值必须是一个整型（char、short, int, long等）或枚举类型case后面的值必须是常量，而不能是变量default是可选的，当没有匹配的case时，执行defaultbreak语句可以使程序跳出switch语句块，如果没有break，会执行下一个case 语句块，直到遇到break或者执行到switch结尾，这个现象称为穿透\",\"#include <stdio.h> int main() { char c; printf(\\\"请输入一个字符(a,b,c,d)：\\\"); scanf(\\\"%c\\\", &c); switch (c) { case 'a': printf(\\\"今天星期一, 猴子穿新衣\\\"); break; case 'b': printf(\\\"今天星期二, 猴子当小二\\\"); break; case 'c': printf(\\\"今天星期三, 猴子爬雪山\\\"); break; case 'd': printf(\\\"今天星期四, 猴子有急事\\\"); break; default: printf(\\\"没有匹配到任何值~\\\"); } printf(\\\"switch 结束~\\\"); return 0; } \",\"（5）switch和if else if的比较\",\"如果判断条件是判等，而且符合整型、枚举类型，虽然两个语句都可以使用，建议使用swtich语句如果判断条件是区间判断，大小判断等，使用if else if，注意使用最短路径，也就是先判断不合适的一般来说都不用switch，嵌套太深了，各功能模块都是抽离出来适用的\",\"（6）嵌套分支\",\"嵌套分支是指，在一个分支结构中又嵌套了另一个分支结构，里面的分支的结构称为内层分支，外面的分支结构称为外层分支。嵌套分支层数不宜过多，建议最多不要超过3层\",\"if () { if () { } else { switch () { case … } } } \",\"#include <stdio.h> int main() { // 获取用户输入的油号和油量 int oilN, oilL; printf(\\\"请输入油号：\\\"); scanf(\\\"%d\\\", &oilN); printf(\\\"请输入油量：\\\"); scanf(\\\"%d\\\", &oilL); // 定义变量记录价格 double price; // 嵌套分支 switch (oilN) { case 92: price = 4; if (oilL >= 40) { price = 3.5; } printf(\\\"您本次加油需支付：%.2f\\\", price * oilL); break; case 95: price = 5; if (oilL >= 40) { price = 4.5; } printf(\\\"您本次加油需支付：%.2f\\\", price * oilL); break; default: printf(\\\"本加油站没有您所需油号！\\\"); } return 0; } \"]},\"298\":{\"h\":\"3.循环控制语句\",\"t\":[\"（1）while循环\",\"while (循环条件表达式) { 循环体语句; } \",\"当循环条件表达式成立，就执行循环体语句，直到条件不成立停止循环 为避免死循环，循环条件表达式不能永远成立，且随着循环次数增加，应该越来越趋向于不成立\",\"//输出10次 \\\"我第n天吃了n个韭菜馅的包子 #include <stdio.h> int main() { // 输出10次 \\\"我第n天吃了n个韭菜馅的包子\\\" // 定义循环变量 int num = 0; // 开始循环 while (num < 10) { printf(\\\"我第%d天吃了%d个韭菜馅的包子 \\\\n\\\", num, num); // 循环标记变量变化 num++; } printf(\\\"循环结束后循环变量的值：%d\\\", num); return 0; } \",\"（2）do...while循环\",\"do { 循环体语句； } while (循环条件表达式); \",\"do…while循环是先执行再判断，但只有第一次循环语句的执行没有经过判断，以后的每一次仍然先经过判断注意：while后面的分号不能省略\",\"#include <stdio.h> int main() { // 输出10次 \\\"我第n天吃了n个韭菜馅的包子\\\" int i = 0; do { printf(\\\"我第%d天吃了%d个韭菜馅的包子 \\\\n\\\", i, i); i++; } while (i < 10); printf(\\\"循环结束后循环变量的值：%i\\\", i); return 0; } \",\"（3）for循环\",\"for (循环变量初始化; 循环条件表达式; 循环变量变化) { 循环语句; } \",\"循环变量初化只执行一次，且循环开始前就执行循环条件表达式每次循环都执行，同while循环一样，每次先判断后执行循环体语句循环标记变量变化每次循环都执行，在大括号中循环体语句之后执行\",\"#include <stdio.h> int main() { // 输出10次 \\\"我第n天吃了n个韭菜馅的包子\\\" for (int i = 0; i < 10; i++) { printf(\\\"我第%d天吃了%d个韭菜馅的包子 \\\\n\\\", i, i); } return 0; } \",\"（4）多重循环\",\"将一个循环放在另一个循环体内，就形成了嵌套循环， 其中，for、while、do…while均可以作为外层循环和内层循环，建议一般使用两层，最多不要超过3层，如果嵌套循环过多，会造成可读性降低如果外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*n次\",\"#include <stdio.h> int main() { // 输入列数和行数 int rows, cols; printf(\\\"请输入行数：\\\"); scanf(\\\"%d\\\", &rows); printf(\\\"请输入列数：\\\"); scanf(\\\"%d\\\", &cols); // 循环 for (int i = 0; i < rows; i++) { for (int j = 0; j < cols; j++) { printf(\\\"[%d,%d] \\\", i, j); } printf(\\\"\\\\n\\\"); } //假如输入：4行，7列 /* [0,0] [0,1] [0,2] [0,3] [0,4] [0,5] [0,6] [1,0] [1,1] [1,2] [1,3] [1,4] [1,5] [1,6] [2,0] [2,1] [2,2] [2,3] [2,4] [2,5] [2,6] [3,0] [3,1] [3,2] [3,3] [3,4] [3,5] [3,6] */ return 0; } \"]},\"299\":{\"h\":\"4.跳转控制语句\",\"t\":[\"（1）break\",\"break语句用于终止某个语句块的执行，用在switch语句或者循环语句中\",\"#include <stdio.h> int main() { for (int i = 0; i < 10; i++) { if (i == 3) { break; } printf(\\\"%d \\\\n\\\", i); } /* 0 1 2 */ return 0; } \",\"（2）continue\",\"continue语句用于结束本次循环，继续执行下一次循环\",\"#include <stdio.h> int main() { for (int i = 0; i < 10; i++) { if (i == 3) { continue; } printf(\\\"%d \\\\n\\\", i); } /* 0 1 2 4 5 6 7 8 9 */ return 0; } \",\"（3）goto语句\",\"goto语句是一种跳转语句，它允许程序控制流程在代码中跳转到带有标签（label）的语句处，标签（label）的名称可以自行设置，需要满足标识符规范我们在开发中不建议使用goto语句，但我们需要掌握 goto 语句的执行流程，以能够看懂其他开发者的代码中可能出现的 goto 语句\",\"goto 标签名 // 跳转到指定的标签（label）处 ... 标签名: // 定义一个标签（label） 语句; \",\"注意：goto 后面如果引用了没有定义的标签，编译器会报错！\",\"#include <stdio.h> int main() { printf(\\\"start \\\\n\\\"); goto label1; // label1是标签名 printf(\\\"ok1 \\\\n\\\"); printf(\\\"ok2 \\\\n\\\"); label1: printf(\\\"ok3 \\\\n\\\"); printf(\\\"ok4 \\\\n\\\"); /* start ok3 ok4 */ return 0; } \"]},\"300\":{\"h\":\"第十一章：自定义数据类型\"},\"301\":{\"h\":\"1.枚举\",\"t\":[\"（1）什么是枚举\",\"枚举（Enumeration）是C语言中的一种用户自定义数据类型，用于定义一组相关的常量。枚举使我们可以为这些常量分配有意义的名字，从而提高代码的可读性和可维护性如果我们定义一个变量，用来表示一周中的一天，该变量的值只能从七个有效值中选择，枚举可以帮助我们限制变量的有效值\",\"（2）如何定义枚举\",\"枚举使用 enum 关键字来定义，枚举名称和枚举元素名称都是标识符，定义一个枚举就是定义了一种枚举数据类型，语法如下：\",\"enum 枚举名称 { 枚举元素1, 枚举元素2, ... 枚举元素N }; \",\"枚举元素也称为枚举成员或枚举常量，具有如下特点：\",\"枚举元素的值必须在同一枚举中是唯一的枚举元素的值必须是整数类型，通常是int如果没有为枚举元素指定值，编译器会自动为它们分配值，从0开始，依次递增定义枚举的时候也可以为枚举元素自定义值，需保证唯一性和整型类型\",\"// 定义枚举类型,表示星期一到星期天，枚举元素的值自动分配，从0到6。 enum Weekday { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY }; // 定义枚举类型，表示北京地区一年四季的平均温度 enum Season { SPRING = 18, SUMMER = 30, AUTUMN = 20, WINTER = -5 }; \",\"（3）枚举变量什么是枚举变量\",\"定义变量时指定类型是我们所定义的枚举类型，该变量称为枚举变量。枚举变量的值应该是枚举类型中的枚举常量中的一个，不能是其他值\",\"定义枚举变量的语法：\",\"第一种：先定义枚举类型，再定义枚举变量\",\"// 定义枚举类型 enum DAY { MON = 1, TUE, WED, THU, FRI, SAT, SUN }; // 使用枚举类型定义枚举变量 enum DAY day; \",\"第二种：定义枚举类型的同时声明枚举变量\",\"enum DAY { MON = 1, TUE, WED, THU, FRI, SAT, SUN } day; \",\"第三种：定义枚举类型的同时声明枚举变量，且省略枚举名称\",\"enum { MON = 1, TUE, WED, THU, FRI, SAT, SUN } day; \"]},\"302\":{\"h\":\"2.结构体\",\"t\":[\"（1）什么是结构体\",\"C语言提供了struct关键字，允许自定义复合数据类型，将不同类型的值组合在一起，这种类型称为结构体（structure）类型C语言没有其他语言的对象（object）和类（class）的概念，struct 结构很大程度上提供了对象和类的功能\",\"（2）声明结构体\",\"struct 结构体名 { 数据类型1 成员名1; 数据类型2 成员名2; …… 数据类型n 成员名n; }; \",\"// 定义结构体：学生 struct Student { int id; // 学号 int age; // 年龄 char *name; // 姓名 char gender; // 性别 char *address; // 家庭住址 }; \",\"（3）声明结构体变量方式一：先定义结构体，然后再创建结构体变量\",\"// 定义结构体 struct Student { int id; // 学号 int age; // 年龄 char *name; // 姓名 char gender; // 性别 char *address; // 家庭住址 }; // 定义结构体变量 struct Student stu1,stu2; \",\"方式二：在定义结构体的同时定义结构体变量\",\"// 定义结构体的同时定义 stu1和 stu2 两个变量 struct Student { int id; // 学号 int age; // 年龄 char *name; // 姓名 char gender; // 性别 char *address; // 家庭住址 } stu1, stu2; \",\"方式三：在定义时也可以不给出结构体名\",\"// 不给出结构体的名字 struct { int id; // 学号 int age; // 年龄 char *name; // 姓名 char gender; // 性别 char *address; // 家庭住址 } stu1, stu2; \",\"注意：在C语言中，结构体（struct）和结构体变量是两个不同的概念\",\"结构体是一种自定义的数据类型，像一种模板，定义了数据的格式结构体变量是根据结构体类型创建的变量，代表了一个具体的对象，用于存储数据\",\"（4）成员的获取和赋值\",\"成员是结构体的一个组成部分，一般是基本数据类型、也可以是数组、指针、结构体等。结构体的成员也可以称为属性结构体和数组类似，也是一组数据的集合，结构体使用点号 . 获取单个成员，可以进行赋值和取值\",\"#include <stdio.h> int main() { // 声明结构体以及结构体变量,并给结构体成员赋值 struct Student { int id; // 学号 int age; // 年龄 char *name; // 姓名 char gender; // 性别 char *address; // 家庭住址 } stu1 = {1002, 19, \\\"Jim Liu\\\", 'f', \\\"Songjiang Shanghai\\\"}, stu2 = {1003, 16, \\\"Tom Chen\\\", 'm', \\\"Baoan Shenzhen\\\"}; // 获取成员的值 printf(\\\"id: %d \\\\n\\\", stu1.id); printf(\\\"name: %s \\\\n\\\", stu1.name); printf(\\\"age: %d \\\\n\\\", stu1.age); printf(\\\"gender: %c \\\\n\\\", stu1.gender); printf(\\\"address: %s \\\\n \\\\n\\\", stu1.address); printf(\\\"id: %d \\\\n\\\", stu2.id); printf(\\\"name: %s \\\\n\\\", stu2.name); printf(\\\"age: %d \\\\n\\\", stu2.age); printf(\\\"gender: %c \\\\n\\\", stu2.gender); printf(\\\"address: %s \\\\n\\\", stu2.address); /* id: 1002 name: Jim Liu age: 19 gender: f address: Songjiang Shanghai id: 1003 name: Tom Chen age: 16 gender: m address: Baoan Shenzhen */ return 0; } \",\"（5）结构体指针\",\"①结构体指针介绍：\",\"结构体指针是指向结构体的指针变量，允许间接访问和操作结构体的成员，它提供了一种方便的方式来处理结构体数据\",\"声明结构体指针的语法格式：struct 结构体名 * 结构体指针变量名;\",\"②声明结构体指针\",\"通常需要先定义一个结构体变量，再创建结构体指针，并取结构体变量的地址作为结构体指针的值\",\"// 声明结构体 struct Student { int id; // 学号 int age; // 年龄 char *name; // 姓名 char gender; // 性别 char *address; // 家庭住址 }; // 声明结构体变量 struct Student stu; // 声明结构体指针并初始化 struct Student *ptr = &stu; \",\"③通过结构体指针访问成员\",\"结构体指针可以通过“->” 操作符访问结构体的成员\",\"#include <stdio.h> int main() { // 结构体 struct Student { char *name; int age; char gender; }; // 结构体变量 struct Student s = {\\\"张三\\\", 20, 'M'}; // 通过结构体变量访问成员 printf(\\\"name=%s,age=%d,gender=%c \\\\n\\\", s.name, s.age, s.gender); // 声明结构体指针 struct Student *ps = &s; // 结构体指针通过解引用访问成员 printf(\\\"name=%s,age=%d,gender=%c\\\\n\\\", (*ps).name, (*ps).age, (*ps).gender); // 结构体指针使用->访问成员 printf(\\\"name=%s,age=%d,gender=%c\\\\n\\\", ps->name, ps->age, ps->gender); /* name=张三,age=20,gender=M name=张三,age=20,gender=M name=张三,age=20,gender=M */ return 0; } \",\"总结：如果指针变量p指向一个结构体变量stu，以下3种用法等价\",\"指针用->，变量用.\",\"stu.成员名 (*p).成员名 p->成员名 \",\"（6）区分结构体、结构体变量、结构体成员\",\"int num1; // int 是数据类型, 而num1是一个具体的int变量 struct Car car1; // Car 是结构体数据类型，而car1是一个Car变量 \"]},\"303\":{\"h\":\"3.共用体\",\"t\":[\"（1）什么是共用体\",\"有时需要一种数据结构，不同的场合表示不同的数据类型。比如，如果只用一种数据结构表示学生的“成绩”，这种结构就需要有时是整数（80、90），有时是字符（'A'、'B'），有时是浮点数（80.5、60.5）C语言提供了共用体类型（Union 结构），用来自定义可以灵活变更的数据结构。它内部可以包含各种属性，但同一时间只能有一个属性，因为所有属性都保存在同一个内存地址，后面写入的属性会覆盖前面的属性。这样做的最大好处是节省空间\",\"共用体”与“结构体”的定义形式相似，但它们的含义是不同的\",\"结构体变量所占内存长度，可以认为是各成员占的内存长度的叠加；每个成员分别占有其自己的内存单元共用体变量所占的内存长度等于最长的成员的长度；几个成员共用一个内存区\",\"（2）声明共用体\",\"union 共用体类型名称 { 数据类型 成员名1; 数据类型 成员名2; … 数据类型 成员名n; }; \",\"//union命令定义了一个包含三个属性的数据类型data。虽然包含三个属性，但是同一时间只能取到一个属性。最后赋值的属性，就是可以取到值的那个属性 union data { int m; float x; char c; }; \",\"（3）声明共用体变量方式一：先定义共用体类型，再定义共用体变量\",\"// 声明共用体类型 union data { short m; float x; char c; }; // 声明共用体变量 union data a, b; \",\"方式二：定义共用体类型的同时定义共用体变量\",\"union data { short m; float x; char c; } a, b; \",\"方式三：在定义时也可以不给出共用体名\",\"union { short m; float x; char c; } a, b; \",\"（4）共用体内存分析\",\"由上面方式二中共用体变量a为例，它由3个成员组成，分别是m、x和c，系统会按照最长的成员为它分配内存，由于成员x的长度最长，它占4个字节，所以共用体变量a的内存空间也为4个字节\",\"（5）成员的获取和赋值\",\"同结构体一样，共用体也使用点号.获取单个成员，可以进行赋值和取值\",\"方式一：声明共用体变量，再赋值\",\"union data a; a.c = 4; \",\"方式二：声明共用体变量的同时，给任一成员赋值\",\"union data a = {.c = 4}; \",\"方式三：声明共用体变量的同时，给首成员赋值\",\"//方式三不指定成员名，所以只能为第一个成员进行赋值 union data a = {8}; \"]},\"304\":{\"h\":\"4.typedef\",\"t\":[\"（1）typedef介绍\",\"C语言允许为一个数据类型起一个新的别名，就像给人起“绰号”一样\",\"起别名的目的不是为了提高程序运行效率，而是为了编码方便。例如，有一个结构体的名字是 student，定义一个结构体变量stu1，代码如下：\",\"struct student stu1; \",\"struct 看起来就是多余的，但不写又会报错。如果为 struct student起了一个别名 Student，书写起来就简单了：\",\"Student stu1; \",\"这种写法更加简练，意义也非常明确，不管是在标准头文件中还是以后的编程实践中，都会大量使用这种别名\",\"（2）typedef的应用场景\",\"①为某个基本类型起别名\",\"typedef 命令用来为某个类型起别名\",\"typedef 类型名 别名; \",\"习惯上，常把用typedef声明的类型名的第1个字母用大写表示，以便与系统提供的标准类型标识符相区别\",\"typedef int Integer; //用Integer作为int类型别名，作用与int相同 Integer a, b; a = 1; b = 2; typedef unsigned char Byte; //为类型 unsign char 起别名 Byte Byte c = 'z'; \",\"注意：使用 typedef 可以为基本类型一次起多个别名\",\"typedef int chocolate, doughnut, mushroom; //一次性为 int 类型起了三个别名 \",\"②为结构体、共用体起别名\",\"为 struct、union等命令定义的复杂数据结构创建别名，从而便于引用\",\"//下例中，自定义数据类型时，同时使用typedef命令，为struct Treenode起了一个别名 Tree typedef struct Treenode { char *name; int legs; int speed; } Tree; //下例中，union命令定义了一个包含三个属性的数据类型，typedef 命令为它起别名为Quantity typedef union { short count; float weight; float volume; } Quantity; \",\"③为指针取别名\",\"typedef可以为指针起别名\",\"//下例中，intptr是int*的别名。不过，使用的时候要小心，这样不容易看出来，变量 x 是一个指针类型 typedef int *intptr; int a = 10; intptr x = &a; //为字符指针起别名为 String，以后使用String声明变量时，就可以轻易辨别该变量是字符串 typedef char *String; char *str1 = \\\"hello\\\"; // 之前的写法 String str2 = \\\"hello\\\"; // 现在的写法 \",\"④为数组类型起别名\",\"typedef也可以用来为数组类型起别名\",\"// 举例1 给int[5] 取别名 fiveInts typedef int fiveInts[5]; fiveInts x = {11, 22, 33, 44, 55}; // 相当于 int x[5] = {11, 22, 33, 44, 55}; // 举例2 给 int[100] 取别名 Num typedef int Num[100]; // 声明Num为整型数组类型名 Num a; // 相当于 int a[100]; \",\"使用 typedef 为数组指针取别名\",\"// 为 int (*)[5] 取别名为 IntArrayPointer typedef int (*IntArrayPointer)[5]; // 定义数组 int arr[5] = {1, 2, 3, 4, 5}; // 使用别名定义数组指针 IntArrayPointer ptr = &arr; // 使用别名指向数组 \"]},\"305\":{\"h\":\"5.位段\",\"t\":[\"位段概念：位段是一种以位为单位定义结构体或联合体成员变量所占的空间位段结构：含有位段的结构体或联合体成为位段结构位段优点：既能节约空间，又方便使用位段形式：变量类型 变量名 : 位段数。比如：int a:3;表示使用3bit存储a变量位段用途：用于网络发包时节约空间\"]},\"306\":{\"h\":\"6.内存对齐规则\"},\"307\":{\"h\":\"第十三章：文件操作\"},\"308\":{\"h\":\"1.文件基本介绍\",\"t\":[\"文件，对我们并不陌生，文件是数据源（保存数据的地方）的一种，比如大家经常使用的word文档，txt文件，excel文件...都是文件。文件最主要的作用就是保存数据，它既可以保存一张图片，也可以保持视频，声音...\",\"C程序中，文件中数据的输入/输出操作以“流”的方式进行，可以看做是一种数据的流动\",\"输入流（Input Stream）：数据从数据源（例如文件、键盘等）到程序（内存）的传输路径\",\"输出流（Output Stream）：数据从程序（内存）到数据源（例如文件、屏幕等）的传输路径\"]},\"309\":{\"h\":\"2.C语言的输入与输出\",\"t\":[\"（1）标准文件\",\"C 语言把所有的设备都当作文件，所以设备（比如显示器）被处理的方式与文件相同。以下三个文件会在程序执行时自动打开，以便访问键盘和屏幕\",\"（2）scanf和printf函数\",\"C语言中的I/O （输入/输出）通常使用printf()和scanf()两个函数，scanf()函数从标准输入流stdin读取输入，printf()函数把输出写入到标准输出流stdout。这两个函数我们在前面的案例中已经大量使用\",\"​#include <stdio.h> int main() { // 定义变量 char str[100]; int i; // 获取输入 printf(\\\"Please Input A String And A Number :\\\"); scanf(\\\"%s %d\\\", str, &i); // 输出到屏幕终端 printf(\\\"You entered: %s %d \\\", str, i); printf(\\\"\\\\n\\\"); return 0; } \",\"（3）getchar和putchar函数\",\"getchar()：用于从标准输入流（通常是键盘输入）读取一个字符。这个函数在同一个时间内只会读取一个单一的字符函数原型：int getchar(void);返回值说明：返回一个整数值，表示读取的字符\",\"putchar()：用于将一个字符写入到标准输出流（通常是屏幕）。这个函数在同一个时间内只会输出一个单一的字符函数原型：int putchar(int character);返回值说明：返回一个整数值，是写入的字符的ASCII码值参数说明：character是要写入的字符的ASCII码值\",\"#include <stdio.h> int main( ) { int c; printf( \\\"Enter a value :\\\"); c = getchar(); printf( \\\"\\\\nYou entered: \\\"); putchar(c); printf(\\\"\\\\n\\\"); return 0; } \",\"（4）gets和puts函数\",\"gets()：用于从标准输入流（通常是键盘）读取一行文本，并将其存储在一个字符数组中（gets() 的参数），直到遇到换行符为止函数原型：char * gets(char * str);返回值说明：返回一个指向存储在 str 中的字符串的指针参数说明：字符数组（字符串）的指针，用于存储读取的输入数据\",\"puts()：用于将字符串输出到标准输出流（通常是屏幕），并自动添加换行符。它接受一个字符串作为参数，然后将其显示在屏幕上函数原型：int puts(const char * str);返回值说明：返回成功写入的字符数，如果写入失败或出现错误，它会返回 特殊值EOF（（EOF 是一个定义在 stdio.h 头文件中的常量，值通常为 -1））参数说明：str 是要输出的字符串\",\"#include <stdio.h> int main() { char str[20]; printf(\\\"Enter a line of text :\\\"); gets(str); printf(\\\"You entered: \\\"); // printf(\\\"%s\\\", str); puts(str); return 0; } \"]},\"310\":{\"h\":\"3.C语言的文件读写\",\"t\":[\"文件，无论是文本文件还是二进制文件，都以一系列字节的形式存在，C语言提供了一系列函数处理存储设备上的文件\",\"（1）打开文件\",\"使用fopen( ) 函数来创建一个新的文件或者打开一个已有的文件。该函数位于标准库的 stdio.h 头文件中函数原型：FILE * fopen( const char * filename, const char * mode );返回值说明：返回一个指向 FILE 结构的指针，该结构表示文件流，可以使用这个指针来进行文件的读取和写入操作。如果打开文件失败，返回一个空指针（NULL）参数说明：filename是一个以字符串形式指定的文件名，表示要打开的文件的名称，可以包括文件路径和文件名。mode 是一个以字符串形式指定的打开模式，表示打开文件的方式，可以是以下值之一：\",\"（2）关闭文件\",\"文件读写完毕后，一定要关闭文件，使用fclose( ) 函数可以关闭文件。该函数位于标准库的 stdio.h 头文件中函数原型：int fclose(FILE * stream);返回值说明：返回一个整数值，通常为零（0），表示关闭操作成功。如果关闭失败，它返回特殊值EOF （EOF 是一个定义在 stdio.h 头文件中的常量，值通常为 -1）参数说明：stream是一个指向 FILE 结构的指针，表示要关闭的文件流\",\"（3）写入文件\",\"①fputc() 函数用于逐字符写入文件。位于标准库的stdio.h 头文件中函数原型：int fputc(int character, FILE * stream);返回值说明：返回一个整数值，通常是写入的字符的ASCII码值。如果写入成功，返回的值与输入的 character 值相同；如果写入失败，它返回特殊值 EOF参数说明：character是要写入的字符，通常以整数形式表示，即字符的ASCII码值。stream是一个指向 FILE 结构的指针，表示要写入字符的文件流\",\"#include <stdio.h> int main() { // FILE *file = fopen(\\\"output.txt\\\", \\\"w\\\"); // 从头写入 FILE *file = fopen(\\\"output.txt\\\", \\\"a\\\"); // 追加写入 if (file != NULL) { // 使用 fputc 写入一个字符 char ch = 'A'; int result1 = fputc(ch, file); if (result1 != EOF) { printf(\\\"成功使用 fputc 写入字符 '%c'，返回值：%d。\\\\n\\\", ch, result1); } else { printf(\\\"使用 fputc 写入字符时出现错误。\\\\n\\\"); } // 关闭文件 fclose(file); } else { printf(\\\"打开文件时出现错误。\\\\n\\\"); } return 0; } \",\"②fputs() 函数用于将字符串写入文件。位于标准库的stdio.h 头文件中函数原型：int fputs(const char * str, FILE * stream);返回值说明：返回一个整数值，如果写入成功，则返回非负整数（通常是成功写入的字符数，具体取决于编译器），否则返回特殊值 EOF参数说明：str是要写入的字符串，通常以 const char * 指针的形式传递。stream是指向输出流的指针，通常是文件指针\",\"#include <stdio.h> int main() { FILE *file = fopen(\\\"output.txt\\\", \\\"w\\\"); // 从头写入 // FILE *file = fopen(\\\"output.txt\\\", \\\"a\\\"); // 追加写入 if (file != NULL) { // 使用 fputs 写入一个字符串 const char *text = \\\"fputs: Hello Shangguigu\\\\n\\\"; int result2 = fputs(text, file); if (result2 != EOF) { printf(\\\"成功使用 fputs 写入字符串，返回值：%d。\\\\n\\\", result2); } else { printf(\\\"使用 fputs 写入字符串时出现错误。\\\\n\\\"); } // 关闭文件 fclose(file); } else { printf(\\\"打开文件时出现错误。\\\\n\\\"); } return 0; } \",\"③fprintf() 函数用于格式化写入文件。位于标准库的stdio.h 头文件中函数原型：int fprintf(FILE * stream, const char * format, ...);返回值说明：返回一个整数值，如果写入成功，则返回非负整数（通常是成功写入的字符数，具体取决于编译器），否则返回特殊值 EOF参数说明：stream是一个指向 FILE 结构的指针，表示要写入的文件流。format是一个格式化字符串，类似于 printf() 函数中的格式化字符串。...表示可变数量的参数，根据格式化字符串中的格式占位符对应\",\"#include <stdio.h> int main() { FILE *file = fopen(\\\"output.txt\\\", \\\"w\\\"); // 从头写入 // FILE *file = fopen(\\\"output.txt\\\", \\\"a\\\"); // 追加写入 if (file != NULL) { // 使用 fputs 写入一个字符串 const char *text = \\\"fprintf: %s is studying in Shangguigu\\\\n\\\"; char *name = \\\"Alice\\\"; int result3 = fprintf(file, text, name); if (result3 != EOF) { printf(\\\"成功使用 fprintf 写入字符串，返回值：%d。\\\\n\\\", result3); } else { printf(\\\"使用 fprintf 写入字符串时出现错误。\\\\n\\\"); } // 关闭文件 fclose(file); } else { printf(\\\"打开文件时出现错误。\\\\n\\\"); } return 0; } \",\"三种打开方式对比参考代码：\",\"#include <stdio.h> int main() { // FILE *file = fopen(\\\"output.txt\\\", \\\"w\\\"); // 从头写入 FILE *file = fopen(\\\"output.txt\\\", \\\"a\\\"); // 追加写入 if (file != NULL) { // 使用 fputc 写入一个字符 char ch = 'A'; int result1 = fputc(ch, file); if (result1 != EOF) { printf(\\\"成功使用 fputc 写入字符 '%c'，返回值：%d。\\\\n\\\", ch, result1); } else { printf(\\\"使用 fputc 写入字符时出现错误。\\\\n\\\"); } // 使用 fputs 写入一个字符串 const char *text = \\\"fputs: Hello Shangguigu\\\\n\\\"; int result2 = fputs(text, file); if (result2 != EOF) { printf(\\\"成功使用 fputs 写入字符串，返回值：%d。\\\\n\\\", result2); } else { printf(\\\"使用 fputs 写入字符串时出现错误。\\\\n\\\"); } // 使用 fprintf 写入格式化数据 int num = 42; float pi = 3.14159; const char *formattedText = \\\"fprintf: %d %.2f\\\\n\\\"; int result3 = fprintf(file, formattedText, num, pi); if (result3 >= 0) { printf(\\\"成功使用 fprintf 写入格式化数据，返回值：%d。\\\\n\\\", result3); } else { printf(\\\"使用 fprintf 写入格式化数据时出现错误。\\\\n\\\"); } fclose(file); // 关闭文件 } else { printf(\\\"打开文件时出现错误。\\\\n\\\"); } return 0; } \",\"（4）读取文件\",\"①fgetc() 函数用于从文件中逐字符读取。位于标准库的stdio.h 头文件中函数原型：int fgetc(FILE * stream);返回值说明：如果读取成功，它返回所读取字符的ASCII码值（0-255之间的整数），如果到达文件结束或发生错误，它返回特殊值 EOF参数说明：stream是一个指向 FILE 结构的指针，表示要写入字符的文件流\",\"#include <stdio.h> int main() { FILE *file = fopen(\\\"output.txt\\\", \\\"r\\\"); // 打开文件以供读取 if (file != NULL) { int ch; // 用于存储读取的字符 // 使用 fgetc 逐字符读取文件 while ((ch = fgetc(file)) != EOF) { printf(\\\"%c\\\", ch); // 将字符显示在屏幕上 } fclose(file); // 关闭文件 } else { printf(\\\"Error opening the file.\\\\n\\\"); } return 0; } \",\"②fgets() 函数从文件中逐行读取，遇到换行符即读取结束，读取的内容中包含换行符。该函数位于标准库的stdio.h 头文件中函数原型：char * fgets(char * str, int num, FILE * stream);返回值说明：如果读取成功，它返回指向 str 的指针；如果到达文件结束或发生错误，它返回一个空指针（NULL）参数说明：str是一个指向字符数组的指针，用于存储读取的字符串。num是要读取的最大字符数（包括字符串终止符 \\\\0），通常是str的长度。stream是一个文件流，通常是标准输入流（stdin）或其他文件流，用于指定从哪里读取数据\",\"#include <stdio.h> int main() { FILE *file = fopen(\\\"output.txt\\\", \\\"r\\\"); // 打开文件以供读取 if (file != NULL) { char buffer[256]; // 用于存储读取的字符串 // 使用 fgets 逐行读取文件 while (fgets(buffer, sizeof(buffer), file) != NULL) { printf(\\\"%s\\\", buffer); // 将读取的字符串显示在屏幕上 } fclose(file); // 关闭文件 } else { printf(\\\"Error opening the file.\\\\n\\\"); } return 0; } \",\"③fscanf() 函数用于从文件中解析数据并存储到变量中，使用空白字符（空格、制表符、换行符等）分隔内容赋值给不同的变量。该函数位于标准库的stdio.h 头文件中函数原型：int fscanf(FILE * stream, const char * format, ...);返回值说明：返回成功读取和分配的参数数目，如果没有成功读取任何参数，它返回 0；如果读取过程中发生错误，它返回特殊值 EOF参数说明：stream是一个指向 FILE 结构的指针，表示要从中读取数据的文件流。format是一个格式化字符串，类似于 printf() 函数中的格式化字符串。... 表示可变数量的参数，根据格式化字符串中的格式指定要存储数据的变量\",\"#include <stdio.h> int main() { FILE *file = fopen(\\\"example.txt\\\", \\\"r\\\"); // 打开文件以供读取 if (file != NULL) { // 变量 char msg1[100], msg2[100], msg3[100]; int num; // 读取 fscanf(file, \\\"%s %s %s %d\\\", msg1, msg2, msg3, &num); // 输出 printf(\\\"%s\\\\n%s\\\\n%s\\\\n%d\\\", msg1, msg2, msg3, num); // 关闭文件 fclose(file); } else { printf(\\\"打开文件时出现错误。\\\\n\\\"); } return 0; } \",\"（5）二进制读写文件\",\"fread：用于二进制读，函数原型：size_t fread(void * buffer, size_t size_t, size_t count, FILE * stream)说明：buffer是指向要读取的数组中首个对象的指针，size是每个对象的字节大小，count是要读取的对象数，stream是读取来源的输入流\",\"fwrite：用于二进制写，函数原型：size_t fwrite(const void * buffer, size_t size_t, size_t count, FILE * stream)\",\"函数的例子：\",\"#include <stdio.h> #include <stdlib.h> #define BUFFER_SIZE 1024 int main() { FILE *input_file, *output_file; char buffer[BUFFER_SIZE]; size_t bytes_read; // 打开输入文件（读取模式） input_file = fopen(\\\"input.txt\\\", \\\"rb\\\"); if (input_file == NULL) { perror(\\\"Error opening input file\\\"); return EXIT_FAILURE; } // 打开输出文件（写入模式） output_file = fopen(\\\"output.txt\\\", \\\"wb\\\"); if (output_file == NULL) { perror(\\\"Error opening output file\\\"); fclose(input_file); return EXIT_FAILURE; } // 从输入文件中读取数据，并写入到输出文件中 while ((bytes_read = fread(buffer, 1, BUFFER_SIZE, input_file)) > 0) { fwrite(buffer, 1, bytes_read, output_file); } // 关闭文件 fclose(input_file); fclose(output_file); printf(\\\"File copied successfully.\\\\n\\\"); return 0; } \",\"（6）文件的随机访问函数\",\"fseek：根据文件指针的位置和偏移量来定位文件指针。函数原型：int fseek(FILE * stream, long offset, int origin)说明：stream是指向FILE对象的指针；offset是相对origin的偏移量，以字节为单位；origin表示开始添加偏移offset的位置，取值为：SEEK_SET、SEEK_CUR、SEEK_ENDSEEK_SET：从文件起始位置开始计算偏移量；SEEK_CUR：从文件当前位置开始计算偏移量；SEEK_END：从文件末尾位置开始计算偏移量\",\"ftell：返回文件指针相对于起始位置的偏移量。函数原型：long ftell(FILE * stream)\",\"rewind：让文件指针的位置返回文件的起始位置。函数原型：void rewind(FILE * stream)\",\"函数的例子：\",\"#include <stdio.h> int main() { FILE *file; long size; int ch; // 打开文件 file = fopen(\\\"example.txt\\\", \\\"r\\\"); if (file == NULL) { perror(\\\"Error opening file\\\"); return -1; } // 获取文件大小 fseek(file, 0, SEEK_END); // 定位到文件末尾 size = ftell(file); // 获取当前文件指针位置，即文件大小 printf(\\\"File size: %ld bytes\\\\n\\\", size); // 将文件指针重新定位到文件开头 rewind(file); // 逐字符读取并输出文件内容 printf(\\\"File content:\\\\n\\\"); while ((ch = fgetc(file)) != EOF) { putchar(ch); } // 关闭文件 fclose(file); return 0; } \",\"（7）文件读取结束判断函数\",\"feof：用于判断文件读取是否结束，这个函数容易被错误使用文本文件读取判断结束：判断返回值是否为EOF（getc）、或者NULL（gets）二进制文本的读取判断结束：判断返回值是否小于实际要读的个数EOF是一个宏，底层定义为：#define EOF (-1)\",\"牢记：在文本读取过程中，不能使用feof函数的返回值直接判断文本是否结束，而是当文件读取结束时，判断是读取失败结束还是遇到文件结束\",\"比如：fgetc判断是否为EOF、fgets判断返回值是否为NULL\"]},\"311\":{\"h\":\"第十二章：动态内存分配\"},\"312\":{\"h\":\"1.C程序动态内存分配\",\"t\":[\"动态内存分配：是指根据需要向系统申请所需大小的空间，由于未在声明部分定义其为变量或者数组，不能通过变量名或者数组名来引用这些数据，只能通过指针来引用\"]},\"313\":{\"h\":\"2.void指针(无类型指针)\",\"t\":[\"（1）void指针介绍\",\"C99允许定义一个类型为void的指针变量，它可以指向任何类型的数据\",\"（2）void指针作用\",\"指针变量必须有类型，否则编译器无法知道如何解读内存块保存的二进制数据。但是，有时候向系统请求内存的时候，还不确定会有什么类型的数据写入内存，需要要先获得内存块，稍后再确定写入的数据类型这种情况下就可以使用 void 指针，它只有内存块的地址信息，没有类型信息，等到使用该块内存的时候，再向编译器补充说明，里面的数据类型是什么\",\"（3）void指针特点\",\"void 指针与其他所有类型指针之间是互相转换关系，任一类型的指针都可以转为 void 指针，而 void 指针也可以转为任一类型的指针由于不知道 void 指针指向什么类型的值，所以不能用 * 运算符取出它指向的值（解引用）\",\"#include <stdio.h> int main() { int num = 42; double pi = 3.14159; // int 指针转为 void 指针 void *viPtr = &num; // 隐式类型转换 // double 指针转为 void 指针 void *vdPtr = &pi; // 隐式类型转换 // void 指针转换为 int 指针并解引用 // int *intPtr = viPtr; // 隐式类型转换 int *intPtr = (int *)viPtr; // 显示类型转换 printf(\\\"整数值：%d \\\\n\\\", *intPtr); // void 指针转换为 double 指针并解引用 // double *doublePtr = vdPtr; // 隐式类型转换 double *doublePtr = (double *)vdPtr; // 显式类型转换 printf(\\\"浮点数：%f \\\\n\\\", *doublePtr); // void 指针不能解引用 会报错 // printf(\\\"%d\\\", *viPtr); // printf(\\\"%d\\\", *vdPtr); /* 整数值：42 浮点数：3.141590 */ return 0; } \",\"（4）特别注意\",\"其他类型指针赋给 void指针，使用隐式转换即可，因为 void 指针不包含指向的数据类型的信息，通常是安全的void 指针赋给其他类型指针，建议使用显式类型转换，这样更加安全，如果使用隐式类型转换，有些编译器会触发警告\"]},\"314\":{\"h\":\"3.内存分配相关函数\",\"t\":[\"头文件 <stdlib.h> 声明了四个关于内存动态分配的函数：malloc、calloc、realloc、free\",\"（1）malloc函数malloc() 函数用于分配一块连续的内存空间\",\"函数原型：void * malloc(size_t size);返回值说明：如果内存分配成功，返回一个void指针，指向新分配内存块的地址；如果分配失败（例如内存不足），返回一个空指针（NULL）参数说明：size是要分配的内存块的大小，以字节为单位\",\"#include <stdio.h> #include <stdlib.h> int main() { int *p; p = (int *)malloc(sizeof(int)); // 判断是否分配成功 if (p == NULL) { printf(\\\"内存分配失败\\\\n\\\"); return 1; // 退出程序 } // 使用解引用赋值并输出 *p = 120; printf(\\\"p指向的地址：%p \\\\n\\\", p); printf(\\\"p指向的值：%d\\\", *p); /* p指向的地址：00000053575ff838 p指向的值：120 */ // 释放分配的内存 free(p); return 0; } \",\"（2）calloc函数calloc() 函数用于分配内存并将其初始化为零，它在分配内存块时会自动将内存中的每个字节都设置为零\",\"函数原型：void * calloc(size_t numElements, size_t sizeOfElement);返回值说明：如果内存分配成功，返回一个 void 指针，指向新分配内存块的地址；如果分配失败（例如内存不足），返回一个空指针（NULL）参数说明：numElements是要分配的元素的数量，sizeOfElement是每个元素的大小（以字节为单位）\",\"#include <stdio.h> #include <stdlib.h> int main() { int *p; // 定义整型指针 int n = 5; // 定义数组长度 // 动态分配内存，将地址赋给指针p p = (int *)calloc(n, sizeof(int)); // 判断是否分配成功 if (p == NULL) { printf(\\\"内存分配失败\\\\n\\\"); return 1; // 退出程序 } // 输出数组的元素的值 for (int i = 0; i < n; i++) { printf(\\\"p[%d]=%d \\\\n\\\", i, p[i]); } /* p[0]=0 p[1]=0 p[2]=0 p[3]=0 p[4]=0 */ // 释放分配的内存 free(p); return 0; } \",\"（3）reallco函数realloc() 函数用于重新分配malloc() 或calloc() 函数所获得的内存块的大小\",\"函数原型：void * realloc(void * ptr, size_t size);返回值说明：返回一个指向重新分配内存块的指针。如果内存重新分配成功，返回的指针可能与原始指针相同，也可能不同；如果内存分配失败，返回返回一个空指针（NULL）。如果在原内存块上进行缩减，通常返回的原先的地址参数说明：ptr是要重新分配的内存块的指针，size是新的内存块的大小（以字节为单位）\",\"//说明：_msize()函数，该函数可以获取指定内存块的大小，头文件为#include<malloc.h> #include <stdio.h> #include <stdlib.h> #include <malloc.h> int main() { // 声明指针 int *b; // 分配内存 b = malloc(sizeof(int) * 100); printf(\\\"b=%p, size:%zu \\\\n\\\", b, _msize(b)); // 调整内存大小 b = realloc(b, sizeof(int) * 2000); printf(\\\"b=%p, size:%zu \\\\n\\\", b, _msize(b)); // 再次调整内存大小 b = realloc(b, sizeof(int) * 200); printf(\\\"b=%p, size:%zu \\\\n\\\", b, _msize(b)); /* b=000001f5fc3f4770, size:400 b=000001f5fc3f47d0, size:8000 b=000001f5fc3f47d0, size:800 */ // 释放内存 free(b); return 0; } \",\"（4）free函数\",\"如果动态分配的内存空间没有被正确释放，这种情况称为内存泄漏，内存泄漏会导致系统中的可用内存逐渐减少，直到耗尽系统可用的内存资源free() 函数用于释放动态分配的内存，以便将内存返回给操作系统，防止内存泄漏\",\"函数原型：void free(void * ptr);返回值说明：没有有返回值参数说明：ptr是指向要释放的内存块的指针，ptr必须是malloc() 或calloc() 动态分配的内存块地址\",\"注意:分配的内存块一旦释放，就不应该再次操作已经释放的地址，也不应该再次使用 free() 对该地址释放第二次如果忘记调用free()函数，会导致无法访问未回收的内存块，构成内存泄漏\",\"（5）内存分配案例\",\"动态创建数组，输入5个学生的成绩，再定义一个函数检测成绩低于60分的，输出不合格的成绩\",\"#include <stdlib.h> #include <stdio.h> // 函数原型声明 void check(int *); int main() { int *p; // 在堆区开辟一个 5 * 4 的空间 p = (int *)malloc(5 * sizeof(int)); printf(\\\"请输入5个成绩：\\\"); for (int i = 0; i < 5; i++) { scanf(\\\"%d\\\", p + i); } check(p); free(p); // 销毁 堆区 p 指向的空间 return 0; } // 函数定义 void check(int *p) { printf(\\\"\\\\n不及格的成绩有: \\\"); for (int i = 0; i < 5; i++) { if (p[i] < 60) { printf(\\\" %d \\\", p[i]); } } } \"]},\"315\":{\"h\":\"4.内存分配基本原则\",\"t\":[\"（1）避免分配大量的小内存块：分配堆上的内存有一些系统开销，所以分配许多小的内存块比分配几个大内存块的系统开销大\",\"（2）仅在需要时分配内存：只要使用完堆上的内存块，就需要及时释放它，否则可能出现内存泄漏\",\"（3）总是确保释放已分配的内存：在编写分配内存的代码时，就要确定好在代码的什么地方释放内存\"]},\"316\":{\"h\":\"第十章：预处理器\"},\"317\":{\"h\":\"1.预处理器基本介绍\",\"t\":[\"（1）预处理器\",\"C语言编译器在编译程序之前，会先使用预处理器（preprocessor）处理代码，代码经过预处理之后再送入编译器进行编译预处理器的主要任务包括宏替换、文件包含、条件编译等\",\"（2）预处理指令\",\"预处理过程中会执行预处理指令，预处理指令以 # 号开头，用于指导预处理器执行不同的任务\",\"预处理指令具有如下特点：\",\"1.预处理指令应该放在代码的开头部分2.预处理指令都以 # 开头，指令前面可以有空白字符（比如空格或制表符），# 和指令的其余部分之间也可以有空格，但是为了兼容老的编译器，一般不留空格\",\"// 推荐写法 #include <stdio.h> // 不推荐写法 #include <stdio.h> # include <stdio.h> \",\"3.预处理指令都是一行的，除非在行尾使用反斜杠，将其折行\",\"#include <std\\\\ io.h> \",\"4.预处理指令不需要分号作为结束符，指令结束是通过换行符来识别的\",\"#include <stdio.h>; // 这里有分号会报错 #define PI 3.14; // 分号会成为 PI 的值的一部分 \",\"5.预处理指令通常不能写在函数内部，有些编译器的扩展允许将预处理指令写在函数里，但强烈不建议这么干\",\"int main () { // 一般不允许写在这里 #include <stdio.h> return 0; } \"]},\"318\":{\"h\":\"2.宏定义\",\"t\":[\"（1）宏定义基本介绍\",\"宏定义，就是用一个标识符（宏名称）来表示一个替换文本，如果在后面的代码中出现了宏名称，预处理器会将它替换为对应的文本，称为宏替换或宏展开\",\"宏定义基本语法：#define 宏名称 替换文本宏名称：宏的名称，是一个标识符，通常使用大写字母表示，以便与变量名区分开来替换文本：宏名称在代码中的每次出现都会被替换为这段文本前面的案例中，我们曾经使用宏定义来定义常量和布尔类型\",\"（2）使用宏定义常量\",\"//下面代码中，使用宏定义声明了N，后面代码中出现了 N，会替换成 100 #include <stdio.h> // 定义常量 #define PI 3.14 int main() { // 定义变量保存半径，值通过用户输入获取 double radius; printf(\\\"请输入半径：\\\"); scanf(\\\"%lf\\\", &radius); // 计算面积并输出 printf(\\\"圆的面积：%.2f\\\", radius * PI * PI); return 0; } \",\"（3）使用宏定义数据类型\",\" //下面代码中使用宏定义声明了BOOL、TURE、FALSE，后面代码中出现BOOL会替换成int，出现TRUE会替换成1，出现FALSE替换成0 #include <stdio.h> // 宏定义 #define BOOL int #define TRUE 1 #define FALSE 0 int main() { // 使用整型表示真假两种状态 // int isPass = 0; // int isOk = 1; // 借助于宏定义 BOOL isPass = FALSE; BOOL isOk = TRUE; if (isPass) { printf(\\\"Pass\\\"); } if (isOk) { printf(\\\"Ok\\\"); } return 0; } \",\"（4）宏定义的替换文本\",\"替换文本可以含任何字符，它可以是字面量、表达式、if 语句、函数等，预处理程序对它不作任何检查，直接进行文本替换，如有错误，只能在编译已被宏展开后的源程序时发现\",\"#include <stdio.h> #define M (n * n + 3 * n) #define PRINT_SUM printf(\\\"sum=%d\\\", sum) int main() { int n = 3; int sum = 3 * M + 4 * M + 5 * M; // 宏展开 3*(n*n+3*n)+4*(n*n+3*n)+5*(n*n+3*n); PRINT_SUM; // 宏展开 printf(\\\"sum=%d\\\", sum) //sum=216 return 0; } \",\"（5）宏定义嵌套\",\"宏定义允许嵌套，在宏定义的替换文本中可以使用已经定义的宏名，在宏展开时由预处理程序层层替换\",\"#include <stdio.h> #define PI 3.1415926 #define S PI *y *y int main() { int y = 2; printf(\\\"%f\\\", S); // 宏替换变为 printf(\\\"%f\\\", 3.1415926*y*y); //12.566370 return 0; } \",\"（6）取消宏定义\",\"如要取消宏定义使用#undef命令\",\"#include <stdio.h> #define PI 3.14159 int main() { printf(\\\"PI=%f\\\", PI); //PI=3.141590 return 0; } #undef PI // 取消宏定义 void func() { // printf(\\\"PI=%f\\\", PI); //错误,这里不能使用到PI了 } \"]},\"319\":{\"h\":\"3.带参数的宏定义\",\"t\":[\"（1）带参数的宏定义基本介绍\",\"C语言允许宏带有参数。在宏定义中的参数称为“形式参数”，在宏调用中的参数称为“实际参数”，这和函数有些类似对带参数的宏，在展开过程中不仅要进行文本替换，还要用实参去替换形参带参宏定义的一般形式为#define宏名（形参列表）替换文本，在替换文本中可以含有各个形参带参宏调用的一般形式为：宏名（实参列表）\",\"#include <stdio.h> // 说明 // 1. MAX 就是带参数的宏 // 2. (a,b) 就是形参 // 3. (a>b) ? a : b是带参数的宏对应字符串，该字符串中可以使用形参 #define MAX(a, b) (a > b) ? a : b int main() { int x, y, max; printf(\\\"input two numbers: \\\"); scanf(\\\"%d %d\\\", &x, &y); // 说明 // 1. MAX(x, y); 调用带参数宏定义 // 2. 在宏替换时(预处理，由预处理器)， 会进行字符串的替换，同时会使用实参， 去替换形参 // 3. 即MAX(x, y) 宏替换后 (x>y) ? x : y max = MAX(x, y); printf(\\\"max=%d\\\\n\\\", max); return 0; } \",\"（2）注意事项和细节\",\"带参宏定义中，形参之间可以出现空格，但是宏名和形参列表之间不能有空格出现在带参宏定义中，不会为形式参数分配内存，因此不必指明数据类型，而在宏调用中，实参包含了具体的数据，要用它们去替换形参，因此实参必须要指明数据类型在宏定义中，替换文本内的形参通常要用括号括起来以避免出错\",\"#include <stdio.h> // 带参宏定义,字符串内的形参通常要用括号括起来以避免出错 #define SQ(y) (y) * (y) int main() { int a, sq; printf(\\\"input a number: \\\"); scanf(\\\"%d\\\", &a); // 宏替换为 (a+1) * (a+1) sq = SQ(a + 1); printf(\\\"sq=%d\\\\n\\\", sq); return 0; } \",\"（3）带参宏定义和函数的区别\",\"宏展开仅仅是文本的替换，不会对表达式进行计算；宏在编译之前就被处理掉了，它没有机会参与编译，也不会占用内存函数是一段可以重复使用的代码，会被编译，会给它分配内存，每次调用函数， 就是执行这块内存中的代码\",\"//函数实现 #include <stdio.h> int SQ(int y) { return y * y; } int main() { int i = 1; while (i <= 5) { printf(\\\"%d\\\\n\\\", SQ(i++)); } return 0; } \",\"//带参数的宏实现 #include <stdio.h> #define SQ(y) (y) * (y) int main() { int i = 1; while (i <= 5) { // SQ(i++) 会被宏替换为 (i++) * (i++), i++ 会执行两次，最终无法得到我们想要的结果 // printf(\\\"%d\\\\n\\\", SQ(i++)); printf(\\\"%d\\\\n\\\", SQ(i)); i ++; } return 0; } \"]},\"320\":{\"h\":\"4.文件包含\",\"t\":[\"#include 指令用于引入标准库头文件、自定义头文件或其他外部源代码文件，以便在当前源文件中使用其中定义的函数、变量、宏等内容\",\"一个源文件可以导入多个头文件，一个头文件也可以被多个源文件导入标准库头文件、自定义头文件的扩展名都是 .h\",\"（1）包含标准库头文件\",\"标准库头文件是系统提供的头文件，直接引入即可，像我们前面用过的 stdio.h、stdbool.h、string.h、time.h 等。引入标准库头文件需要使用尖括号将文件名包裹起来，格式如下:\",\"#include <头文件名.h> \",\"（2）包含自定义头文件\",\"自定义头文件的文件名写在双引号里面，格式如下：\",\"#include \\\"文件名.h\\\" \",\"建议把所有的常量、宏、系统全局变量和函数原型写在自定义的头文件中，在需要的时候随时引用这些头文件\",\"（3）使用相对路径\",\"如果自定义的头文件在源文件的同级目录或源文件所在目录的下级目录，使用 ./ 开头的路径，./ 可以省略如果自定义的头文件在源文件所在目录的上级或者更上级，使用 ../ 开头的路径\",\"如果要在源文件 main.c 中引入以上自定义的头文件，需按照如下写法：\",\"//需要注意的是，建议将头文件放置在源文件所在目录或子目录中，以保持项目的组织结构清晰 #include \\\"myheader01.h\\\" // 等价于 #include \\\"./myheader01.h\\\" #include \\\"includes/myheader02.h\\\" // 等价于 #include \\\"./myheader01.h\\\" #include \\\"../myheader03.h\\\" #include \\\"../inc/myheader04.h\\\" #include \\\"../../myheader05.h\\\" \",\"（4）使用绝对路径\",\"绝对路径是文件在文件系统中的完整路径，它从文件系统的盘符（Windows系统）或根目录（Linux系统、MacOS系统）开始，沿着文件系统的目录结构一直到达目标文件\",\"Windows 系统中使用绝对路径引入自定义头文件，示例如下：\",\"#include \\\"C:\\\\Preparation\\\\Embedded\\\\01CLang\\\\code\\\\project\\\\foo.h\\\" \",\"Linux系统或MacOS系统中使用绝对路径引入自定义头文件，示例如下：\",\"#include \\\"/usr/local/lib/foo.h\\\" \"]},\"321\":{\"h\":\"5.条件编译\",\"t\":[\"（1）#if①#if...#endif\",\"#if...#endif指令用于预处理器的条件判断，满足条件时，内部的行会被编译，否则就被编译器忽略\",\"#if 0 const double pi = 3.1415; // 不会执行 #endif \",\"上面示例中，#if后面的0，表示判断条件不成立。所以，内部的变量定义语句会被编译器忽略。#if 0这种写法常用来当作注释使用，不需要的代码就放在#if 0里面#if后面的判断条件，通常是一个表达式。如果表达式的值不等于0，就表示判断条件为真，编译内部的语句；如果表达式的值等于0，表示判断条件为伪，则忽略内部的语句\",\"②#if...#else...#endif\",\"#if...#endif之间还可以加入#else指令，用于指定判断条件不成立时，需要编译的语句\",\"#define FOO 1 #if FOO printf(\\\"defined\\\\n\\\"); #else printf(\\\"not defined\\\\n\\\"); #endif \",\"上面示例中，宏FOO如果定义过，会被替换成1，从而输出defined，否则输出not defined\",\"③#if...#elif...#else...#endif\",\"如果有多个判断条件，还可以加入#elif命令\",\"#if HAPPY_FACTOR == 0 printf(\\\"I'm not happy!\\\\n\\\"); #elif HAPPY_FACTOR == 1 printf(\\\"I'm just regular\\\\n\\\"); #else printf(\\\"I'm extra happy!\\\\n\\\"); #endif \",\"上面示例中，通过#elif指定了第二重判断。注意，#elif的位置必须在#else之前。如果多个判断条件皆不满足，则执行#else的部分没有定义过的宏，等同于0。因此如果UNDEFINED是一个没有定义过的宏，那么#if UNDEFINED为伪，而#if !UNDEFINED为真\",\"（2）#ifdef\",\"①#ifdef...#endif指令用于判断某个宏是否定义过\",\"有时源码文件可能会重复加载某个库，为了避免这种情况，可以在库文件里使用#define定义一个空的宏。通过这个宏，判断库文件是否被加载了\",\"//下面示例中，EXTRA_HAPPY就是一个空的宏 #define EXTRA_HAPPY \",\"然后，源码文件使用#ifdef...#endif检查这个宏是否定义过\",\"//下面示例中，#ifdef检查宏EXTRA_HAPPY是否定义过。如果已经存在，表示加载过库文件，就会打印一行提示 #ifdef EXTRA_HAPPY printf(\\\"I'm extra happy!\\\\n\\\"); #endif \",\"②#ifdef可以与#else指令配合使用\",\"//下面示例中，如果宏EXTRA_HAPPY没有定义过，就会执行#else的部分 #ifdef EXTRA_HAPPY printf(\\\"I'm extra happy!\\\\n\\\"); #else printf(\\\"I'm just regular\\\\n\\\"); #endif \",\"③#ifdef...#else...#endif可以用来实现条件加载\",\"//下面示例中，通过判断宏MAVIS是否定义过，实现加载不同的头文件 #ifdef MAVIS #include \\\"foo.h\\\" #define STABLES 1 #else #include \\\"bar.h\\\" #define STABLES 2 #endif \",\"（3）#if defined\",\"#ifdef指令，等同于#if defined\",\"//下面示例中，defined是一个预处理运算符，如果它的参数是一个定义过的宏，就会返回1，否则返回0 #ifdef FOO // 等同于 #if defined FOO \",\"//使用这种语法，可以完成多重判断 #if defined FOO x = 2; #elif defined BAR x = 3; #else x = 4; #endif \",\"（4）#ifndef\",\"#ifndef...#endif指令跟#ifdef...#endif正好相反。它用来判断，如果某个宏没有被定义过，则执行指定的操作\",\"//下面示例中，针对宏EXTRA_HAPPY是否被定义过，#ifdef和#ifndef分别指定了两种情况各自需要编译的代码 #ifdef EXTRA_HAPPY printf(\\\"I'm extra happy!\\\\n\\\"); #endif #ifndef EXTRA_HAPPY printf(\\\"I'm just regular\\\\n\\\"); #endif \",\"#ifndef常用于防止重复加载。举例来说，为了防止头文件myheader.h被重复加载，可以把它放在#ifndef...#endif里面加载\",\"//下面示例中，宏MYHEADER_H对应文件名myheader.h的大写。只要#ifndef发现这个宏没有被定义过，就说明该头文件没有加载过，从而加载内部的代码，并会定义宏MYHEADER_H，防止被再次加载 #ifndef MYHEADER_H #define MYHEADER_H #include \\\"myheader.h\\\" #endif \"]},\"322\":{\"h\":\"6.预处理命令总结\"},\"323\":{\"h\":\"第四章：二进制与数据类型\"},\"324\":{\"h\":\"1.二进制\"},\"325\":{\"h\":\"1.1 进制\",\"t\":[\"计算机世界中只有二进制，所以计算机中存储和运算的所有数据都要转为二进制。包括数字、字符、图片、声音、视频等\",\"（1）常见进制介绍\",\"（1）二进制：0、1，满2进1 （2）十进制：0 - 9，满10进1 （3）十六进制：0 - 9及A-F，满16进1。十六进制中，除了 0 到 9 十个数字外，还引入了字母，以便表示超过9的值。字母A对应十进制的10，字母B对应十进制的11，字母 C、D、E、F 分别对应十进制的 12、13、14、15\",\"（2）C语言中使用不同进制表示整数\",\"（1）二进制：以0b或0B开头表示 （2）十进制：正常数字表示 （3）十六进制：以0x或0X开头表示，此处的A-F不区分大小写\",\"#include <stdio.h> int main() { int num1 = 0b10; // 二进制 int num2 = 210; // 十进制 int num3 = 0x1f; // 十六进制 //都打印为10进制整数 printf(\\\"num1=%d \\\\n\\\", num1); printf(\\\"num1=%d \\\\n\\\", num2); printf(\\\"num1=%d \\\\n\\\", num3); //num1=2 //num1=210 //num1=31 return 0; } \",\"（3）C语言的输出格式\",\"%d ：十进制整数 %x ：十六进制整数 %#x ：显示前缀 0x(小写) 的十六进制整数 %#X ：显示前缀 0X(大写) 的十六进制整数\",\"#include <stdio.h> int main() { int x = 100; printf(\\\"十进制：%d \\\\n\\\", x); printf(\\\"十六进制：%x \\\\n\\\", x); printf(\\\"十六进制（0x开头）：%#x \\\\n\\\", x); printf(\\\"十六进制（0X开头）：%#X \\\\n\\\", x); /* 十进制：100 十六进制：64 十六进制（0x开头）：0x64 十六进制（0X开头）：0X64 */ return 0; } \"]},\"326\":{\"h\":\"1.2 进制的转换\",\"t\":[\"（1）二进制与十进制的转换\",\"二进制转换成十进制：从最低位开始，将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和\",\"十进制转换成二进制：将该数不断除以2，直到商为0为止，然后将每步得到的余数倒过来，就是对应的二进制\",\"（2）十六进制与十进制的转换\",\"十六进制转成十进制：从最低位开始，将每个位上的数提取出来，乘以16的（位数-1）次方，然后求和\",\"十进制转成十六进制：将该数不断除以16，直到商为0为止，然后将每步得到的余数倒过来，就是对应的十六进制\",\"（3）二进制与十六进制的转换\",\"二进制转成十六进制：低位开始，将二进制数每四位一组，转成对应的十六进制数即可\",\"十六进制转成二进制：将十六进制数每1位，转成对应的4位的一个二进制数即可\"]},\"327\":{\"h\":\"1.3 原码、补码、反码\",\"t\":[\"计算机底层存储数据时使用的是二进制数字，但是计算机在存储一个数字时并不是直接存储该数字对应的二进制数字，而是存储该数字对应二进制数字的补码\",\"（1）机器数和真值\",\"机器数：一个数在计算机的存储形式是二进制数，我们称这些二进制数为机器数。机器数可以是有符号的，用机器数的最高位存放符号位，0表示正数，1表示负数真值：因为机器数带有符号位，所以机器数的形式值不等于其真实表示的值（真值），以机器数10000001为例，其真正表示的值（首位为符号位）为-1，而形式值（首位就是代表1）为129；因此将带符号的机器数的真正表示的值称为机器数的真值\",\"（2）原码、补码、反码的概念总结：\",\"正数的原码、反码、补码都一样，三码合一\",\"负数的反码：它的原码符号位不变，其它位取反；\",\"负数的补码：它的反码+1\",\"0的反码，补码都是0\",\"原码：原码的表示与机器数真值表示的一样，即用第一位表示符号，其余位表示数值\",\"正数的原码：就是它对应的二进制数\",\"负数的原码：它的绝对值对应的二进制数，且最左边位变为1\",\"0的原码：仍然是0十进制的正负1，用8位二进制的原码表示如下：+1 原码：[ 0000 0001 ]-1 原码：[ 000 0001 ]\",\"反码：\",\"正数的反码：和原码相同\",\"负数的反码：在其原码的基础上，符号位不变，其余各位取反\",\"0的反码：仍然是0\",\"十进制的正负1，用8位二进制的反码表示如下：+1 原码：[ 0000 0001 ] 反码：[ 0000 0001 ]-1 原码：[ 1000 0001 ] 反码：[ 1 ]注意：反码通常是用来由原码求补码或者由补码求原码的过渡码\",\"补码：\",\"正数的补码：和原码、反码相同\",\"负数的补码：反码的基础上加1\",\"0的补码：仍然是0\",\"十进制的正负1，用8位二进制的补码表示如下：+1 原码：[ 0000 0001 ] 反码：[ 0000 0001 ] 补码：[ 0000 0001 ]-1 原码：[ 1000 0001 ] 反码：[ 1111 1110 ] 补码：[ 1111 1111 ]\"]},\"328\":{\"h\":\"1.4 计算机为什么要用补码\",\"t\":[\"简言之：简化硬件设计和提高计算效率\"]},\"329\":{\"h\":\"2.数据类型\",\"t\":[\"C语言根据数据的特性和用途进行了类型划分，不同类型的数据在内存中占据不同大小的空间\"]},\"330\":{\"h\":\"2.1 整形类型\",\"t\":[\"（1）关于存储大小单位：\",\"bit（位）：计算机中的最小存储单位，表示一个二进制位 byte（字节）：计算机中基本存储单元，1byte = 8bit\",\"各类型存储大小受到操作系统、编译器、硬件平台的影响\",\"整型分为有符号signed和无符号unsigned两种，默认是signed\",\"开发中使用整型一般用int型，如果不足以表示大数，可以使用long long\",\"类型\",\"存储大小\",\"值范围\",\"short、signed short\",\"2字节\",\"-32,768 (- 2^15)到 32,767 (2^15 -1)\",\"unsigned short\",\"2字节\",\"0 到 65,535 (2^16 - 1)\",\"int、signed int\",\"16位：2 字节、32位：4 字节\",\"16位：-32,768 (- 2^15 ) 到 32,767 (2^15-1)、32位：-2,147,483,648 (- 2^31) 到 2,147,483,647 (2^31 -1)\",\"unsigned int\",\"16位：2 字节、32位：4 字节\",\"16位：0 到 65,535 (2^16-1) 、32位：0 到 4,294,967,295 (2^32 -1)\",\"long 、signed long\",\"32位：4 字节、64位：8 字节\",\"32位：-2,147,483,648 (- 2^31) 到 2,147,483,647 (2^31 - 1)、64位：9223372036854775808(-2^63) 到9223372036854775807 (2^63-1)\",\"unsigned long\",\"4 或 8 字节\",\"32位：0 到 4,294,967,295 (2^32 - 1)、64位：0 ~ 18446744073709551615 (2^64 - 1)\",\"long long、signed long long\",\"8字节\",\"9223372036854775808(-2^63) 到9223372036854775807 (2^63-1)\",\"unsigned long long\",\"8 字节\",\"0 ~ 18446744073709551615 (2^64 - 1)\",\"（2）字面常量后缀字面量是源代码中一个固定值的表示法，用于直接表示数据，如图所示：\",\"（1）一个整数字面量默认是int类型 （2）如果需要表示 long 类型字面量，需要添加后缀 l 或 L （3）如果需要表示 long long 类型字面量，需要添加后缀 ll 或 LL （4）如果需要表示无符号整数字面量，需要添加后缀 u 或 U， 注意， u 和 l 可以结合使用，不分先后，如 ul（无符号long类型）、ULL（无符号 long long类型），lu（无符号 long 类型）等\",\"#include <stdio.h> int main() { // short 类型 short a1 = 10; // 等同于 signed short a1 = 10; short a2 = -10; // 等同于 signed short a1 = -10; // unsigned short a3 = -20; unsigned short a3 = 20; printf(\\\"a1=%d; a2=%d; a3=%d \\\\n\\\", a1, a2, a3); // a1=10; a2=-10; a3=20 // int 类型 int b1 = 100; // 等同于 signed int a1 = 100; int b2 = -100; // 等同于 signed int a1 = -100; unsigned int b3 = 200u; unsigned b4 = 300U; // 等同于 unsigned int b4 = 300U; printf(\\\"b1=%d; b2=%d; b3=%d; b4=%d \\\\n\\\", b1, b2, b3, b4); // b1=100; b2=-100; b3=200; b4=300 // long 类型 long c1 = 1000l; // 等同于 signed long c1 = 1000l; long c2 = -1000L; // 等同于 signed long c2 = -1000L; unsigned long c3 = 2000ul; printf(\\\"c1=%ld; c2=%ld; c3=%ld \\\\n\\\", c1, c2, c3); // c1=100; c2=-1000; c3=2000 // long long 类型 long long d1 = 10000ll; // 等同于 signed long long d1 = 10000ll; long long d2 = -10000LL; // 等同于 signed long long d2 = -10000LL; unsigned long long d3 = 20000ULL; printf(\\\"d1=%lld; d2=%lld; d3=%lld \\\\n\\\", d1, d2, d3); // d1=10000; d2=-10000; d3=20000 /* a1=10; a2=-10; a3=20 b1=100; b2=-100; b3=200; b4=300 c1=100; c2=-1000; c3=2000 d1=10000; d2=-10000; d3=20000 */ return 0; } \",\"（4）精确宽度类型C 语言的整数类型（short、int、long）在不同计算机上，占用的字节宽度可能是不一样的。程序员有时需要精准的字节宽度，以提高代码的可移植性，尤其是嵌入式开发中，使用精确宽度类型可以确保代码在各种平台上的一致性\",\"标准库的头文件 <stdint.h> 中定义了一些新的类型别名，如下：\",\"类型名称\",\"含义\",\"int8_t\",\"8 位有符号整数\",\"int16_t\",\"16 位有符号整数\",\"int32_t\",\"32 位有符号整数\",\"int64_t\",\"64 位有符号整数\",\"uint8_t\",\"8 位无符号整数\",\"uint16_t\",\"16 位无符号整数\",\"uint32_t\",\"32 位无符号整数\",\"uint64_t\",\"64 位无符号整数\",\"#include <stdio.h> #include <stdint.h> int main() { // 变量 x32 声明为 int32_t 类型，可以保证是32位(4个字节)的宽度。 int32_t x32 = 45933945; printf(\\\"x32=%d\\\\n\\\", x32); //x32=45933945 return 0; } \"]},\"331\":{\"h\":\"2.2 浮点类型\",\"t\":[\"浮点类型可以表示一个小数，比如：123.4，7.8，0.12等\",\"（1）浮点型的类型\",\"类型\",\"存储大小\",\"值范围\",\"有效小数位数\",\"float 单精度\",\"4 字节\",\"1.2E-38 到 3.4E+38\",\"6 ~ 9\",\"double 双精度\",\"8 字节\",\"2.3E-308 到 1.7E+308\",\"15 ~18\",\"long double 长双精度\",\"32位：10字节、64位：16字节\",\"32位：与 double 相同或更大、64位：3.4E-4932到1.2E+4932\",\"18或更多\",\"（2）浮点型数据表示形式\",\"十进制数形式：如：5.12、512.0f、.512（0.512 可以省略 0） 科学计数法形式：如：5.12e2、5.12E-2 开发中用到浮点型数字，建议使用double型，如精度要求更高可以使用long double 型\",\"（3）字面量后缀\",\"浮点数字面量默认是double型 如果需要表示float类型字面量，须加后缀 f 或 F 如果需要表示long double类型字面量，需加后缀 l 或 L\",\"（4）格式占位符\",\"%f：是浮点类型的格式占位符，在printf中对应float类型（float类型会转换成double来处理）；默认会保留6位小数，可以指定小数位数，如：%.2f 表示保留2位小数%lf：在printf中和 %f意思相同（C99标准加入），对应double类型，默认保留6位小数，可以指定小数位数，如：%.2lf 表示保留2位小数。但需要注意的是，在scanf中 %lf和 %f含义不同：输入一个float类型数据时使用 %f；而输入double类型时必须使用 %lf%Lf：对应的是long double 类型，默认保留6位小数，可以指定小数位数，如： %.2Lf 表示保留2位小数。需要注意的是，输入输出 long double 类型都必须使用 %Lf 占位符%e：对应科学计数法表示的浮点数，可以指定尾数部分所保留的小数位数，如 %.2e 表示尾数部分保留两位小数\",\"#include <stdio.h> int main() { // double 类型 double a1 = 3.1415; double a2 = .12345678; double a3 = -2e12; double a4 = 1.9823e2; printf(\\\"a1=%f, a2=%.10f, a3=%.2lf, a4=%lf \\\\n\\\", a1, a2, a3, a4); printf(\\\"a1=%e, a2=%.2e, a3=%e, a4=%e \\\\n\\\", a1, a2, a3, a4); // float 类型 float b1 = 3.1415f; float b2 = .123456f; float b3 = -2e12f; float b4 = 1.9823e2f; printf(\\\"b1=%f, b2=%f, b3=%.0f, b4=%f \\\\n\\\", b1, b2, b3, b4); printf(\\\"b1=%e, b2=%.2e, b3=%e, b4=%e \\\\n\\\\n\\\", b1, b2, b3, b4); /* a1=3.141500, a2=0.1234567800, a3=-2000000000000.00, a4=198.230000 a1=3.141500e+00, a2=1.23e-01, a3=-2.000000e+12, a4=1.982300e+02 b1=3.141500, b2=0.123456, b3=-1999999991808, b4=198.229996 b1=3.141500e+00, b2=1.23e-01, b3=-2.000000e+12, b4=1.982300e+02 */ return 0; } \"]},\"332\":{\"h\":\"2.3 字符类型\",\"t\":[\"字符类型 char 可以表示单个字符，如一个数字、一个字母、一个符号\",\"char类型的字面量是用单引号括起来的单个字符可以使用转义字符 \\\\ 表示特殊含义的字符多个字符称为字符串，在C语言中使用char数组表示，数组不是基本数据类型，而是构造类型使用%c表示char类型\",\"转义字符\",\"说明\",\"\\\\b\",\"退格\",\"\\\\n\",\"换行符\",\"\\\\r\",\"回车符\",\"\\\\t\",\"制表符\",\"\\\\”\",\"双引号\",\"\\\\'\",\"单引号\",\"\\\\\\\\\",\"反斜杠\",\"（1）字符类型本质\",\"C语言中，char类型本质是一个整数，是ASCII码中对应的数字，存储长度是 1 个字节，char类型可以进行数学运算字符型同样分为signed char（无符号）和unsigned char（有符号），其中signed char取值范围-128 ~ 127，unsigned char取值范围0 ~ 255。默认是否带符号取决于当前运行环境\",\"（2）字符型数据在计算中存储和读取的过程\",\"（3）ASCII码介绍\",\"ASCII码是一种用于表示文本字符的字符编码标准，一共规定了128个字符的编码，比如空格“SPACE” 是32（二进制00100000），大写的字母A是65（二进制01000001）主要记住：A是65，a是97，相差32\",\"#include <stdio.h> int main() { // char 类型字面量需要使用单引号包裹 char a1 = 'A'; char a2 = '9'; char a3 = '\\\\t'; printf(\\\"c1=%c, c3=%c, c2=%c \\\\n\\\", a1, a3, a2); // char 类型本质上整数可以进行运算 char b1 = 'b'; char b2 = 101; printf(\\\"%c->%d \\\\n\\\", b1, b1); printf(\\\"%c->%d \\\\n\\\", b2, b2); printf(\\\"%c+%c=%d \\\\n\\\", b1, b2, b1 + b2); // char 类型取值范围 unsigned char c1 = 200; // 无符号char取值范围 0 ~255 signed char c2 = 200; // 有符号char取值范围 -128~127，c2会超出范围 char c3 = 200; // 当前系统，char 默认是 signed char printf(\\\"c1=%d, c2=%d, c3=%d\\\", c1, c2, c3); /* c1=A, c3= , c2=9 b -> 98 e -> 101 b + e = 199 c1=200, c2=-56, c3=-56 */ return 0; } \"]},\"333\":{\"h\":\"2.4 布尔类型\",\"t\":[\"布尔值用于表示真、假两种状态，通常用于逻辑运算和条件判断\",\"（1）声明布尔类型的三种方法：主要用第三种\",\"①宏定义：\",\"#define BOOL int #define TURE 1 #define FALSE 0 \",\"②C99标准提供了_Bool 型，_Bool仍是整数类型，但与一般整型不同的是，_Bool变量只能赋值为0或1，非0的值都会被存储为1\",\"③C99标准还提供了一个头文件 <stdbool.h> 定义了bool代表_Bool，true代表1，false代表0\"]},\"334\":{\"h\":\"2.5 存储类别说明符\",\"t\":[\"存储类别说明符分为：auto、static、register、extern\",\"auto：默认存储类型说明符\",\"static：用于声明静态变量和函数，静态变量在程序的整个生命周期内存在，不会在函数调用结束就销毁，static声明的变量只会初始化一次\",\"register：用于建议编译器将变量存储在寄存器中，以便提高访问速度，在现代编译器中不需要使用，编译器足够智能\",\"extern：用于声明一个变量或函数，告知它的定义可能在其他文件中，通常在头文件中声明全局变量，在源文件中定义\"]},\"335\":{\"h\":\"3.获取数据的存储大小\",\"t\":[\"使用sizeof 可以获取数据类型或变量、字面量的存储大小，单位是字节。sizeof返回一个size_t类型的无符号整数值，格式占位符是 %zu，通常用%d打印\",\"size_t 通常是 unsigned int 或 unsigned long 的别名，具体是哪个类型的别名，由系统和编译器决定\",\"#include <stdio.h> int main() { // 计算数据类型的大小, 必须使用括号将数据类型关键字包裹起来 printf(\\\"char：%zu \\\\n\\\", sizeof(char)); // char：1 printf(\\\"short：%zu \\\\n\\\", sizeof(short)); // short：2 printf(\\\"int：%zu \\\\n\\\", sizeof(int)); printf(\\\"long：%zu \\\\n\\\", sizeof(long)); // long：4 printf(\\\"long long：%zu \\\\n\\\", sizeof(long long)); // long long：8 printf(\\\"float：%zu \\\\n\\\", sizeof(float)); // float：4 printf(\\\"double：%zu \\\\n\\\", sizeof(double)); // double：8 printf(\\\"long double：%zu \\\\n\\\", sizeof(long double)); // long double：16 printf(\\\"\\\\n\\\"); // 计算字面量数据的大小，字面量可以省略括号 printf(\\\"%zu \\\\n\\\", sizeof('a')); // 4 printf(\\\"%zu \\\\n\\\", sizeof(431)); // 4 printf(\\\"%zu \\\\n\\\", sizeof 4.31); // 8 printf(\\\"\\\\n\\\"); // 计算变量的大小，变量可以省略括号 char a = 'A'; int b = 90; long long c = 100; double d = 10.8; printf(\\\"a: %zu \\\\n\\\", sizeof(a)); // a: 1 printf(\\\"b: %zu \\\\n\\\", sizeof b); // b: 4 printf(\\\"c: %zu \\\\n\\\", sizeof(c)); // c: 8 printf(\\\"d: %zu \\\\n\\\", sizeof(d)); // d: 8 /* char：1 short：2 int：4 long：4 long long：8 float：4 double：8 long double：16 4 4 8 a: 1 b: 4 c: 8 */ return 0; } \"]},\"336\":{\"h\":\"4.数据类型转换\",\"t\":[\"数据类型转换分为：自动类型转换(隐式类型转换)、强制类型转换(显式类型转换)\"]},\"337\":{\"h\":\"4.1 隐式类型转换\",\"t\":[\"不同类型的数据进行混合运算，会发生数据类型转换，窄类型会自动转为宽类型，这样不会造成精度损失\",\"（1）运算过程中的隐式转换\",\"不同类型整数进行运算，窄类型整数自动转换为宽类型整数 不同类型浮点数进行运算，精度小的类型自动转换为精度大的类型 整数与浮点数进行运算，整数自动转换为浮点数\",\"#include <stdio.h> int main() { // 整型提升 short s1 = 10; int n1 = 40000; // 运算过程中，变量 s1 是 short 类型，会自动转为 int 类型 printf(\\\"%d \\\\n\\\", s1 + n1); // 有符号整数自动转为无符号整数 // int n2 = 100; int n2 = -100; unsigned int n3 = 20; // 负数转为无符号整数，两者绝对值的和是无符号整数的最大值再加 1 printf(\\\"%u \\\\n\\\", n2 + n3); // 不同类型的浮点数运算，精度低的转诶精度高的 float f1 = 1.25f; double d2 = 4.58667435; // printf(\\\"%f \\\\t\\\", f1); printf(\\\"%.10f\\\\n\\\", f1 + d2); // 整型与浮点型运算，整型转为浮点型 int n4 = 10; double d3 = 1.67; printf(\\\"%f\\\", n4 + d3); /* 40010 4294967216 5.8366743500 11.670000 */ return 0; } \",\"（2）赋值时的隐式转换\",\"在赋值运算中，赋值号 两边量的数据类型不同时，等号右边的类型将转换为左边的类型。 如果窄类型赋值给宽类型，不会造成精度损失；如果宽类型赋值给窄类型，会造成精度损失\",\"#include <stdio.h> int main() { // 赋值 窄类型赋值给宽类型 int a1 = 10; double a2 = a1; printf(\\\"%f \\\\n\\\", a2); // 赋值 宽类型赋值给窄类型 double b1 = 1.2; int b2 = b1; printf(\\\"%d\\\", b2); /* 10.000000 1 */ return 0; } \"]},\"338\":{\"h\":\"4.2 显示类型转换\",\"t\":[\"隐式类型转换中的宽类型赋值给窄类型，编译器是会产生警告的，提示程序存在潜在的隐患，如果非常明确地希望转换数据类型，就需要用到强制（或显式）类型转换\",\"转换格式：（类型名）变量、常量、表达式\",\"#include <stdio.h> int main() { double d1 = 1.934; double d2 = 4.2; int num1 = (int)d1 + (int)d2; // d1转为1，d2转为4，结果是5 int num2 = (int)(d1 + d2); // d1+d2=6.134，6.134转为6 int num3 = (int)(3.5 * 10 + 6 * 1.5); // 35.0 + 9.0 = 44.0 -> int = 44 printf(\\\"num1=%d \\\\n\\\", num1); printf(\\\"num2=%d \\\\n\\\", num2); printf(\\\"num3=%d \\\\n\\\", num3); /* num1=5 num2=6 num3=44 */ return 0; } \"]},\"339\":{\"h\":\"5.大小端存储\"},\"340\":{\"h\":\"练手项目：通讯录管理系统\"},\"341\":{\"h\":\"1.项目效果\"},\"342\":{\"h\":\"2.项目要求\",\"t\":[\"技术要求：包含C语言所有常用基础知识和文件系统\",\"通讯录系统功能： 1.添加联系人：向通讯录中添加联系人，信息包括（姓名、性别、年龄、联系方式、住址）最多记录1000人 2.删除联系人：按照用户需求进行删除指定联系人 3.修改联系人：按照用户需求重新修改指定联系人 4.查询联系人：按照用户需求查看指定联系人信息 5.显示通讯录：显示通讯录中所有联系人信息 6.排序通讯录：按照用户需求排序联系人 0.退出系统： 退出当前使用的通讯录\"]},\"343\":{\"h\":\"3.项目代码\"},\"344\":{\"h\":\"3.1 contact.h头文件\",\"t\":[\"// Author：JimBo (1353429820@qq.com) // Filename：Contact.h // Date：2024/1/14 // Description：implement basic functions of the address book // Copyrights（c）JimBo. All rights reserved //头文件 #pragma once #include<stdio.h> #include<string.h> #include<assert.h> #include<stdlib.h> #include<errno.h> #include<unistd.h> //通讯录结构体成员最大值宏 #define MAX_NAME 16 //名字 特殊情况：这人名字有8位(1个汉字=2字节) #define MAX_SEX 5 //性别 特殊情况：填的未知 #define MAX_TEL 16 //电话号码 特殊情况：加地域号4位 #define MAX_ADD 50 //地址 特殊情况：地址有25位 #define MAX_ARR 16 //联系人地址 //通讯录功能界面选择 enum Option { EXIT, //退出通讯录 0 ADD, //添加联系人 1 DEL, //删除联系人 2 MODIFY, //修改联系人 3 SEARCH, //查找联系人 4 SORT, //排序通讯录 5 PRINT //显示通讯录 6 }; //通讯录联系人基本信息结构体 typedef struct ContactInfo { char name[MAX_NAME]; //联系人姓名 int age; //联系人年龄 char sex[MAX_SEX]; //联系人性别 char telephone[MAX_TEL];//联系人电话 char address[MAX_ADD]; //联系人地址 }ContactInfo; //通讯录结构体 typedef struct Contact { ContactInfo* data; //联系人信息结构体 int size; //通讯录大小 int capacity; //通讯录容量 }Contact; //通讯录功能函数 /* * 函数名：ContactSave * 函数功能：保存通讯录文件 * 参数说明：psl指向Contact结构体的指针 * 返回值：无 */ void ContactSave(Contact* psl); /* * 函数名：ContactLoad * 函数功能：加载通讯录文件 * 参数说明：psl指向Contact结构体的指针 * 返回值：无 */ void ContactLoad(Contact* psl); /* * 函数名：ContactInit * 函数功能：初始化通讯录文件 * 参数说明：psl指向Contact结构体的指针 * 返回值：无 */ void ContactInit(Contact* psl); /* * 函数名：ContactDestroy * 函数功能：销毁通讯录文件 * 参数说明：psl指向Contact结构体的指针 * 返回值：无 */ void ContactDestroy(Contact* psl); /* * 函数名：ContactCheck * 函数功能：检查通讯录容量 * 参数说明：psl指向Contact结构体的指针 * 返回值：无 */ void ContactCheck(Contact* psl); /* * 函数名：ContactAdd * 函数功能：添加联系人 * 参数说明：psl指向Contact结构体的指针 * 返回值：无 */ void ContactAdd(Contact* psl); /* * 函数名：ContactDelete * 函数功能：删除联系人 * 参数说明：psl指向Contact结构体的指针 * 返回值：无 */ void ContactDelete(Contact* psl); /* * 函数名：ContactModify * 函数功能：修改联系人 * 参数说明：psl指向Contact结构体的指针 * 返回值：无 */ void ContactModify(Contact* psl); /* * 函数名：ContactFind * 函数功能：查询联系人的下标 * 参数说明：psl指向Contact结构体的指针、name存储要查找的联系人名 * 返回值：int */ int ContactFind(Contact* psl,char name[]); /* * 函数名：ContactSearch * 函数功能：查询联系人 * 参数说明：psl指向Contact结构体的指针 * 返回值：无 */ void ContactSearch(Contact* psl); /* * 函数名：ContactSort * 函数功能：升序排序联系人 * 参数说明：psl指向Contact结构体的指针 * 返回值：无 */ void ContactSort(Contact* psl); /* * 函数名：ContactPrint * 函数功能：显示全部通讯录联系人 * 参数说明：psl指向Contact结构体的指针 * 返回值：无 */ void ContactPrint(const Contact* psl); /* * 函数名：ContactMenu * 函数功能：显示通讯录功能界面 * 参数说明：无 * 返回值：无 */ void ContactMenu(); /* * 函数名：ContactMenu * 函数功能：实现姓氏升序排序 * 参数说明：psl指向Contact结构体的指针 * 返回值：无 */ void ContactSortUp(Contact* psl); //函数功能实现 void ContactSave(Contact* psl) { //打开文件 FILE* pf=fopen(\\\"contact.txt\\\",\\\"wb\\\");//wb：二进制可写 if(pf==NULL) { printf(\\\"保存文件失败：%s\\\\n\\\",strerror(errno)); return; } //写文件 for(int i=0;i<psl->size;++i) { fwrite(psl->data+i,sizeof(ContactInfo),1,pf); } //关闭文件 fclose(pf); pf=NULL; } void ContactLoad(Contact* psl) { //打开文件 FILE* pf= fopen(\\\"contact.txt\\\",\\\"rb\\\");//二进制可读 if(pf==NULL) { printf(\\\"加载文件失败：%s\\\\n\\\",strerror(errno)); return; } //读取文件 ContactInfo buf={0};//这里{0}有也可以，没有也可以。起一个初始化作用 while(fread(&buf,sizeof(ContactInfo),1,pf)) { ContactCheck(psl); psl->data[psl->size]=buf; psl->size++; } fclose(pf); } void ContactInit(Contact* psl) { assert(psl); //这里不用检查扩容函数，因为初始化的时候我们就设定了capacity的大小 ContactInfo* tmp=(ContactInfo*)malloc(sizeof(ContactInfo)); if(tmp!=NULL) { psl->data=tmp; } else { printf(\\\"开辟空间失败：%s\\\\n\\\", strerror(errno)); return; } psl->size=0; psl->capacity=0; //加载文件信息 ContactLoad(psl); } void ContactDestroy(Contact* psl) { assert(psl); free(psl->data); psl->data=NULL; psl->size=0; psl->capacity=0; } void ContactCheck(Contact* psl) { assert(psl); if(psl->size==psl->capacity) { //增加容量 ContactInfo* tmp=(Contact*)realloc(psl->data,(psl->capacity+2)*sizeof(ContactInfo)); if(tmp!=NULL) { psl->data=tmp; psl->capacity+=2; } } } void ContactAdd(Contact* psl) { assert(psl); ContactCheck(psl); printf(\\\"请输入名字:>\\\"); scanf(\\\"%s\\\",psl->data[psl->size].name);//size代表最后一位元素，由于下标从0开始，所有size位置没存元素 printf(\\\"请输入年龄:>\\\"); scanf(\\\"%d\\\",&psl->data[psl->size].age);//数组名表示首元素地址，可以不加& printf(\\\"请输入性别:>\\\"); scanf(\\\"%s\\\",psl->data[psl->size].sex); printf(\\\"请输入电话:>\\\"); scanf(\\\"%s\\\",psl->data[psl->size].telephone); printf(\\\"请输入地址:>\\\"); scanf(\\\"%s\\\",psl->data[psl->size].address); psl->size++; printf(\\\"添加联系人成功!\\\\n\\\"); } void ContactDelete(Contact* psl) { assert(psl); if(psl->size==0) { printf(\\\"通讯录为空，无法删除!\\\\n\\\"); return; } printf(\\\"请输入要删除的联系人名字:>\\\"); char tmp[MAX_ARR]={0};//这里一定要用字符数组并且给大小，否则会出现数组越界问题！这个BUG我改了几个小时！！！ scanf(\\\"%s\\\",tmp); //查找指定联系人 int pos= ContactFind(psl,tmp);//pos是元素的下标 if(pos==-1) { printf(\\\"联系人不存在!\\\\n\\\"); return; } else { //删除 for (int i = pos; i < psl->size-1; ++i) { psl->data[i]=psl->data[i+1];//联系人信息结构体整体赋值 } psl->size--; printf(\\\"删除联系人成功!\\\\n\\\"); } } void ContactModify(Contact* psl) { assert(psl); printf(\\\"请输入要修改的联系人名字:>\\\"); char tmp[MAX_ARR]={0}; scanf(\\\"%s\\\",tmp);//这里接收失败，tmp=NULL int pos= ContactFind(psl,tmp); if(pos==-1) { printf(\\\"联系人不存在!\\\\n\\\"); return; } else { //修改联系人 printf(\\\"请输入修改后的年龄:>\\\"); scanf(\\\"%d\\\", &psl->data[pos].age);//数组名表示首元素地址，可以不加& printf(\\\"请输入修改后的性别:>\\\"); scanf(\\\"%s\\\", psl->data[pos].sex); printf(\\\"请输入修改后的电话:>\\\"); scanf(\\\"%s\\\", psl->data[pos].telephone); printf(\\\"请输入修改后的地址:>\\\"); scanf(\\\"%s\\\", psl->data[pos].address); printf(\\\"修改联系人成功!\\\\n\\\"); } } int ContactFind(Contact* psl,char* arr) { assert(psl && arr); for(int i=0;i<psl->size;++i) { if(strcmp(psl->data[i].name,arr)==0) { return i; } } return -1;//没找到返回-1 } void ContactSearch(Contact* psl) { assert(psl); printf(\\\"请输入要查找的联系人名字:>\\\"); char tmp[MAX_ARR]={0}; scanf(\\\"%s\\\",tmp); int pos= ContactFind(psl,tmp); if(pos==-1) { printf(\\\"不存在联系人!\\\\n\\\"); return; } else { printf(\\\"找到了联系人，它的信息如下：\\\\n\\\"); printf(\\\"%-10s\\\\t%-5d\\\\t%-5s\\\\t%-14s\\\\t%-20s\\\\n\\\", psl->data[pos].name, psl->data[pos].age, psl->data[pos].sex, psl->data[pos].telephone, psl->data[pos].address); } } void ContactSort(Contact* psl) { assert(psl); if(psl->size==0) { printf(\\\"通讯录为空，无需排序!\\\\n\\\"); return; } else { printf(\\\"通讯录即将按照联系人姓氏升序进行排序！\\\\n\\\"); printf(\\\"排序中...\\\\n\\\"); sleep(2);//睡2s假装处理排序 //姓氏升序排序 ContactSortUp(psl); printf(\\\"排序完成!\\\\n\\\"); } } void ContactPrint(const Contact* psl) { assert(psl); int i = 0; printf(\\\"%-10s\\\\t%-5s\\\\t%-5s\\\\t%-14s\\\\t%-20s\\\\n\\\", \\\"名字\\\", \\\"年龄\\\", \\\"性别\\\", \\\"电话\\\", \\\"地址\\\"); for (i = 0; i < psl->size; i++) { printf(\\\"%-10s\\\\t%-5d\\\\t%-5s\\\\t%-14s\\\\t%-20s\\\\n\\\", psl->data[i].name, psl->data[i].age, psl->data[i].sex, psl->data[i].telephone, psl->data[i].address); } } void ContactSortUp(Contact* psl) { for(int i=0;i<psl->size-1;++i) { for(int j=0;j<psl->size-1;++j) { if(strcmp(psl->data[i].name,psl->data[i+1].name)>0)//前面的比后面的字母大，则交换 { ContactInfo tmp; tmp=psl->data[i]; psl->data[i]=psl->data[i+1]; psl->data[i+1]=tmp; } } } } void ContactMenu() { printf(\\\"----------------通讯录系统-----------------\\\\n\\\"); printf(\\\"**************1.添加联系人*****************\\\\n\\\"); printf(\\\"**************2.删除联系人*****************\\\\n\\\"); printf(\\\"**************3.修改联系人*****************\\\\n\\\"); printf(\\\"**************4.查询联系人*****************\\\\n\\\"); printf(\\\"**************5.排序通讯录*****************\\\\n\\\"); printf(\\\"**************6.显示通讯录*****************\\\\n\\\"); printf(\\\"**************0.退出通讯录*****************\\\\n\\\"); printf(\\\"******************************************\\\\n\\\"); } \"]},\"345\":{\"h\":\"3.2 main.c源文件\",\"t\":[\"// Author：JimBo (1353429820@qq.com) // Filename：main.c // Date：2024/1/14 // Description：implement the main function of the address book // Copyrights（c）JimBo. All rights reserved #include\\\"Contact.h\\\" int main() { int input=0; Contact con={0};//初始化通讯录，不初始化也行，反正后也要初始化 //初始化通讯录 ContactInit(&con); //界面循环：do...while实现 do { ContactMenu(); printf(\\\"请选选择功能:>\\\"); scanf(\\\"%d\\\", &input); switch (input) { case ADD: ContactAdd(&con); break; case DEL: ContactDelete(&con); break; case MODIFY: ContactModify(&con); break; case SEARCH: ContactSearch(&con); break; case SORT: ContactSort(&con); break; case PRINT: ContactPrint(&con); break; case EXIT: //保存信息到文件 ContactSave(&con); ContactDestroy(&con); printf(\\\"已退出，感谢使用通讯录系统!\\\\n\\\"); break; default: printf(\\\"选择错误，请重新选择功能!\\\\n\\\"); break; } }while(input); return 0; } \"]},\"346\":{\"h\":\"第一章：C++基础\"},\"347\":{\"h\":\"知识点思维导图\"},\"348\":{\"h\":\"复习代码\",\"t\":[\"// Author：JimBo (1353429820@qq.com) // Filename：main // Date：2024/1/14 // Description：review knowledge points // Copyrights（c）JimBo. All rights reserved //1.命名空间的使用 #include<iostream> //单独命名空间 namespace A { //命名空间可以定义变量、函数、类型 int num; int Add(int num1, int num2) { return num1 + num2; } } //嵌套命名空间、同名命名空间会合并 namespace A { namespace B{} } //1.命名空间的使用 #include<iostream> namespace A { int num1 = 1; int num2 = 2; int Add(int num1, int num2) { return num1 + num2; } } namespace B { int num1 = 1; int num2 = 2; int Add(int num1, int num2) { return num1 + num2; } } using B::num2; namespace C { int num3 = 1; int num4 = 2; int Add(int num1, int num2) { return num1 + num2; } } using namespace C; int main() { std::cout <<\\\"普通调用A空间成员，num1值为：\\\"<< A::num1 << std::endl;//普通调用成员 std::cout <<\\\"部分释放B空间成员，num2值为：\\\"<< num2 << std::endl; //部分释放成员 std::cout <<\\\"全部释放C空间成员，num3值为：\\\"<< num3 << std::endl; //全部释放成员 return 0; } /* 运行结果： 普通调用A空间成员，num1值为：1 部分释放B空间成员，num2值为：2 全部释放C空间成员，num3值为：1 */ //3.C++输入与输出 #include<iostream> using namespace std;//释放c++标准库std int main() { int a = 3; float f = 3.1415926; cout << \\\"a的值为：\\\" << a << endl; cout << \\\"f的值为：\\\" << f << endl; return 0; } /* 运行结果： a的值为：3 f的值为：3.14159 编译器默认float类型显示6位有效数字，double为11位有效数字 */ //4.C++缺省参数 #include<iostream> using namespace std; void func1(int x = 0, int y = 1, int z = 2) { cout << \\\"全缺省参数时\\\" << endl; cout << \\\"x的值为：\\\" << x << endl; cout << \\\"y的值为：\\\" << y << endl; cout << \\\"z的值为：\\\" << z << endl; } void func2(int x, int y = 1, int z = 2) { cout << \\\"半缺省参数时\\\" << endl; cout << \\\"x的值为：\\\" << x << endl; cout << \\\"y的值为：\\\" << y << endl; cout << \\\"z的值为：\\\" << z << endl; } int main() { func1(); func2(5,4); return 0; } /* 运行结果： 全缺省参数时 x的值为：0 y的值为：1 z的值为：2 半缺省参数时 x的值为：5 y的值为：4 z的值为：2 */ //5.C++函数重载 #include<iostream> using namespace std; //注意：重载函数，同一作用域下，函数名相同，参数不同(类型、顺序、个数)，与返回值类型无关 int Add(int x, int y)//原函数Add { return x + y; } double Add(double x, double y)//Add重载函数 { return x + y; } int main() { cout << Add(1, 2) << endl; cout << Add(1.1, 2.2) << endl; return 0; } /* 运行结果： 3 3.3 */ //6.C++引用 #include<iostream> using namespace std; int main() { int x = 0; int& num1 = x; int& num2 = x; cout << \\\"x：\\\" << x << endl; cout << \\\"num1：\\\" << num1 << endl; cout << \\\"num2：\\\" << num2 << endl; return 0; } /* 运行结果： x：0 num1：0 num2：0 */ //6.C++常引用权限问题 #include<iostream> using namespace std; //常引用权限问题： void func() { //取别名原则：对原引用变量，权限只能缩小，不能放大 //注意：临时变量具有常性，要用const+引用 const int x = 0;//常引用时，赋值是0先拷贝给临时变量，临时变量在赋值给x。因为常变量只能读，不能写 //int& tmp=x;该语句编译错误，因为x为常量,权限放大了 const int& tmp = x;//同一权限级 //int& num=0;该语句编译错误，因为0为常量 权限放大了 const int& num = 0; double y = 1.234; //int& num2=y;该语句编译错误，因为类型不同，引用要求类型相同，常值具有常性const const int& num2 = y; //正确，因为底层实现是y先赋值给一个临时变量，再让临时变量赋值给num2，临时变量有常性，所以引用 //必须加const---临时变量问题也解释了为什么nums2的地址和y的地址不一样，nums2存的应该是临时 //变量的地址 int f = y;//正确，因为f和y没有使用指针和引用，不会改变原值，所以不加const也可以 } //6.C++常引用使用场景 //1.做参数---代替指针使用---输出型参数、减少拷贝、提高效率 void Swap(int& x, int& y) { int temp = x; x = y; y = temp; } //2.做返回值---变量出了函数还在用，则使用引用做返回值---其实就是&必须有目标变量在才能用，否则目标变量没了，还用它的地址，不就是野指针了吗 int& count() { static int n = 0;//static只会初始化一次 n++; //int&相当于返回的n的别名，而不是开一个临时变量进行值拷贝 return n; } //9.C++关键字auto #include<iostream> using namespace std; int func() { return 0; } //错误使用： void func() { int a[] = { 1,2,3,4,5,6 }; auto b[] = { 1,2,3,4,5 };//编译错误，auto不能声明数组 return 0; } int main() { int x = 1; auto xx = x; auto xxx = 'x'; auto xxxx = func(); //auto xxxxx;编译错误，使用auto必须初始化 //typeid(x).name 输出x的类型名字 cout << typeid(xx).name() << endl;//int cout << typeid(xxx).name() << endl;//char cout << typeid(xxxx).name() << endl;//int return 0; } /* 运行结果： int char int */ //10.C++范围for循环 //普通for遍历 void func() { int a[] = { 1,2,3,4,5,6,7 }; for (int i = 0; i < sizeof(a) / sizeof(a[0]); ++i) { a[i] += 1; } for (int* j = a; j < a + sizeof(a) / sizeof(a[0]), ++j) { cout << *j << endl; } } //范围for遍历：自动获取array中的数据，赋值给e，自动判断结束 void func() { int a[] = { 1,2,3,4,5,6,7 }; int aa[] = { 2,4,6,8,10,12 }; //auto&与auto的在for遍历中的区别 //auto---相当于操作的是临时变量(拷贝的) for (auto e : a) e /= 2; for (auto e : a) cout << e << \\\" \\\";//还是打印的1 2 3 4 5 6 7---原因：把a的元素赋值给e相当于形参的改变不影响实参 //auto&---相当于操作的变量别名 for (auto& ee : aa) ee /= 2; for (auto& ee : aa) cout << ee << \\\" \\\";//打印1 2 3 4 5 6 return 0; } //11.C++指针空值nullptr //NULL底层是一个宏，值为0，头文件为：#include<stddef.h> #ifndef NULL #ifdef __cplusplus #define NULL 0 #else #define NULL ((void *)0) #endif #endif //NULL可能被定义为字面常量0，或者无类型指针(void*)的常量 //NULL和0的值一样就会引发问题--所以C++使用了nullptr \"]},\"349\":{\"h\":\"第十章：C++智能指针\"},\"350\":{\"h\":\"知识点思维导图\"},\"351\":{\"h\":\"复习代码\",\"t\":[\"// Author：jimbo（1353429820@qq.com） // Filename：main // Date：2024/1/23 // Description：review knowledge points // Copyrights（c）JimBo. All rights reserved //智能指针概念：用于对一个资源进行管理，避免因为疏忽或错误造成程序未能释放已经不再使用的内存的情况 //智能指针的设计： //1.在对象构造时获取资源，在对象析构时释放资源，利用对象的生命周期来控制资源，即RAII特性 //2.对*和->运算符进行重载，使得智能指针具有和指针一样的行为 //3.智能指针的拷贝问题：根据解决拷贝问题方式的不同，从而衍生出了不同版本的智能指针 //分类：auto_ptr、unique_ptr、shared_ptr、weak_ptr //0.它们的头文件是：#include<memory> //1.auto_ptr：通过管理权限转移的方式，保证一个资源在任何时候都只有一个对象在对其进行管理。C++11以前使用，C++11后被弃用。 //2.unique_ptr：通过防拷贝的方式，防止对智能指针对象进行拷贝 //3.shared_ptr：通过引用计数的方式，支持多个对象一起对同一个资源进行管理 //4.weak_ptr：通过不增加、不减少引用计数的方式，解决shared_ptr的循环引用问题 //auto_ptr、unique_ptr、shared_ptr、weak_ptr的使用 #include<iostream> #include<memory> //auto_ptr、unique_ptr、shared_ptr、weak_ptr头文件 int main() { //使用std::auto_ptr(C++11后弃用) std::auto_ptr<int> autoPtr(new int(42)); std::cout << \\\"autoPtr：\\\" << *autoPtr << std::endl; //输出42 //auto_ptr离开作用域后，释放内存 //使用std::unique_ptr std::unique_ptr<int> uniquePtr(new int(43)); std::cout << \\\"uniquePtr：\\\" << *uniquePtr << std::endl; //unique_ptr离开作用域后，释放内存 //使用std::shared_ptr std::shared_ptr<int> sharedPtr = std::make_shared<int>(44); //多个shared_ptr共享同一个对象 std::shared_ptr<int> anotherSharePtr = sharedPtr; std::cout << \\\"sharedPtr：\\\" << *sharedPtr << std::endl; std::cout << \\\"anotherSharedPtr：\\\" << *anotherSharePtr << std::endl; //当最后一个shared_ptr离开作用域后，释放内存 //使用std::weak_ptr std::shared_ptr<int> sharedPtr1 = std::make_shared<int>(45); std::weak_ptr<int> weakPtr = sharedPtr1; //使用weak_ptr时需要通过lock()转换shared_ptr if(auto shared = weakPtr.lock()) { std::cout << \\\"weakPtr：\\\" << *shared << std::endl; //输出45 } else { std::cout << \\\"The object is no longer available\\\" << std::endl; } //当最后一个shared_ptr离开作用域时，weak_ptr不影响内存释放 return 0; } //运行结果 //autoPtr：42 //uniquePtr：43 //sharedPtr：44 //anotherSharedPtr：44 //weakPtr：45 //2.boost中智能指针关系 //C++98中产生了第一个智能指针auto_ptr //C++boost给出了更实用的scoped_ptr、shared_ptr、weak_ptr //C++TR1引入boost中的shared_ptr等，不过注意的是TR1并不是标准版，而是一个技术报告 //C++11引入了boost中的unique_ptr、shared_ptr和weak_ptr，其中unique_ptr对应的就是boost中的scope_ptr \"]},\"352\":{\"h\":\"第十一章：C++特殊类设计\"},\"353\":{\"h\":\"知识点思维导图\"},\"354\":{\"h\":\"复习代码\",\"t\":[\"// Author：jimbo（1353429820@qq.com） // Filename：main // Date：2024/1/24 // Description：review knowledge points // Copyrights（c）JimBo. All rights reserved //特殊类设计 //1.只能在堆上创建对象 //2.只能在栈上创建对象 //3.不能被拷贝 //4.不能被继承 //5.只能创建一个对象(单例模式) //1.只能在堆上创建对象 //实现说明： //①向外部提供的CreateObj函数必须设置为静态成员函数，因为外部调用该接口就是为了获取对象的，而非静态成员函数必须通过对象才能调用 //②C++98通过将拷贝构造函数声明为私有以达到防拷贝的目的，C++11可以在拷贝构造函数后面加上=delete，表示让编译器将拷贝构造函数删除，此时也能达到防拷贝的目的 #include<iostream> class HeapOnlyClass { public: //步骤二：提供一个获取对象的接口，并将该接口设置为静态成员函数 static HeapOnlyClass* CreateObj() { return new HeapOnlyClass; } private: //步骤一：将构造函数设置为私有 HeapOnlyClass(){} //步骤三：防止外部调用拷贝函数在栈上创建对象 //C++98：将拷贝构造函数设置为私有，并且只声明不实现 //HeapOnlyClass(const HeapOnlyClass&); //C++11：在拷贝构造函数后面加上=delete HeapOnlyClass(const HeapOnlyClass&) = delete; }; //2.只能在栈上创建对象 //方法一：将构造函数设置为私有，防止外部直接调用构造函数在堆上创建对象。向外提供一个获取对象的static接口，该接口在栈上创建一个对象返回 //缺陷：无法防止外部调用拷贝构造函数创建对象，但是又不能将构造函数设置为私有，也不能用=delete方式将拷贝构造函数删除，因为CreateObj函数 //当中创建的是局部对象，返回局部对象的过程势必需要调用拷贝构造函数 //方法二：屏蔽operator new函数和operator delete函数 //缺陷：无法防止外部在静态区创建对象，比如：static OnlyStackClass obj;//在静态区创建对象 //方法一 #include<iostream> class OnlyStackClass { public: //步骤二：提供一个获取对象的接口，并且该接口必须设置为静态成员函数 static OnlyStackClass CreateObj() { return OnlyStackClass(); } private: //步骤一：将构造函数设置为私有 OnlyStackClass(){} }; //方法二 #include<iostream> class OnlyStackClass2 { public: OnlyStackClass2(){} private: //C++98 void* operator new(size_t size); void operator delete(void* ptr); //C++11 //void* operator new(size_t size) = delete; //void operator delete(void* ptr) = delete; }; //3.不能被拷贝 #include<iostream> class BanCopyClass { public: BanCopyClass(){} private: //C++98 BanCopyClass(const BanCopyClass&); BanCopyClass& operator=(const BanCopyClass); //C++11 //BanCopyClass(const BanCopyClass&) = delete; //BanCopyClass& operator=(const BanCopyClass&) = delete; }; //4.不能被继承 #include<iostream> class BanInheritClass { //C++98，不够彻底，这个类仍可被继承，只是被继承后无法实例化出对象 //C++11则是在类外增加关键字final，比如：class BanInheritClass final{...}; public: static BanInheritClass CreateObj() { return BanInheritClass(); } private: //将构造函数设置为私有 BanInheritClass(){} }; //5.只能创建一个对象(单例模式) //单例模式是一种设计模式，指的是一个类只能创建一个对象，该模式保证系统中该类只有一个实例，并提供一个全局访问点，该实例被所有程序模块共享 //单例模式实现方式：饿汉模式、懒汉模式 //饿汉模式实现方法： //1.将构造函数设置为私有，并将拷贝构造函数和赋值运算符重载设置为私有或删除，防止外部创建或拷贝对象 //2.提供一个指向单例对象的static指针，并在程序入口之前完成单例对象的初始化 //3.提供一个全局访问点获取单例对象 //饿汉模式的线程安全问题 //饿汉模式在程序运行主程序之前就完成了单例对象的创建，由于main函数之前是不存在多线程的，因此饿汉模式下单例对象的创建是线程安全的 //后续所有多线程要访问这个单例对象，都需要通过调用GetInstance函数来获取，这个获取是不需要加锁的，因为这是一个读操作 //当然，如果线程通过GetInstance获取到单例对象后，要用这个单例对象进行一些线程不安全的操作，那么这时就需要加锁了 #include<iostream> class Singleton { public: //3.提供一个全局访问点获取单例对象 static Singleton* GetInstance() { return singlePtr; } private: //1.将构造函数设置为私有 Singleton(){} Singleton(const Singleton&) = delete; Singleton& operator=(const Singleton&) = delete; //2.提供一个指向单例对象的static指针 static Singleton* singlePtr; }; //在程序入口之前完成单例对象的初始化 Singleton* Singleton::singlePtr = new Singleton; //懒汉模式实现方法： //1.将构造函数设置为私有，并将拷贝构造函数和赋值运算符重载函数设置为私有或删除，防止外部创建或拷贝对象 //2.提供一个指向单例对象的static指针，并在程序入口之前现将其初始化为空 //3.提供一个全局访问点获取单例对象 #include<iostream> #include<mutex> class Singleton { public: //3.提供一个全局访问点获取单例对象 static Singleton* GetInstance() { //双检查 if(singlePtr == nullptr) { mtx.lock(); if(singlePtr == nullptr) { singlePtr = new Singleton; } mtx.unlock(); } return singlePtr; } private: //1.将构造函数设置为私有，并防拷贝 Singleton(){} Singleton(const Singleton&) = delete; Singleton& operator=(const Singleton&) = delete; //2.提供一个指向单例对象的static指针 static Singleton* singlePtr; static std::mutex mtx;//互斥锁 }; //在程序入口前先将static指针初始化为空 Singleton* Singleton::singlePtr = nullptr; std::mutex Singleton::mtx; //初始化互斥锁 //懒汉模式实现方法： //1.将构造函数设置为私有，并将拷贝构造函数和赋值运算符重载函数设置为私有或删除，防止外部创建或拷贝对象 //2.提供一个指向单例对象的static指针，并在程序入口之前现将其初始化为空 //3.提供一个全局访问点获取单例对象 //懒汉模式线程安全问题： //懒汉模式在程序运行之前没有进行单例对象的创建，而是等到某个线程需要使用这个单例对象时再进行创建，也就是GetInstance函数第一次被调用的时创建单例对象 //因此在调用GetInstance函数获取单例对象时，先判断这个static指针是否为空，如果为空则说明这个单例对象还没有被创建，此时需要先创建这个单例对象然后再将单例对象返回 //GetInstance函数第一次调用需要对static指针进行写入操作，这个过程不是线程安全的，因为多个线程可能同时调用GetInstance函数，如果不对这个过程进行保护，此时多个线程就会各自创建处一个对象 //双检查加锁： //对GetInstance函数中创建单例对象的过程进行保护，本质就是需要引入互斥锁，最简单的加锁方式就是在进行if判断之前加锁，在整个if语句之后进行解锁 //但实际只有GetInstance函数第一次被调用，创建单例对象时需要使用互斥锁进行保护，而后续调用GetInstance函数获取单例对象只是一个读操作，是不需要使用互斥锁进行保护的 //如果简单的将加锁解锁操作放到if语句前后，那么在后续调用GetInstance函数获取已经创建好的单例对象时，就会进行大量无意义的加锁解锁操作，导致线程不断切入切出，进而影响程序运行效率 //对于这种只有第一次需要加锁保护的场景可以使用双检查加锁，双检查就是在当前加锁和解锁的外面再进行一次if判断，判断static指针是否为空 //这样一来，后续调用GetInstance函数获取已经创建好的单例对象时，外层新加的if判断就会起作用，这样就避免了后续无意义的加锁解锁操作 #include<iostream> #include<mutex> class Singleton { public: //3.提供一个全局访问点获取单例对象 static Singleton* GetInstance() { //双检查 if(singlePtr == nullptr) { mtx.lock(); if(singlePtr == nullptr) { singlePtr = new Singleton; } mtx.unlock(); } return singlePtr; } private: //1.将构造函数设置为私有，并防拷贝 Singleton(){} Singleton(const Singleton&) = delete; Singleton& operator=(const Singleton&) = delete; //2.提供一个指向单例对象的static指针 static Singleton* singlePtr; static std::mutex mtx;//互斥锁 }; //在程序入口前先将static指针初始化为空 Singleton* Singleton::singlePtr = nullptr; std::mutex Singleton::mtx; //初始化互斥锁 //其他版本的懒汉模式实现方式 //1.将构造函数设置为私有，并将拷贝构造函数和赋值运算符重载函数设置为私有或删除，防止外部创建或拷贝对象 //2.提供一个全局访问点获取单例对象 //这种版本的懒汉主要有如下两个缺点： //单例对象定义在静态区，因此太大的单例对象不适合使用这种方式 //单例对象创建在静态区后没办法主动释放 //如果要考虑单例对象的释放，可以参考以下两种方式： //1.在单例类中编写一个DelInstance函数，在该函数中进行单例对象的释放动作，当不再需要该单例对象时就可以主动调用DelInstance释放单例对象 //2.在单例类中实现一个内嵌的垃圾回收类，在垃圾回收类的析构函数中完成单例对象的释放。在单例类中定义一个静态的垃圾回收类对象，当该对象被消耗时就会调用其析构函数，这时便对单例对象进行了释放 #include<iostream> class Singleton { public: //2.提供一个全局访问点获取单例对象 static Singleton* GetInstance() { static Singleton singlePtr; return &singlePtr; } private: //1.将构造函数设置为私有，并防止拷贝 Singleton(){} Singleton(const Singleton&) = delete; Singleton& operator=(const Singleton&) = delete; }; //单例对象释放：方法一 static void DelInstance() { _mtx.lock(); if (_inst != nullptr) { delete _inst; _inst = nullptr; } _mtx.unlock(); } //单例对象释放：方法二(垃圾回收类) class CGarbo { public: ~CGarbo() { if (_inst != nullptr) { delete _inst; _inst = nullptr; } } }; \"]},\"355\":{\"h\":\"第十二章：C++类型转换\"},\"356\":{\"h\":\"知识点思维导图\"},\"357\":{\"h\":\"复习代码\",\"t\":[\"// Author：JimBo (1353429820@qq.com) // Filename：main.cpp // Date：2024/1/2 // Description：review knowledge points // Copyrights（c）JimBo. All rights reserved //1.C语言中的类型转换 //隐式类型转换、显式类型转换 #include<stdio.h> int main() { //隐式类型转换：同类型，较低转较高层次 int a = 5; float b = 2.5; float result = a + b;//int隐式转换为float，有效数字7位 printf(\\\"result = %lf\\\\n\\\", result); //运行结果：result = 7.500000 //显示类型转换：同类型，较高转较低层次 double x = 5.67; int y = (int)x;//double类型强转为int类型，丢失精度 printf(\\\"y = %d\\\\n\\\", y); //运行结果：y = 5 return 0; } //2.C++类型转换 //static_cast：静态转换，用于相近类型转换 //reinterpret_cast：重新解释转换，用于指针或引用之间的转换 //const_cast：常量转换，用于指针或引用去除const性质 //dynamic_cast：动态转换，用于基类和派生类的转换 //explicit：禁止单参数构造函数隐式转换 #include<iostream> int main() { //static_cast：用于相近类型转换 double x = 3.14; int y = static_cast<int>(x);//double转变为int类型 //reinterpret_cast：用于指针或引用之间的转换 int* ptr = new int; char* charPtr = reinterpret_cast<char*>(ptr);//将int指针转换为char指针 //const_cast：用于添加或移除变量的const性质 const int a = 5; //错误的使用方式：int b = const_cast<int>(a);//因为const_cast主要用于指针或引用去除const const int* constPtr = &a; int* nonConstPtr = const_cast<int*>(constPtr);//去除constPtr的const属性 //dynamic_cast：用于基类和派生类的转换 class Bsae { virtual void foo(){} }; class Derived : public Base {}; Base* basePtr = new Derived; Derived* derivedPtr = dynamic_cast<Derived*>(basePtr);//基类Base转换为派生类Derived return 0; } //explicit的使用 #include<iostream> class MyClass { public: explicit MyClass(int x) : data(x) { //构造函数禁止隐式转换 } int getData() const { return data; } private: int data; }; int main() { MyClass obj1 = 42;//错误，因为构造函数被标记为explicit，禁止隐式转换 //说明：因为MyClass构造函数接受一个int类型的参数，所以42可以隐式的传递给MyClass的构造函数进行对象的构造 MyClass obj2(42);//正确，使用构造函数显示创建对象 MyClass obj3 = MyClass(42);//正确，先调用构造函数创建对象，再调用拷贝构造拷贝值给obj3 return 0; } //3.RTT1机制：运行时类型识别 //①typeid：运行时识别对象类型 //②dynamic_cast：运行时识别父类的指针或引用，用于安全的向下转型(向上转型本来就安全) //③decltype：运行时推演一个表达式或函数返回值类型 //typeid的使用 #include<iostream> class MyBaseClass { //... }; class MyDerivedClass : public MyBaseClass { //... }; int main() { MyBaseClass* ptr = new MyDerivedClass(); if(typeid(*ptr) == typeid(MyDerivedClass)) { std::cout << \\\"ptr指向的对象是MyDerivedClass类型\\\" << std::endl; } //没有结果，ptr指向对象不是MyDerivedClass类型 delete ptr; return 0; } //dynamic_cast的使用 #include<iostream> class MyBaseClass { virtual void foo(){}; }; class MyDervivedClass : public MyBaseClass { //... }; int main() { MyBaseClass* ptr = new MyDervivedClass(); MyDervivedClass* dervivedPtr = dynamic_cast<MyDervivedClass*>(ptr); if(dervivedPtr) { std::cout << \\\"转型成功\\\" << std::endl; } else { std::cout << \\\"转型失败\\\" << std::endl; } return 0; } //decltype的使用：decltype(expression) variableName; //decltype用于推演类型，主要用于模板和泛型编程中 #include<iostream> int main() { int x = 5; const double& y = 3.14; decltype(x) a = 10;//a的类型为int decltype(y) b =4.56;//b的类型为const double& return 0; } \"]},\"358\":{\"h\":\"第十三章：C++STL库\"},\"359\":{\"h\":\"第二章：C++类和对象\"},\"360\":{\"h\":\"知识点思维导图\"},\"361\":{\"h\":\"复习代码\",\"t\":[\"// Author：JimBo (1353429820@qq.com) // Filename：main // Date：2024/1/15 // Description：review knowledge points // Copyrights（c）JimBo. All rights reserved //3.类的引入：struct升级为类 #include<iostream> using namespace std; //在C语言中struct是结构体不能在struct里定义函数。在C++中struct被升级为了类(class)，可以在struct中定义函数 struct Student { //成员变量定义习惯在前面加m_ char m_name1[20]; char m_gender1[3]; int m_age1; //设置学生基本信息 void Set_StudentInfo(const char* name, const char* gender, int age) { strcpy(m_name1, name); strcpy(m_gender1, gender); m_age1 = age; } //打印学生信息 void Print_StudentInfo() { cout << m_name1 << \\\" \\\" << m_gender1 << \\\" \\\" << m_age1 << endl; } }; int main() { Student s; s.Set_StudentInfo(\\\"小张\\\", \\\"男\\\", 18); s.Print_StudentInfo(); return 0; } /* 运行结果： 小张 男 18 */ //3.类的定义 #include<iostream> using namespace std; //同时声明和定义类的方法 class Dog { public: //成员函数 void ShowInfo() { cout << \\\"姓名：\\\" << m_name << endl; cout << \\\"性别：\\\" << m_name << endl; cout << \\\"年龄：\\\" << m_name << endl; } public: //成员变量 //声明和定义的区分：不开空间是声明，开空间是定义 //所以下面的成员变量是声明，创建对象时才定义 char* m_name;//姓名 char* m_sex;//性别 int m_age;//年龄 }; //分开声明和定义类的方法：ShowInfo方法声明放.h里，实现放在.cpp里 //8.类的大小问题 #include<iostream> using namespace std; //类中既有成员变量，又有成员函数 class A1 { public: //成员函数放在公共代码段，不在类中 void f1(){} private: //成员变量放在类中，符合C语言内存对齐规则 //对齐数：默认对齐数和成员自身大小的较小值 //最大对齐数：成员中对齐数最大的 //结构体/类大小：最大对齐数的整数倍 int _a; //对齐数4 char _aa;//对齐数1 //成员总大小是5，则类大小为最大对齐数4的倍数，即8 }; //类中仅有成员函数 class A2 { public: void f2() {} //没有成员变量的类对象，编译会给他们分配1byte占位，表示对象存在过 }; //类中什么都没有---空类 class A3{}; //没有成员变量的类对象，编译会给他们分配1byte占位，表示对象存在过 int main() { //计算类的长度，符合C语言内存对齐规则 cout << \\\"sizeof(A1)：\\\" << sizeof(A1) << endl;//8 cout << \\\"sizeof(A2)：\\\" << sizeof(A2) << endl;//1 cout << \\\"sizeof(A3)：\\\" << sizeof(A3) << endl;//1 } /* 运行结果： sizeof(A1)：8 sizeof(A2)：1 sizeof(A3)：1 */ //9.探究this指针 #include<iostream> using namespace std; //定义一个日期类Date class Date { public: void Display() { cout << _year << \\\"-\\\" << _month << \\\"-\\\" << _day << endl; } void SetDate(int year, int month, int day) { _year = year; _month = month; _day = day; } private: int _year; // 年 int _month; // 月 int _day; // 日 }; int main() { Date s1, s2; s1.SetDate(2024, 1, 1); s2.SetDate(2024, 2, 1); s1.Display(); s2.Display(); return 0; } /* Date类中有SetDate与Display两个成员函数，他们是存在公共代码段的，函数体中没有关于不同对象的区分，那当s1调用SetDate函数时， 该函数是如何知道应该设置s1对象，而不是设置s2对象呢？ 实现方法：void Dispaly()会被编译器默认处理成void Display(Date* this) 严格来说是Date* const this(const修饰this) 如下代码： //隐藏this指针的原函数 void Display() { cout <<_year<< \\\"-\\\" <<_month << \\\"-\\\"<< _day <<endl; } //显示this指针的原函数 void Display(Date* const this) { //Date* const this谁调用就访问谁的成员 cout <<this->_year<< \\\"-\\\" <<this->_month << \\\"-\\\"<<this->_day <<endl; } */ //10.构造函数 class Date { public: //0.不写构造函数，编译器自动生成一个构造函数 Date() {}//自动生成 // 1.无参构造函数 Date() {} // 2.带参构造函数 Date(int year, int month, int day) { _year = year; _month = month; _day = day; } private: int _year; int _month; int _day; //以下代码为C++11补丁，针对编译器自己生成默认成员函数不初始化问题 //给的缺省值，给编译器自己生成的默认构造函数使用 //int _year=0; //int _month=0; //int _day=0; }; void TestDate() { // 注意：如果通过无参构造函数创建对象时，对象后面不用跟括号，否则就成了函数声明 Date d1;// 调用无参构造函数 Date d2(2015, 1, 1);// 调用带参的构造函数 Date d3();//声明了d3函数，该函数无参，返回一个日期类型的对象 } //10.析构函数 typedef int DataType; class SeqList { public: SeqList(int capacity = 10)//全缺省构造函数---初始化类的成员变量 { _Data = (DataType*)malloc(capacity * sizeof(DataType)); assert(_Data); _size = 0; _capacity = capacity; } //只有类需要管理空间才自己写析构函数 ~SeqList()//析构函数---销毁类的成员 { if (_Data) { free(_Data); // 释放堆上的空间 _pData = NULL; // 将指针置为空 _capacity = 0; _size = 0; } } private: int* _Data; size_t _size; size_t _capacity; }; //10.拷贝构造函数优化问题：类对象初始化、作函数参数、作返回值就调用拷贝构造函数 //没有优化的编译器 class Weight { public: Weight() { cout << \\\"Weight()\\\" << endl; } weight(const Weight& w) { cout << \\\"Weight(const Weight& w)\\\" << endl; } void f() {} }; Weight func1(Weight u)//调用函数传参时会拷贝构造一次---函数参数以对象传递 { Weight v(u);//Weight v(u)和Weight v=u 等价 拷贝构造一次---对象初始化 Weight w = v;//拷贝构造一次---对象初始化 return w;//拷贝构造一---函数返回值以对象返回 先拷贝构造一个临时变量，再拷贝给赋的值 } //func1调用4次拷贝构造 Weight func2(Weight& u)//这里用的是别名，不会调用拷贝构造 { Weight v(u);//拷贝构造一次 Weight w = v;//拷贝构造一次 return w;//拷贝构造一次 } //func2调用3次拷贝构造 Weight& func3(Weight& u)//这里用的别名，不拷贝构造 { Weight v(u);//拷贝构造一次 直接构造 Weight w = v;//拷贝构造一次 隐式类型转换 return w;//返回值用的别名，不拷贝构造 } //func3调用2次拷贝构造 //优化的编译器 //例题:这个函数调用了几次拷贝构造函数? 答案：7次 //一个表达式中，连续步骤的构造+拷贝构造或者拷贝构造+拷贝构造，编译器可能优化，合二为一 Weight f(Weight u)//1 省略一次 { Weight v(u);//2 5 Weight w = v;//3 6 return w;//4 7 } int main() { Weight x; Weight y = f(f(x)); } /* 说明： 第一次调用f(x)，4次 第二次调用f(f(x))，省略第一次参数时x给u的拷贝构造，其他相同，一共4+3=7次 */ //10.拷贝构造函数特性 class Date { public: Date(int year = 2022, int month = 5, int day = 1)//全缺省构造函数 { _year = year; _month = month; _day = day; } Date(const Date& d)//拷贝构造函数 { _year = d._year; _month = d._month; _day = d._day; } private: int _year; int _month; int _day; }; int main() { Date d1; //调用默认构造---全缺省、不写自动生成、无参构造 Date d2(d1);//调用拷贝构造 return 0; } class Date { public: Date(int year = 2022, int month = 5, int day = 1)//全缺省构造函数 { _year = year; _month = month; _day = day; } //生成默认拷贝构造函数 //Date(const Date& d){} private: int _year; int _month; int _day; }; int main() { Date d1;//调用默认构造函数，使用全缺省构造函数 //这里d2调用的默认拷贝构造完成拷贝，d2和d1的值也是一样的。 Date d2(d1); return 0; } //10.const引发的浅拷贝崩溃问题---需要深拷贝解决问题 class String { public: //浅拷贝构造函数 String(const char* str = \\\"jack\\\") { _str = (char*)malloc(strlen(str) + 1); strcpy(_str, str); } // 深拷贝构造函数 String(const String& other) { _str = (char*)malloc(strlen(other._str) + 1); strcpy(_str, other._str); } ~String() { cout << \\\"~String()\\\" << endl; free(_str); } private: char* _str; }; int main() { String s1(\\\"hello\\\");//调用浅拷贝 String s2(s1);//调用深拷贝，浅拷贝程序会崩掉 需要深拷贝才能解决问题 //解析： //浅拷贝是直接将内容复制过去，所以s1和s2的_str的地址是一样的 //s1和s2的_str指向同一块空间，从而导致资源释放时，_str被释放两次，从而导致野指针问题崩溃 //解决方案：自己实现拷贝构造，即深拷贝 } //10.全局和局部运算符重载 // 全局的operator== class Date { public: Date(int year = 2022, int month = 5, int day = 1) { _year = year; _month = month; _day = day; } bool operator==(const Date& d)//局部operator { return _year == d.year && _month == d.month && _day == d.day; } //private: int _year; int _month; int _day; }; // 这里会发现运算符重载成全局的就需要成员变量是共有的，那么问题来了，封装性如何保证？ // 这里其实可以用我们后面学习的友元解决，或者干脆重载成成员函数 bool operator==(const Date& d1, const Date& d2)//操作符重载的声明和定义，全局operator { return d1._year == d2._year && d1._month == d2._month && d1._day == d2._day; } //这里编译不通过，因为上面的成员是私有的 //处理方法3种：成员改为共有、提供函数获取内容、友元函数(常用) //运算符重载格式： //1. if (operator==(d1, d2))//定义的：类外的operator，全局operator { cout << \\\"==\\\" << endl; } //2. if (d1.operator==(d2))//定义的：类里面的operator，成员operator { cout << \\\"==\\\" << endl; } //3. if (d1 == d2)//编译器会处理成对应重载运算符调用if(operator==(d1,d2)){}或if(d1.operator(d2)){} { cout << \\\"==\\\" << endl; } void Test() { Date d1(2022, 5, 1); Date d2(2022, 6, 1); cout << (d1 == d2) << endl; } //10.运算符重载默认形参this class Date { public: Date(int year = 2022, int month = 5, int day = 1) { _year = year; _month = month; _day = day; } // bool operator==(Date* this, const Date& d2) // 这里需要注意的是，左操作数是this指向的调用函数的对象 bool operator==(const Date& d2)//操作符重载 隐含Date* this指针 { return _year == d2._year; && _month == d2._month; && _day == d2._day; } private: int _year; int _month; int _day; }; void Test() { Date d1(2022, 5, 1); Date d2(2022, 6, 1); cout << (d1 == d2) << endl;//d1==d2 ->d1.operator==(const Date& d2); } //10.赋值运算符重载特性 class Date { public: Date(int year = 2022, int month = 5, int day = 1)//构造函数 { _year = year; _month = month; _day = day; } //赋值重载 Date& operator=(const Date& d)//返回Date类的引用 { if (this != &d)//判断是否自己赋值自己 { _year = d._year; _month = d._month; _day = d._day; } return *this; } private: int _year; int _month; int _day; }; void Test() { Date d1(2022, 5, 1); Date d2(2022, 10, 1); Date d3(d1);//拷贝构造---一个存在的对象去初始化另一个要创建的对象 d2 = d1;//赋值重载/复制拷贝---两个已经存在的对象之间赋值 d1(d2);//赋值重载---两个已经存在的对象赋值 } //10.普通对象取地址和const对象取地址 class Date { public: Date* operator&()//普通对象取地址 { return this; } const Date* operator&()const//const取地址 { return this; } private: int _year; // 年 int _month; // 月 int _day; // 日 }; void func(Date& d) { cout << &d << endl; } void func2(const Date& d1) { cout << &d1 << endl; } //C++默认构造函数的练习：日期类的实现 //日期类文件名：Date.h #pragma once #include <iostream> #include <assert.h> using std::cin; using std::cout; using std::endl; class Date { public: bool isLeapYear(int year)//是闰年 4年一润且百年不润，或400年一润 { return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0); } int GetMonthDay(int year, int month); // 默认生成的析构函数，内置类型成员不做处理，自定义类型成员会去调用它的析构函数 Date(int year = 1, int month = 1, int day = 1); //Date(const Date& d) //{ // _year = d._year; // _month = d._month; // _day = d._day; //} //Date& operator=(const Date& d) //{ // if (this != &d) // { // _year = d._year; // _month = d._month; // _day = d._day; // } // return *this; //} void Print() const { cout << _year << \\\"-\\\" << _month << \\\"-\\\" << _day << endl; } Date operator+(int day) const; Date& operator+=(int day); Date operator-(int day) const; Date& operator-=(int day); //代码短的用inline // ++d1 Date& operator++() // 前置 { *this += 1; return *this; } // d1++ Date operator++(int) // 后置 这里的int传的值大小无关，只是用于区分，一般写0或1 { Date tmp(*this);//拷贝一份当前值 *this += 1; return tmp; } Date& operator--() // 前置 { *this -= 1; return *this; } Date operator--(int) // 后置 { Date tmp(*this); *this -= 1; return tmp; } // d1 - d2 int operator-(const Date& d) const; bool operator==(const Date& d) const; bool operator<(const Date& d) const; // inline不支持声明和定义分别放到.h 和.cpp // 所以成员函数中要成为inline最好直接在类里面定义 // 类里面定义默认就是inline bool operator>(const Date& d) const { return !(*this <= d); } bool operator>=(const Date& d) const { return !(*this < d); } bool operator!=(const Date& d) const { return !(*this == d); } // d1 <= d2 bool operator<=(const Date& d) const { return *this < d || *this == d; } private: int _year; int _month; int _day; }; //文件名：Date.cpp //Date.cpp #include \\\"Date.h\\\" bool Date::operator<(const Date& d)const { if ((_year < d._year) || (_year == d._year && _month < d._month) || (_year == d._year && _month == d._month && _day < d._day)) { return true; } else { return false; } } // d1 == d2 bool Date::operator==(const Date& d)const { return _year == d._year && _month == d._month && _day == d._day; } int Date::GetMonthDay(int year, int month) { assert(year >= 0 && month > 0 && month < 13); const static int monthDayArray[13] = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; if (month == 2 && isLeapYear(year)) { return 29; } else { return monthDayArray[month]; } } Date::Date(int year, int month, int day) { if (year >= 1 && month <= 12 && month >= 1 && day >= 1 && day <= GetMonthDay(year, month)) { _year = year; _month = month; _day = day; } else { cout << \\\"日期错误\\\" << endl; } } // d1 + 100 -->d1.operator+(day); // d1 += 100 Date& Date::operator+=(int day) { *this = *this + day; return *this; } Date Date::operator+(int day) { Date ret(*this); ret._day += day; while (ret._day > GetMonthDay(ret._year, ret._month)) { ret._day -= GetMonthDay(ret._year, ret._month); ret._month++; if (ret._month == 13) { ++ret._year; ret._month = 1; } } return ret; } Date Date::operator+(int day)const { Date ret(*this); ret += day; return ret; } // d1 += 100 Date& Date::operator+=(int day) { if (day < 0) return *this -= -day; _day += day; while (_day > GetMonthDay(_year, _month)) { _day -= GetMonthDay(_year, _month); _month++; if (_month == 13) { ++_year; _month = 1; } } return *this; } Date Date::operator-(int day)const { Date ret = *this; ret -= day; return ret; } // d1 -= 100 Date& Date::operator-=(int day) { if (day < 0) return *this += -day; _day -= day; while (_day <= 0) { --_month; if (_month == 0) { _month = 12; --_year; } _day += GetMonthDay(_year, _month); } return *this; } // d1 - d2 --> d1.operator-(const Date& d) const //最简日期类相减运算 int Date::operator-(const Date& d)const { int flag = 1;//设置标识：1为正数，-1为负数 Date max = *this; Date min = d; if (*this < d) { min = *this; max = d; flag = -1; } int n = 0;//天数标识 //最大值和最小值不相等则让天数+1，用n标记数，最终由n*flag确定相差的天数 while (min != max) { ++n; ++min; } return n * flag; } //11.初始化列表 int data = 20; class Date { public: Date(int year, int month, int day)//列表初始化 : _year(year) , _month(month) , _day(day) {} Date(int year, int month, int day，int n, int data)//列表初始化 : _year(year) , _month(month) , _day(day) , _n(n) , _data(data) {} //以下代码会报错：Date::n和Date::data必须初始化引用类型的成员，因为对象赋值不能让成员初始化，没有给_n和_data开空间 /* Date(int year,int month,int day,int n,int data) { _year=year; _month=month; _day=day; _n=n; _data=data; }*/ private: //这些成员不需要考虑，它们可以在定义的时候初始化也可以定义后赋值修改 int _year;//声明_yaer int _month;//声明_month int _day;//声明_day //这些成员(引用、const、没有默认构造函数)只能在定义的时候初始化 const int _n; int& _data; }; int main() { Date d1(2022, 5, 1);//对象定义 对象整体定义调用构造函数，而初始化列表就是对象成员的定义 date d2; return 0; } //11.初始化列表特性 class B { public: B(int a, int b) :_x(a)//先列表初始化_x，再_y，再_z , _z(10) , _y(b) {} private: A _x; //自定义类型成员变量---没有默认构造函数 int& _y; //引用成员变量---由于B类中初始化列表初始化了_y const int _z; //const成员变量 }; class A { public: A(int a) :_a1(a)//_a2初始化完，走_a1初始化，因为a=1，则_a1 , _a2(_a1)//先走_a2的列表初始化，因为_a1还没初始化则_a2为随机值，值为随机值 {} void Print() { cout << _a1 << \\\" \\\" << _a2 << endl; } private: int _a2;//_a2先声明，则先执行_a2的初始化 int _a1;//_a2初始化完，然后_a1声明，_a1初始化 } int main() { A aa(1); aa.Print();//输出 1 随机值 } //12.explicit关键字 class A { public: A(int a)// 单参数的构造函数 : _a(a) { cout << \\\"A(int a)\\\" << endl; } private: int _a; }; int main() { // 实例化新对象的两种写法： // 调用构造函数，实例化新对象a1 A a1(10); // 下面本质上是一个隐式类型转换 --> 用一个int类型变量给A类型对象赋值 // 实际上编译器，会先用20作为参数构造一个临时对象，再用临时对象拷贝构造新对象a2 // 最终编译器进行了优化(变成第一种形式)，直接用20作为参数构造新对象a2，把临时对象当成a2来用了，没有调用拷贝构造 A a2 = 20; return 0; } //14.友元类与友元函数 class Date { //友元函数哪里声明都可以，推荐类开始，在类外实现 friend ostream& operator<<(ostream& _cout, const Date& d);//友元函数---可以访问私有、保护成员 friend istream& operator>>(istream& _cin, Date& d);//友元函数 public: private: int _year; int _month; int _day; }; ostream& operator<<(ostream& _cout, const Date& d) { _cout << d._year << \\\"-\\\" << d._month << \\\"-\\\" << d._day; return _cout; } istream& operator>>(istream& _cin, Date& d) { _cin >> d._year; _cin >> d._month; _cin >> d._day; return _cin; } int main() { Date d;//调用默认构造 cin >> d;//调用运算符重载 cout << d << endl;//调用运算符重载 return 0; } //15.内部类 class A { private: static int k; int h; public: //B天生是A的友元，A不是B的友元 class B { public: void foo(const A& a) { cout << k << endl;//内部类可以直接使用外部类的static成员、枚举成员 cout << a.h << endl;//内部类可以使用外部类对象成员 } }; }; int A::k = 1; int main() { A::B b; b.foo(A()); return 0; } \"]},\"362\":{\"h\":\"第三章：C++内存管理\"},\"363\":{\"h\":\"知识点思维导图\"},\"364\":{\"h\":\"复习代码\",\"t\":[\"// Author：JimBo (1353429820@qq.com) // Filename：main // Date：2024/1/16 // Description：review knowledge points // Copyrights（c）JimBo. All rights reserved //1.new与delete用法 #include<iostream> #include<string> using namespace std; int main() { //动态申请释放一个空间 int* ptr = new int; delete ptr; //动态申请释放多个某类型空间 int* ptr2 = new int[10];//创建10个 delete[] ptr2; //动态申请释放一个某类型空间并初始化 int* ptr3 = new int(1);//初始化为1 delete ptr3; //动态申请释放多个某类型空间并初始化 int* ptr4 = new int[10]{1,2,3,4,5,6,7,8,9,10}; delete[] ptr4; //动态申请释放一个类的空间 string* ptr5 = new string; delete ptr5; //动态申请多个类的空间 string* ptr6 = new string[10]; delete[] ptr6; return 0; } //2.定位new表达式 //定位new表达式是C++中的一种特殊形式的new表达式，它允许在已分配的内存块中构造对象 //形式：new(place_address)type //比如：new(buffer)Myclass(1)，给预先分配内存块的buffer中构造Myclass对象类型，(1)是传给Myclass构造函数的参数 #include<iostream> using namespace std; class MyClass { public: MyClass(int val) : value(val) { std::cout << \\\"使用值调用的构造函数: \\\" << value << std::endl; } ~MyClass() { std::cout << \\\"使用值调用的析构函数: \\\" << value << std::endl; } private: int value; }; int main() { //分配内存块 char buffer[sizeof(MyClass) * 5]; // 为5个MyClass对象分配足够的空间 //使用定位new在已分配的内存块中构造对象 //new(buffer)Myclass(1)，给预先分配内存块的buffer中构造Myclass对象类型 //(1)是传给Myclass构造函数的参数 MyClass* myObjects = new (buffer) MyClass(1); myObjects++; // 移动指针到下一个位置 new (myObjects) MyClass(2); // 使用完对象后手动调用析构函数 myObjects->~MyClass(); myObjects--; myObjects->~MyClass(); return 0; } /* 使用值调用的构造函数: 1 使用值调用的构造函数: 2 使用值调用的析构函数: 2 使用值调用的析构函数: 1 */ \"]},\"365\":{\"h\":\"第四章：C++模板\"},\"366\":{\"h\":\"知识点思维导图\"},\"367\":{\"h\":\"复习代码\",\"t\":[\"// Author：JimBo (1353429820@qq.com) // Filename：main // Date：2024/1/17 // Description：review knowledge points // Copyrights（c）JimBo. All rights reserved //1.函数模板定义：template<class>、template<typename> //早期使用：template<class>，因为早期class是唯一的关键字 //现在使用：template<typename> #include<iostream> //add函数时一个模板，使用typename T来表示参数类型的占位符 //当调用add函数时，编译器会根据传入的实际类型自动生成相应的函数 template<typename T> T add(T a, T b) { return a+b; } int main() { //使用函数模板 int result_int = add(5,10); double result_double = add (3.5, 2.7); std::cout << result_int <<std::endl; std::cout << result_double <<std::endl; return 0; } /* 运行结果： 15 6.2 */ //2.函数模板实例化：显式实例化、隐式实例化 //显式实例化：在模板后用<类型>来指定类型 //隐式实例化：根据传入的参数自动实例化 #include<iostream> template<typename T> void function(T param) { std::cout << \\\"param：\\\" << param << std::endl; } int main() { //隐式实例化为：int、double function(10); function(20.20); //显式实例化为：char、string function<char>('a'); function<std::string>(\\\"你好\\\"); return 0; } /* 运行结果： param：10 param：20.20 param：a param：你好 */ //3.类模板的定义、实例化 #include<iostream> template<typename T> class mycontainer { public: //构造函数 mycontainer(T arg):element(arg){} //获取元素 T get_value() const { return element; } private: //模板推导成员变量类型 T element; }; // 全局显式实例化为int类型的版本，也可以在声明类变量的时候实例化 template class MyContainer<int>; int main() { //类模板显式实例化 mycontainer<int> intContainer(42); std::cout << \\\"Value of intContainer：\\\" << intContainer.get_value() << std::endl; //类模板隐式实例化 mycontainer doubleContainer(42.2); std::cout << \\\"Value of doubleContainer：\\\" << doubleContainer.get_value() << std::endl; return 0; } /* 运行结果： Value of intContainer：42 Value of doubleContainer：42.2 */ #include<iostream> //通过非类型模板参数给array数组一个初始size，方便后续操作 template<int size> class FixedArray { public: void set_value(int index, int value) { if(index>= 0 && index < size) { array[index] = value; } else { std::cout << \\\"下标越界!\\\" << std::endl; } } int get_value(int index) const { if(index >= 0 && index < size) { return array[index]; } else { std::cout << \\\"下标越界!\\\" << std::endl; return -1; } } private: int array[size]; }; int main() { FixedArray<5> myArray; myArray.set_value(2,42); std::cout << \\\"Value at index 2：\\\" << myArray.get_value(2) << std::endl; return 0; } /* 运行结果： Value at index 2：42 */ //5.模板特化 //通过模板特化对一些特殊的类型进行特殊化实现 //比如下面使用char类型时，就调用特化为char类型的模板 #include<iostream> //通用模板 template<typename T> void print_value(T value) { std::cout << \\\"通用模板：\\\" << value << std::endl; } //函数模板特化为char类型 template<> void print_value<char>(char value) { std::cout << \\\"特化为char的模板：\\\" << value <<std::endl; } int main() { print_value(42); print_value('A'); return 0; } /* 运行结果： 通用模板：42 特化为char的模板：A */ //6.全特化和偏特化 //全特化：是指为模板提供特定类型或特定值的完整实现，相当于定死模板特化内容 //偏特化：是指在模板中一部分参数被具体指定，而另一部分参数保留为泛型形式，相当于保留一部分给你修改 #include<iostream> //通用函数模板 template<typename T, int N> class myContainer { public: void print_value() { std::cout << \\\"通用类模板\\\" << std::endl; } }; //类模板全特化为int类型和值为5 template<> class myContainer<int, 5> { public: void print_value() { std::cout << \\\"全特化为int和值为5\\\" <<std::endl; } }; //类模板偏特化为int类型 template<int N> class myContainer<int, N> { public: void print_value() { std::cout << \\\"偏特化为int，值为：\\\" << N <<std::endl; } }; int main() { //调用通用模板 myContainer<double, 3> genericContainer; genericContainer.print_value(); //调用全特化模板 myContainer<int, 5> specializeContainer; specializeContainer.print_value(); //调用偏特化模板 myContainer<int, 7> partialSpecializeContainer; partialSpecializeContainer.print_value(); return 0; } /* 运行结果： 通用类模板 全特化为int和值为5 偏特化为int，值为：7 */ \"]},\"368\":{\"h\":\"第五章：C++IO流\"},\"369\":{\"h\":\"知识点思维导图\"},\"370\":{\"h\":\"复习代码\",\"t\":[\"// Author：JimBo (1353429820@qq.com) // Filename：main // Date：2024/1/18 // Description：review knowledge points // Copyrights（c）JimBo. All rights reserved //1.C++标准IO流 //std::cout：标准输出流，用于将数据输出到屏幕 //std::cin：标准输入流，用户从键盘读取输入 //std::cerr：标准错误输出流，用于将错误信息输出到屏幕 //std::clog：标准日志输出流，用于输出错误信息 #include<iostream> int main() { int num1, num2; //使用cout、cin进行输入输出 std::cout << \\\"Enter two numbers：\\\"; std::cin >> num1 >> num2; std::cout << \\\"Sum：\\\" << num1+num2 << std::endl; //使用cerr输出错误信息 if(num2 ==0) { std::cerr << \\\"Error：num2 is zero!\\\" <<std::endl; } //使用clog输出日志信息 std::clog << \\\"Operation completed successfully.\\\" << std::endl; } /* 运行结果： Enter two numbers：1 0 Sum：1 Error：num2 is zero! Operation completed successfully. */ //2.文件流对象：ifstream(只读)、ofstream(只写)、fstream(读写)，头文件为#include<fstream> //读文件 #include<iostream> #include<fstream> int main() { std::ifstream inFile(\\\"../example.txt\\\"); if(inFile.is_open()) { //读文件中数据 std::string line; while(std::getline(inFile, line)) { std::cout << \\\"Read from file：\\\" << line << std::endl; } //关闭文件 inFile.close(); } else { std::cerr << \\\"Unable to open file for reading.\\\" <<std::endl; } return 0; } //运行结果：Read from file：1234 //写文件 #include<iostream> #include<fstream> int main() { std::ofstream outFile(\\\"../example.txt\\\"); //打开一个文件以写入 if(outFile.is_open()) { //覆盖写入数据到文件 outFile << \\\"Hello I/O!\\\" << std::endl; outFile << 42 << std::endl; outFile << 3.14 << std::endl; //关闭文件 outFile.close(); } else { std::cerr << \\\"Unable to open file for writing\\\" << std::endl; } return 0; } //fstream常用读写文件 //std::ios::in：以读方式打开 //std::ios::out：以写方式打开 //std::ios::app：以追加方式写入文件 #include<iostream> #include<fstream> int main() { //文件读、写、读写、追加 std::fstream inFile(\\\"example.txt\\\", std::ios::in);//读 std::fstream outFile(\\\"example.txt\\\", std::ios::out);//写 std::fstream file(\\\"example.txt\\\", std::ios::in | std::ios::out);//读写 std::fstream outFile2(\\\"example.txt\\\", std::ios::out | std::ios::app);//追加 return 0; } //文件读写操作成员函数使用的时候查文档来用，没必要记住 \"]},\"371\":{\"h\":\"第六章：C++继承\"},\"372\":{\"h\":\"知识点思维导图\"},\"373\":{\"h\":\"复习代码\",\"t\":[\"// Author：jimbo（1353429820@qq.com） // Filename：main // Date：2024/1/19 // Description：review knowledge points // Copyrights（c）JimBo. All rights reserved //1.继承的定义 //形式：class 子类 : 继承方式 父类 //三种继承方式：public、protected、private //public、protected继承派生类可见，private继承方式派生类不可见。不可见指的是继承下来用不了的意思 //类内外都可访问用public、类内访问用protected、都不访问用private。一般都用public #include<iostream> //父类(基类) class Animal { public: void eat() { std::cout << \\\"Animal is eating\\\" << std::endl; } }; //子类(派生类)：公有继承 class Cat : public Animal { public: void cat_break() { std::cout << \\\"Cat is breaking\\\" << std::endl; } }; //子类(派生类)：保护继承 class Dog : protected Animal { public: void dog_break() { std::cout << \\\"Dog is breaking\\\" << std::endl; } }; //子类(派生类)：私有继承 class Fish : private Animal { public: void fish_break() { std::cout << \\\"Fish is breaking\\\" << std::endl; } }; int main() { //公有继承：创建派生类对象、派生类调用基类成员函数、调用自身成员函数 Cat mycat; mycat.eat(); mycat.cat_break(); //保护继承：创建派生类对象、派生类调用基类成员函数、调用自身成员函数 Dog mydog; //mydog.eat(); //报错：因为采用的保护继承，protected在类外不能访问 mydog.dog_break(); //私有继承：创建派生类对象、派生类调用基类成员函数、调用自身成员函数 Fish myfish; //myfish.eat(); //报错：因为采用私有继承，private在类外不能访问，且不可见 myfish.fish_break(); } /* 运行结果： Animal is eating Cat is breaking Dog is breaking Fish is breaking */ //2.基类和派生类对象的赋值转换 //派生类赋值基类：向上转型，切片 //基类指针赋值派生类指针：强转，注意：基类对象不可以赋值给派生类对象，基类指针可以强转给派生类指针 //注意：非必要，不要用基类指针赋值派生类指针，不安全 #include<iostream> //基类 class Person { protected: std::string name;//名字 std::string sex;//性别 int age;//年龄 }; //派生类 class Student : public Person { protected: int stuId;//学号 }; int main() { //派生类对象赋值给基类对象、指针、引用，向上转型，进行切片，抛弃派生类特有内容 Student s; Person p = s; //派生类对象赋值给基类对象，抛弃stuId Person* ptr = &s; //派生类对象赋值给基类指针 Person& ref = s; //派生类对象赋值给基类引用 //基类指针强制给派生类指针，只有基类指针指向派生类的对象才是安全的，避免这样用 Student* stu; Person* per; stu = (Student*)per; return 0; } //3.继承中的作用域 //继承中引入了一个新的作用域，其中派生类可以访问基类的成员 //这个作用域被称为派生类的作用域 //派生类作用域特点 //1.访问基类的成员：派生类可以直接访问基类的公有和受保护的成员，私有成员对于派生类来说是不可访问的 //2.隐藏：若子类和父类中有同名成员，子类成员将屏蔽父类同名成员(成员变量、成员函数)的直接访问，这种情况叫隐藏，也叫重定向 //3.通过::访问基类成员：在派生类中，可以使用::来显式指定访问基类的成员 //注意：父类和子类的同名函数不是构成了重载，因为重载需要在同一作用域下 #include<iostream> //基类 class Base { public: int commonVar; void commonfunction() { std::cout << \\\"Base class function\\\" << std::endl; } }; //派生类 class Derived : public Base { public: //覆盖基类同名成员 int commonVar; //覆盖基类同名函数：只要名字相同就构成覆盖 void commonfunction() { std::cout << \\\"Derived class function\\\" << std::endl; } void accessBaseMember() { //访问派生类中的同名成员 std::cout << \\\"Derived class commonVar：\\\" << commonVar << std::endl; //访问基类中的同名成员 std::cout << \\\"Base class commonVar：\\\" << Base::commonVar << std::endl; } }; int main() { Derived derived; derived.commonVar = 42; derived.commonfunction(); derived.accessBaseMember(); return 0; } /* 运行结果： Derived class funciton Derived class commonVar：42 Base class commonVar：-333280960(随机值) */ //4.单继承、多继承、菱形继承 //单继承：指一个派生类只继承一个基类 //多继承：指一个派生类继承多个基类 //菱形继承：指一个派生类继承多个基类，这多个基类由继承一个基类 //菱形继承存在数据冗余和二义性问题，通过菱形虚拟继承解决 #include<iostream> //单继承 class Animal{}; class cat : public Animal{}; //多继承 class Bird{}; class Horse{}; class Pegasus : public Bird, public Horse{}; //菱形继承：Bat继承Manmal、Bird2，Manmal、Bird2又继承Animal class Animal1{}; class Manmal : public Animal1{}; class Bird2 : public Animal1{}; class Bat : public Manmal, public Bird2{}; //5.菱形虚拟继承：解决菱形继承数据冗余和二义性问题 //原理：菱形虚拟继承对于重复的成员只存储一份，通过虚基表指针和虚基表找到公共虚基类，从而解决数据冗余、二义性 #include<iostream> class Animal{}; class Mammal : virtual public Animal{}; class Bird : virtual public Animal{}; class Bat : public Mammal, public Bird{}; \"]},\"374\":{\"h\":\"第七章：C++多态\"},\"375\":{\"h\":\"知识点思维导图\"},\"376\":{\"h\":\"复习代码\",\"t\":[\"// Author：jimbo（1353429820@qq.com） // Filename：main // Date：2024/1/20 // Description：review knowledge points // Copyrights（c）JimBo. All rights reserved //1.虚函数的重写 //虚函数的重写也叫虚函数的覆盖，若派生类中有一个和基类完全相同的虚函数，此时称该派生类虚函数重写了基类虚函数 //在重写基类虚函数时，派生类虚函数不加virtual关键字也构成重写，因为继承后基类的虚函数被继承下来，但不推荐不加 //C++11引入final修饰虚函数，表示不能被继承或重写。而override放在虚函数声明后，用于检查是否存在于基类虚函数相匹配的函数 #include<iostream> //基类 class Shape { public: //虚函数 virtual void draw() const { std::cout << \\\"Drawing a shape\\\" << std::endl; } //虚拟析构函数，保证正确释放资源 virtual ~Shape(){} }; //派生类：Circle class Circle : public Shape { public: void draw() const override { std::cout << \\\"Drawing a circle\\\" << std::endl; } }; //派生类：Square class Square : public Shape { public: void draw() const override { std::cout << \\\"Drawing a square\\\" << std::endl; } }; //函数：接收Shape的基类指针，并调用虚函数draw() void drawShape(const Shape* shape) { shape->draw(); } int main() { //创建对象 Circle circle; Square square; //使用基类指针调用虚函数，实现多态性 drawShape(&circle); drawShape(&square); return 0; } /* 运行结果： Drawing a circle Drawing a square */ //2.虚函数重写的两个例外：协变、析构函数重写，两个特例也构成重载 //协变：派生类重写基类虚函数时，与基类虚函数返回值类型不同，基类虚函数返回基类对象的指针或引用，派生类返回派生类对象的指针或引用 //析构函数重写：如果基类的析构函数为虚函数，此时派生类析构函数只要定义，无论是否加virtual，都与基类析构函数构成重写，即使名字不同 //协变例子 #include<iostream> //基类 class Animal { public: virtual Animal* clone() const { std::cout<< \\\"cloning an animal\\\" << std::endl; return new Animal(*this); } }; //派生类 class Dog : public Animal { public: //Dog类中采用协变，重写了clone()函数。并返回Dog*类型的指针 Dog* clone() const override { std::cout<< \\\"cloning a dog\\\" << std::endl; return new Dog(*this); } }; int main() { //创建派生类 Dog myDog; //使用基类指针调用虚函数 Animal* clonedAnimal = myDog.clone(); //说明：通过基类指针调用clone()函数，由于协变存在，实际调用Dog类的clone()函数 //协变使得在派生类中的虚函数能够返回更具体的类型，提高了灵活性和代码的可读性 //清理指针 delete clonedAnimal; return 0; } // 运行结果：cloning a dog //析构函数重写例子 #include<iostream> //基类 class Base { public: //基类的虚拟析构函数 virtual ~Base() { std::cout << \\\"Base Destructor\\\" << std::endl; } }; //派生类 class Derived : public Base { public: //派生类的虚拟析构函数，重写基类的析构函数 ~Derived() override { std::cout << \\\"Derived Destructor\\\" << std::endl; } }; int main() { //使用基类指针指向派生类对象 Base* ptr = new Derived; //使用基类指针删除对象，调用派生类析构函数 delete ptr; //说明：基类析构被声明为虚析构函数，则被重写为Dervied类的析构函数，然后再调用Base类的虚析构函数 return 0; } /* 运行结果： Derived Destructor Base Destructor */ //3.抽象类(接口类) //在虚函数后加=0，则这个函数称为存虚函数，包含纯虚函数的类叫做抽象类，也叫接口类，抽象类不能实例化对象 #include<iostream> //抽象类 class Shape { public: //纯虚函数，使得Shape成为抽象类 virtual void draw() const = 0; //普通成员函数 void display() const { std::cout << \\\"displaying a shape\\\" << std::endl; } //虚析构函数，通常在抽象类中声明为虚析构函数 virtual ~Shape() { std::cout << \\\"shape destructor\\\" << std::endl; } }; //派生类 class Circle : public Shape { public: //实现抽象类中的纯虚函数 void draw() const override { std::cout << \\\"drawing a circle\\\" << std::endl; } //派生类的其他成员函数 void calculateArea() const { std::cout << \\\"calculating the area of a circle\\\" << std::endl; } //派生类的析构函数 ~Circle() override { std::cout << \\\"circle destructor\\\" << std::endl; } }; int main() { //抽象类(接口类)不能实例化 //Shape shape; //报错：不能实例化 //使用基类指针指向派生类对象，向上转型切片 Shape* circle = new Circle; //说明：向上转型进行了切片，舍去了派生类的draw()，但是Circle对象赋值给Shape*， //虽然静态类型变成了基类Shape*，但是动态类型还是派生类Circle，因此虚函数调用时 //会根据动态类型调用响应的实现 //调用纯虚函数，实际调用了派生类的实现 circle->draw(); //调用普通成员函数，也是通过基类指针调用 circle->display(); //使用基类指针删除对象，调用派生类的析构函数 delete circle; return 0; } /* 运行结果： drawing a circle displaying a shape circle destructor shape destructor */ \"]},\"377\":{\"h\":\"第八章：C++11\"},\"378\":{\"h\":\"知识点思维导图\"},\"379\":{\"h\":\"复习代码\",\"t\":[\"// Author：jimbo（1353429820@qq.com） // Filename：main // Date：2024/1/21 // Description：review knowledge points // Copyrights（c）JimBo. All rights reserved //1.列表统一初始化 //c++11提供{}初始化的方法用来简单化列表初始化和其他初始化 //实际使用中还是更多使用new，而不是直接用{}，因为这样让代码可读性变差了 #include<iostream> #include<vector> #include<list> int main() { int x = {0}; int array[] = {1,2,3,4,5}; int array2[5] = {1,2}; int* ptr = new int[4]{0}; int* ptr2 = new int[4]{1,2,3,4}; std::vector<int> v = {1,2,3,4,5}; std::list<int> i = {1,2,3,4,5}; return 0; } //2.auto、decltype、typeid、nullptr关键字 #include<iostream> int main() { //auto：自动推导类型 auto x = 42; auto y = 3.14; //decltype：获取表达式的类型，而不是使用初始值的类型 int a = 10; decltype(a) b = 20;//获取a的类型，即b的类型为int，原式等于int b = 20； //typeid：获取表达式的类型信息，常用typeid(类型).name()来获取类型类别 float f = 3.14; typeid(f).name();//float //nullptr：表示空指针，取代以前的NULL和0表示空指针 int* ptr = nullptr; return 0; } //3.范围for循环 //形式：for(declaration : range)，declaration是变量声明随便定名字，range是遍历的范围 //注意：范围for的遍历范围必须确定 #include<iostream> #include<vector> #include<string> int main() { //数组 int arr[] = {1,2,3,4,5}; for(int value : arr) { std::cout << value << \\\" \\\"; } std::cout << std::endl; //STL容器 std::vector<int> vec = {10,20,30,40,50}; for(int value : vec) { std::cout<< value << \\\" \\\"; } std::cout << std::endl; //字符串 std::string str = \\\"hello\\\"; for(char ch : str) { std::cout << ch << \\\" \\\"; } std::cout << std::endl; //指针范围 int arr2[] = {1,2,3,4,5}; for(int& value : arr2) { value*=2; std::cout << value << \\\" \\\"; } return 0; } /* 运行结果： 1 2 3 4 5 10 20 30 40 50 h e l l o 2 4 6 8 10 */ //4.explicit关键字：禁止单参数构造函数的隐式转换 #include<iostream> class Myclass { public: explicit Myclass(int value):data(value){} void print_data() { std::cout << \\\"Data：\\\" << data << std::endl; } private: int data; }; int main() { //不使用explicit，会进行隐式类型转换 //Myclass obj = 42;//这行会报错，因为构造函数使用了explicit关键字，禁止了隐式类型转换 //使用explicit，需要显式的进行类型转换 Myclass obj(42);//正确，显式的调用构造函数 obj.print_data(); return 0; } //运行结果：Data：42 //5.STL变化：新增array、forward_list、unordered_map、unordered_set //array：静态数组 //forward_list：单链表 //unordered_map、unordered_set：无序容器，底层是哈希表 #include<iostream> #include<array> #include<forward_list> #include<unordered_map> #include<unordered_set> int main() { //array使用 std::array<int, 5> arr = {1,2,3,4,5}; //forward_list使用 std::forward_list<int> myList = {1,2,3,4,5}; //unordered_map使用 std::unordered_map<std::string, int> myMap = {{\\\"one\\\", 1}, {\\\"two\\\", 2}}; //unordered_set使用 std::unordered_set<int> mySet = {1,2,3,4,5}; return 0; } //6.STL字符串转换函数 //内置类型转string：统一调用std::to_string //string转内置类型： //1.stoi：转整型 //2.stol：转长整型 //3.stoul:转无符号长整型 //4.stoull：转无符号长长整型 //5.stof：转单精度浮点型 //6.stod：转双精度浮点型 //7.stold：转长双精度浮点型 #include<iostream> #include<string> int main() { int num = 10; //std::to_string使用 std::string str = std::to_string(num); //stoi使用，其他类似，用的时候查文档 std::string str2 = \\\"123\\\"; int num2 = stoi(str2); return 0; } //7.容器新方法 //提供initializer_list为参数的构造函数，用于支持列表初始化---也就是{}进行初始化 //提供cbegin和cend方法，返回const迭代器 //提供emplace系列方法，并在容器原有的插入方法基础上重载右值引用版本的插入函数，用于提高容器中插入的效率 #include<iostream> #include<vector> int main() { std::vector<int> myVector = {1,2,3,4,5};//{}就是调用initializer_list为参数的构造函数 //使用cbegin和cend获取const迭代器 for(auto it = myVector.cbegin(); it != myVector.cend(); ++it) { std::cout << *it << \\\" \\\"; } return 0; } //运行结果：1 2 3 4 5 //7.容器新方法 //提供initializer_list为参数的构造函数，用于支持列表初始化---也就是{}进行初始化 //提供cbegin和cend方法，返回const迭代器 //提供emplace系列方法，并在容器原有的插入方法基础上重载右值引用版本的插入函数，用于提高容器中插入的效率 #include<iostream> #include<vector> #include<string> #include<map> int main() { //使用emplace在vector中就地构造元素 std::vector<std::pair<int, std::string>> myVector; myVector.emplace_back(1, \\\"one\\\"); myVector.emplace_back(2, \\\"two\\\"); //使用emplace在map中就地构造元素 std::map<int, std::string> myMap; myMap.emplace(1, \\\"one\\\"); myMap.emplace(2, \\\"two\\\"); //打印vector中元素 for(const auto& element : myVector) { std::cout << \\\"Vector Pair：\\\" << element.first << \\\"，\\\" << element.second << std::endl; } //打印map中元素 for(const auto& pair : myMap) { std::cout << \\\"Map Pair：\\\" << pair.first << \\\"，\\\" << pair.second <<std::endl; } return 0; } /* 运行结果： Vector Pair：1，one Vector Pair：2，two Map Pair：1，one Map Pair：2，two */ //8.默认成员函数控制 //在默认函数定义或者声明时加上=default，从而显式的指示编译器生成该函数的默认版本，用=default修饰的函数称为显式缺省函数 //在默认函数定义或声明时加上=delete，从而显式的指示编译器不生产该函数的默认版本，用=delete修饰的函数称为删除函数 //要避免=delete或=default与explicit一起使用 //8.左值和右值 //左值：可以标识并且在内存中有存储位置的表达式，通常是变量或对象的名称 //右值：不具有内存位置的表达式，通常是临时量、字面常量或表达式计算结果 #include<iostream> int main() { int sum = 10 + 20; //sum是左值，10+20是右值 int* ptr = &sum; //ptr是左值 return 0; } //9.左值引用和右值引用 //左值引用：就是使用&来引用左值，也就是引用有具体内存位置的对象，如变量、常量、表达式等 //右值引用：就是使用&来引用右值，如临时对象、字面常量、表达式的计算结果等 //右值引用可以使用std::move将左值转为右值引用 #include<iostream> void left_modifyValue(int& reference) { reference = 100;//修改引用的对象值 } void right_modifyValue(int&& reference) { reference = 200; } int main() { int x = 42; int& valueRef = x;//左值引用，给左值取别名 left_modifyValue(x);//传递引用给函数修改 std::cout << \\\"modified value：\\\" << valueRef << std::endl;//输出modified value：100 int&& valueRef2 = 42;//右值引用，给右值取别名 right_modifyValue(std::move(valueRef2));//使用std::move将左值转换为右值引用 std::cout << \\\"modified value：\\\" << valueRef2 << std::endl;//输出modified value：200 return 0; } //10.右值引用和移动语义 //右值引用：引入目的，主要为了支持移动语义，在某些情况下将资源从一个对象移动到另一个对象，避免昂贵的拷贝操作 //移动语义：允许将资源的所有权从一个对象移动到另一个对象，而不是进行深层次的拷贝 //移动语义用途：通常与右值引用一起使用，用于某些情况下高效的移动资源，例如：容器插入、返回临时对象的函数、动态内存管理 #include<iostream> #include<vector> #include<utility> int main() { std::vector<int> source = {1,2,3,4,5}; //使用移动语义将资源从source移动到destination std::vector<int> destination = std::move(source); return 0; } //11.完美转发 //模板中的&&不代表右值引用，而是万能引用，其既能接收左值又能接收右值 //作用：右值经过一次参数传递后，其属性可能会退化为左值，因为右值被引用后会导致右值被存储到特定位置 //这时这个右值可以被取地址，并且可以被修改，因此在下一次传参时该右值会被识别成左值 #include<iostream> //模板函数，使用完美转发 template<typename T> void firestfunction(T&& arg) { //使用std::forward<T>将参数以原始的左值或右值引用进行转发 secondfunction(std::forward<T>(arg));//会提示没声明，放后面或者上面声明下函数就行 } void secondfunction(int& arg) { std::cout << \\\"Reference：\\\" << arg << std::endl; } void secondfunction(int&& arg) { std::cout << \\\"Revalue Reference：\\\" << arg << std::endl; } int main() { int x = 42; //调用firstfunction是，参数arg将被完美转发到secondfunction firestfunction(x);//转发为左值引用 结果：Reference：42 firestfunction(123);//转发为右值引用 结果：Revalue Reference：123 return 0; } //12.lambda表达式 //形式：[capture](parameters) -> return_type{} //capture：允许你从周围作用域中捕捉变量 //parameters：参数列表 //return_type：lambda函数的返回值 #include<iostream> int main() { //定义lambda函数，接受两个参数并返回它们的值 auto add = [](int a, int b) -> int { return a + b; }; //使用lambda函数 int result = add(3, 4); std::cout << \\\"结果为：\\\" << result << std::endl; //结果为：7 //使用lambda表达式捕获外部变量 int factor = 2; auto multiply = [factor](int x) -> int { return x * factor; }; std::cout << multiply(5) << std::endl; //输出：10 } //13.包装器：std::function、std::bind //std::function：函数包装器，也叫适配器，明确可调用对象的返回值和形参类型，更加方便使用 #include<iostream> #include<functional> //std::function、std::bind //普通函数 int add(int a, int b) { return a+b; } //函数对象 struct multiply { int operator()(int a, int b) const { return a*b; } }; int main() { //使用std::function包装普通函数 std::function<int(int, int)> addFunction = add; //使用std::function包装函数对象 std::function<int(int, int)> multiplyFunction = multiply(); //使用lambda表达式 std::function<int(int, int)> lambdaFunction = [](int a, int b) { return a*b; }; //调用并输出结果 std::cout << \\\"Add：\\\" << addFunction(3,4) << std::endl; //Add：7 std::cout << \\\"Multiply：\\\" << multiplyFunction(3,4) << std::endl; //Multiply：12 std::cout << \\\"Lambda：\\\" << lambdaFunction(3,4) << std::endl; //Lambda：12 return 0; } //std::bind：将一个函数的某些参数绑定为固定的值，让我们在调用时可以不用传递某些参数 #include<iostream> #include<functional> //目标函数 int add(int a, int b, int c) { return a+b+c; } int main() { //使用std::bind绑定函数和部分参数 auto partiallyBound = std::bind(add, std::placeholders::_1, 2, std::placeholders::_2); //说明：std::bind绑定add函数，将第一个参数和第三个参数分别绑定为std::placeholders::_1和std::placeholders::_2 //其中std::placeholders::_1和_2都是占位符，用于指定调用函数时，应该使用传入的参数的哪些位置 //这样调用partiallyBound(3,4)就相当于调用add(3,2,4)，输出结果为9 //调用并输出结果 std::cout << \\\"Partially Bound：\\\" << partiallyBound(3,4) <<std::endl; //输出结果：Partially Bound：9 return 0; } //14.线程库 //线程对象的构造方式： //1.调用无参的构造函数，比如：thread t //2.调用带参的构造函数，比如：thread t(func, arg) //3.调用移动构造函数， 比如：thread t = thread(func, arg) //调用无参构造函数 #include<iostream> #include<thread> void threadFunction() { std::cout << \\\"Thread is running\\\" << std::endl; } int main() { //调用无参构造函数 std::thread thread1; //如果使用无参构造函数创建的线程，后续通过std::thread::operator=或std::thread::swap赋予一个线程函数 thread1 = std::thread(threadFunction);//创建线程时需要指定新线程要执行的函数，也可以是函数指针、可调用对象 //等待线程结束 thread1.join(); std::cout << \\\"Thread has finished\\\" << std::endl; return 0; } //运行结果： //Thread is running //Thread has finished //调用带参的构造函数 #include<iostream> #include<thread> void threadFunction(int x) { std::cout << \\\"Thread is running with parameter：\\\" << x << std::endl; } int main() { int value = 42; //调用带参的构造函数 std::thread thread1(threadFunction, value);//value作为参数传递给threadFunction，用于新线程的创建 //等待线程结束 thread1.join(); std::cout << \\\"Thread has finished\\\" << std::endl; return 0; } //运行结果： //Thread is running with parameter：42 //Thread has finished //调用移动构造函数 #include<iostream> #include<thread> void threadFunction(int x) { std::cout << \\\"Thread is running with parameter：\\\" << x << std::endl; } int main() { int value = 42; //创建并启动一个新线程 std::thread thread1(threadFunction, value);//value作为参数传递给threadFunction，用于新线程的创建 //移动构造函数 std::thread thread2 = std::move(thread1); //主线程继续执行其他任务 std::cout << \\\"Main thread is running\\\" << std::endl; //等待新线程结束 thread2.join(); std::cout << \\\"Thread has finished\\\" << std::endl; return 0; } //运行结果： //Main thread is running //Thread is running with parameter：42 //Thread has finished //说明：线程的执行是并发的，具体执行顺序可能受到多个因素的影响，包括系统调度策略和处理器的状态 //因此，输出语句的顺序可能会有所不同，thread2 可能会在 thread1（新线程）之前输出信息，但这并 //不表示 thread2 先于 thread1 运行，而是由于主线程和新线程的并发执行 //thread提供的成员函数 //join()：对该线程进行等待，在等待的线程返回前，调用join()的线程将会被阻塞 //joinable()：判断该线程是否已经执行完毕，如果是就返回true，否则返回false //detach()：将该线程与创建线程进行分离，被分离后的线程不需要创建线程调用join()对其进行等待 //get_id()：获得该线程的id //swap()：将两个线程对象关联线程的状态进行交换 //join()、joinable()的使用 #include<iostream> #include<thread> void function() { std::cout << \\\"Thread is running\\\" << std::endl; } int main() { std::thread myThread(function); //joinable检查线程执行完毕function没有 if(myThread.joinable()) { std::cout << \\\"Thread is joinable\\\" << std::endl; //主线程执行一些任务 //join()的使用：等待新进程结束 myThread.join(); } else { std::cout << \\\"Thread is not joinable\\\" << std::endl; } std::cout << \\\"Main thread has finished\\\" << std::endl; return 0; } //运行结果： //Thread is joinable //Thread is running //Main thread has finished //detach()的使用 #include<iostream> #include<thread> void function() { std::cout << \\\"Thread is running\\\" << std::endl; } int main() { std::thread myThread(function); //分离新线程，使其在后台运行 myThread.detach(); std::cout << \\\"Main thread has finished\\\" << std::endl; return 0; } //运行结果： //Main thread has finished //get_id()的使用 //获取线程id的方式：1.调用get_id()访问、2.调用this_thread::get_id()获取 #include<iostream> #include<thread> void function() { std::cout << \\\"Thread ID：\\\" << std::this_thread::get_id() << std::endl; } int main() { std::thread myThread(function); //主线程执行一些任务 //等待新进程结束 myThread.join(); std::cout << \\\"Main thread has finished\\\" << std::endl; return 0; } //运行结果： //Thread ID：140148637431360 //Main thread has finished #include<iostream> #include<thread> void function() { std::cout << \\\"Thread is running\\\" << std::endl; } int main() { std::thread myThread1(function); std::thread myThread2; //交换两个线程对象 myThread1.swap(myThread2); if(myThread1.joinable()) { myThread1.join(); } if(myThread2.joinable()) { myThread2.join(); } std::cout << \\\"Main thread has finished\\\" << std::endl; return 0; } //运行结果： //Thread is running //Main thread has finished //线程函数参数问题 //问题：线程函数的参数是以值拷贝的方式拷贝到线程空间中的，计算线程函数的参数为引用类型，在线程函数中修改后也不会 //影响到外部实参，因为其实际引用的就是线程栈中的拷贝，而不是外部实参 //解决办法： //1.借助std::ref()保持对实参的引用 //2.将实参的地址传入线程函数，在线程函数中通过该地址修改变量 //3.将lambda表达式作为线程函数，利用lambda函数的捕捉列表以引用的方式对外部实参进行捕捉 //借助std::ref()保持对实参的引用 #include<iostream> #include<thread> void function(int& x) { //在线程函数中修改实参的值 x +=10; } int main() { int value = 42; //使用std::ref()传递引用 std::thread myThread(function, std::ref(value)); //主线程等待新线程结束 myThread.join(); //输出修改后的值 std::cout << \\\"Modified value in main：\\\" << value << std::endl; return 0; } //运行结果：Modified value in main：52 //将实参的地址传入线程函数，在线程函数中通过该地址修改变量 #include<iostream> #include<thread> void function(int* x) { //在线程函数中修改实参的值 (*x) +=10; } int main() { int value = 42; //传递变量的地址给新线程 std::thread myThread(function, &value); //主线程等待新线程结束 myThread.join(); //输出修改后的值 std::cout << \\\"Modified value in main：\\\" << value << std::endl; return 0; } //运行结果：Modified value in main：52 //将lambda表达式作为线程函数，利用lambda函数的捕捉列表以引用的方式对外部实参进行捕捉 #include<iostream> #include<thread> int main() { int value = 42; //传递变量的地址给新线程 std::thread myThread([&value]() { //在线程函数中通过引用修改外部变量的值 value +=10; std::cout << \\\"Value inside thread：\\\" << value << std::endl; }); //主线程等待新线程结束 myThread.join(); //输出修改后的值 std::cout << \\\"Modified value in main：\\\" << value << std::endl; return 0; } //运行结果： //Value inside thread：52 //Modified value in main：52 //15.互斥量库 //mutex的种类： //1.mutex：最基本的互斥量，不可拷贝，不可移动 //2.recursive_mutex：递归互斥锁，专门用于递归函数中的加锁操作 //3.timed_mutex：时间锁，能够在指定时间内进行加锁操作 //4.recursive_timed_mutex：既支持递归函数中进行加锁，也支持在指定实际内加锁 //lock_guard和unique_lock //lock_guard是一个轻量级的互斥锁封装类，使用RAII原则，即在构造函数中获取互斥锁，在析构函数中释放互斥锁 //unique_lock是一个更加灵活的互斥锁封装类，与lock_guard不同，它需要手动锁定和释放互斥锁，提供额外成员函数 //1.void lock()：手动锁定互斥量 //2.void unlock()：手动解锁互斥量 //3.bool try_lock()：尝试锁定互斥量，互斥量当前不可用，立刻返回false #include<iostream> #include<mutex> int main() { std::mutex myMutex; //std::lock_guard的使用 { std::lock_guard<std::mutex> lock(myMutex); //互斥锁在这个作用域内被持有 //这里进行一些线程安全的操作 } //lock_guard在这里离开作用域，互斥锁被自动释放 //std::unique_lock的使用 { std::unique_lock<std::mutex> lock2(myMutex); //互斥锁在这个作用域内被持有 //这里进行一些线程安全的操作 //手动释放互斥锁：unlock() lock2.unlock(); //这里可以执行一些不需要互斥锁的操作 //重新锁定互斥锁：lock() lock2.lock(); //这里再次持有互斥锁，进行一些线程安全的操作 } //unique_lock在这里离开作用域，互斥锁被自动释放 return 0; } //16.原子性操作库 //解决线程安全问题：多线程最主要的问题就是共享数据带来的线程安全问题，共享数据支持多个线程同时对其进行读操作，但不支持多个线程同时对其进程写操作 //因此C++11中引入了原子操作。所谓原子操作：即不可被中断的一个或一系列操作，C++11引入的原子操作类型，使得线程间数据的同步变得非常高效 //原子类：不需要对原子类型进行加锁解锁操作，线程能够对原子类型变量互斥访问 //原子类型变量定义方式： //1.通过原子类型名称定义，例如：atomic_bool n = {true}、atomic_int n = {0}、atomic_char n = {'a'} //2.通过atomic类模板定义，例如：atomic<bool> n = true、atomic<int> n = 0、atomic<char> n = 'a' //atomic类模板是C++标准库提供的，已经实现了原子操作的一系列方法，具体用的时候查 #include<iostream> #include<atomic> int main() { //通过原子类型名称定义 std::atomic_int atomicInteger(42); std::atomic_bool atomicFlag(true); //通过atomic类模板定义 std::atomic<int> atomicInteger2(42); std::atomic<bool> atomicFlag2(true); //进行原子操作 atomicInteger.fetch_add(5); // 原子加法 fetch_add atomicFlag.store(false); // 原子存储 store将值设置给原子变量 atomicInteger2.fetch_add(5); // 原子加法 atomicFlag2.store(false); // 原子存储 // 输出修改后的值 std::cout << \\\"Modified atomicInteger: \\\" << atomicInteger.load() << std::endl;//load()加载当前值 std::cout << \\\"Modified atomicInteger2: \\\" << atomicInteger2.load() << std::endl; std::cout << \\\"Modified atomicFlag: \\\" << std::boolalpha << atomicFlag.load() << std::endl; std::cout << \\\"Modified atomicFlag2: \\\" << std::boolalpha << atomicFlag2.load() << std::endl; return 0; } //运行结果： //Modified atomicInteger: 47 //Modified atomicInteger2: 47 //Modified atomicFlag: false //Modified atomicFlag2: false //17.条件变量库 //C++11引入条件变量来协调多个线程的执行，条件变量允许一个线程等待另一个线程满足某个条件后再继续执行 //wait系列成员函数：用于让调用线程进行等待，包括：wait、wait_for、wait_until //notify系列成员函数：用于唤醒等待的线程，包括：notify_one、notify_all #include<iostream> #include<thread> #include<mutex> #include<condition_variable> //条件变量库头文件 std::mutex mutex; std::condition_variable cv; bool dataReady = false; void producer() { //模拟一些工作 std::this_thread::sleep_for(std::chrono::seconds(2)); //数据准备完毕 { std::lock_guard<std::mutex> lock(mutex); dataReady = true; } //通知等待的线程 cv.notify_one();//notify_one()用于唤醒等待队列中首个线程，notify_all()用于唤醒等待队列中所有线程 } void consumer() { //等待数据准备完毕的通知 { std::unique_lock<std::mutex> lock(mutex); cv.wait(lock, []{return dataReady;}); } //进行操作，此时数据已经准备好了 std::cout << \\\"Consumer：Data is ready\\\" << std::endl; } int main() { //启动生产者和消费者线程 std::thread producerThread(producer); std::thread consumerThread(consumer); //等待线程结束 producerThread.join(); consumerThread.join(); return 0; } //运行结果：Consumer：Data is ready \"]},\"380\":{\"h\":\"第九章：C++异常\"},\"381\":{\"h\":\"知识点思维导图\"},\"382\":{\"h\":\"复习代码\",\"t\":[\"// Author：jimbo（1353429820@qq.com） // Filename：main // Date：2024/1/22 // Description：review knowledge points // Copyrights（c）JimBo. All rights reserved //C++异常 //1.异常关键字try、catch、throw的使用 #include<iostream> int main() { try { //在try块中放置可能抛出异常的代码 int numerator, denominator; //用户输入 std::cout << \\\"Enter numerator：\\\"; std::cin >> numerator; std::cout << \\\"Enter denominator：\\\"; std::cin >> denominator; //当分母为零时，抛出异常 if(denominator == 0) { throw std::runtime_error(\\\"Denominator cannot be zero!\\\"); } //执行除法运算 double result = static_cast<double>(numerator) / denominator; std::cout << \\\"Result：\\\" << result << std::endl; } catch (const std::runtime_error& e) { //捕获std::runtime_error异常 std::cerr << \\\"Error：\\\" << e.what() << std::endl; } return 0; } //运行结果： //Enter numerator：2 //Enter denominator：0 //Error：Denominator cannot be zero! //2.自定义异常体系 //std::exception是所有异常类的基类，提供了一个what()方法，用于返回异常的描述信息 #include<iostream> //自定义基类异常 class MyException : public std::exception { public: const char* what() const noexcept override { return \\\"MyException occurred!\\\"; } }; //自定义派生类异常 class CustomException : public MyException { public: const char* what() const noexcept override { return \\\"CustomException occurred!\\\"; } //添加自定义成员或行为 int get_error_code() const { return errorCode; } private: int errorCode = 42; }; int main() { try { //抛出自定义异常 throw CustomException(); } catch (const MyException& e) { //捕获基类异常 std::cout << \\\"Caught exception：\\\" << e.what() << std::endl; //如果是CustomException，可以使用其特定的成员或行为 const CustomException* customExceptionPtr = dynamic_cast<const CustomException*>(&e); if(customExceptionPtr) { std::cerr << \\\"Custom error code：\\\" << customExceptionPtr->get_error_code() << std::endl; } } return 0; } //运行结果： //Caught exception：CustomException occurred! //Custom error code：42 //3.标准库异常体系 //std::exception：所有标准库异常的基类，提供了一个what()方法，用于返回异常的描述信息 //std::bad_exception：当throw其他类型的异常时，std::bad_exception用于充当未被捕获的异常的一个基类 //std::bad_alloc：当动态内存分配失败时抛出的异常 //std::bad_cast：在类型转换中遇到无效的类型转换时抛出的异常 //std::bad_typeid：在使用typeid运算符获取无效类型信息时抛出的异常 //std::logic_error：表示在逻辑上存在错误，如逻辑断言失败、无效的转换等 //std::runtime_error：表示在运行时发生的错误，如除零错误、无效参数等 //...具体查文档 #include <iostream> int main() { try { // std::exception 示例 //throw std::exception(\\\"Generic exception\\\"); // std::bad_exception 示例 // 注意：std::bad_exception通常在异常处理中使用，表示未捕获的异常 // 在主函数中直接抛出它并不是常规做法 //throw std::bad_exception(); // std::bad_alloc 示例 int* dynamicArray = new int[1000000000000]; // 模拟分配失败 delete[] dynamicArray; // std::bad_cast 示例 class Base { virtual void dummy() {} }; class Derived : public Base {}; Base baseObj; try { Derived& derivedRef = dynamic_cast<Derived&>(baseObj); // 抛出 std::bad_cast } catch (const std::bad_cast& e) { std::cerr << \\\"Caught bad_cast: \\\" << e.what() << std::endl; } // std::bad_typeid 示例 try { throw std::bad_typeid(); } catch (const std::bad_typeid& e) { std::cerr << \\\"Caught bad_typeid: \\\" << e.what() << std::endl; } // std::logic_error 示例 throw std::logic_error(\\\"Logical error occurred\\\"); // std::runtime_error 示例 // 注意：std::runtime_error通常用于表示运行时错误 // 在主函数中直接抛出它并不是常规做法 //throw std::runtime_error(\\\"Runtime error occurred\\\"); } catch (const std::exception& e) { std::cerr << \\\"Caught exception: \\\" << e.what() << std::endl; } return 0; } \"]},\"383\":{\"h\":\"第一章：Linux常用命令\"},\"384\":{\"h\":\"知识点思维导图\"},\"385\":{\"h\":\"第十章：Linux的IO多路转接之poll\"},\"386\":{\"h\":\"1.知识点思维导图\"},\"387\":{\"h\":\"2.poll服务器代码\"},\"388\":{\"h\":\"2.1 PollServer类\",\"t\":[\"#pragma once #include \\\"socket.hpp\\\" #include <poll.h> #define BACK_LOG 5 class PollServer { private: int _listen_sock; //监听套接字 int _port; //端口号 public: PollServer(int port) : _port(port) {} void InitPollServer() { _listen_sock = Socket::SocketCreate(); Socket::SocketBind(_listen_sock, _port); Socket::SocketListen(_listen_sock, BACK_LOG); } ~PollServer() { if (_listen_sock >= 0) { close(_listen_sock); } } }; \"]},\"389\":{\"h\":\"2.2 运行服务器\",\"t\":[\"#pragma once #include \\\"socket.hpp\\\" #include <poll.h> #define BACK_LOG 5 #define NUM 1024 #define DFL_FD - 1 class PollServer { private: int _listen_sock; //监听套接字 int _port; //端口号 public: void Run() { struct pollfd fds[NUM]; ClearPollfds(fds, NUM, DFL_FD); //清空数组中的所有位置 SetPollfds(fds, NUM, _listen_sock); //将监听套接字添加到数组中，并关心其读事件 for (;;) { switch (poll(fds, NUM, -1)) { case 0: std::cout << \\\"timeout...\\\" << std::endl; break; case -1: std::cerr << \\\"poll error\\\" << std::endl; break; default: //正常的事件处理 //std::cout<<\\\"有事件发生...\\\"<<std::endl; HandlerEvent(fds, NUM); break; } } } private: void ClearPollfds(struct pollfd fds[], int num, int default_fd) { for (int i = 0; i < num; i++) { fds[i].fd = default_fd; fds[i].events = 0; fds[i].revents = 0; } } bool SetPollfds(struct pollfd fds[], int num, int fd) { for (int i = 0; i < num; i++) { if (fds[i].fd == DFL_FD) { //该位置没有被使用 fds[i].fd = fd; fds[i].events |= POLLIN; //添加读事件到events当中 return true; } } return false; //fds数组已满 } }; \"]},\"390\":{\"h\":\"2.3 事件处理\",\"t\":[\"#pragma once #include \\\"socket.hpp\\\" #include <poll.h> #define BACK_LOG 5 #define NUM 1024 #define DFL_FD - 1 class PollServer { private: int _listen_sock; //监听套接字 int _port; //端口号 public: void HandlerEvent(struct pollfd fds[], int num) { for (int i = 0; i < num; i++) { if (fds[i].fd == DFL_FD) { //跳过无效的位置 continue; } if (fds[i].fd == _listen_sock&&fds[i].revents&POLLIN) { //连接事件就绪 struct sockaddr_in peer; memset(&peer, 0, sizeof(peer)); socklen_t len = sizeof(peer); int sock = accept(_listen_sock, (struct sockaddr*)&peer, &len); if (sock < 0) { //获取连接失败 std::cerr << \\\"accept error\\\" << std::endl; continue; } std::string peer_ip = inet_ntoa(peer.sin_addr); int peer_port = ntohs(peer.sin_port); std::cout << \\\"get a new link[\\\" << peer_ip << \\\":\\\" << peer_port << \\\"]\\\" << std::endl; if (!SetPollfds(fds, NUM, sock)) { //将获取到的套接字添加到fds数组中，并关心其读事件 close(sock); std::cout << \\\"poll server is full, close fd: \\\" << sock << std::endl; } } else if (fds[i].revents&POLLIN) { //读事件就绪 char buffer[1024]; ssize_t size = read(fds[i].fd, buffer, sizeof(buffer)-1); if (size > 0) { //读取成功 buffer[size] = '\\\\0'; std::cout << \\\"echo# \\\" << buffer << std::endl; } else if (size == 0) { //对端连接关闭 std::cout << \\\"client quit\\\" << std::endl; close(fds[i].fd); UnSetPollfds(fds, i); //将该文件描述符从fds数组中清除 } else { std::cerr << \\\"read error\\\" << std::endl; close(fds[i].fd); UnSetPollfds(fds, i); //将该文件描述符从fds数组中清除 } } } } private: bool SetPollfds(struct pollfd fds[], int num, int fd) { for (int i = 0; i < num; i++) { if (fds[i].fd == DFL_FD) { //该位置没有被使用 fds[i].fd = fd; fds[i].events |= POLLIN; //添加读事件到events当中 return true; } } return false; //fds数组已满 } void UnSetPollfds(struct pollfd fds[], int pos) { fds[pos].fd = DFL_FD; fds[pos].events = 0; fds[pos].revents = 0; } }; \"]},\"391\":{\"h\":\"2.4 Poll服务器测试\",\"t\":[\"#include \\\"poll_server.hpp\\\" #include <string> static void Usage(std::string proc) { std::cerr << \\\"Usage: \\\" << proc << \\\" port\\\" << std::endl; } int main(int argc, char* argv[]) { if (argc != 2) { Usage(argv[0]); exit(1); } int port = atoi(argv[1]); PollServer* svr = new PollServer(port); svr->InitPollServer(); svr->Run(); return 0; } \",\"因为我们编写的poll服务器在调用poll函数时，将timeout的值设置成了-1，因此运行服务器后如果没有客户端发来连接请求，那么服务器就会在调用poll函数后进行阻塞等待\",\"当我们用telnet工具连接poll服务器后，poll服务器调用的poll函数在检测到监听套接字的读事件就绪后就会调用accept获取建立好的连接，并打印输出客户端的IP和端口号，此时客户端发来的数据也能够成功被poll服务器收到并进行打印输出\",\"此外，poll服务器也是一个单进程服务器，但是它也可以同时为多个客户端提供服务\",\"当服务器端检测到客户端退出后，也会关闭对应的连接，并将对应的套接字从fds数组当中清除\"]},\"392\":{\"h\":\"第十一章：Linux的IO多路转接之epoll\"},\"393\":{\"h\":\"1.知识点思维导图\"},\"394\":{\"h\":\"2.epoll服务器代码\"},\"395\":{\"h\":\"2.1 EpollServer类\",\"t\":[\"#include \\\"socket.hpp\\\" #include <sys/epoll.h> #define BACK_LOG 5 #define SIZE 256 class EpollServer { private: int _listen_sock; //监听套接字 int _port; //端口号 int _epfd; //epoll模型 public: EpollServer(int port) : _port(port) {} void InitEpollServer() { _listen_sock = Socket::SocketCreate(); Socket::SocketBind(_listen_sock, _port); Socket::SocketListen(_listen_sock, BACK_LOG); //创建epoll模型 _epfd = epoll_create(SIZE); if (_epfd < 0) { std::cerr << \\\"epoll_create error\\\" << std::endl; exit(5); } } ~EpollServer() { if (_listen_sock >= 0) { close(_listen_sock); } if (_epfd >= 0) { close(_epfd); } } }; \"]},\"396\":{\"h\":\"2.2 运行服务器\",\"t\":[\"#include \\\"socket.hpp\\\" #include <sys/epoll.h> #define BACK_LOG 5 #define SIZE 256 #define MAX_NUM 64 class EpollServer { private: int _listen_sock; //监听套接字 int _port; //端口号 int _epfd; //epoll模型 public: void Run() { AddEvent(_listen_sock, EPOLLIN); //将监听套接字添加到epoll模型中，并关心其读事件 for (;;) { struct epoll_event revs[MAX_NUM]; int num = epoll_wait(_epfd, revs, MAX_NUM, -1); if (num < 0) { std::cerr << \\\"epoll_wait error\\\" << std::endl; continue; } else if (num == 0) { std::cout << \\\"timeout...\\\" << std::endl; continue; } else { //正常的事件处理 //std::cout<<\\\"有事件发生...\\\"<<std::endl; HandlerEvent(revs, num); } } } private: void AddEvent(int sock, uint32_t event) { struct epoll_event ev; ev.events = event; ev.data.fd = sock; epoll_ctl(_epfd, EPOLL_CTL_ADD, sock, &ev); } }; \"]},\"397\":{\"h\":\"2.3 事件处理\",\"t\":[\"#include \\\"socket.hpp\\\" #include <sys/epoll.h> #define BACK_LOG 5 #define SIZE 256 #define MAX_NUM 64 class EpollServer { private: int _listen_sock; //监听套接字 int _port; //端口号 int _epfd; //epoll模型 public: void HandlerEvent(struct epoll_event revs[], int num) { for (int i = 0; i < num; i++) { int fd = revs[i].data.fd; //就绪的文件描述符 if (fd == _listen_sock&&revs[i].events&EPOLLIN) { //连接事件就绪 struct sockaddr_in peer; memset(&peer, 0, sizeof(peer)); socklen_t len = sizeof(peer); int sock = accept(_listen_sock, (struct sockaddr*)&peer, &len); if (sock < 0) { //获取连接失败 std::cerr << \\\"accept error\\\" << std::endl; continue; } std::string peer_ip = inet_ntoa(peer.sin_addr); int peer_port = ntohs(peer.sin_port); std::cout << \\\"get a new link[\\\" << peer_ip << \\\":\\\" << peer_port << \\\"]\\\" << std::endl; AddEvent(sock, EPOLLIN); //将获取到的套接字添加到epoll模型中，并关心其读事件 } else if (revs[i].events&EPOLLIN) { //读事件就绪 char buffer[64]; ssize_t size = recv(fd, buffer, sizeof(buffer)-1, 0); if (size > 0) { //读取成功 buffer[size] = '\\\\0'; std::cout << \\\"echo# \\\" << buffer << std::endl; } else if (size == 0) { //对端连接关闭 std::cout << \\\"client quit\\\" << std::endl; close(fd); DelEvent(fd); //将文件描述符从epoll模型中删除 } else { std::cerr << \\\"recv error\\\" << std::endl; close(fd); DelEvent(fd); //将文件描述符从epoll模型中删除 } } } } private: void AddEvent(int sock, uint32_t event) { struct epoll_event ev; ev.events = event; ev.data.fd = sock; epoll_ctl(_epfd, EPOLL_CTL_ADD, sock, &ev); } void DelEvent(int sock) { epoll_ctl(_epfd, EPOLL_CTL_DEL, sock, nullptr); } }; \"]},\"398\":{\"h\":\"2.4 epoll服务器测试\",\"t\":[\"#include \\\"epoll_server.hpp\\\" #include <string> static void Usage(std::string proc) { std::cout << \\\"Usage: \\\" << proc << \\\" port\\\" << std::endl; } int main(int argc, char* argv[]) { if (argc != 2) { Usage(argv[0]); exit(1); } int port = atoi(argv[1]); EpollServer* svr = new EpollServer(port); svr->InitEpollServer(); svr->Run(); return 0; } \",\"因为编写epoll服务器在调用epoll_wait函数时，我们将timeout的值设置成了-1，因此运行服务器后如果没有客户端发来连接请求，那么服务器就会在调用epoll_wait函数后进行阻塞等待\",\"当我们用telnet工具连接epoll服务器后，epoll服务器调用的epoll_wait函数在检测到监听套接字的读事件就绪后就会调用accept获取建立好的连接，并打印输出客户端的IP和端口号，此时客户端发来的数据也能够成功被epoll服务器收到并进行打印输出\",\"此外，我们这里编写的也是一个单进程的epoll服务器，但是它可以同时为多个客户端提供服务\",\"我们可以用ls /proc/PID/fd命令，查看当前epoll服务器的文件描述符的使用情况。其中文件描述符0、1、2是默认打开的，分别对应的是标准输入、标准输出和标准错误，3号文件描述符对应的是监听套接字，4号文件描述符对应的是服务器创建的epoll模型，5号和6号文件描述符对应的分别是正在访问服务器的两个客户端\",\"当服务器端检测到客户端退出后，也会关闭对应的连接，此时epoll服务器对应的5号和6号文件描述符就关闭了\"]},\"399\":{\"h\":\"第十二章：Linux的动态库和静态库\"},\"400\":{\"h\":\"知识点思维导图\"},\"401\":{\"h\":\"第十三章：Linux进程间通信之管道\"},\"402\":{\"h\":\"1.知识点思维导图\"},\"403\":{\"h\":\"2.用命名管道实现server&client通信\",\"t\":[\"//comm.h #pragma once #include <stdio.h> #include <unistd.h> #include <sys/types.h> #include <sys/stat.h> #include <string.h> #include <fcntl.h> #define FILE_NAME \\\"myfifo\\\" //让客户端和服务端使用同一个命名管道 \",\"//server.c #include \\\"comm.h\\\" int main() { umask(0); //将文件默认掩码设置为0 if (mkfifo(FILE_NAME, 0666) < 0) { //使用mkfifo创建命名管道文件 perror(\\\"mkfifo\\\"); return 1; } int fd = open(FILE_NAME, O_RDONLY); //以读的方式打开命名管道文件 if (fd < 0) { perror(\\\"open\\\"); return 2; } char msg[128]; while (1) { msg[0] = '\\\\0'; //每次读之前将msg清空 //从命名管道当中读取信息 ssize_t s = read(fd, msg, sizeof(msg)-1); if (s > 0) { msg[s] = '\\\\0'; //手动设置'\\\\0'，便于输出 printf(\\\"client# %s\\\\n\\\", msg); //输出客户端发来的信息 } else if (s == 0) { printf(\\\"client quit!\\\\n\\\"); break; } else { printf(\\\"read error!\\\\n\\\"); break; } } close(fd); //通信完毕，关闭命名管道文件 return 0; } \",\"//client.c #include \\\"comm.h\\\" int main() { int fd = open(FILE_NAME, O_WRONLY); //以写的方式打开命名管道文件 if (fd < 0) { perror(\\\"open\\\"); return 1; } char msg[128]; while (1) { msg[0] = '\\\\0'; //每次读之前将msg清空 printf(\\\"Please Enter# \\\"); //提示客户端输入 fflush(stdout); //从客户端的标准输入流读取信息 ssize_t s = read(0, msg, sizeof(msg)-1); if (s > 0) { msg[s - 1] = '\\\\0'; //将信息写入命名管道 write(fd, msg, strlen(msg)); } } close(fd); //通信完毕，关闭命名管道文件 return 0; } \",\"代码编写完毕后，先将服务端进程运行起来，之后我们就能在客户端看到这个已经被创建的命名管道文件\",\"接着再将客户端也运行起来，此时我们从客户端写入的信息被客户端写入到命名管道当中，服务端再从命名管道当中将信息读取出来打印在服务端的显示器上，该现象说明服务端是能够通过命名管道获取到客户端发来的信息的，换句话说，此时这两个进程之间是能够通信的\",\"当客户端和服务端运行起来时，我们还可以通过ps命令查看这两个进程的信息，可以发现这两个进程确实是两个毫不相关的进程，因为它们的PID和PPID都不相同。也就证明了，命名管道是可以实现两个毫不相关进程之间的通信的\",\"服务端和客户端之间的退出关系：当客户端退出后，服务端将管道当中的数据读完后就再也读不到数据了，那么此时服务端也就会去执行它的其他代码了（在当前代码中是直接退出了）\",\"当服务端退出后，客户端写入管道的数据就不会被读取了，也就没有意义了，那么当客户端下一次再向管道写入数据时，就会收到操作系统发来的13号信号(SIGPIPE)，此时客户端就被操作系统强制杀掉了\",\"通信是在内存当中进行的。若是我们只让客户端向管道写入数据，而服务端不从管道读取数据，那么这个管道文件的大小会不会发生变化呢？\",\"//server.c #include \\\"comm.h\\\" int main() { umask(0); //将文件默认掩码设置为0 if (mkfifo(FILE_NAME, 0666) < 0) { //使用mkfifo创建命名管道文件 perror(\\\"mkfifo\\\"); return 1; } int fd = open(FILE_NAME, O_RDONLY); //以读的方式打开命名管道文件 if (fd < 0) { perror(\\\"open\\\"); return 2; } while (1) { //服务端不读取管道信息 } close(fd); //通信完毕，关闭命名管道文件 return 0; } \",\"可以看到，尽管服务端不读取管道当中的数据，但是管道当中的数据并没有被刷新到磁盘，使用ll命令看到命名管道文件的大小依旧为0，也就说明了双方进程之间的通信依旧是在内存当中进行的，和匿名管道通信是一样的\"]},\"404\":{\"h\":\"3.用命名管道实现派发计算任务\",\"t\":[\"需要注意的是两个进程之间的通信，并不是简单的发送字符串而已，服务端是会对客户端发送过来的信息进行某些处理的\",\"这里我们以客户端向服务端派发计算任务为例，客户端通过管道向服务端发送双操作数的计算请求，服务端接收到客户端的信息后需要计算出相应的结果\",\"这里我们无需更改客户端的代码，只需改变服务端处理通信信息的逻辑即可\",\"//server.c #include \\\"comm.h\\\" int main() { umask(0); //将文件默认掩码设置为0 if (mkfifo(FILE_NAME, 0666) < 0) { //使用mkfifo创建命名管道文件 perror(\\\"mkfifo\\\"); return 1; } int fd = open(FILE_NAME, O_RDONLY); //打开命名管道文件 if (fd < 0) { perror(\\\"open\\\"); return 2; } char msg[128]; while (1) { msg[0] = '\\\\0'; //每次读之前将msg清空 //从命名管道当中读取信息 ssize_t s = read(fd, msg, sizeof(msg)-1); if (s > 0) { msg[s] = '\\\\0'; //手动设置'\\\\0'，便于输出 printf(\\\"client# %s\\\\n\\\", msg); //服务端进行计算任务 char* lable = \\\"+-*/%\\\"; char* p = msg; int flag = 0; while (*p) { switch (*p) { case '+': flag = 0; break; case '-': flag = 1; break; case '*': flag = 2; break; case '/': flag = 3; break; case '%': flag = 4; break; } p++; } char* data1 = strtok(msg, \\\"+-*/%\\\"); char* data2 = strtok(NULL, \\\"+-*/%\\\"); int num1 = atoi(data1); int num2 = atoi(data2); int ret = 0; switch (flag) { case 0: ret = num1 + num2; break; case 1: ret = num1 - num2; break; case 2: ret = num1 * num2; break; case 3: ret = num1 / num2; break; case 4: ret = num1 % num2; break; } printf(\\\"%d %c %d = %d\\\\n\\\", num1, lable[flag], num2, ret); //打印计算结果 } else if (s == 0) { printf(\\\"client quit!\\\\n\\\"); break; } else { printf(\\\"read error!\\\\n\\\"); break; } } close(fd); //通信完毕，关闭命名管道文件 return 0; } \",\"此时服务端接收到客户端的信息后，需要进行的处理动作就不是将其打印到显示器了，而是需要将信息经过进一步的处理，从而得到相应的结果\"]},\"405\":{\"h\":\"4.用命名管道实现进程遥控\",\"t\":[\"比较有意思的是，我们可以通过一个进程来控制另一个进程的行为，比如我们从客户端输入命令到管道当中，再让服务端将管道当中的命令读取出来并执行下面我们只实现了让服务端执行不带选项的命令，若是想让服务端执行带选项的命令，可以对管道当中获取的命令进行解析处理。这里的实现非常简单，只需让服务端从管道当中读取命令后创建子进程，然后再进行进程程序替换即可这里也无需更改客户端的代码，只需改变服务端处理通信信息的逻辑即可\",\"#include \\\"comm.h\\\" int main() { umask(0); //将文件默认掩码设置为0 if (mkfifo(FILE_NAME, 0666) < 0) { //使用mkfifo创建命名管道文件 perror(\\\"mkfifo\\\"); return 1; } int fd = open(FILE_NAME, O_RDONLY); //以读的方式打开命名管道文件 if (fd < 0) { perror(\\\"open\\\"); return 2; } char msg[128]; while (1) { msg[0] = '\\\\0'; //每次读之前将msg清空 //从命名管道当中读取信息 ssize_t s = read(fd, msg, sizeof(msg)-1); if (s > 0) { msg[s] = '\\\\0'; //手动设置'\\\\0'，便于输出 printf(\\\"client# %s\\\\n\\\", msg); if (fork() == 0) { //child execlp(msg, msg, NULL); //进程程序替换 exit(1); } waitpid(-1, NULL, 0); //等待子进程 } else if (s == 0) { printf(\\\"client quit!\\\\n\\\"); break; } else { printf(\\\"read error!\\\\n\\\"); break; } } close(fd); //通信完毕，关闭命名管道文件 return 0; } \",\"此时服务端接收到客户端的信息后，便进行进程程序替换，进而执行客户端发送过来的命令\"]},\"406\":{\"h\":\"5.用命名管道实现文件拷贝\",\"t\":[\"其中服务端需要做的就是，创建命名管道并以读的方式打开该命名管道，再创建一个名为file-bat.txt的文件，之后需要做的就是将从管道当中读取到的数据写入到file-bat.txt文件当中即可\",\"//server.c #include \\\"comm.h\\\" int main() { umask(0); //将文件默认掩码设置为0 if (mkfifo(FILE_NAME, 0666) < 0) { //使用mkfifo创建命名管道文件 perror(\\\"mkfifo\\\"); return 1; } int fd = open(FILE_NAME, O_RDONLY); //以读的方式打开命名管道文件 if (fd < 0) { perror(\\\"open\\\"); return 2; } //创建文件file-bat.txt，并以写的方式打开该文件 int fdout = open(\\\"file-bat.txt\\\", O_CREAT | O_WRONLY, 0666); if (fdout < 0) { perror(\\\"open\\\"); return 3; } char msg[128]; while (1) { msg[0] = '\\\\0'; //每次读之前将msg清空 //从命名管道当中读取信息 ssize_t s = read(fd, msg, sizeof(msg)-1); if (s > 0) { write(fdout, msg, s); //将读取到的信息写入到file-bat.txt文件当中 } else if (s == 0) { printf(\\\"client quit!\\\\n\\\"); break; } else { printf(\\\"read error!\\\\n\\\"); break; } } close(fd); //通信完毕，关闭命名管道文件 close(fdout); //数据写入完毕，关闭file-bat.txt文件 return 0; } \",\"而客户端需要做的就是，以写的方式打开这个已经存在的命名管道文件，再以读的方式打开file.txt文件，之后需要做的就是将file.txt文件当中的数据读取出来并写入管道当中即可\",\"//client.c #include \\\"comm.h\\\" int main() { int fd = open(FILE_NAME, O_WRONLY); //以写的方式打开命名管道文件 if (fd < 0) { perror(\\\"open\\\"); return 1; } int fdin = open(\\\"file.txt\\\", O_RDONLY); //以读的方式打开file.txt文件 if (fdin < 0) { perror(\\\"open\\\"); return 2; } char msg[128]; while (1) { //从file.txt文件当中读取数据 ssize_t s = read(fdin, msg, sizeof(msg)); if (s > 0) { write(fd, msg, s); //将读取到的数据写入到命名管道当中 } else if (s == 0) { printf(\\\"read end of file!\\\\n\\\"); break; } else { printf(\\\"read error!\\\\n\\\"); break; } } close(fd); //通信完毕，关闭命名管道文件 close(fdin); //数据读取完毕，关闭file.txt文件 return 0; } \",\"共用头文件的代码和之前的一样，如下：\",\"//comm.h #pragma once #include <stdio.h> #include <unistd.h> #include <sys/types.h> #include <sys/stat.h> #include <string.h> #include <fcntl.h> #define FILE_NAME \\\"myfifo\\\" //让客户端和服务端使用同一个命名管道 \",\"编写完代码后，先运行服务端，再运行客户端，一瞬间这两个进程就相继运行结束了\",\"使用管道实现文件的拷贝有什么意义？\",\"因为这里是使用管道在本地进行的文件拷贝，所以看似没什么意义，但我们若是将这里的管道想象成“网络”，将客户端想象成“Windows Xshell”，再将服务端想象成“centos服务器”。那我们此时实现的就是文件上传的功能，若是将方向反过来，那么实现的就是文件下载的功能\"]},\"407\":{\"h\":\"第十四章：Linux进程间通信之System V IPC\"},\"408\":{\"h\":\"知识点思维导图\"},\"409\":{\"h\":\"第十五章：Linux进程间通信之POSIX\"},\"410\":{\"h\":\"知识点思维导图\"},\"411\":{\"h\":\"第十六章：Linux进程信号\"},\"412\":{\"h\":\"知识点思维导图\"},\"413\":{\"h\":\"第十七章：Linux任务管理与守护进程\"},\"414\":{\"h\":\"知识点思维导图\"},\"415\":{\"h\":\"第十八章：Linux多线程\"},\"416\":{\"h\":\"知识点思维导图\"},\"417\":{\"h\":\"第十九章：Linux线程安全\"},\"418\":{\"h\":\"知识点思维导图\"},\"419\":{\"h\":\"第二章：Linux权限管理\"},\"420\":{\"h\":\"知识点思维导图\"},\"421\":{\"h\":\"第三章：Linux开发工具使用\"},\"422\":{\"h\":\"知识点思维导图\"},\"423\":{\"h\":\"第四章：Linux进程状态\"},\"424\":{\"h\":\"知识点思维导图\"},\"425\":{\"h\":\"第五章：Linux环境变量与地址空间\"},\"426\":{\"h\":\"知识点思维导图\"},\"427\":{\"h\":\"第六章：Linux进程控制\"},\"428\":{\"h\":\"知识点思维导图\"},\"429\":{\"h\":\"第七章：Linux的基础IO\"},\"430\":{\"h\":\"知识点思维导图\"},\"431\":{\"h\":\"第八章：Linux的高级IO\"},\"432\":{\"h\":\"知识点思维导图\"},\"433\":{\"h\":\"第九章：Linux的IO多路转接之select\"},\"434\":{\"h\":\"1.知识点思维导图\"},\"435\":{\"h\":\"2.select服务器代码\"},\"436\":{\"h\":\"2.1 select服务器的Socket类\",\"t\":[\"#pragma once #include <iostream> #include <unistd.h> #include <sys/socket.h> #include <sys/types.h> #include <arpa/inet.h> #include <cstring> #include <cstdlib> class Socket { public: //创建套接字 static int SocketCreate() { int sock = socket(AF_INET, SOCK_STREAM, 0); if (sock < 0) { std::cerr << \\\"socket error\\\" << std::endl; exit(2); } //设置端口复用 int opt = 1; setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)); return sock; } //绑定 static void SocketBind(int sock, int port) { struct sockaddr_in local; memset(&local, 0, sizeof(local)); local.sin_family = AF_INET; local.sin_port = htons(port); local.sin_addr.s_addr = INADDR_ANY; socklen_t len = sizeof(local); if (bind(sock, (struct sockaddr*)&local, len) < 0) { std::cerr << \\\"bind error\\\" << std::endl; exit(3); } } //监听 static void SocketListen(int sock, int backlog) { if (listen(sock, backlog) < 0) { std::cerr << \\\"listen error\\\" << std::endl; exit(4); } } }; \"]},\"437\":{\"h\":\"2.2 select服务器的SelectServer类\",\"t\":[\"#pragma once #include \\\"socket.hpp\\\" #include <sys/select.h> #define BACK_LOG 5 class SelectServer { private: int _listen_sock; //监听套接字 int _port; //端口号 public: SelectServer(int port) : _port(port) {} void InitSelectServer() { _listen_sock = Socket::SocketCreate(); Socket::SocketBind(_listen_sock, _port); Socket::SocketListen(_listen_sock, BACK_LOG); } ~SelectServer() { if (_listen_sock >= 0) { close(_listen_sock); } } }; \"]},\"438\":{\"h\":\"2.3 select服务器的运行\",\"t\":[\"#pragma once #include \\\"socket.hpp\\\" #include <sys/select.h> #define BACK_LOG 5 #define NUM 1024 #define DFL_FD - 1 class SelectServer { private: int _listen_sock; //监听套接字 int _port; //端口号 public: void Run() { fd_set readfds; //读文件描述符集 int fd_array[NUM]; //保存需要被监视读事件是否就绪的文件描述符 ClearFdArray(fd_array, NUM, DFL_FD); //将数组中的所有位置设置为无效 fd_array[0] = _listen_sock; //将监听套接字添加到fd_array数组中的第0个位置 for (;;) { FD_ZERO(&readfds); //清空readfds //将fd_array数组当中的文件描述符添加到readfds当中，并记录最大的文件描述符 int maxfd = DFL_FD; for (int i = 0; i < NUM; i++) { if (fd_array[i] == DFL_FD) //跳过无效的位置 continue; FD_SET(fd_array[i], &readfds); //将有效位置的文件描述符添加到readfds当中 if (fd_array[i] > maxfd) //更新最大文件描述符 maxfd = fd_array[i]; } switch (select(maxfd + 1, &readfds, nullptr, nullptr, nullptr)) { case 0: std::cout<<\\\"timeout...\\\"<<std::endl; break; case -1: std::cerr << \\\"select error\\\" << std::endl; break; default: //正常的事件处理 std::cout<<\\\"有事件发生...\\\"<<std::endl; //HandlerEvent(readfds, fd_array, NUM); break; }//end switch }//end for } private: void ClearFdArray(int fd_array[], int num, int default_fd) { for (int i = 0; i < num; i++) { fd_array[i] = default_fd; } } }; \"]},\"439\":{\"h\":\"2.4 timeout测试\",\"t\":[\"#include \\\"select_server.hpp\\\" #include <string> static void Usage(std::string proc) { std::cerr << \\\"Usage: \\\" << proc << \\\" port\\\" << std::endl; } int main(int argc, char* argv[]) { if (argc != 2) { Usage(argv[0]); exit(1); } int port = atoi(argv[1]); SelectServer* svr = new SelectServer(port); svr->InitSelectServer(); svr->Run(); return 0; } \",\"由于当前服务器调用select函数时直接将timeout设置为了nullptr，因此select函数调用后会进行阻塞等待。而服务器在第一次调用select函数时只让select监视监听套接字的读事件，所以运行服务器后如果没有客户端发来连接请求，那么读事件就不会就绪，而服务器则会一直在第一次调用的select函数中进行阻塞等待\",\"当我们借助telnet工具向select服务器发起连接请求后，select函数就会立马检测到监听套接字的读事件就绪，此时select函数便会成功返回，并将我们设置的提示语句进行打印输出，因为当前程序并没有对就绪事件进行处理，此后每次select函数一调用就会检测到读事件就绪并成功返回，因此会看到屏幕不断打印输出提示语句\",\"如果服务器在调用select函数时将timeout的值设置为0，那么select函数调用后就会进行非阻塞等待，无论被监视的文件描述符上的事件是否就绪，select检测后都会立即返回\",\"此时如果select监视的文件描述符上有事件就绪，那么select函数的返回值就是大于0的，如果select监视的文件描述符上没有事件就绪，那么select的返回值就是等于0的\",\"struct timeval timeout = { 0, 0 }; //每隔0秒timeout一次 switch (select(maxfd + 1, &readfds, nullptr, nullptr, &timeout)) { case 0: std::cout << \\\"timeout...\\\" << std::endl; break; case -1: std::cerr << \\\"select error\\\" << std::endl; break; default: //正常的事件处理 std::cout << \\\"有事件发生...\\\" << std::endl; //HandlerEvent(readfds, fd_array, NUM); break; } \",\"运行服务器后如果没有客户端发来连接请求，那么select服务器就会一直调用select函数进行轮询检测，但每次检测时读事件都不就绪，因此每次select函数的返回值都是0，因此就会不断打印“timeout…”提示语句\",\"当有客户端发来连接请求后，select在某次轮询检测时就会检测到监听套接字的读事件就绪，此时select函数便会成功返回，并将我们设置的提示语句进行打印输出\",\"如果服务器在调用select函数时将timeout的值设置为特定的时间值，比如我们这里将timeout的值设置为5秒，那么select函数调用后的5秒内会进行阻塞等待，如果5秒后依旧没有读事件就绪，那么select函数将会进行超时返回\",\"我们可以将select函数超时返回和成功返回时timeout的值进行打印，以验证timeout是一个输入输出型参数\",\"struct timeval timeout = { 5, 0 }; //每隔5秒timeout一次 switch (select(maxfd + 1, &readfds, nullptr, nullptr, &timeout)) { case 0: std::cout << \\\"timeout: \\\" << timeout.tv_sec << std::endl; break; case -1: std::cerr << \\\"select error\\\" << std::endl; break; default: //正常的事件处理 std::cout << \\\"有事件发生... timeout: \\\" << timeout.tv_sec << std::endl; //HandlerEvent(readfds, fd_array, NUM); break; } \",\"运行服务器后如果没有客户端发来连接请求，那么每次select函数调用5秒后都会进行超时返回，并且每次打印输出timeout的值都是0，也就意味着timeout的时间是被耗尽了的\",\"当有客户端发来连接请求后，在某次调用select函数时就会检测到监听套接字的读事件就绪，此时select函数便会成功返回，并将我们设置的提示语句进行打印输出\",\"因为当前程序并没有对就绪事件进行处理，因此在第一次select检测到读事件就绪后，之后每次select函数一调用就会检测到读事件就绪并成功返回，因此会看到屏幕不断打印输出提示语句，并且后续打印输出timeout的值都是4，表示本次select检测到读事件就绪时timeout的剩余时间为4秒\",\"因为timeout和readfds、writefds与exceptfds一样，它们都是输入输出型参数，因此如果要使用timeout参数，那么在每次调用select函数之前也都需要对timeout的值进行重新设置\"]},\"440\":{\"h\":\"2.5 select服务器事件处理\",\"t\":[\"#pragma once #include \\\"socket.hpp\\\" #include <sys/select.h> #define BACK_LOG 5 #define NUM 1024 #define DFL_FD - 1 class SelectServer { private: int _listen_sock; //监听套接字 int _port; //端口号 public: void HandlerEvent(const fd_set& readfds, int fd_array[], int num) { for (int i = 0; i < num; i++) { if (fd_array[i] == DFL_FD) { //跳过无效的位置 continue; } if (fd_array[i] == _listen_sock&&FD_ISSET(fd_array[i], &readfds)) { //连接事件就绪 //获取连接 struct sockaddr_in peer; memset(&peer, 0, sizeof(peer)); socklen_t len = sizeof(peer); int sock = accept(_listen_sock, (struct sockaddr*)&peer, &len); if (sock < 0) { //获取连接失败 std::cerr << \\\"accept error\\\" << std::endl; continue; } std::string peer_ip = inet_ntoa(peer.sin_addr); int peer_port = ntohs(peer.sin_port); std::cout << \\\"get a new link[\\\" << peer_ip << \\\":\\\" << peer_port << \\\"]\\\" << std::endl; if (!SetFdArray(fd_array, num, sock)) { //将获取到的套接字添加到fd_array当中 close(sock); std::cout << \\\"select server is full, close fd: \\\" << sock << std::endl; } } else if (FD_ISSET(fd_array[i], &readfds)) { //读事件就绪 char buffer[1024]; ssize_t size = read(fd_array[i], buffer, sizeof(buffer)-1); if (size > 0) { //读取成功 buffer[size] = '\\\\0'; std::cout << \\\"echo# \\\" << buffer << std::endl; } else if (size == 0) { //对端连接关闭 std::cout << \\\"client quit\\\" << std::endl; close(fd_array[i]); fd_array[i] = DFL_FD; //将该文件描述符从fd_array中清除 } else { std::cerr << \\\"read error\\\" << std::endl; close(fd_array[i]); fd_array[i] = DFL_FD; //将该文件描述符从fd_array中清除 } } } } private: bool SetFdArray(int fd_array[], int num, int fd) { for (int i = 0; i <num; i++) { if (fd_array[i] == DFL_FD) { //该位置没有被使用 fd_array[i] = fd; return true; } } return false; //fd_array数组已满 } }; \",\"说明一下：当调用accept函数从底层获取上来连接后，不能立即调用read函数读取该连接当中的数据，因为此时新连接当中的数据可能并没有就绪，如果直接调用read函数可能需要进行阻塞等待，我们应该将这个等待过程交给select函数来完成，因此在获取完连接后直接将该连接对应的文件描述符添加到fd_array数组当中就行了，当该连接的读事件就绪时select函数会告知我们，那个时候我们再进行数据读取就不会被阻塞住了添加文件描述符到fd_array数组当中，本质就是遍历fd_array数组，找到一个没有被使用的位置将该文件描述符添加进去即可。但有可能fd_array数组中全部的位置都已经被占用了，那么文件描述符就会添加失败，此时就只能将刚刚获取上来的连接对应的套接字进行关闭，因为此时服务器已经没有能力处理这个连接了\"]},\"441\":{\"h\":\"3.select服务器测试\",\"t\":[\"至此select服务器编写完毕，重新编译后运行服务器，并用telnet工具连接我们的服务器，此时通过telnet向服务器发送的数据就能够被服务器读到并且打印输出了\",\"此外，虽然当前的select服务器是一个单进程的服务器，但它却可以同时为多个客户端提供服务，根本原因就是因为select函数调用后会告知select服务器是哪个客户端对应的连接事件就绪了，此时select服务器就可以读取对应客户端发来的数据，读取完后又会调用select函数等待某个客户端连接的读事件就绪\",\"当服务器检测到客户端退出后，也会关闭对应的连接，并将对应的套接字从fd_array数组当中清除\"]},\"442\":{\"h\":\"4.select服务器存在的问题\",\"t\":[\"服务器没有对客户端发进行响应。select服务器如果要向客户端发送数据，不能直接调用write函数，因为调用write函数时实际也分为“等”和“拷贝”两步，我们也应该将“等”的这个过程交给select函数，因此在每次调用select函数之前，除了需要重新设置readfds还需要重新设置writefds，并且还需要一个数组来保存需要被监视写事件是否就绪的文件描述符，当某一文件描述符的写事件就绪时我们才能够调用write函数向客户端发送数据\",\"没有定制协议。代码中读取数据时并没有按照某种规则进行读取，此时就可能造成粘包问题，根本原因就是因为我们没有定制协议，比如HTTP协议规定在读取底层数据时读取到空行就表明读完了一个HTTP报头，此时再根据HTTP报头当中的Content-Length属性得知正文的长度，最终就能够读取到一个完整的HTTP报文，HTTP协议通过这种方式就避免了粘包问题\",\"没有对应的输入输出缓冲区。代码中直接将读取的数据存储到了字符数组buffer当中，这是不严谨的，因为本次数据读取可能并没有读取到一个完整的报文，此时服务器就不能进行数据的分析处理，应该将读取到的数据存储到一个输入缓冲区当中，当读取到一个完整的报文后再让服务器进行处理。此外，如果服务器要能够对客户端进行响应，那么服务器的响应数据也不应该直接调用write函数发送给客户端，应该先存储到一个输出缓冲区当中，因为响应数据可能很庞大，无法一次发送完毕，可能需要进行分批发送\"]},\"443\":{\"h\":\"第一章：绪论\"},\"444\":{\"h\":\"1.绪论\"},\"445\":{\"h\":\"第二章：线性表\"},\"446\":{\"h\":\"1.线性表\"},\"447\":{\"h\":\"2.线性表的链式表示\"},\"448\":{\"h\":\"第三章：栈和队列\"},\"449\":{\"h\":\"1.栈\"},\"450\":{\"h\":\"2.队列\"},\"451\":{\"h\":\"第四章：串、数组和特殊矩阵\"},\"452\":{\"h\":\"1.串、数组和特殊矩阵\"},\"453\":{\"h\":\"第五章：树和二叉树\"},\"454\":{\"h\":\"1.树与二叉树\"},\"455\":{\"h\":\"2.二叉树的遍历(递归方式)\"},\"456\":{\"h\":\"3.二叉树的遍历(非递归方式)\"},\"457\":{\"h\":\"4.线索二叉树\"},\"458\":{\"h\":\"5.树和森林\"},\"459\":{\"h\":\"6.树与二叉树的应用\"},\"460\":{\"h\":\"第六章：图\"},\"461\":{\"h\":\"1.图的定义\"},\"462\":{\"h\":\"2.图的存储与基本操作\"},\"463\":{\"h\":\"3.图的遍历\"},\"464\":{\"h\":\"4.图的应用\"},\"465\":{\"h\":\"5.拓扑排序\"},\"466\":{\"h\":\"6.关键路径\"},\"467\":{\"h\":\"第七章：查找\"},\"468\":{\"h\":\"1.查找\"},\"469\":{\"h\":\"2.B树和B+树\"},\"470\":{\"h\":\"3.散列表\"},\"471\":{\"h\":\"第八章：排序\"},\"472\":{\"h\":\"1.插入排序\"},\"473\":{\"h\":\"2.交换排序\"},\"474\":{\"h\":\"3.选择排序\"},\"475\":{\"h\":\"4.排序算法总结\"},\"476\":{\"h\":\"5.外部排序算法\"},\"477\":{\"h\":\"第一章：计算机系统概述\"},\"478\":{\"h\":\"1.计算机系统概述\"},\"479\":{\"h\":\"2.计算机的性能指标\"},\"480\":{\"h\":\"第二章：数据的表示和运算\"},\"481\":{\"h\":\"1.数据的表示和运算\"},\"482\":{\"h\":\"第三章：存储器层次结构\"},\"483\":{\"h\":\"1.存储系统\"},\"484\":{\"h\":\"2.虚拟存储器\"},\"485\":{\"h\":\"第四章：指令系统\"},\"486\":{\"h\":\"1.指令系统\"},\"487\":{\"h\":\"第五章：中央处理器\"},\"488\":{\"h\":\"1.中央处理器\"},\"489\":{\"h\":\"第六章：总线\"},\"490\":{\"h\":\"1.总线\"},\"491\":{\"h\":\"第七章：输入输出系统\"},\"492\":{\"h\":\"1.输入/输出系统\"},\"493\":{\"h\":\"第一章：操作系统概述\"},\"494\":{\"h\":\"1.操作系统概述\"},\"495\":{\"h\":\"2.系统调用\"},\"496\":{\"h\":\"3.中断和异常\"},\"497\":{\"h\":\"第二章：进程管理\"},\"498\":{\"h\":\"1.进程管理\"},\"499\":{\"h\":\"2.线程管理\"},\"500\":{\"h\":\"3.处理机调度\"},\"501\":{\"h\":\"4.进程同步\"},\"502\":{\"h\":\"5.死锁\"},\"503\":{\"h\":\"第三章：内存管理\"},\"504\":{\"h\":\"1.内存管理\"},\"505\":{\"h\":\"第四章：文件管理\"},\"506\":{\"h\":\"1.文件管理\"},\"507\":{\"h\":\"第五章：输入输出管理\"},\"508\":{\"h\":\"1.I/O管理\"},\"509\":{\"h\":\"第一章：计算机网络体系结构\"},\"510\":{\"h\":\"1.计算机网络体系结构\"},\"511\":{\"h\":\"2.OSI参考模型\"},\"512\":{\"h\":\"第二章：物理层\"},\"513\":{\"h\":\"1.物理层\"},\"514\":{\"h\":\"第三章：数据链路层\"},\"515\":{\"h\":\"1.数据链路层\"},\"516\":{\"h\":\"第四章：网络层\"},\"517\":{\"h\":\"1.网络层\"},\"518\":{\"h\":\"第五章：传输层\"},\"519\":{\"h\":\"1.传输层\"},\"520\":{\"h\":\"第六章：应用层\"},\"521\":{\"h\":\"1.应用层\"},\"522\":{\"h\":\"第七章：网络安全\"},\"523\":{\"h\":\"1.网络安全\"},\"524\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"525\":{\"h\":\"2.算法题型\"},\"526\":{\"h\":\"算法学习\"},\"527\":{\"h\":\"1.算法知识\"},\"528\":{\"h\":\"1. C语言\"},\"529\":{\"h\":\"编程学习\"},\"530\":{\"h\":\"2. CPP\"},\"531\":{\"h\":\"3. Linux\"},\"532\":{\"h\":\"1.数据结构\"},\"533\":{\"h\":\"计算机基础理论\"},\"534\":{\"h\":\"2.计算机组成原理\"},\"535\":{\"h\":\"3.操作系统\"},\"536\":{\"h\":\"4.计算机网络\"}},\"dirtCount\":0,\"index\":[[\"死锁\",{\"0\":{\"502\":1}}],[\"散列表\",{\"0\":{\"470\":1}}],[\"拓扑排序\",{\"0\":{\"465\":1}}],[\"串\",{\"0\":{\"451\":1,\"452\":1}}],[\"绪论\",{\"0\":{\"443\":1,\"444\":1}}],[\"服务器没有对客户端发进行响应\",{\"1\":{\"442\":1}}],[\"服务端进行计算任务\",{\"1\":{\"404\":1}}],[\"服务端接收到客户端的信息后需要计算出相应的结果\",{\"1\":{\"404\":1}}],[\"服务端是会对客户端发送过来的信息进行某些处理的\",{\"1\":{\"404\":1}}],[\"服务端不读取管道信息\",{\"1\":{\"403\":1}}],[\"服务端将管道当中的数据读完后就再也读不到数据了\",{\"1\":{\"403\":1}}],[\"服务端和客户端之间的退出关系\",{\"1\":{\"403\":1}}],[\"服务端再从命名管道当中将信息读取出来打印在服务端的显示器上\",{\"1\":{\"403\":1}}],[\"监听\",{\"1\":{\"436\":1}}],[\"监听套接字\",{\"1\":{\"388\":1,\"389\":1,\"390\":1,\"395\":1,\"396\":1,\"397\":1,\"437\":1,\"438\":1,\"440\":1}}],[\"绑定\",{\"1\":{\"436\":1}}],[\"便进行进程程序替换\",{\"1\":{\"405\":1}}],[\"便于输出\",{\"1\":{\"403\":1,\"404\":1,\"405\":1}}],[\"客户端通过管道向服务端发送双操作数的计算请求\",{\"1\":{\"404\":1}}],[\"客户端写入管道的数据就不会被读取了\",{\"1\":{\"403\":1}}],[\"事件处理\",{\"0\":{\"390\":1,\"397\":1}}],[\"清空readfds\",{\"1\":{\"438\":1}}],[\"清空数组中的所有位置\",{\"1\":{\"389\":1}}],[\"清理指针\",{\"1\":{\"376\":1}}],[\"端口号\",{\"1\":{\"388\":1,\"389\":1,\"390\":1,\"395\":1,\"396\":1,\"397\":1,\"437\":1,\"438\":1,\"440\":1}}],[\"捕获基类异常\",{\"1\":{\"382\":1}}],[\"捕获std\",{\"1\":{\"382\":1}}],[\"抛出\",{\"1\":{\"382\":1}}],[\"抛出自定义异常\",{\"1\":{\"382\":1}}],[\"抛出异常\",{\"1\":{\"382\":1}}],[\"抛弃stuid\",{\"1\":{\"373\":1}}],[\"抛弃派生类特有内容\",{\"1\":{\"373\":1}}],[\"异常关键字try\",{\"1\":{\"382\":1}}],[\"异或哈希\",{\"1\":{\"177\":2}}],[\"启动生产者和消费者线程\",{\"1\":{\"379\":1}}],[\"启发式搜索\",{\"1\":{\"78\":1}}],[\"立刻返回false\",{\"1\":{\"379\":1}}],[\"手动设置\",{\"1\":{\"403\":1,\"404\":1,\"405\":1}}],[\"手动释放互斥锁\",{\"1\":{\"379\":1}}],[\"手动解锁互斥量\",{\"1\":{\"379\":1}}],[\"手动锁定互斥量\",{\"1\":{\"379\":1}}],[\"专门用于递归函数中的加锁操作\",{\"1\":{\"379\":1}}],[\"影响到外部实参\",{\"1\":{\"379\":1}}],[\"获得该线程的id\",{\"1\":{\"379\":1}}],[\"获取连接\",{\"1\":{\"440\":1}}],[\"获取连接失败\",{\"1\":{\"390\":1,\"397\":1,\"440\":1}}],[\"获取线程id的方式\",{\"1\":{\"379\":1}}],[\"获取a的类型\",{\"1\":{\"379\":1}}],[\"获取表达式的类型信息\",{\"1\":{\"379\":1}}],[\"获取表达式的类型\",{\"1\":{\"379\":1}}],[\"获取数据的存储大小\",{\"0\":{\"335\":1}}],[\"获取数组的最大元素\",{\"1\":{\"56\":1}}],[\"获取当前文件指针位置\",{\"1\":{\"310\":1}}],[\"获取当前的时间\",{\"1\":{\"291\":1}}],[\"获取文件大小\",{\"1\":{\"310\":1}}],[\"获取输入\",{\"1\":{\"309\":1}}],[\"获取成员的值\",{\"1\":{\"302\":1}}],[\"获取单个成员\",{\"1\":{\"302\":1,\"303\":1}}],[\"获取用户输入的油号和油量\",{\"1\":{\"297\":1}}],[\"获取里面存储的值\",{\"1\":{\"249\":1}}],[\"获取指定位置的元素\",{\"1\":{\"243\":1}}],[\"获取父节点的索引\",{\"1\":{\"209\":1}}],[\"获取右子节点的索引\",{\"1\":{\"209\":1}}],[\"获取左子节点的索引\",{\"1\":{\"209\":1}}],[\"获取节点\",{\"1\":{\"205\":1,\"211\":1}}],[\"获取节点高度\",{\"1\":{\"199\":1}}],[\"获取平衡因子\",{\"1\":{\"199\":1}}],[\"获取中序遍历中\",{\"1\":{\"195\":1}}],[\"获取中序遍历后继节点需要o\",{\"1\":{\"195\":1}}],[\"获取索引为\",{\"1\":{\"190\":1}}],[\"获取前序遍历\",{\"1\":{\"190\":1}}],[\"获取它的值\",{\"1\":{\"190\":1}}],[\"获取所有值\",{\"1\":{\"167\":1}}],[\"获取所有键\",{\"1\":{\"167\":1}}],[\"获取所有键值对\",{\"1\":{\"167\":1}}],[\"获取双向队列的长度\",{\"1\":{\"164\":1}}],[\"获取双向队列的容量\",{\"1\":{\"164\":1}}],[\"获取队列的容量\",{\"1\":{\"161\":1}}],[\"获取队列的长度\",{\"1\":{\"160\":1,\"161\":1,\"163\":1}}],[\"获取栈的长度\",{\"1\":{\"156\":1,\"157\":1}}],[\"获取并返回随机元素\",{\"1\":{\"140\":1}}],[\"获取\",{\"1\":{\"56\":2,\"379\":1}}],[\"获取元素\",{\"1\":{\"56\":1,\"367\":1}}],[\"新线程\",{\"1\":{\"379\":1}}],[\"新增array\",{\"1\":{\"379\":1}}],[\"线索二叉树\",{\"0\":{\"457\":1}}],[\"线程管理\",{\"0\":{\"499\":1}}],[\"线程能够对原子类型变量互斥访问\",{\"1\":{\"379\":1}}],[\"线程函数的参数是以值拷贝的方式拷贝到线程空间中的\",{\"1\":{\"379\":1}}],[\"线程函数参数问题\",{\"1\":{\"379\":1}}],[\"线程的执行是并发的\",{\"1\":{\"379\":1}}],[\"线程对象的构造方式\",{\"1\":{\"379\":1}}],[\"线程库\",{\"1\":{\"379\":1}}],[\"线性表的链式表示\",{\"0\":{\"447\":1}}],[\"线性表\",{\"0\":{\"445\":1,\"446\":1}}],[\"线性探测到\",{\"1\":{\"172\":1}}],[\"线性探测到该空桶就会返回\",{\"1\":{\"172\":1}}],[\"线性探测容易产生\",{\"1\":{\"172\":1}}],[\"线性探测采用固定步长的线性搜索来进行探测\",{\"1\":{\"172\":1}}],[\"线性探测\",{\"0\":{\"172\":1},\"1\":{\"172\":3}}],[\"线性查找\",{\"0\":{\"29\":1},\"1\":{\"144\":1}}],[\"线性数据结构\",{\"1\":{\"14\":1}}],[\"线性与非线性\",{\"0\":{\"14\":1}}],[\"让客户端和服务端使用同一个命名管道\",{\"1\":{\"403\":1,\"406\":1}}],[\"让我们在调用时可以不用传递某些参数\",{\"1\":{\"379\":1}}],[\"让文件指针的位置返回文件的起始位置\",{\"1\":{\"310\":1}}],[\"明确可调用对象的返回值和形参类型\",{\"1\":{\"379\":1}}],[\"范围for的遍历范围必须确定\",{\"1\":{\"379\":1}}],[\"范围for循环\",{\"1\":{\"379\":1}}],[\"范围for遍历\",{\"1\":{\"348\":1}}],[\"舍去了派生类的draw\",{\"1\":{\"376\":1}}],[\"纯虚函数\",{\"1\":{\"376\":1}}],[\"抽象类不能实例化对象\",{\"1\":{\"376\":1}}],[\"抽象类\",{\"1\":{\"376\":3}}],[\"协变使得在派生类中的虚函数能够返回更具体的类型\",{\"1\":{\"376\":1}}],[\"协变例子\",{\"1\":{\"376\":1}}],[\"协变\",{\"1\":{\"376\":2}}],[\"虚拟存储器\",{\"0\":{\"484\":1}}],[\"虚拟析构函数\",{\"1\":{\"376\":1}}],[\"虚析构函数\",{\"1\":{\"376\":1}}],[\"虚函数重写的两个例外\",{\"1\":{\"376\":1}}],[\"虚函数\",{\"1\":{\"376\":1}}],[\"虚函数的重写也叫虚函数的覆盖\",{\"1\":{\"376\":1}}],[\"虚函数的重写\",{\"1\":{\"376\":1}}],[\"菱形虚拟继承对于重复的成员只存储一份\",{\"1\":{\"373\":1}}],[\"菱形虚拟继承\",{\"1\":{\"373\":1}}],[\"菱形继承存在数据冗余和二义性问题\",{\"1\":{\"373\":1}}],[\"菱形继承\",{\"1\":{\"373\":3}}],[\"私有成员对于派生类来说是不可访问的\",{\"1\":{\"373\":1}}],[\"私有继承\",{\"1\":{\"373\":2}}],[\"强转\",{\"1\":{\"373\":1}}],[\"强制类型转换\",{\"1\":{\"336\":1}}],[\"强制规范\",{\"1\":{\"257\":1}}],[\"切片\",{\"1\":{\"373\":1}}],[\"切割字符串\",{\"1\":{\"292\":1}}],[\"公有继承\",{\"1\":{\"373\":2}}],[\"派生类的析构函数\",{\"1\":{\"376\":1}}],[\"派生类的其他成员函数\",{\"1\":{\"376\":1}}],[\"派生类的虚拟析构函数\",{\"1\":{\"376\":1}}],[\"派生类返回派生类对象的指针或引用\",{\"1\":{\"376\":1}}],[\"派生类重写基类虚函数时\",{\"1\":{\"376\":1}}],[\"派生类虚函数不加virtual关键字也构成重写\",{\"1\":{\"376\":1}}],[\"派生类可以直接访问基类的公有和受保护的成员\",{\"1\":{\"373\":1}}],[\"派生类作用域特点\",{\"1\":{\"373\":1}}],[\"派生类对象赋值给基类引用\",{\"1\":{\"373\":1}}],[\"派生类对象赋值给基类指针\",{\"1\":{\"373\":1}}],[\"派生类对象赋值给基类对象\",{\"1\":{\"373\":2}}],[\"派生类赋值基类\",{\"1\":{\"373\":1}}],[\"派生类调用基类成员函数\",{\"1\":{\"373\":3}}],[\"派生类\",{\"1\":{\"373\":5,\"376\":5}}],[\"父类和子类的同名函数不是构成了重载\",{\"1\":{\"373\":1}}],[\"父类\",{\"1\":{\"373\":2}}],[\"父节点的索引为\",{\"1\":{\"209\":1}}],[\"父节点\",{\"1\":{\"190\":1}}],[\"继承中引入了一个新的作用域\",{\"1\":{\"373\":1}}],[\"继承中的作用域\",{\"1\":{\"373\":1}}],[\"继承方式\",{\"1\":{\"373\":1}}],[\"继承的定义\",{\"1\":{\"373\":1}}],[\"继续执行下一次循环\",{\"1\":{\"299\":1}}],[\"继续迭代\",{\"1\":{\"56\":1}}],[\"读事件就绪\",{\"1\":{\"390\":1,\"397\":1,\"440\":1}}],[\"读\",{\"1\":{\"370\":1}}],[\"读文件描述符集\",{\"1\":{\"438\":1}}],[\"读文件中数据\",{\"1\":{\"370\":1}}],[\"读文件\",{\"1\":{\"370\":1}}],[\"读写\",{\"1\":{\"370\":3}}],[\"读取完后又会调用select函数等待某个客户端连接的读事件就绪\",{\"1\":{\"441\":1}}],[\"读取成功\",{\"1\":{\"390\":1,\"397\":1,\"440\":1}}],[\"读取模式\",{\"1\":{\"310\":1}}],[\"读取\",{\"1\":{\"310\":1}}],[\"读取的内容中包含换行符\",{\"1\":{\"310\":1}}],[\"读取文件\",{\"1\":{\"310\":1,\"344\":1}}],[\"读取一行文本\",{\"1\":{\"309\":1}}],[\"读取一个字符\",{\"1\":{\"309\":1}}],[\"读取数据并将其存储到指定的变量中\",{\"1\":{\"252\":1}}],[\"读取元素的值\",{\"1\":{\"244\":1}}],[\"偏特化为int\",{\"1\":{\"367\":2}}],[\"偏特化\",{\"1\":{\"367\":1}}],[\"模拟分配失败\",{\"1\":{\"382\":1}}],[\"模拟一些工作\",{\"1\":{\"379\":1}}],[\"模板函数\",{\"1\":{\"379\":1}}],[\"模板中的\",{\"1\":{\"379\":1}}],[\"模板特化\",{\"1\":{\"367\":1}}],[\"模板推导成员变量类型\",{\"1\":{\"367\":1}}],[\"模型等各种形式\",{\"1\":{\"16\":1}}],[\"早期使用\",{\"1\":{\"367\":1}}],[\"友元类与友元函数\",{\"1\":{\"361\":1}}],[\"友元函数哪里声明都可以\",{\"1\":{\"361\":1}}],[\"友元函数\",{\"1\":{\"361\":3}}],[\"变成第一种形式\",{\"1\":{\"361\":1}}],[\"变量出了函数还在用\",{\"1\":{\"348\":1}}],[\"变量可以省略括号\",{\"1\":{\"335\":1}}],[\"变量类型\",{\"1\":{\"305\":1}}],[\"变量用\",{\"1\":{\"302\":1}}],[\"变量在内存中分配空间\",{\"1\":{\"261\":1}}],[\"变量需要提前声明\",{\"1\":{\"252\":1}}],[\"变量或表达式\",{\"1\":{\"251\":1}}],[\"变量必须先声明\",{\"1\":{\"250\":1}}],[\"变量名前面需要添加\",{\"1\":{\"252\":1}}],[\"变量名\",{\"1\":{\"249\":1,\"305\":1}}],[\"变量的地址\",{\"1\":{\"348\":1}}],[\"变量的地址赋给\",{\"1\":{\"265\":1}}],[\"变量的访问方式\",{\"1\":{\"261\":1}}],[\"变量的值可以在同一类型范围内不断变化\",{\"1\":{\"250\":1}}],[\"变量的声明和使用\",{\"0\":{\"250\":1}}],[\"变量的构成包含三个要素\",{\"1\":{\"249\":1}}],[\"变量的概念\",{\"0\":{\"249\":1}}],[\"变量是内存中的一个存储区域\",{\"1\":{\"249\":1}}],[\"变量和常量\",{\"0\":{\"247\":1}}],[\"变量\",{\"0\":{\"248\":1},\"1\":{\"198\":1,\"214\":1,\"275\":1,\"286\":1,\"304\":1,\"310\":1,\"320\":1,\"330\":1,\"337\":1,\"338\":1}}],[\"变量a和b使用常数大小的额外空间\",{\"1\":{\"128\":1}}],[\"变量i\",{\"1\":{\"124\":1}}],[\"天数标识\",{\"1\":{\"361\":1}}],[\"浅拷贝是直接将内容复制过去\",{\"1\":{\"361\":1}}],[\"浅拷贝程序会崩掉\",{\"1\":{\"361\":1}}],[\"浅拷贝构造函数\",{\"1\":{\"361\":1}}],[\"深拷贝构造函数\",{\"1\":{\"361\":1}}],[\"深度优先遍历辅助函数\",{\"1\":{\"225\":1}}],[\"深度优先遍历的算法流程如图下图所示\",{\"1\":{\"225\":1}}],[\"深度优先遍历的序列是否唯一\",{\"1\":{\"225\":1}}],[\"深度优先遍历序列的顺序也不是唯一的\",{\"1\":{\"225\":1}}],[\"深度优先遍历是一种优先走到底\",{\"1\":{\"224\":1}}],[\"深度优先遍历\",{\"0\":{\"224\":1},\"1\":{\"190\":1,\"225\":1}}],[\"深度优先遍历就像是绕着整棵二叉树的外围\",{\"1\":{\"187\":1}}],[\"深度优先搜索通常基于递归实现\",{\"1\":{\"187\":1}}],[\"深度优先搜索\",{\"1\":{\"74\":1}}],[\"答案\",{\"1\":{\"361\":1}}],[\"答案是肯定的\",{\"1\":{\"188\":1}}],[\"严格来说是date\",{\"1\":{\"361\":1}}],[\"严重影响哈希表的可用性\",{\"1\":{\"169\":1}}],[\"他们是存在公共代码段的\",{\"1\":{\"361\":1}}],[\"他和父亲达成协议\",{\"1\":{\"297\":1}}],[\"日期错误\",{\"1\":{\"361\":1}}],[\"日期类文件名\",{\"1\":{\"361\":1}}],[\"日期类的实现\",{\"1\":{\"361\":1}}],[\"日期时间相关函数\",{\"1\":{\"291\":1}}],[\"日\",{\"1\":{\"361\":2}}],[\"探究this指针\",{\"1\":{\"361\":1}}],[\"探测次数的平方\",{\"1\":{\"173\":1}}],[\"探测起始点\",{\"1\":{\"172\":1}}],[\"探测方式主要包括线性探测\",{\"1\":{\"171\":1}}],[\"符合c语言内存对齐规则\",{\"1\":{\"361\":2}}],[\"符号位不变\",{\"1\":{\"327\":1}}],[\"符号表示\",{\"1\":{\"261\":2}}],[\"符号\",{\"1\":{\"252\":1}}],[\"符号甚至表情符号等\",{\"1\":{\"18\":1}}],[\"男\",{\"1\":{\"361\":2}}],[\"禁止了隐式类型转换\",{\"1\":{\"379\":1}}],[\"禁止单参数构造函数的隐式转换\",{\"1\":{\"379\":1}}],[\"禁止单参数构造函数隐式转换\",{\"1\":{\"357\":1}}],[\"禁止隐式转换\",{\"1\":{\"357\":1}}],[\"去除constptr的const属性\",{\"1\":{\"357\":1}}],[\"去替换形参\",{\"1\":{\"319\":1}}],[\"较高转较低层次\",{\"1\":{\"357\":1}}],[\"较低转较高层次\",{\"1\":{\"357\":1}}],[\"较大时\",{\"1\":{\"85\":1}}],[\"垃圾回收类\",{\"1\":{\"354\":1}}],[\"互斥量当前不可用\",{\"1\":{\"379\":1}}],[\"互斥量库\",{\"1\":{\"379\":1}}],[\"互斥锁被自动释放\",{\"1\":{\"379\":2}}],[\"互斥锁在这个作用域内被持有\",{\"1\":{\"379\":2}}],[\"互斥锁\",{\"1\":{\"354\":2}}],[\"互不依赖\",{\"1\":{\"59\":1}}],[\"懒汉模式在程序运行之前没有进行单例对象的创建\",{\"1\":{\"354\":1}}],[\"懒汉模式线程安全问题\",{\"1\":{\"354\":1}}],[\"懒汉模式实现方法\",{\"1\":{\"354\":2}}],[\"懒汉模式\",{\"1\":{\"354\":1}}],[\"懒删除可能会加速哈希表的性能退化\",{\"1\":{\"172\":1}}],[\"饿汉模式在程序运行主程序之前就完成了单例对象的创建\",{\"1\":{\"354\":1}}],[\"饿汉模式的线程安全问题\",{\"1\":{\"354\":1}}],[\"饿汉模式实现方法\",{\"1\":{\"354\":1}}],[\"饿汉模式\",{\"1\":{\"354\":1}}],[\"屏蔽operator\",{\"1\":{\"354\":1}}],[\"屏幕等\",{\"1\":{\"308\":1}}],[\"缺陷\",{\"1\":{\"354\":2}}],[\"缺点\",{\"1\":{\"138\":1}}],[\"智能指针的拷贝问题\",{\"1\":{\"351\":1}}],[\"智能指针的设计\",{\"1\":{\"351\":1}}],[\"智能指针概念\",{\"1\":{\"351\":1}}],[\"普通函数\",{\"1\":{\"379\":1}}],[\"普通成员函数\",{\"1\":{\"376\":1}}],[\"普通对象取地址\",{\"1\":{\"361\":1}}],[\"普通对象取地址和const对象取地址\",{\"1\":{\"361\":1}}],[\"普通for遍历\",{\"1\":{\"348\":1}}],[\"普通调用成员\",{\"1\":{\"348\":1}}],[\"普通调用a空间成员\",{\"1\":{\"348\":2}}],[\"做返回值\",{\"1\":{\"348\":1}}],[\"做参数\",{\"1\":{\"348\":1}}],[\"做出选择\",{\"1\":{\"77\":2,\"81\":1,\"82\":1,\"85\":2,\"86\":1,\"92\":1}}],[\"临时变量问题也解释了为什么nums2的地址和y的地址不一样\",{\"1\":{\"348\":1}}],[\"临时变量有常性\",{\"1\":{\"348\":1}}],[\"临时变量在赋值给x\",{\"1\":{\"348\":1}}],[\"临时变量具有常性\",{\"1\":{\"348\":1}}],[\"权限放大了\",{\"1\":{\"348\":2}}],[\"权限只能缩小\",{\"1\":{\"348\":1}}],[\"权重\",{\"1\":{\"214\":1}}],[\"顺序\",{\"1\":{\"348\":1}}],[\"顺序控制语句\",{\"0\":{\"296\":1}}],[\"顺序控制\",{\"1\":{\"295\":1}}],[\"半缺省参数时\",{\"1\":{\"348\":2}}],[\"部分释放成员\",{\"1\":{\"348\":1}}],[\"部分释放b空间成员\",{\"1\":{\"348\":2}}],[\"知识点思维导图\",{\"0\":{\"347\":1,\"350\":1,\"353\":1,\"356\":1,\"360\":1,\"363\":1,\"366\":1,\"369\":1,\"372\":1,\"375\":1,\"378\":1,\"381\":1,\"384\":1,\"386\":1,\"393\":1,\"400\":1,\"402\":1,\"408\":1,\"410\":1,\"412\":1,\"414\":1,\"416\":1,\"418\":1,\"420\":1,\"422\":1,\"424\":1,\"426\":1,\"428\":1,\"430\":1,\"432\":1,\"434\":1}}],[\"感谢使用通讯录系统\",{\"1\":{\"345\":1}}],[\"界面循环\",{\"1\":{\"345\":1}}],[\"电话\",{\"1\":{\"344\":1}}],[\"电话号码\",{\"1\":{\"344\":1}}],[\"姓氏升序排序\",{\"1\":{\"344\":1}}],[\"姓名为例\",{\"1\":{\"167\":1}}],[\"姓名\",{\"1\":{\"166\":1,\"302\":6,\"342\":1,\"361\":2}}],[\"睡2s假装处理排序\",{\"1\":{\"344\":1}}],[\"没必要记住\",{\"1\":{\"370\":1}}],[\"没找到返回\",{\"1\":{\"344\":1}}],[\"没有对应的输入输出缓冲区\",{\"1\":{\"442\":1}}],[\"没有定制协议\",{\"1\":{\"442\":1}}],[\"没有调用拷贝构造\",{\"1\":{\"361\":1}}],[\"没有默认构造函数\",{\"1\":{\"361\":2}}],[\"没有给\",{\"1\":{\"361\":1}}],[\"没有优化的编译器\",{\"1\":{\"361\":1}}],[\"没有成员变量的类对象\",{\"1\":{\"361\":2}}],[\"没有结果\",{\"1\":{\"357\":1}}],[\"没有也可以\",{\"1\":{\"344\":1}}],[\"没有有返回值参数说明\",{\"1\":{\"314\":1}}],[\"没有类型信息\",{\"1\":{\"313\":1}}],[\"没有匹配到任何值~\",{\"1\":{\"297\":1}}],[\"没有任何奖励\",{\"1\":{\"297\":1}}],[\"没有明确限制的\",{\"1\":{\"267\":1}}],[\"没有它就没法正确读取值\",{\"1\":{\"252\":1}}],[\"没有指定长度\",{\"1\":{\"244\":2}}],[\"没有指定元素个数\",{\"1\":{\"244\":1}}],[\"没有子节点的节点\",{\"1\":{\"181\":1}}],[\"没有父节点\",{\"1\":{\"181\":1}}],[\"没有归并排序稳定\",{\"1\":{\"44\":1}}],[\"写\",{\"1\":{\"370\":2}}],[\"写文件\",{\"1\":{\"344\":1,\"370\":1}}],[\"写入模式\",{\"1\":{\"310\":1}}],[\"写入格式化数据时出现错误\",{\"1\":{\"310\":1}}],[\"写入格式化数据\",{\"1\":{\"310\":2}}],[\"写入字符串时出现错误\",{\"1\":{\"310\":3}}],[\"写入字符串\",{\"1\":{\"310\":3}}],[\"写入字符时出现错误\",{\"1\":{\"310\":2}}],[\"写入字符\",{\"1\":{\"310\":2}}],[\"写入一个字符串\",{\"1\":{\"310\":3}}],[\"写入一个字符\",{\"1\":{\"310\":2}}],[\"写入文件\",{\"1\":{\"310\":1}}],[\"升序排序联系人\",{\"1\":{\"344\":1}}],[\"填的未知\",{\"1\":{\"344\":1}}],[\"名字\",{\"1\":{\"344\":2,\"373\":1}}],[\"名称来源于\",{\"1\":{\"251\":1}}],[\"住址\",{\"1\":{\"342\":1}}],[\"联系人不存在\",{\"1\":{\"344\":2}}],[\"联系人信息结构体整体赋值\",{\"1\":{\"344\":1}}],[\"联系人信息结构体\",{\"1\":{\"344\":1}}],[\"联系人电话\",{\"1\":{\"344\":1}}],[\"联系人性别\",{\"1\":{\"344\":1}}],[\"联系人年龄\",{\"1\":{\"344\":1}}],[\"联系人姓名\",{\"1\":{\"344\":1}}],[\"联系人地址\",{\"1\":{\"344\":2}}],[\"联系方式\",{\"1\":{\"342\":1}}],[\"联合体\",{\"0\":{\"233\":1}}],[\"信息包括\",{\"1\":{\"342\":1}}],[\"技术要求\",{\"1\":{\"342\":1}}],[\"项目代码\",{\"0\":{\"343\":1}}],[\"项目要求\",{\"0\":{\"342\":1}}],[\"项目效果\",{\"0\":{\"341\":1}}],[\"练手项目\",{\"0\":{\"340\":1}}],[\"宽类型赋值给窄类型\",{\"1\":{\"337\":1}}],[\"宽度j\",{\"1\":{\"123\":1}}],[\"宽度是两个隔板的数组索引之差\",{\"1\":{\"122\":1}}],[\"精度低的转诶精度高的\",{\"1\":{\"337\":1}}],[\"精度小的类型自动转换为精度大的类型\",{\"1\":{\"337\":1}}],[\"精确宽度类型c\",{\"1\":{\"330\":1}}],[\"窄类型赋值给宽类型\",{\"1\":{\"337\":1}}],[\"窄类型整数自动转换为宽类型整数\",{\"1\":{\"337\":1}}],[\"窄类型会自动转为宽类型\",{\"1\":{\"337\":1}}],[\"告知它的定义可能在其他文件中\",{\"1\":{\"334\":1}}],[\"须加后缀\",{\"1\":{\"331\":1}}],[\"型\",{\"1\":{\"331\":1,\"333\":1}}],[\"型变量\",{\"1\":{\"261\":1}}],[\"科学计数法形式\",{\"1\":{\"331\":1}}],[\"长双精度\",{\"1\":{\"331\":1}}],[\"长度可控追加字符串\",{\"1\":{\"292\":1}}],[\"长度可控拷贝字符串\",{\"1\":{\"292\":1}}],[\"长度可控求字符串长度\",{\"1\":{\"292\":1}}],[\"长度\",{\"1\":{\"263\":2}}],[\"长度不可变\",{\"1\":{\"138\":1}}],[\"浮点型数据表示形式\",{\"1\":{\"331\":1}}],[\"浮点型的类型\",{\"1\":{\"331\":1}}],[\"浮点类型可以表示一个小数\",{\"1\":{\"331\":1}}],[\"浮点类型\",{\"0\":{\"331\":1}}],[\"浮点数字面量默认是double型\",{\"1\":{\"331\":1}}],[\"浮点数常量\",{\"1\":{\"254\":1}}],[\"浮点数\",{\"1\":{\"32\":1,\"313\":2}}],[\"浮点数类型\",{\"1\":{\"16\":1}}],[\"默认成员函数控制\",{\"1\":{\"379\":1}}],[\"默认生成的析构函数\",{\"1\":{\"361\":1}}],[\"默认对齐数和成员自身大小的较小值\",{\"1\":{\"361\":1}}],[\"默认存储类型说明符\",{\"1\":{\"334\":1}}],[\"默认是\",{\"1\":{\"332\":1}}],[\"默认是否带符号取决于当前运行环境\",{\"1\":{\"332\":1}}],[\"默认是signed\",{\"1\":{\"330\":1}}],[\"默认保留6位小数\",{\"1\":{\"331\":2}}],[\"默认会保留6位小数\",{\"1\":{\"331\":1}}],[\"默认情况下\",{\"1\":{\"211\":1,\"287\":2}}],[\"硬件平台的影响\",{\"1\":{\"330\":1}}],[\"硬币找零问题\",{\"1\":{\"117\":1}}],[\"次方\",{\"1\":{\"326\":2}}],[\"次对角线上存在皇后\",{\"1\":{\"90\":1}}],[\"次对角线上的所有格子的row+col是恒定值\",{\"1\":{\"89\":1}}],[\"十个数字外\",{\"1\":{\"325\":1}}],[\"十六进制转成二进制\",{\"1\":{\"326\":1}}],[\"十六进制转成十进制\",{\"1\":{\"326\":1}}],[\"十六进制与十进制的转换\",{\"1\":{\"326\":1}}],[\"十六进制整数\",{\"1\":{\"325\":1}}],[\"十六进制中\",{\"1\":{\"325\":1}}],[\"十六进制\",{\"1\":{\"325\":9}}],[\"十进制数形式\",{\"1\":{\"331\":1}}],[\"十进制的正负1\",{\"1\":{\"327\":2}}],[\"十进制的位范围为\",{\"1\":{\"56\":1}}],[\"十进制转成十六进制\",{\"1\":{\"326\":1}}],[\"十进制转换成二进制\",{\"1\":{\"326\":1}}],[\"十进制整数\",{\"1\":{\"325\":1}}],[\"十进制\",{\"1\":{\"325\":5}}],[\"针对编译器自己生成默认成员函数不初始化问题\",{\"1\":{\"361\":1}}],[\"针对宏extra\",{\"1\":{\"321\":1}}],[\"针对函数无返回值或明确不需返回值的情况\",{\"1\":{\"286\":1}}],[\"示例\",{\"1\":{\"382\":7}}],[\"示例如下\",{\"1\":{\"320\":2}}],[\"示例代码如下\",{\"1\":{\"38\":1,\"190\":1,\"195\":1}}],[\"沿着文件系统的目录结构一直到达目标文件\",{\"1\":{\"320\":1}}],[\"绝对路径是文件在文件系统中的完整路径\",{\"1\":{\"320\":1}}],[\"像我们前面用过的\",{\"1\":{\"320\":1}}],[\"像一种模板\",{\"1\":{\"302\":1}}],[\"圆的面积\",{\"1\":{\"318\":1}}],[\"圆盘只能从一根柱子顶部拿出\",{\"1\":{\"70\":1}}],[\"替换文本内的形参通常要用括号括起来以避免出错\",{\"1\":{\"319\":1}}],[\"替换文本\",{\"1\":{\"319\":1}}],[\"替换文本可以含任何字符\",{\"1\":{\"318\":1}}],[\"替换文本宏名称\",{\"1\":{\"318\":1}}],[\"替换为\",{\"1\":{\"202\":2}}],[\"宏myheader\",{\"1\":{\"321\":1}}],[\"宏foo如果定义过\",{\"1\":{\"321\":1}}],[\"宏\",{\"1\":{\"320\":1}}],[\"宏等内容\",{\"1\":{\"320\":1}}],[\"宏在编译之前就被处理掉了\",{\"1\":{\"319\":1}}],[\"宏替换为\",{\"1\":{\"319\":1}}],[\"宏替换后\",{\"1\":{\"319\":1}}],[\"宏替换变为\",{\"1\":{\"318\":1}}],[\"宏名\",{\"1\":{\"319\":1}}],[\"宏名称在代码中的每次出现都会被替换为这段文本前面的案例中\",{\"1\":{\"318\":1}}],[\"宏名称\",{\"1\":{\"318\":2}}],[\"宏展开仅仅是文本的替换\",{\"1\":{\"319\":1}}],[\"宏展开\",{\"1\":{\"318\":2}}],[\"宏的名称\",{\"1\":{\"318\":1}}],[\"宏定义允许嵌套\",{\"1\":{\"318\":1}}],[\"宏定义嵌套\",{\"1\":{\"318\":1}}],[\"宏定义的替换文本\",{\"1\":{\"318\":1}}],[\"宏定义基本语法\",{\"1\":{\"318\":1}}],[\"宏定义基本介绍\",{\"1\":{\"318\":1}}],[\"宏定义\",{\"0\":{\"318\":1},\"1\":{\"318\":2}}],[\"推荐类开始\",{\"1\":{\"361\":1}}],[\"推荐写法\",{\"1\":{\"317\":1}}],[\"推导状态转移方程\",{\"1\":{\"102\":1}}],[\"销毁类的成员\",{\"1\":{\"361\":1}}],[\"销毁通讯录文件\",{\"1\":{\"344\":1}}],[\"销毁\",{\"1\":{\"314\":1}}],[\"退出通讯录\",{\"1\":{\"344\":2}}],[\"退出当前使用的通讯录\",{\"1\":{\"342\":1}}],[\"退出系统\",{\"1\":{\"342\":1}}],[\"退出程序\",{\"1\":{\"314\":2}}],[\"退格\",{\"1\":{\"332\":1}}],[\"退回到之前的状态\",{\"1\":{\"75\":1}}],[\"隐藏\",{\"1\":{\"373\":1}}],[\"隐藏this指针的原函数\",{\"1\":{\"361\":1}}],[\"隐式实例化为\",{\"1\":{\"367\":1}}],[\"隐式实例化\",{\"1\":{\"367\":2}}],[\"隐式类型转换中的宽类型赋值给窄类型\",{\"1\":{\"338\":1}}],[\"隐式类型转换\",{\"0\":{\"337\":1},\"1\":{\"313\":4,\"336\":1,\"357\":2,\"361\":1}}],[\"隐含date\",{\"1\":{\"361\":1}}],[\"隐含在各种算法与数据结构之中\",{\"1\":{\"63\":1}}],[\"任一类型的指针都可以转为\",{\"1\":{\"313\":1}}],[\"任意节点的值\",{\"1\":{\"208\":2}}],[\"任意节点的左\",{\"1\":{\"192\":1}}],[\"任意节点都可以视作头节点\",{\"1\":{\"153\":1}}],[\"稍后再确定写入的数据类型这种情况下就可以使用\",{\"1\":{\"313\":1}}],[\"牢记\",{\"1\":{\"310\":1}}],[\"底层是哈希表\",{\"1\":{\"379\":1}}],[\"底层定义为\",{\"1\":{\"310\":1}}],[\"底部称为\",{\"1\":{\"155\":1}}],[\"制表符\",{\"1\":{\"310\":1,\"332\":1}}],[\"遇到换行符即读取结束\",{\"1\":{\"310\":1}}],[\"追加\",{\"1\":{\"370\":2}}],[\"追加写入\",{\"1\":{\"310\":4}}],[\"追加字符串\",{\"1\":{\"292\":1}}],[\"打开命名管道文件\",{\"1\":{\"404\":1}}],[\"打开一个文件以写入\",{\"1\":{\"370\":1}}],[\"打开输出文件\",{\"1\":{\"310\":1}}],[\"打开输入文件\",{\"1\":{\"310\":1}}],[\"打开文件以供读取\",{\"1\":{\"310\":3}}],[\"打开文件时出现错误\",{\"1\":{\"310\":5}}],[\"打开文件\",{\"1\":{\"310\":2,\"344\":2}}],[\"打印计算结果\",{\"1\":{\"404\":1}}],[\"打印map中元素\",{\"1\":{\"379\":1}}],[\"打印vector中元素\",{\"1\":{\"379\":1}}],[\"打印学生信息\",{\"1\":{\"361\":1}}],[\"打印1\",{\"1\":{\"348\":1}}],[\"打印指针的值和指向的值\",{\"1\":{\"262\":1}}],[\"打印邻接矩阵\",{\"1\":{\"218\":1}}],[\"打印哈希表\",{\"1\":{\"167\":1,\"170\":1,\"172\":1}}],[\"打印队列\",{\"1\":{\"160\":1,\"163\":1}}],[\"​\",{\"1\":{\"309\":1}}],[\"键盘等\",{\"1\":{\"308\":1}}],[\"键值对的分布情况由哈希函数决定\",{\"1\":{\"175\":1}}],[\"键值对数量\",{\"1\":{\"170\":1,\"172\":1}}],[\"键值对\",{\"1\":{\"167\":1,\"170\":1}}],[\"键值对分别为数组元素和元素索引\",{\"1\":{\"30\":1}}],[\"流\",{\"1\":{\"308\":1}}],[\"声音\",{\"1\":{\"308\":1,\"325\":1}}],[\"声明\",{\"1\":{\"361\":3}}],[\"声明了d3函数\",{\"1\":{\"361\":1}}],[\"声明了四个关于内存动态分配的函数\",{\"1\":{\"314\":1}}],[\"声明和定义的区分\",{\"1\":{\"361\":1}}],[\"声明和日期和时间相关的函数\",{\"1\":{\"291\":2}}],[\"声明布尔类型的三种方法\",{\"1\":{\"333\":1}}],[\"声明为\",{\"1\":{\"330\":1}}],[\"声明指针\",{\"1\":{\"314\":1}}],[\"声明指针变量的时候\",{\"1\":{\"266\":1}}],[\"声明num为整型数组类型名\",{\"1\":{\"304\":1}}],[\"声明共用体变量的同时\",{\"1\":{\"303\":2}}],[\"声明共用体变量\",{\"1\":{\"303\":2}}],[\"声明共用体变量方式一\",{\"1\":{\"303\":1}}],[\"声明共用体类型\",{\"1\":{\"303\":1}}],[\"声明共用体\",{\"1\":{\"303\":1}}],[\"声明结构体指针\",{\"1\":{\"302\":1}}],[\"声明结构体指针并初始化\",{\"1\":{\"302\":1}}],[\"声明结构体指针的语法格式\",{\"1\":{\"302\":1}}],[\"声明结构体变量\",{\"1\":{\"302\":1}}],[\"声明结构体变量方式一\",{\"1\":{\"302\":1}}],[\"声明结构体以及结构体变量\",{\"1\":{\"302\":1}}],[\"声明结构体\",{\"1\":{\"302\":2}}],[\"声明函数\",{\"1\":{\"286\":2}}],[\"声明函数语法\",{\"1\":{\"286\":1}}],[\"声明多级指针时\",{\"1\":{\"265\":1}}],[\"声明一个整型变量\",{\"1\":{\"250\":2,\"251\":2}}],[\"又有成员函数\",{\"1\":{\"361\":1}}],[\"又方便使用位段形式\",{\"1\":{\"305\":1}}],[\"又称散列表\",{\"1\":{\"166\":1}}],[\"既支持递归函数中进行加锁\",{\"1\":{\"379\":1}}],[\"既能节约空间\",{\"1\":{\"305\":1}}],[\"既快又稳\",{\"1\":{\"176\":1}}],[\"既快又省\",{\"1\":{\"135\":1}}],[\"举例来说\",{\"1\":{\"321\":1}}],[\"举例2\",{\"1\":{\"304\":1}}],[\"举例1\",{\"1\":{\"304\":1}}],[\"zero\",{\"1\":{\"370\":2,\"382\":2,\"438\":1}}],[\"z的值为\",{\"1\":{\"348\":4}}],[\"z\",{\"1\":{\"304\":1,\"348\":4,\"361\":3}}],[\"zu\",{\"1\":{\"263\":2,\"314\":3,\"335\":16}}],[\"习惯上\",{\"1\":{\"304\":1}}],[\"别名\",{\"1\":{\"304\":1}}],[\"意义也非常明确\",{\"1\":{\"304\":1}}],[\"书写起来就简单了\",{\"1\":{\"304\":1}}],[\"看起来就是多余的\",{\"1\":{\"304\":1}}],[\"看看执行花费时间\",{\"1\":{\"291\":1}}],[\"绰号\",{\"1\":{\"304\":1}}],[\"几个成员共用一个内存区\",{\"1\":{\"303\":1}}],[\"几个指针变量使用o\",{\"1\":{\"48\":1}}],[\"家庭住址\",{\"1\":{\"302\":6}}],[\"性别\",{\"1\":{\"302\":6,\"342\":1,\"344\":2,\"361\":2,\"373\":1}}],[\"学生\",{\"1\":{\"302\":1}}],[\"学号和\",{\"1\":{\"167\":1}}],[\"学号\",{\"1\":{\"166\":1,\"302\":6,\"373\":1}}],[\"您本次加油需支付\",{\"1\":{\"297\":2}}],[\"嵌套命名空间\",{\"1\":{\"348\":1}}],[\"嵌套分支层数不宜过多\",{\"1\":{\"297\":1}}],[\"嵌套分支是指\",{\"1\":{\"297\":1}}],[\"嵌套分支\",{\"1\":{\"297\":2}}],[\"嵌套太深了\",{\"1\":{\"297\":1}}],[\"嵌套循环递归一般分为\",{\"1\":{\"136\":1}}],[\"猴子有急事\",{\"1\":{\"297\":1}}],[\"猴子爬雪山\",{\"1\":{\"297\":1}}],[\"猴子当小二\",{\"1\":{\"297\":1}}],[\"猴子穿新衣\",{\"1\":{\"297\":1}}],[\"今天星期四\",{\"1\":{\"297\":1}}],[\"今天星期三\",{\"1\":{\"297\":1}}],[\"今天星期二\",{\"1\":{\"297\":1}}],[\"今天星期一\",{\"1\":{\"297\":1}}],[\"今年12岁\",{\"1\":{\"291\":1}}],[\"今年\",{\"1\":{\"291\":1}}],[\"遥遥领先\",{\"1\":{\"297\":1}}],[\"奖励你一部华为\",{\"1\":{\"297\":1}}],[\"奖励你一个ipad\",{\"1\":{\"297\":1}}],[\"奖励你一个肉夹馍\",{\"1\":{\"297\":1}}],[\"奖励一部华为mate60\",{\"1\":{\"297\":1}}],[\"奖励一个\",{\"1\":{\"297\":1}}],[\"奖励一个肉夹馍\",{\"1\":{\"297\":1}}],[\"含义\",{\"1\":{\"330\":1}}],[\"含有位段的结构体或联合体成为位段结构位段优点\",{\"1\":{\"305\":1}}],[\"含\",{\"1\":{\"297\":2}}],[\"欢迎继续访问\",{\"1\":{\"297\":1}}],[\"垂直制表符\",{\"1\":{\"293\":1}}],[\"水平制表符\",{\"1\":{\"293\":1}}],[\"换行符\",{\"1\":{\"332\":1}}],[\"换行符等\",{\"1\":{\"310\":1}}],[\"换行\",{\"1\":{\"293\":1}}],[\"换页\",{\"1\":{\"293\":1}}],[\"换句话说\",{\"1\":{\"60\":1,\"101\":1,\"163\":1,\"167\":1,\"200\":1,\"403\":1}}],[\"里的计算式不执行strlen是一个库函数\",{\"1\":{\"292\":1}}],[\"里面的数据类型是什么\",{\"1\":{\"313\":1}}],[\"里面的分支的结构称为内层分支\",{\"1\":{\"297\":1}}],[\"里面定义\",{\"1\":{\"271\":1}}],[\"里面包括内置的标准函数和数据结构集合等\",{\"1\":{\"271\":1}}],[\"里面包括格式占位符和普通字符\",{\"1\":{\"251\":1}}],[\"拷贝\",{\"1\":{\"442\":1}}],[\"拷贝一份当前值\",{\"1\":{\"361\":1}}],[\"拷贝构造\",{\"1\":{\"361\":1}}],[\"拷贝构造函数\",{\"1\":{\"361\":1}}],[\"拷贝构造函数特性\",{\"1\":{\"361\":1}}],[\"拷贝构造函数优化问题\",{\"1\":{\"361\":1}}],[\"拷贝构造一\",{\"1\":{\"361\":1}}],[\"拷贝构造一次\",{\"1\":{\"361\":7}}],[\"拷贝的\",{\"1\":{\"348\":1}}],[\"拷贝内存数据\",{\"1\":{\"294\":1}}],[\"拷贝字符串\",{\"1\":{\"292\":1}}],[\"拷贝链表中的数据到数组\",{\"1\":{\"160\":1,\"163\":1}}],[\"秒\",{\"1\":{\"291\":2}}],[\"起一个初始化作用\",{\"1\":{\"344\":1}}],[\"起别名\",{\"1\":{\"304\":1}}],[\"起别名的目的不是为了提高程序运行效率\",{\"1\":{\"304\":1}}],[\"起至某一特定时刻所经过的秒数\",{\"1\":{\"291\":1}}],[\"起始点\",{\"1\":{\"98\":1}}],[\"起始状态下\",{\"1\":{\"70\":1}}],[\"零时零分零秒\",{\"1\":{\"291\":1}}],[\"零钱兑换\",{\"1\":{\"113\":1}}],[\"孙悟空成绩\",{\"1\":{\"291\":2}}],[\"我第\",{\"1\":{\"298\":3}}],[\"我第n天吃了n个韭菜馅的包子\",{\"1\":{\"298\":4}}],[\"我叫张三\",{\"1\":{\"291\":1}}],[\"我叫\",{\"1\":{\"291\":1}}],[\"我们应该将这个等待过程交给select函数来完成\",{\"1\":{\"440\":1}}],[\"我们应当将注意力集中在哈希算法\",{\"1\":{\"175\":1}}],[\"我们还可以通过ps命令查看这两个进程的信息\",{\"1\":{\"403\":1}}],[\"我们还可以为边添加\",{\"1\":{\"214\":1}}],[\"我们这里编写的也是一个单进程的epoll服务器\",{\"1\":{\"398\":1}}],[\"我们称这些二进制数为机器数\",{\"1\":{\"327\":1}}],[\"我们称为递归调用\",{\"1\":{\"290\":1}}],[\"我们曾经使用宏定义来定义常量和布尔类型\",{\"1\":{\"318\":1}}],[\"我们创建一个名为\",{\"1\":{\"287\":1}}],[\"我们代码中使用的\",{\"1\":{\"271\":1}}],[\"我们比较插入节点与其父节点的值\",{\"1\":{\"211\":1}}],[\"我们首先将其添加到堆底\",{\"1\":{\"211\":1}}],[\"我们关注以该失衡节点为根节点的子树\",{\"1\":{\"201\":1}}],[\"我们同样将获取节点平衡因子的功能封装成函数\",{\"1\":{\"199\":1}}],[\"我们同样也可以借助数组\",{\"1\":{\"89\":1}}],[\"我们无法直接删除它\",{\"1\":{\"195\":1}}],[\"我们无须通过循环来切分整数\",{\"1\":{\"128\":1}}],[\"我们无须考虑状态i之前的状态\",{\"1\":{\"99\":1}}],[\"我们根据目标节点的子节点数量\",{\"1\":{\"195\":1}}],[\"我们都可以通过映射公式来访问它的左\",{\"1\":{\"189\":1}}],[\"我们都是将原问题分解为两个规模为原问题一半的子问题\",{\"1\":{\"70\":1}}],[\"我们能否用数组来表示二叉树呢\",{\"1\":{\"188\":1}}],[\"我们能否仅用一个数组实现空间优化呢\",{\"1\":{\"111\":1}}],[\"我们也应该将\",{\"1\":{\"442\":1}}],[\"我们也需要借助一个哈希表\",{\"1\":{\"225\":1}}],[\"我们也能设计一些简单的哈希算法\",{\"1\":{\"177\":1}}],[\"我们也可以使用环形数组来实现双向队列\",{\"1\":{\"164\":1}}],[\"我们也可以利用变量\",{\"1\":{\"86\":1}}],[\"我们得到\",{\"1\":{\"168\":1}}],[\"我们向哈希表中输入一个键\",{\"1\":{\"166\":1}}],[\"我们采用以下操作步骤\",{\"1\":{\"212\":1}}],[\"我们采用\",{\"1\":{\"163\":1}}],[\"我们采用不同的分解策略\",{\"1\":{\"70\":1}}],[\"我们仅能删除头部元素或在尾部添加元素\",{\"1\":{\"162\":1}}],[\"我们仅需将数组\",{\"1\":{\"111\":1}}],[\"我们把堆叠元素的顶部称为\",{\"1\":{\"155\":1}}],[\"我们既可以通过索引遍历数组\",{\"1\":{\"143\":1}}],[\"我们才能将各种算法进行对比\",{\"1\":{\"135\":1}}],[\"我们希望找到尽可能高效的算法\",{\"1\":{\"135\":1}}],[\"我们希望所有的重叠子问题都只被计算一次\",{\"1\":{\"94\":1}}],[\"我们只有向内收缩短板i\",{\"1\":{\"123\":1}}],[\"我们只需将右旋的实现代码中的所有的\",{\"1\":{\"202\":1}}],[\"我们只需将元素插入链表头部\",{\"1\":{\"156\":1}}],[\"我们只需根据具体问题来定义\",{\"1\":{\"77\":1}}],[\"我们只需关注中序遍历和前序遍历中与左子树对应的部分\",{\"1\":{\"66\":1}}],[\"我们建立了一个物品类\",{\"1\":{\"120\":1}}],[\"我们贪心地选择不大于且最接近它的硬币\",{\"1\":{\"113\":1}}],[\"我们借助记忆列表\",{\"1\":{\"109\":1}}],[\"我们借助一个哈希表\",{\"1\":{\"69\":1}}],[\"我们先考虑最简单的情况\",{\"1\":{\"167\":1}}],[\"我们先来了解如何在程序中实现重复执行任务\",{\"1\":{\"136\":1}}],[\"我们先来求解最常见的\",{\"1\":{\"107\":1}}],[\"我们先后追求以下两个层面的目标\",{\"1\":{\"135\":1}}],[\"我们先初始化指针i=0和j=n\",{\"1\":{\"20\":1}}],[\"我们引入一个和网格\",{\"1\":{\"104\":1}}],[\"我们使用\",{\"1\":{\"291\":1}}],[\"我们使用列表\",{\"1\":{\"219\":1}}],[\"我们使用一个经典问题\",{\"1\":{\"102\":1}}],[\"我们使用了与\",{\"1\":{\"48\":1}}],[\"我们很难从问题描述中直接提取出这些特性\",{\"1\":{\"101\":1}}],[\"我们对爬楼梯问题稍作改动\",{\"1\":{\"98\":1}}],[\"我们对例题一稍作拓展\",{\"1\":{\"75\":1}}],[\"我们学习动态规划是如何通过子问题分解来求解原问题的\",{\"1\":{\"97\":1}}],[\"我们初始化一个数组\",{\"1\":{\"95\":1}}],[\"我们从原问题\",{\"1\":{\"95\":1}}],[\"我们从一个经典例题入手\",{\"1\":{\"92\":1}}],[\"我们便可直接从\",{\"1\":{\"94\":1}}],[\"我们声明一个节点\",{\"1\":{\"193\":1}}],[\"我们声明一个数组\",{\"1\":{\"94\":1}}],[\"我们声明一个递归函数\",{\"1\":{\"64\":1,\"73\":1}}],[\"我们考虑在搜索过程中通过剪枝进行去重\",{\"1\":{\"85\":1}}],[\"我们考虑在每一轮选择中开启一个哈希表\",{\"1\":{\"82\":1}}],[\"我们考虑引入一个布尔型数组\",{\"1\":{\"81\":1}}],[\"我们的目标是设计\",{\"1\":{\"135\":1}}],[\"我们的目标是在某一轮选择中\",{\"1\":{\"82\":1}}],[\"我们的任务是要把这n个圆盘移到柱子\",{\"1\":{\"70\":1}}],[\"我们不能在运行时直接获取数组长度\",{\"1\":{\"244\":1}}],[\"我们不能在开放寻址哈希表中直接删除元素\",{\"1\":{\"172\":1}}],[\"我们不能简单地确定哪种实现更加节省内存\",{\"1\":{\"158\":1}}],[\"我们不单独实现框架代码中的各个函数\",{\"1\":{\"81\":1}}],[\"我们不禁发问\",{\"1\":{\"60\":1}}],[\"我们不禁会问\",{\"1\":{\"18\":1}}],[\"我们就能对各种失衡情况进行旋转\",{\"1\":{\"205\":1}}],[\"我们就进行哈希表扩容\",{\"1\":{\"169\":1}}],[\"我们就得到了下图所示的二维dp矩阵\",{\"1\":{\"102\":1}}],[\"我们就可以将图看作一种从链表拓展而来的数据结构\",{\"1\":{\"213\":1}}],[\"我们就可以将它们链接到根节点上\",{\"1\":{\"66\":1}}],[\"我们就可以利用\",{\"1\":{\"167\":1}}],[\"我们就可以从链表的头节点出发\",{\"1\":{\"147\":1}}],[\"我们就可以假设它是一个动态规划问题\",{\"1\":{\"101\":1}}],[\"我们就可以在框架代码中做\",{\"1\":{\"81\":1}}],[\"我们就将\",{\"1\":{\"81\":1}}],[\"我们在邻接表中使用\",{\"1\":{\"219\":1}}],[\"我们在二叉搜索树中获取有序数据仅需o\",{\"1\":{\"196\":1}}],[\"我们在找到值为7的节点后应该继续搜索\",{\"1\":{\"77\":1}}],[\"我们在未排序区间选择一个基准元素\",{\"1\":{\"40\":1}}],[\"我们基于框架代码来解决例题三\",{\"1\":{\"77\":1}}],[\"我们尝试将回溯的\",{\"1\":{\"77\":1}}],[\"我们\",{\"1\":{\"76\":1}}],[\"我们通过数组元素来演示指针加减整数的情况\",{\"1\":{\"262\":1}}],[\"我们通过判断失衡节点的平衡因子以及较高一侧子节点的平衡因子的正负号\",{\"1\":{\"205\":1}}],[\"我们通过\",{\"1\":{\"89\":1}}],[\"我们通过将当前节点添加进\",{\"1\":{\"75\":1}}],[\"我们通常称为行下标\",{\"1\":{\"246\":1}}],[\"我们通常会用一些标准哈希算法\",{\"1\":{\"178\":1}}],[\"我们通常选取质数作为模数\",{\"1\":{\"177\":1}}],[\"我们通常将头节点当作链表的代称\",{\"1\":{\"147\":1}}],[\"我们通常使用一种更加优雅的实现方式\",{\"1\":{\"47\":1}}],[\"我们通常采用公式m=\",{\"1\":{\"20\":1}}],[\"我们前序遍历这棵树\",{\"1\":{\"74\":1}}],[\"我们利用前序遍历构造一个回溯问题\",{\"1\":{\"74\":1}}],[\"我们提到前序\",{\"1\":{\"74\":1}}],[\"我们可总结出图下图所示的解决汉诺塔问题的分治策略\",{\"1\":{\"72\":1}}],[\"我们可以用ls\",{\"1\":{\"398\":1}}],[\"我们可以暂时将\",{\"1\":{\"287\":1}}],[\"我们可以说该指针指向变量\",{\"1\":{\"261\":1}}],[\"我们可以直接访问矩阵元素以获取边\",{\"1\":{\"216\":1}}],[\"我们可以获取到其父节点\",{\"1\":{\"194\":1}}],[\"我们可以考虑在层序遍历序列中显式地写出所有\",{\"1\":{\"190\":1}}],[\"我们可以考虑通过回溯来穷举所有可能性\",{\"1\":{\"92\":1}}],[\"我们可以推导出父节点索引与子节点索引之间的\",{\"1\":{\"189\":1}}],[\"我们可以通过一个进程来控制另一个进程的行为\",{\"1\":{\"405\":1}}],[\"我们可以通过指针间接访问内存中另一个数据\",{\"1\":{\"261\":1}}],[\"我们可以通过sizeof\",{\"1\":{\"244\":1}}],[\"我们可以通过扩容哈希表来减少哈希冲突\",{\"1\":{\"168\":1}}],[\"我们可以通过哈希函数得到该\",{\"1\":{\"167\":1}}],[\"我们可以通过下图所示的步骤得到划分结果\",{\"1\":{\"67\":1}}],[\"我们可以使用一个变量\",{\"1\":{\"161\":1}}],[\"我们可以使用上图所示的公式计算得到该元素的内存地址\",{\"1\":{\"140\":1}}],[\"我们可以采用懒删除\",{\"1\":{\"172\":1}}],[\"我们可以采用以下策略\",{\"1\":{\"169\":1}}],[\"我们可以采用以下巧妙方法来避免这个问题\",{\"1\":{\"161\":1}}],[\"我们可以采取逐行放置策略\",{\"1\":{\"88\":1}}],[\"我们可以得出以下结论\",{\"1\":{\"158\":1}}],[\"我们可以初始化一个比较长的数组\",{\"1\":{\"142\":1}}],[\"我们可以在o\",{\"1\":{\"140\":1,\"150\":1}}],[\"我们可以根据需求选用数组的两种初始化方式\",{\"1\":{\"139\":1}}],[\"我们可以根据递推公式得到暴力搜索解法\",{\"1\":{\"93\":1}}],[\"我们可以对物品任意地进行切分\",{\"1\":{\"118\":1}}],[\"我们可以对全排列代码进行小幅修改\",{\"1\":{\"85\":1}}],[\"我们可以总结出动态规划的常用术语\",{\"1\":{\"95\":1}}],[\"我们可以借助下图所示的数组\",{\"1\":{\"89\":1}}],[\"我们可以把树看作图的一种特例\",{\"1\":{\"221\":1}}],[\"我们可以把子集的生成过程想象成一系列选择的结果\",{\"1\":{\"85\":1}}],[\"我们可以把生成排列的过程想象成一系列选择的结果\",{\"1\":{\"81\":1}}],[\"我们可以将select函数超时返回和成功返回时timeout的值进行打印\",{\"1\":{\"439\":1}}],[\"我们可以将图g抽象地表示为一组顶点v和一组边e的集合\",{\"1\":{\"213\":1}}],[\"我们可以将索引映射公式封装成函数\",{\"1\":{\"209\":1}}],[\"我们可以将数组视为首尾相接的\",{\"1\":{\"161\":1}}],[\"我们可以将数组的尾部作为栈顶\",{\"1\":{\"157\":1}}],[\"我们可以将链表的\",{\"1\":{\"160\":1}}],[\"我们可以将链表的头节点视为栈顶\",{\"1\":{\"156\":1}}],[\"我们可以将\",{\"1\":{\"107\":1}}],[\"我们可以将每个决策步骤之前的子序列看作一个子问题\",{\"1\":{\"97\":1}}],[\"我们可以将搜索过程展开成一棵递归树\",{\"1\":{\"81\":1}}],[\"我们可以将尝试和回退理解为\",{\"1\":{\"75\":1}}],[\"我们可以将原问题划分为两个子问题\",{\"1\":{\"66\":1}}],[\"我们可以将内存想象成一个巨大的\",{\"1\":{\"15\":1}}],[\"我们可以先设定一条大致的分界线\",{\"1\":{\"51\":1}}],[\"我们可以利用一个长度为n的布尔型数组\",{\"1\":{\"89\":1}}],[\"我们可以利用已经学过的\",{\"1\":{\"47\":1}}],[\"我们可以利用查找最左元素的函数来查找最右元素\",{\"1\":{\"27\":1}}],[\"我们可以构造一个数组中不存在的元素\",{\"1\":{\"27\":1}}],[\"我们可以基于该表示实现具有相同功能的二分查找算法\",{\"1\":{\"21\":1}}],[\"我们已经得到根节点\",{\"1\":{\"68\":1}}],[\"我们已经学过\",{\"1\":{\"64\":1}}],[\"我们仍然可以复用以上划分方法\",{\"1\":{\"66\":1}}],[\"我们仍然可以将判断条件保持展开\",{\"1\":{\"24\":1}}],[\"我们计算以下不等式\",{\"1\":{\"61\":1}}],[\"我们遍历\",{\"1\":{\"53\":1}}],[\"我们假设商品价格服从正态分布\",{\"1\":{\"51\":1}}],[\"我们想要将淘宝上的所有商品按价格范围平均分配到\",{\"1\":{\"51\":1}}],[\"我们将timeout的值设置成了\",{\"1\":{\"398\":1}}],[\"我们将根节点的值与其两个子节点的值进行比较\",{\"1\":{\"212\":1}}],[\"我们将二叉树的根节点称为\",{\"1\":{\"208\":1}}],[\"我们将旋转操作封装成一个函数\",{\"1\":{\"205\":1}}],[\"我们将平衡因子绝对值\",{\"1\":{\"200\":1}}],[\"我们将创建两个工具函数\",{\"1\":{\"199\":1}}],[\"我们将所有节点按照层序遍历的顺序存储在一个数组中\",{\"1\":{\"189\":1}}],[\"我们将该节点的左子节点及其以下节点形成的树称为该节点的左子树\",{\"1\":{\"180\":1}}],[\"我们将哈希表看作一个\",{\"1\":{\"172\":1}}],[\"我们将哈希表扩容至原先的2倍\",{\"1\":{\"170\":1}}],[\"我们将这种多个输入对应同一输出的情况称为哈希冲突\",{\"1\":{\"168\":1}}],[\"我们将\",{\"1\":{\"167\":1}}],[\"我们将数组中的每个空位称为桶\",{\"1\":{\"167\":1}}],[\"我们将数字的二进制表示的最高位视为符号位\",{\"1\":{\"17\":1}}],[\"我们将双向链表的头节点和尾节点视为双向队列的队首和队尾\",{\"1\":{\"163\":1}}],[\"我们将队列头部称为\",{\"1\":{\"159\":1}}],[\"我们将首个节点称为头节点\",{\"1\":{\"153\":1}}],[\"我们将元素在数组中的位置称为该元素的索引\",{\"1\":{\"138\":1}}],[\"我们将其记录至\",{\"1\":{\"94\":1}}],[\"我们将第二个1记为i\",{\"1\":{\"82\":1}}],[\"我们将问题f\",{\"1\":{\"72\":1}}],[\"我们将它直接从\",{\"1\":{\"71\":1}}],[\"我们将海量的数据平均分配到各个桶中\",{\"1\":{\"62\":1}}],[\"我们将探讨几种\",{\"1\":{\"49\":1}}],[\"我们接下来只需对这两个子数组进行排序\",{\"1\":{\"42\":1}}],[\"我们会将元素插入到相等元素的右侧\",{\"1\":{\"41\":1}}],[\"我们会想到文本\",{\"1\":{\"16\":1}}],[\"我们发现数组首个元素的索引为0\",{\"1\":{\"140\":1}}],[\"我们发现该对角线上所有格子的行索引减列索引都相等\",{\"1\":{\"89\":1}}],[\"我们发现\",{\"1\":{\"39\":1}}],[\"我们用k来记录未排序区间内的最小元素\",{\"1\":{\"36\":1}}],[\"我们期望排序算法的时间复杂度尽量低\",{\"1\":{\"33\":1}}],[\"我们开启一个两层循环\",{\"1\":{\"29\":1}}],[\"我们常通过将线性查找替换为哈希查找来降低算法的时间复杂度\",{\"1\":{\"28\":1}}],[\"我们知道\",{\"1\":{\"27\":1,\"62\":1}}],[\"我们需要从这个节点开始\",{\"1\":{\"206\":1}}],[\"我们需要保证在删除操作完成后\",{\"1\":{\"195\":1}}],[\"我们需要通过哈希函数来重新计算所有键值对的存储位置\",{\"1\":{\"168\":1}}],[\"我们需要让\",{\"1\":{\"161\":1}}],[\"我们需要限制相等元素在每一轮中只能被选择一次\",{\"1\":{\"86\":1}}],[\"我们需要添加剪枝操作\",{\"1\":{\"76\":1}}],[\"我们需要将该节点从\",{\"1\":{\"75\":1}}],[\"我们需要将从目标索引到\",{\"1\":{\"40\":1}}],[\"我们需要借助一个哈希表\",{\"1\":{\"223\":1}}],[\"我们需要借助一个列表\",{\"1\":{\"75\":1}}],[\"我们需要借助节点\",{\"1\":{\"194\":1}}],[\"我们需要借助几个指针变量\",{\"1\":{\"68\":1}}],[\"我们需要一种更加高效的\",{\"1\":{\"18\":1}}],[\"我们需要建立一套\",{\"1\":{\"18\":1}}],[\"张飞成绩\",{\"1\":{\"291\":2}}],[\"张三参加考试\",{\"1\":{\"297\":1}}],[\"张三成绩\",{\"1\":{\"291\":2}}],[\"张三\",{\"1\":{\"291\":1,\"302\":1}}],[\"张量\",{\"1\":{\"15\":1}}],[\"源码文件使用\",{\"1\":{\"321\":1}}],[\"源文件代码如下\",{\"1\":{\"289\":1}}],[\"源代码文件以\",{\"1\":{\"271\":1}}],[\"功能作用与静态全局变量一致\",{\"1\":{\"289\":1}}],[\"静态数组\",{\"1\":{\"379\":1}}],[\"静态数据结构\",{\"1\":{\"15\":1}}],[\"静态转换\",{\"1\":{\"357\":1}}],[\"静态变量在程序的整个生命周期内存在\",{\"1\":{\"334\":1}}],[\"静态函数\",{\"1\":{\"289\":1}}],[\"静态全局变量仅对当前文件可见\",{\"1\":{\"289\":1}}],[\"静态全局变量\",{\"1\":{\"289\":1}}],[\"静态局部变量只在函数第一次调用时初始化一次并将生命周期延长到整个程序的执行期间静态局部变量如果声明时没有初始赋值\",{\"1\":{\"289\":1}}],[\"静态局部变量具有如下特点\",{\"1\":{\"289\":1}}],[\"静态局部变量与全局变量一样存储在内存中的全局静态区\",{\"1\":{\"289\":1}}],[\"静态局部变量使用static关键字修饰的局部变量\",{\"1\":{\"289\":1}}],[\"区分结构体\",{\"1\":{\"302\":1}}],[\"区\",{\"1\":{\"288\":1}}],[\"区间调度问题\",{\"1\":{\"117\":1}}],[\"区间为\",{\"1\":{\"36\":1}}],[\"区间\",{\"1\":{\"21\":2,\"46\":2}}],[\"区间每轮缩小一半\",{\"1\":{\"20\":1}}],[\"块级变量\",{\"1\":{\"288\":1}}],[\"块级数组等\",{\"1\":{\"288\":1}}],[\"块级常量\",{\"1\":{\"288\":2}}],[\"块级作用域是c99标准引入的概念\",{\"1\":{\"288\":1}}],[\"块级作用域\",{\"1\":{\"288\":1}}],[\"块级作用域同一个作用域中不能声明同名的标识符\",{\"1\":{\"288\":1}}],[\"外层新加的if判断就会起作用\",{\"1\":{\"354\":1}}],[\"外面的分支结构称为外层分支\",{\"1\":{\"297\":1}}],[\"外部排序算法\",{\"0\":{\"476\":1}}],[\"外部声明\",{\"1\":{\"289\":2}}],[\"外部\",{\"1\":{\"288\":3}}],[\"外循环遍历各行\",{\"1\":{\"102\":1}}],[\"外循环共n\",{\"1\":{\"36\":1}}],[\"外循环\",{\"1\":{\"36\":1,\"38\":1,\"39\":1,\"41\":1}}],[\"局部operator\",{\"1\":{\"361\":1}}],[\"局部数组具有相同的特性\",{\"1\":{\"288\":1}}],[\"局部数组初始化是不安全且强烈不建议的\",{\"1\":{\"288\":1}}],[\"局部数组\",{\"1\":{\"288\":3}}],[\"局部数组等通常存储在栈\",{\"1\":{\"288\":1}}],[\"局部数组等\",{\"1\":{\"288\":1}}],[\"局部变量和局部数组如果没有显式初始化\",{\"1\":{\"288\":1}}],[\"局部变量\",{\"1\":{\"288\":2}}],[\"局部常量\",{\"1\":{\"288\":4}}],[\"局部作用域\",{\"1\":{\"288\":2}}],[\"命名管道是可以实现两个毫不相关进程之间的通信的\",{\"1\":{\"403\":1}}],[\"命名空间可以定义变量\",{\"1\":{\"348\":1}}],[\"命名空间的使用\",{\"1\":{\"348\":2}}],[\"命名需要符合标识符规范元素\",{\"1\":{\"243\":1}}],[\"命令为它起别名为quantity\",{\"1\":{\"304\":1}}],[\"命令用来为某个类型起别名\",{\"1\":{\"304\":1}}],[\"命令进行编译\",{\"1\":{\"287\":1}}],[\"形式\",{\"1\":{\"364\":1,\"373\":1,\"379\":2}}],[\"形式参数\",{\"1\":{\"319\":1}}],[\"形参之间可以出现空格\",{\"1\":{\"319\":1}}],[\"形参列表\",{\"1\":{\"319\":1}}],[\"形参argc\",{\"1\":{\"287\":1}}],[\"形参出了作用域就销毁了\",{\"1\":{\"286\":1}}],[\"形参的改变不影响实参\",{\"1\":{\"286\":1}}],[\"形参\",{\"1\":{\"286\":1}}],[\"形成恶性循环\",{\"1\":{\"172\":1}}],[\"库函数\",{\"1\":{\"285\":2}}],[\"库文件是由系统提供\",{\"1\":{\"271\":1}}],[\"封装性如何保证\",{\"1\":{\"361\":1}}],[\"封装功能\",{\"1\":{\"285\":1}}],[\"封装成一个类\",{\"1\":{\"167\":1}}],[\"特化为char的模板\",{\"1\":{\"367\":2}}],[\"特别注意\",{\"1\":{\"313\":1}}],[\"特别是对于\",{\"1\":{\"18\":1}}],[\"特殊类设计\",{\"1\":{\"354\":1}}],[\"特殊情况\",{\"1\":{\"344\":4}}],[\"特殊值eof\",{\"1\":{\"309\":1}}],[\"特殊记忆\",{\"1\":{\"283\":1}}],[\"尽量使用小括号来控制表达式的执行顺序\",{\"1\":{\"283\":1}}],[\"尽管服务端不读取管道当中的数据\",{\"1\":{\"403\":1}}],[\"尽管在删除操作完成后节点\",{\"1\":{\"149\":1}}],[\"尽管快速排序的平均时间复杂度与\",{\"1\":{\"44\":1}}],[\"尽管这些数据的组织形式各异\",{\"1\":{\"16\":1}}],[\"详细了解建议查文档\",{\"1\":{\"283\":1}}],[\"很复杂\",{\"1\":{\"283\":1}}],[\"很差\",{\"1\":{\"170\":1}}],[\"逗号表达式形式\",{\"1\":{\"282\":1}}],[\"逗号表达式\",{\"0\":{\"282\":1}}],[\"真值\",{\"1\":{\"327\":1}}],[\"真\",{\"1\":{\"281\":1}}],[\"条件变量允许一个线程等待另一个线程满足某个条件后再继续执行\",{\"1\":{\"379\":1}}],[\"条件变量库头文件\",{\"1\":{\"379\":1}}],[\"条件变量库\",{\"1\":{\"379\":1}}],[\"条件编译\",{\"0\":{\"321\":1}}],[\"条件编译等\",{\"1\":{\"317\":1}}],[\"条件表达式2\",{\"1\":{\"297\":1}}],[\"条件表达式1\",{\"1\":{\"297\":1}}],[\"条件表达式为假\",{\"1\":{\"297\":1}}],[\"条件表达式\",{\"1\":{\"281\":1,\"297\":2}}],[\"条边的图\",{\"1\":{\"213\":1}}],[\"短路现象\",{\"1\":{\"278\":2}}],[\"成功使用\",{\"1\":{\"310\":6}}],[\"成员operator\",{\"1\":{\"361\":1}}],[\"成员改为共有\",{\"1\":{\"361\":1}}],[\"成员总大小是5\",{\"1\":{\"361\":1}}],[\"成员中对齐数最大的\",{\"1\":{\"361\":1}}],[\"成员变量放在类中\",{\"1\":{\"361\":1}}],[\"成员变量\",{\"1\":{\"361\":1,\"373\":1}}],[\"成员变量定义习惯在前面加m\",{\"1\":{\"361\":1}}],[\"成员函数放在公共代码段\",{\"1\":{\"361\":1}}],[\"成员函数\",{\"1\":{\"361\":1,\"373\":1}}],[\"成员是结构体的一个组成部分\",{\"1\":{\"302\":1}}],[\"成员的获取和赋值\",{\"1\":{\"302\":1,\"303\":1}}],[\"成员名\",{\"1\":{\"302\":2}}],[\"成员名n\",{\"1\":{\"302\":1,\"303\":1}}],[\"成员名2\",{\"1\":{\"302\":1,\"303\":1}}],[\"成员名1\",{\"1\":{\"302\":1,\"303\":1}}],[\"成绩65\",{\"1\":{\"291\":1}}],[\"成绩\",{\"1\":{\"278\":1,\"291\":1,\"303\":1}}],[\"成为最流行版本\",{\"1\":{\"241\":1}}],[\"成为公认标准\",{\"1\":{\"241\":1}}],[\"逻辑操作符关注的是真假\",{\"1\":{\"278\":1}}],[\"逻辑运算符\",{\"0\":{\"278\":1},\"1\":{\"283\":1}}],[\"逻辑结构揭示了数据元素之间的逻辑关系\",{\"1\":{\"14\":1}}],[\"逻辑结构\",{\"0\":{\"14\":1},\"1\":{\"13\":1}}],[\"余数正负只看被除数的正负②\",{\"1\":{\"276\":1}}],[\"算术运算符是对数值类型的变量进行运算的\",{\"1\":{\"276\":1}}],[\"算术运算符\",{\"0\":{\"276\":1},\"1\":{\"283\":1}}],[\"算法知识\",{\"0\":{\"527\":1}}],[\"算法学习\",{\"0\":{\"526\":1}}],[\"算法题型\",{\"0\":{\"525\":1}}],[\"算法占用内存空间的大小\",{\"1\":{\"135\":1}}],[\"算法运行速度的快慢\",{\"1\":{\"135\":1}}],[\"算法效率已成为衡量算法优劣的主要评价指标\",{\"1\":{\"135\":1}}],[\"算法效率评估\",{\"0\":{\"135\":1}}],[\"算法需要在规定的输入范围内可靠地求得问题的正确解\",{\"1\":{\"135\":1}}],[\"算法通常可以基于不同的数据结构实现\",{\"1\":{\"133\":1}}],[\"算法是数据结构发挥作用的舞台\",{\"1\":{\"133\":1}}],[\"算法的定义\",{\"0\":{\"131\":1}}],[\"算法\",{\"0\":{\"130\":1},\"1\":{\"63\":2,\"117\":1,\"131\":1}}],[\"算法所占用的内存峰值不应超过系统剩余空闲内存\",{\"1\":{\"15\":1}}],[\"算法刷题\",{\"0\":{\"1\":1,\"2\":1,\"3\":1,\"4\":1,\"5\":1,\"6\":1,\"7\":1,\"8\":1,\"9\":1,\"10\":1,\"11\":1,\"12\":1}}],[\"⑤位运算符\",{\"1\":{\"275\":1}}],[\"⑤访问元素\",{\"1\":{\"263\":1}}],[\"④为数组类型起别名\",{\"1\":{\"304\":1}}],[\"④逻辑运算符\",{\"1\":{\"275\":1}}],[\"④初始化\",{\"1\":{\"263\":1}}],[\"③decltype\",{\"1\":{\"357\":1}}],[\"③c99标准还提供了一个头文件\",{\"1\":{\"333\":1}}],[\"③\",{\"1\":{\"321\":2}}],[\"③fscanf\",{\"1\":{\"310\":1}}],[\"③fprintf\",{\"1\":{\"310\":1}}],[\"③为指针取别名\",{\"1\":{\"304\":1}}],[\"③通过结构体指针访问成员\",{\"1\":{\"302\":1}}],[\"③关系运算符\",{\"1\":{\"275\":1}}],[\"③三元运算符\",{\"1\":{\"275\":1}}],[\"③可变性\",{\"1\":{\"263\":1}}],[\"生成默认拷贝构造函数\",{\"1\":{\"361\":1}}],[\"生成最终的可执行的二进制程序\",{\"1\":{\"271\":1}}],[\"生成汇编文件\",{\"1\":{\"271\":1}}],[\"生成经过处理的源代码文件\",{\"1\":{\"271\":1}}],[\"生成子集\",{\"1\":{\"85\":2}}],[\"适用于各种编程语言和应用程序开发任务\",{\"1\":{\"270\":1}}],[\"适合用回溯解决的问题通常满足\",{\"1\":{\"101\":1}}],[\"调整内存大小\",{\"1\":{\"314\":1}}],[\"调试器\",{\"1\":{\"270\":1}}],[\"调用this\",{\"1\":{\"379\":1}}],[\"调用test\",{\"1\":{\"267\":1}}],[\"调用get\",{\"1\":{\"379\":1}}],[\"调用join\",{\"1\":{\"379\":1}}],[\"调用移动构造函数\",{\"1\":{\"379\":2}}],[\"调用无参的构造函数\",{\"1\":{\"379\":1}}],[\"调用无参构造函数\",{\"1\":{\"361\":1,\"379\":2}}],[\"调用并输出结果\",{\"1\":{\"379\":2}}],[\"调用firstfunction是\",{\"1\":{\"379\":1}}],[\"调用派生类的析构函数\",{\"1\":{\"376\":1}}],[\"调用派生类析构函数\",{\"1\":{\"376\":1}}],[\"调用普通成员函数\",{\"1\":{\"376\":1}}],[\"调用纯虚函数\",{\"1\":{\"376\":1}}],[\"调用自身成员函数\",{\"1\":{\"373\":3}}],[\"调用偏特化模板\",{\"1\":{\"367\":1}}],[\"调用全特化模板\",{\"1\":{\"367\":1}}],[\"调用通用模板\",{\"1\":{\"367\":1}}],[\"调用运算符重载\",{\"1\":{\"361\":2}}],[\"调用构造函数\",{\"1\":{\"361\":1}}],[\"调用深拷贝\",{\"1\":{\"361\":1}}],[\"调用浅拷贝\",{\"1\":{\"361\":1}}],[\"调用拷贝构造\",{\"1\":{\"361\":1}}],[\"调用默认构造函数\",{\"1\":{\"361\":1}}],[\"调用默认构造\",{\"1\":{\"361\":2}}],[\"调用带参的构造函数\",{\"1\":{\"361\":1,\"379\":3}}],[\"调用带参数宏定义\",{\"1\":{\"319\":1}}],[\"调用结束就销毁\",{\"1\":{\"288\":1}}],[\"调用\",{\"1\":{\"288\":2}}],[\"调用函数传参时会拷贝构造一次\",{\"1\":{\"361\":1}}],[\"调用函数\",{\"1\":{\"264\":2,\"286\":1,\"288\":2,\"290\":1}}],[\"调用栈\",{\"1\":{\"136\":1}}],[\"集成开发环境\",{\"1\":{\"270\":1}}],[\"野指针的成因\",{\"1\":{\"267\":1}}],[\"野指针就是指针指向的位置是不可知\",{\"1\":{\"267\":1}}],[\"野指针\",{\"0\":{\"267\":1}}],[\"带参构造函数\",{\"1\":{\"361\":1}}],[\"带参数的宏实现\",{\"1\":{\"319\":1}}],[\"带参数的宏定义基本介绍\",{\"1\":{\"319\":1}}],[\"带参数的宏定义\",{\"0\":{\"319\":1}}],[\"带参宏定义和函数的区别\",{\"1\":{\"319\":1}}],[\"带参宏定义\",{\"1\":{\"319\":1}}],[\"带参宏定义中\",{\"1\":{\"319\":1}}],[\"带有\",{\"1\":{\"264\":1}}],[\"带约束爬楼梯\",{\"1\":{\"99\":1}}],[\"带约束的爬楼梯问题\",{\"1\":{\"99\":1}}],[\"传输层\",{\"0\":{\"518\":1,\"519\":1}}],[\"传递变量的地址给新线程\",{\"1\":{\"379\":2}}],[\"传递引用\",{\"1\":{\"379\":1}}],[\"传递引用给函数修改\",{\"1\":{\"379\":1}}],[\"传递一个指向数组的指针作为参数\",{\"1\":{\"264\":1}}],[\"传递指针给函数当函数的形参类型是指针类型时\",{\"1\":{\"264\":1}}],[\"传数组给函数数组名本身就代表数组首地址\",{\"1\":{\"264\":1}}],[\"传指针\",{\"1\":{\"264\":1}}],[\"传地址\",{\"1\":{\"264\":1}}],[\"传地址或指针给函数\",{\"1\":{\"264\":1}}],[\"传入n个顶点\",{\"1\":{\"218\":1}}],[\"传入\",{\"1\":{\"56\":1}}],[\"错误的使用方式\",{\"1\":{\"357\":1}}],[\"错误使用\",{\"1\":{\"348\":1}}],[\"错误信号报告\",{\"1\":{\"292\":1}}],[\"错误\",{\"1\":{\"263\":1,\"318\":1,\"357\":1}}],[\"②dynamic\",{\"1\":{\"357\":1}}],[\"②c++98通过将拷贝构造函数声明为私有以达到防拷贝的目的\",{\"1\":{\"354\":1}}],[\"②c99标准提供了\",{\"1\":{\"333\":1}}],[\"②\",{\"1\":{\"321\":2}}],[\"②fgets\",{\"1\":{\"310\":1}}],[\"②fputs\",{\"1\":{\"310\":1}}],[\"②为结构体\",{\"1\":{\"304\":1}}],[\"②声明结构体指针\",{\"1\":{\"302\":1}}],[\"②赋值运算符\",{\"1\":{\"275\":1}}],[\"②二元运算符\",{\"1\":{\"275\":1}}],[\"②类型不同\",{\"1\":{\"263\":1}}],[\"②使用const关键字\",{\"1\":{\"255\":1}}],[\"①typeid\",{\"1\":{\"357\":1}}],[\"①向外部提供的createobj函数必须设置为静态成员函数\",{\"1\":{\"354\":1}}],[\"①宏定义\",{\"1\":{\"333\":1}}],[\"①fgetc\",{\"1\":{\"310\":1}}],[\"①fputc\",{\"1\":{\"310\":1}}],[\"①为某个基本类型起别名\",{\"1\":{\"304\":1}}],[\"①结构体指针介绍\",{\"1\":{\"302\":1}}],[\"①\",{\"1\":{\"276\":1,\"321\":1}}],[\"①算术运算符\",{\"1\":{\"275\":1}}],[\"①一元运算符\",{\"1\":{\"275\":1}}],[\"①指向不同\",{\"1\":{\"263\":1}}],[\"①使用\",{\"1\":{\"255\":1}}],[\"地址有25位\",{\"1\":{\"344\":1}}],[\"地址\",{\"1\":{\"344\":2}}],[\"地址或者数组给该形参\",{\"1\":{\"264\":1}}],[\"地址指向下一个元素\",{\"1\":{\"263\":1}}],[\"地解决问题\",{\"1\":{\"136\":2}}],[\"报错\",{\"1\":{\"263\":2,\"288\":8,\"289\":1,\"373\":2,\"376\":1}}],[\"案例演示如下\",{\"1\":{\"262\":1}}],[\"低位开始\",{\"1\":{\"326\":1}}],[\"低位地址减去高位地址\",{\"1\":{\"262\":1}}],[\"低于\",{\"1\":{\"51\":1}}],[\"防止外部创建或拷贝对象\",{\"1\":{\"354\":4}}],[\"防止外部直接调用构造函数在堆上创建对象\",{\"1\":{\"354\":1}}],[\"防止外部调用拷贝函数在栈上创建对象\",{\"1\":{\"354\":1}}],[\"防止对智能指针对象进行拷贝\",{\"1\":{\"351\":1}}],[\"防止被再次加载\",{\"1\":{\"321\":1}}],[\"防止内存泄漏\",{\"1\":{\"314\":1}}],[\"防止出问题\",{\"1\":{\"261\":1}}],[\"防止频繁扩容\",{\"1\":{\"168\":1}}],[\"放后面或者上面声明下函数就行\",{\"1\":{\"379\":1}}],[\"放左边\",{\"1\":{\"261\":1}}],[\"放置下一行\",{\"1\":{\"90\":1}}],[\"放置到对应索引处\",{\"1\":{\"54\":1}}],[\"靠近数据类型\",{\"1\":{\"261\":1}}],[\"远远超过了通常需要的内存大小\",{\"1\":{\"261\":1}}],[\"远远没有达到哈希算法的设计目标\",{\"1\":{\"178\":1}}],[\"那个时候我们再进行数据读取就不会被阻塞住了添加文件描述符到fd\",{\"1\":{\"440\":1}}],[\"那我们此时实现的就是文件上传的功能\",{\"1\":{\"406\":1}}],[\"那当s1调用setdate函数时\",{\"1\":{\"361\":1}}],[\"那如何访问内存中的变量数据呢\",{\"1\":{\"261\":1}}],[\"那么服务器的响应数据也不应该直接调用write函数发送给客户端\",{\"1\":{\"442\":1}}],[\"那么服务器就会在调用epoll\",{\"1\":{\"398\":1}}],[\"那么服务器就会在调用poll函数后进行阻塞等待\",{\"1\":{\"391\":1}}],[\"那么文件描述符就会添加失败\",{\"1\":{\"440\":1}}],[\"那么每次select函数调用5秒后都会进行超时返回\",{\"1\":{\"439\":1}}],[\"那么select服务器就会一直调用select函数进行轮询检测\",{\"1\":{\"439\":1}}],[\"那么select的返回值就是等于0的\",{\"1\":{\"439\":1}}],[\"那么select函数将会进行超时返回\",{\"1\":{\"439\":1}}],[\"那么select函数调用后的5秒内会进行阻塞等待\",{\"1\":{\"439\":1}}],[\"那么select函数调用后就会进行非阻塞等待\",{\"1\":{\"439\":1}}],[\"那么select函数的返回值就是大于0的\",{\"1\":{\"439\":1}}],[\"那么读事件就不会就绪\",{\"1\":{\"439\":1}}],[\"那么实现的就是文件下载的功能\",{\"1\":{\"406\":1}}],[\"那么当客户端下一次再向管道写入数据时\",{\"1\":{\"403\":1}}],[\"那么此时服务端也就会去执行它的其他代码了\",{\"1\":{\"403\":1}}],[\"那么问题来了\",{\"1\":{\"361\":1}}],[\"那么在每次调用select函数之前也都需要对timeout的值进行重新设置\",{\"1\":{\"439\":1}}],[\"那么在后续调用getinstance函数获取已经创建好的单例对象时\",{\"1\":{\"354\":1}}],[\"那么在卖出之前不能再买\",{\"1\":{\"117\":1}}],[\"那么这个管道文件的大小会不会发生变化呢\",{\"1\":{\"403\":1}}],[\"那么这时就需要加锁了\",{\"1\":{\"354\":1}}],[\"那么这两个数字构成一个逆序对\",{\"1\":{\"63\":1}}],[\"那么表达式的值为真\",{\"1\":{\"278\":1}}],[\"那么编译时就全部替换成指定的常量值\",{\"1\":{\"255\":1}}],[\"那么假设要删除索引为i的顶点\",{\"1\":{\"219\":1}}],[\"那么矩阵元素m\",{\"1\":{\"216\":1}}],[\"那么二叉树中所有节点的索引都会发生变化\",{\"1\":{\"212\":1}}],[\"那么数据就被视为完整\",{\"1\":{\"176\":1}}],[\"那么密码就被视为正确\",{\"1\":{\"176\":1}}],[\"那么可以省去初始化步骤\",{\"1\":{\"158\":1}}],[\"那么多余的空间就被浪费了\",{\"1\":{\"138\":1}}],[\"那么贪心算法在一些情况下可以得到最优解\",{\"1\":{\"117\":1}}],[\"那么贪心算法就可以得到最优解\",{\"1\":{\"117\":1}}],[\"那么遍历到dp\",{\"1\":{\"111\":1}}],[\"那么它就满足决策树模型\",{\"1\":{\"101\":1}}],[\"那么它通常适合用动态规划求解\",{\"1\":{\"101\":1}}],[\"那么如何去除重复的排列呢\",{\"1\":{\"82\":1}}],[\"那么\",{\"1\":{\"60\":1,\"89\":1,\"167\":1,\"188\":1,\"321\":1}}],[\"那么所选用的数据结构必须能够存储在分散的内存空间内\",{\"1\":{\"15\":1}}],[\"控制语句关键字\",{\"1\":{\"259\":1}}],[\"见名知意\",{\"1\":{\"258\":1}}],[\"$zj\",{\"1\":{\"257\":1}}],[\"合二为一\",{\"1\":{\"361\":1}}],[\"合法标识符举例\",{\"1\":{\"257\":1}}],[\"合并在一起\",{\"1\":{\"271\":1}}],[\"合并两个子数组需要o\",{\"1\":{\"61\":1}}],[\"合并左子数组和右子数组\",{\"1\":{\"46\":1}}],[\"合并操作需要借助辅助数组实现\",{\"1\":{\"46\":1}}],[\"合并阶段中的每个子数组都是有序的\",{\"1\":{\"46\":1}}],[\"合并阶段\",{\"1\":{\"45\":1,\"46\":2,\"58\":1}}],[\"合并\",{\"1\":{\"45\":1}}],[\"跟使用\",{\"1\":{\"255\":1}}],[\"跟进新技术\",{\"1\":{\"241\":1}}],[\"yaer\",{\"1\":{\"361\":1}}],[\"y的值为\",{\"1\":{\"348\":4}}],[\"you\",{\"1\":{\"309\":2}}],[\"your\",{\"1\":{\"252\":1}}],[\"y2=\",{\"1\":{\"276\":2}}],[\"y2\",{\"1\":{\"276\":2}}],[\"y1=67\",{\"1\":{\"276\":1}}],[\"y1=\",{\"1\":{\"276\":1}}],[\"y1\",{\"1\":{\"276\":2}}],[\"y\",{\"1\":{\"276\":2,\"286\":3,\"318\":5,\"319\":15,\"348\":14,\"357\":7,\"361\":5,\"379\":1}}],[\"year=year\",{\"1\":{\"361\":1}}],[\"year=0\",{\"1\":{\"361\":1}}],[\"year<<\",{\"1\":{\"361\":2}}],[\"year\",{\"1\":{\"361\":87}}],[\"year等\",{\"1\":{\"258\":1}}],[\"yes\",{\"1\":{\"108\":2,\"109\":2}}],[\"把临时对象当成a2来用了\",{\"1\":{\"361\":1}}],[\"把a的元素赋值给e相当于形参的改变不影响实参\",{\"1\":{\"348\":1}}],[\"把变量b\",{\"1\":{\"251\":2}}],[\"把变量a\",{\"1\":{\"251\":1}}],[\"把索引\",{\"1\":{\"141\":1,\"142\":1}}],[\"作返回值就调用拷贝构造函数\",{\"1\":{\"361\":1}}],[\"作函数参数\",{\"1\":{\"361\":1}}],[\"作用\",{\"1\":{\"379\":1}}],[\"作用与int相同\",{\"1\":{\"304\":1}}],[\"作用域和内存\",{\"1\":{\"288\":1}}],[\"作用域用于确定在代码中某个标识符\",{\"1\":{\"288\":1}}],[\"作用是取出指针指向的内存地址处的数据值\",{\"1\":{\"261\":1}}],[\"作用是取出变量的内存地址\",{\"1\":{\"261\":1}}],[\"作用是将输出的数据转换为指定的格式后输出\",{\"1\":{\"251\":1}}],[\"作为扩展名\",{\"1\":{\"271\":1}}],[\"作为字符串结束的标志\",{\"1\":{\"245\":1}}],[\"作为\",{\"1\":{\"201\":1,\"202\":1}}],[\"作为双向队列的底层数据结构\",{\"1\":{\"163\":1}}],[\"格式如下\",{\"1\":{\"287\":1,\"320\":2}}],[\"格式输出中对应的格式占位符是\",{\"1\":{\"262\":1}}],[\"格式占位符是\",{\"1\":{\"335\":1}}],[\"格式占位符\",{\"1\":{\"251\":1,\"331\":1}}],[\"格式化输入输出函数\",{\"1\":{\"291\":1}}],[\"格式化字符串是用双引号括起来的一个字符串\",{\"1\":{\"251\":1}}],[\"格式化打印\",{\"1\":{\"251\":1}}],[\"修改引用的对象值\",{\"1\":{\"379\":1}}],[\"修改联系人成功\",{\"1\":{\"344\":1}}],[\"修改联系人\",{\"1\":{\"342\":1,\"344\":4}}],[\"修改变量\",{\"1\":{\"250\":1,\"251\":1}}],[\"修改第二个元素的值\",{\"1\":{\"244\":1}}],[\"行\",{\"1\":{\"246\":1}}],[\"行索引\",{\"1\":{\"246\":1}}],[\"行和列置零\",{\"1\":{\"218\":1}}],[\"四维数组\",{\"1\":{\"246\":1}}],[\"三码合一\",{\"1\":{\"327\":1}}],[\"三种继承方式\",{\"1\":{\"373\":1}}],[\"三种打开方式对比参考代码\",{\"1\":{\"310\":1}}],[\"三种情况\",{\"1\":{\"195\":1}}],[\"三元运算符\",{\"1\":{\"283\":1}}],[\"三目运算符\",{\"0\":{\"281\":1},\"1\":{\"275\":1}}],[\"三级指针指向\",{\"1\":{\"265\":1}}],[\"三级指针\",{\"1\":{\"265\":2}}],[\"三维数组\",{\"1\":{\"246\":1}}],[\"号开头\",{\"1\":{\"317\":1}}],[\"号\",{\"1\":{\"245\":1}}],[\"省略第一次参数时x给u的拷贝构造\",{\"1\":{\"361\":1}}],[\"省略一次\",{\"1\":{\"361\":1}}],[\"省略\",{\"1\":{\"245\":1}}],[\"显示this指针的原函数\",{\"1\":{\"361\":1}}],[\"显示全部通讯录联系人\",{\"1\":{\"344\":1}}],[\"显示通讯录功能界面\",{\"1\":{\"344\":1}}],[\"显示通讯录中所有联系人信息\",{\"1\":{\"342\":1}}],[\"显示通讯录\",{\"1\":{\"342\":1,\"344\":2}}],[\"显示前缀\",{\"1\":{\"325\":2}}],[\"显示类型转换\",{\"0\":{\"338\":1},\"1\":{\"313\":1,\"357\":1}}],[\"显式的调用构造函数\",{\"1\":{\"379\":1}}],[\"显式实例化为\",{\"1\":{\"367\":1}}],[\"显式实例化\",{\"1\":{\"367\":2}}],[\"显式类型转换\",{\"1\":{\"313\":1,\"336\":1,\"357\":1}}],[\"显式地设值\",{\"1\":{\"245\":1}}],[\"显然1是最差的\",{\"1\":{\"127\":1}}],[\"显然\",{\"1\":{\"34\":1,\"59\":1,\"221\":1}}],[\"运算过程中\",{\"1\":{\"337\":1}}],[\"运算过程中的隐式转换\",{\"1\":{\"337\":1}}],[\"运算结果的符号与被模数也就是第一个操作数相同\",{\"1\":{\"276\":1}}],[\"运算符重载默认形参this\",{\"1\":{\"361\":1}}],[\"运算符重载格式\",{\"1\":{\"361\":1}}],[\"运算符取出它指向的值\",{\"1\":{\"313\":1}}],[\"运算符优先级总结\",{\"1\":{\"283\":1}}],[\"运算符优先级\",{\"0\":{\"283\":1}}],[\"运算符分类\",{\"1\":{\"275\":1}}],[\"运算符的组合\",{\"1\":{\"275\":1}}],[\"运算符基础\",{\"0\":{\"275\":1}}],[\"运算符返回的是整个数组的大小\",{\"1\":{\"263\":1}}],[\"运算符\",{\"0\":{\"274\":1},\"1\":{\"263\":1,\"275\":1}}],[\"运算符间接计算出数组长度\",{\"1\":{\"244\":1}}],[\"运行服务器后如果没有客户端发来连接请求\",{\"1\":{\"439\":2}}],[\"运行服务器\",{\"0\":{\"389\":1,\"396\":1}}],[\"运行时推演一个表达式或函数返回值类型\",{\"1\":{\"357\":1}}],[\"运行时识别父类的指针或引用\",{\"1\":{\"357\":1}}],[\"运行时识别对象类型\",{\"1\":{\"357\":1}}],[\"运行时类型识别\",{\"1\":{\"357\":1}}],[\"运行结果\",{\"1\":{\"348\":6,\"351\":1,\"357\":2,\"361\":2,\"367\":6,\"370\":2,\"373\":2,\"376\":4,\"379\":16,\"382\":2}}],[\"运行\",{\"1\":{\"271\":1,\"291\":1,\"379\":1}}],[\"运行高效\",{\"1\":{\"42\":1}}],[\"运行快\",{\"1\":{\"34\":1}}],[\"运行速度也更快\",{\"1\":{\"33\":1}}],[\"运行效率显得尤为重要\",{\"1\":{\"33\":1}}],[\"运行效率\",{\"1\":{\"33\":1}}],[\"超出范围视为越界\",{\"1\":{\"244\":1}}],[\"超出数组长度范围的元素会丢失\",{\"1\":{\"142\":1}}],[\"速度很快\",{\"1\":{\"243\":1}}],[\"占位符\",{\"1\":{\"331\":1}}],[\"占据2个字节\",{\"1\":{\"262\":1}}],[\"占据的空间的大小\",{\"1\":{\"243\":1}}],[\"占用的字节宽度可能是不一样的\",{\"1\":{\"330\":1}}],[\"占用的空间\",{\"1\":{\"96\":1}}],[\"占用o\",{\"1\":{\"186\":1}}],[\"占用空间增大\",{\"1\":{\"170\":1}}],[\"占用了\",{\"1\":{\"142\":1,\"149\":1}}],[\"角标\",{\"1\":{\"243\":1}}],[\"什么是共用体\",{\"1\":{\"303\":1}}],[\"什么是结构体\",{\"1\":{\"302\":1}}],[\"什么是枚举\",{\"1\":{\"301\":1}}],[\"什么是函数\",{\"1\":{\"285\":1}}],[\"什么是野指针\",{\"1\":{\"267\":1}}],[\"什么是指针\",{\"1\":{\"261\":1}}],[\"什么是数组\",{\"1\":{\"243\":1}}],[\"什么是程序\",{\"0\":{\"239\":1}}],[\"消除实现定义行为\",{\"1\":{\"241\":1}}],[\"注释\",{\"1\":{\"241\":1}}],[\"注意事项和细节\",{\"1\":{\"319\":1}}],[\"注意使用最短路径\",{\"1\":{\"297\":1}}],[\"注意\",{\"1\":{\"83\":1,\"142\":1,\"149\":1,\"212\":1,\"225\":1,\"255\":1,\"263\":1,\"270\":1,\"276\":2,\"278\":1,\"299\":1,\"302\":1,\"304\":1,\"314\":1,\"321\":1,\"327\":1,\"330\":1,\"348\":2,\"361\":1,\"373\":3,\"379\":1,\"382\":2}}],[\"规范命名风格\",{\"0\":{\"258\":1}}],[\"规范了k\",{\"1\":{\"241\":1}}],[\"规定队尾仅可添加节点\",{\"1\":{\"160\":1}}],[\"规定每个字符和二进制数之间的一一对应关系\",{\"1\":{\"18\":1}}],[\"汇编器将汇编代码翻译成机器码并生成一个或多个目标文件\",{\"1\":{\"271\":1}}],[\"汇编\",{\"1\":{\"271\":1}}],[\"汇编语言\",{\"1\":{\"240\":1}}],[\"汇聚每一层的结果\",{\"1\":{\"136\":1}}],[\"文件管理\",{\"0\":{\"505\":1,\"506\":1}}],[\"文件流对象\",{\"1\":{\"370\":1}}],[\"文件名\",{\"1\":{\"320\":1,\"361\":1}}],[\"文件包含\",{\"0\":{\"320\":1},\"1\":{\"317\":1}}],[\"文件读写操作成员函数使用的时候查文档来用\",{\"1\":{\"370\":1}}],[\"文件读写完毕后\",{\"1\":{\"310\":1}}],[\"文件读\",{\"1\":{\"370\":1}}],[\"文件读取结束判断函数\",{\"1\":{\"310\":1}}],[\"文件的随机访问函数\",{\"1\":{\"310\":1}}],[\"文件中数据的输入\",{\"1\":{\"308\":1}}],[\"文件最主要的作用就是保存数据\",{\"1\":{\"308\":1}}],[\"文件是数据源\",{\"1\":{\"308\":1}}],[\"文件基本介绍\",{\"0\":{\"308\":1}}],[\"文件操作\",{\"0\":{\"307\":1}}],[\"文件\",{\"0\":{\"236\":1},\"1\":{\"271\":1,\"308\":1,\"310\":1}}],[\"枚举成员\",{\"1\":{\"361\":1}}],[\"枚举变量的值应该是枚举类型中的枚举常量中的一个\",{\"1\":{\"301\":1}}],[\"枚举变量什么是枚举变量\",{\"1\":{\"301\":1}}],[\"枚举元素的值自动分配\",{\"1\":{\"301\":1}}],[\"枚举元素的值必须在同一枚举中是唯一的枚举元素的值必须是整数类型\",{\"1\":{\"301\":1}}],[\"枚举元素也称为枚举成员或枚举常量\",{\"1\":{\"301\":1}}],[\"枚举元素n\",{\"1\":{\"301\":1}}],[\"枚举元素2\",{\"1\":{\"301\":1}}],[\"枚举元素1\",{\"1\":{\"301\":1}}],[\"枚举名称\",{\"1\":{\"301\":1}}],[\"枚举名称和枚举元素名称都是标识符\",{\"1\":{\"301\":1}}],[\"枚举使用\",{\"1\":{\"301\":1}}],[\"枚举使我们可以为这些常量分配有意义的名字\",{\"1\":{\"301\":1}}],[\"枚举可以帮助我们限制变量的有效值\",{\"1\":{\"301\":1}}],[\"枚举类型\",{\"1\":{\"297\":1}}],[\"枚举\",{\"0\":{\"233\":1,\"301\":1},\"1\":{\"301\":1}}],[\"曲虚线代表向上回溯\",{\"1\":{\"225\":1}}],[\"弹出队首顶点并记录访问\",{\"1\":{\"223\":1}}],[\"始终优先访问距离最近的顶点\",{\"1\":{\"222\":1}}],[\"广度优先遍历是一种由近及远的遍历方式\",{\"1\":{\"222\":1}}],[\"广度优先遍历\",{\"0\":{\"222\":1},\"1\":{\"223\":1}}],[\"广度优先遍历和深度优先遍历\",{\"1\":{\"221\":1}}],[\"广度优先遍历通常借助\",{\"1\":{\"186\":1}}],[\"类内访问用protected\",{\"1\":{\"373\":1}}],[\"类内外都可访问用public\",{\"1\":{\"373\":1}}],[\"类模板偏特化为int类型\",{\"1\":{\"367\":1}}],[\"类模板全特化为int类型和值为5\",{\"1\":{\"367\":1}}],[\"类模板隐式实例化\",{\"1\":{\"367\":1}}],[\"类模板显式实例化\",{\"1\":{\"367\":1}}],[\"类模板的定义\",{\"1\":{\"367\":1}}],[\"类里面定义默认就是inline\",{\"1\":{\"361\":1}}],[\"类里面的operator\",{\"1\":{\"361\":1}}],[\"类外的operator\",{\"1\":{\"361\":1}}],[\"类对象初始化\",{\"1\":{\"361\":1}}],[\"类中什么都没有\",{\"1\":{\"361\":1}}],[\"类中仅有成员函数\",{\"1\":{\"361\":1}}],[\"类中既有成员变量\",{\"1\":{\"361\":1}}],[\"类大小\",{\"1\":{\"361\":1}}],[\"类的大小问题\",{\"1\":{\"361\":1}}],[\"类的定义\",{\"1\":{\"361\":1}}],[\"类的引入\",{\"1\":{\"361\":1}}],[\"类型的指针\",{\"1\":{\"376\":1}}],[\"类型转换\",{\"1\":{\"338\":1}}],[\"类型取值范围\",{\"1\":{\"332\":1}}],[\"类型本质上整数可以进行运算\",{\"1\":{\"332\":1}}],[\"类型都必须使用\",{\"1\":{\"331\":1}}],[\"类型字面量需要使用单引号包裹\",{\"1\":{\"332\":1}}],[\"类型字面量\",{\"1\":{\"330\":2}}],[\"类型起了三个别名\",{\"1\":{\"304\":1}}],[\"类型名称\",{\"1\":{\"330\":1}}],[\"类型名\",{\"1\":{\"304\":1,\"338\":1}}],[\"类型c语言没有其他语言的对象\",{\"1\":{\"302\":1}}],[\"类型是\",{\"1\":{\"263\":1}}],[\"类型是一个带符号的整数\",{\"1\":{\"262\":1}}],[\"类型整数\",{\"1\":{\"262\":1}}],[\"类型数据\",{\"1\":{\"262\":1}}],[\"类型指针\",{\"1\":{\"262\":1}}],[\"类型\",{\"1\":{\"259\":1,\"330\":7,\"331\":4,\"337\":2,\"348\":2,\"379\":1}}],[\"类型安全性更强\",{\"1\":{\"255\":1}}],[\"类型检查\",{\"1\":{\"255\":1}}],[\"类来表示顶点\",{\"1\":{\"219\":1}}],[\"类似地\",{\"1\":{\"207\":1}}],[\"类似于\",{\"1\":{\"310\":2}}],[\"类似于数组扩容\",{\"1\":{\"168\":1}}],[\"类似于全排列问题\",{\"1\":{\"85\":1}}],[\"类似的子问题\",{\"1\":{\"59\":1}}],[\"另外\",{\"1\":{\"219\":1}}],[\"另一个用于访问列\",{\"1\":{\"246\":1}}],[\"另一部分研究人员和黑客则致力于寻找哈希算法的安全性问题\",{\"1\":{\"178\":1}}],[\"另一子数组的元素比基准值大\",{\"1\":{\"63\":1}}],[\"另一方面\",{\"1\":{\"18\":1,\"63\":1}}],[\"需加后缀\",{\"1\":{\"331\":1}}],[\"需按照如下写法\",{\"1\":{\"320\":1}}],[\"需保证唯一性和整型类型\",{\"1\":{\"301\":1}}],[\"需先定义再使用\",{\"1\":{\"285\":1}}],[\"需先自减一次\",{\"1\":{\"262\":1}}],[\"需使用格式占位符\",{\"1\":{\"261\":1}}],[\"需遍历整个邻接表\",{\"1\":{\"219\":1}}],[\"需要进行的处理动作就不是将其打印到显示器了\",{\"1\":{\"404\":1}}],[\"需要显式的进行类型转换\",{\"1\":{\"379\":1}}],[\"需要深拷贝才能解决问题\",{\"1\":{\"361\":1}}],[\"需要深拷贝解决问题\",{\"1\":{\"361\":1}}],[\"需要添加后缀\",{\"1\":{\"330\":3}}],[\"需要编译的语句\",{\"1\":{\"321\":1}}],[\"需要要先获得内存块\",{\"1\":{\"313\":1}}],[\"需要满足标识符规范我们在开发中不建议使用goto语句\",{\"1\":{\"299\":1}}],[\"需要传形参的地址与实参建立真正的变量联系注意\",{\"1\":{\"286\":1}}],[\"需要传递指针\",{\"1\":{\"264\":1}}],[\"需要根据指针的级别使用适当数量的星号解引用操作\",{\"1\":{\"265\":1}}],[\"需要根据具体的数据特点和问题需求来决定\",{\"1\":{\"34\":1}}],[\"需要加分号\",{\"1\":{\"255\":1}}],[\"需要使用多个星号来表示指针的级别\",{\"1\":{\"265\":1}}],[\"需要使用双层循环结构\",{\"1\":{\"246\":1}}],[\"需要使用两个下标\",{\"1\":{\"246\":1}}],[\"需要同时删除两个方向的边\",{\"1\":{\"219\":1}}],[\"需要将\",{\"1\":{\"218\":1}}],[\"需要从底至顶执行旋转操作\",{\"1\":{\"207\":1}}],[\"需要先对\",{\"1\":{\"204\":1}}],[\"需要先排序数组\",{\"1\":{\"85\":1}}],[\"需要在函数体内与return语句搭配使用如果返回值类型不是void\",{\"1\":{\"286\":1}}],[\"需要在左旋中添加一步\",{\"1\":{\"202\":1}}],[\"需要在右旋中添加一步\",{\"1\":{\"201\":1}}],[\"需要特别注意的是\",{\"1\":{\"199\":1}}],[\"需要借助搜索算法来实现\",{\"1\":{\"185\":1}}],[\"需要针对具体情况进行分析\",{\"1\":{\"158\":1}}],[\"需要遍历整个物品列表\",{\"1\":{\"120\":1}}],[\"需要返回具体的多个方案\",{\"1\":{\"101\":1}}],[\"需要复制矩阵\",{\"1\":{\"90\":1}}],[\"需要复制长度为n的列表\",{\"1\":{\"82\":1}}],[\"需要注意以下两点\",{\"1\":{\"194\":1}}],[\"需要注意两点\",{\"1\":{\"85\":1,\"170\":1}}],[\"需要注意的是两个进程之间的通信\",{\"1\":{\"404\":1}}],[\"需要注意的是\",{\"1\":{\"46\":1,\"252\":1,\"288\":1,\"320\":1,\"331\":1}}],[\"需要遵守以下规则\",{\"1\":{\"70\":1}}],[\"参数列表\",{\"1\":{\"379\":1}}],[\"参数arg将被完美转发到secondfunction\",{\"1\":{\"379\":1}}],[\"参数不同\",{\"1\":{\"348\":1}}],[\"参数说明\",{\"1\":{\"309\":1,\"310\":3,\"314\":2,\"344\":14}}],[\"参数写在小括号中\",{\"1\":{\"286\":1}}],[\"参数\",{\"1\":{\"218\":2}}],[\"参考全排列解法\",{\"1\":{\"85\":1}}],[\"度\",{\"1\":{\"214\":1}}],[\"度的取值范围是\",{\"1\":{\"181\":1}}],[\"路径\",{\"1\":{\"214\":2}}],[\"顶点数量最多为|v|\",{\"1\":{\"225\":1}}],[\"顶点列表\",{\"1\":{\"218\":1}}],[\"顶点列表为v\",{\"1\":{\"216\":1}}],[\"顶点索引越界\",{\"1\":{\"218\":1}}],[\"顶点不能与自身相连\",{\"1\":{\"216\":1}}],[\"顶点\",{\"1\":{\"214\":1,\"219\":1}}],[\"顶部\",{\"1\":{\"73\":4}}],[\"顶部拿出一个圆盘\",{\"1\":{\"73\":1}}],[\"顶部的i个圆盘借助缓冲柱\",{\"1\":{\"73\":1}}],[\"顶部的两个圆盘看作一个整体\",{\"1\":{\"72\":1}}],[\"称这两顶点\",{\"1\":{\"214\":1}}],[\"称为宏替换或宏展开\",{\"1\":{\"318\":1}}],[\"称为静态局部变量\",{\"1\":{\"289\":1}}],[\"称为标识符\",{\"1\":{\"256\":1}}],[\"称为空字符\",{\"1\":{\"245\":1}}],[\"称为状态转移方程\",{\"1\":{\"95\":1}}],[\"称为初始状态\",{\"1\":{\"95\":1}}],[\"称为\",{\"1\":{\"18\":1,\"95\":1}}],[\"邻接表结构与哈希表中的\",{\"1\":{\"217\":1}}],[\"邻接表仅存储实际存在的边\",{\"1\":{\"217\":1}}],[\"邻接表\",{\"0\":{\"217\":1},\"1\":{\"215\":1,\"217\":1}}],[\"邻接矩阵与邻接表的效率对比\",{\"0\":{\"220\":1}}],[\"邻接矩阵具有以下特性\",{\"1\":{\"216\":1}}],[\"邻接矩阵\",{\"0\":{\"216\":1},\"1\":{\"215\":1,\"216\":1,\"218\":1}}],[\"邻接\",{\"1\":{\"214\":2}}],[\"亲密度\",{\"1\":{\"214\":1}}],[\"王者荣耀\",{\"1\":{\"214\":1}}],[\"至少有一个顶点无法到达\",{\"1\":{\"214\":1}}],[\"至此select服务器编写完毕\",{\"1\":{\"441\":1}}],[\"至此\",{\"1\":{\"72\":1}}],[\"被分离后的线程不需要创建线程调用join\",{\"1\":{\"379\":1}}],[\"被分配到同一个桶中的概率就越低\",{\"1\":{\"168\":1}}],[\"被处理的方式与文件相同\",{\"1\":{\"309\":1}}],[\"被关注\",{\"1\":{\"214\":1}}],[\"关闭file\",{\"1\":{\"406\":2}}],[\"关闭命名管道文件\",{\"1\":{\"403\":3,\"404\":1,\"405\":1,\"406\":2}}],[\"关闭文件\",{\"1\":{\"310\":10,\"344\":1,\"370\":2}}],[\"关于存储大小单位\",{\"1\":{\"330\":1}}],[\"关系运算符返回值是布尔类型bool值\",{\"1\":{\"277\":1}}],[\"关系运算符\",{\"0\":{\"277\":1},\"1\":{\"283\":1}}],[\"关系\",{\"1\":{\"214\":1,\"221\":1}}],[\"关注\",{\"1\":{\"214\":1}}],[\"关键路径\",{\"0\":{\"466\":1}}],[\"关键字来定义\",{\"1\":{\"301\":1}}],[\"关键字修饰的全局变量称为静态全局变量普通全局变量对整个工程可见\",{\"1\":{\"289\":1}}],[\"关键字是一些具有特殊含义的保留单词\",{\"1\":{\"259\":1}}],[\"关键字\",{\"0\":{\"259\":1}}],[\"关键字定义的标识符常量以及枚举常量\",{\"1\":{\"254\":1}}],[\"关键词\",{\"1\":{\"142\":1,\"149\":1,\"195\":1,\"207\":1}}],[\"关键是如何优化效率\",{\"1\":{\"78\":1}}],[\"关键在于将元素均匀分配到各个桶中\",{\"1\":{\"51\":1}}],[\"好友关系\",{\"1\":{\"214\":1}}],[\"网络安全\",{\"0\":{\"522\":1,\"523\":1}}],[\"网络层\",{\"0\":{\"516\":1,\"517\":1}}],[\"网络\",{\"1\":{\"406\":1}}],[\"网络关系\",{\"1\":{\"213\":1}}],[\"网格中的每个单元格包含一个非负整数\",{\"1\":{\"102\":1}}],[\"判空处理\",{\"1\":{\"212\":1}}],[\"判断该线程是否已经执行完毕\",{\"1\":{\"379\":1}}],[\"判断static指针是否为空\",{\"1\":{\"354\":1}}],[\"判断库文件是否被加载了\",{\"1\":{\"321\":1}}],[\"判断是否自己赋值自己\",{\"1\":{\"361\":1}}],[\"判断是否分配成功\",{\"1\":{\"314\":2}}],[\"判断是否为空白符\",{\"1\":{\"293\":1}}],[\"判断是否为数字\",{\"1\":{\"293\":1}}],[\"判断是否为字母\",{\"1\":{\"293\":1}}],[\"判断是否为大写\",{\"1\":{\"293\":1}}],[\"判断是否为小写\",{\"1\":{\"293\":1}}],[\"判断是否为解\",{\"1\":{\"77\":1}}],[\"判断是否为分治问题\",{\"0\":{\"66\":1}}],[\"判断是读取失败结束还是遇到文件结束\",{\"1\":{\"310\":1}}],[\"判断返回值是否小于实际要读的个数eof是一个宏\",{\"1\":{\"310\":1}}],[\"判断返回值是否为eof\",{\"1\":{\"310\":1}}],[\"判断待删除节点是否存在子节点\",{\"1\":{\"195\":1}}],[\"判断双向队列是否为空\",{\"1\":{\"164\":1}}],[\"判断队列是否为空\",{\"1\":{\"160\":1,\"161\":1,\"163\":1,\"223\":1}}],[\"判断栈是否为空\",{\"1\":{\"156\":1,\"157\":1}}],[\"判断在当前状态下\",{\"1\":{\"77\":1}}],[\"判断当前状态是否为解\",{\"1\":{\"77\":1}}],[\"判断选择是否合法\",{\"1\":{\"77\":1}}],[\"判断节点\",{\"1\":{\"48\":1,\"212\":1}}],[\"判断数字\",{\"1\":{\"30\":1}}],[\"判断分支\",{\"1\":{\"24\":1}}],[\"判断\",{\"1\":{\"16\":1,\"20\":1}}],[\"≥\",{\"1\":{\"208\":1}}],[\"唯一的区别在于\",{\"1\":{\"206\":1}}],[\"镜像\",{\"1\":{\"202\":1}}],[\"失衡节点\",{\"1\":{\"200\":1}}],[\"操作系统\",{\"0\":{\"535\":1}}],[\"操作系统概述\",{\"0\":{\"493\":1,\"494\":1}}],[\"操作数进行位运算的时候\",{\"1\":{\"280\":1}}],[\"操作数状态取反作为表达式的值\",{\"1\":{\"278\":1}}],[\"操作数量优化\",{\"0\":{\"61\":1}}],[\"操作符重载\",{\"1\":{\"361\":1}}],[\"操作符重载的声明和定义\",{\"1\":{\"361\":1}}],[\"操作符访问结构体的成员\",{\"1\":{\"302\":1}}],[\"操作符只能用于整数\",{\"1\":{\"276\":1}}],[\"操作符\",{\"0\":{\"230\":1},\"1\":{\"276\":1}}],[\"操作\",{\"1\":{\"200\":1,\"201\":1,\"202\":1}}],[\"旋转的选择\",{\"0\":{\"205\":1}}],[\"旋转操作分为四种\",{\"1\":{\"200\":1}}],[\"旋转操作既能保持\",{\"1\":{\"200\":1}}],[\"旋转\",{\"1\":{\"200\":1}}],[\"旋转哈希\",{\"1\":{\"177\":2}}],[\"覆盖基类同名函数\",{\"1\":{\"373\":1}}],[\"覆盖基类同名成员\",{\"1\":{\"373\":1}}],[\"覆盖写入数据到文件\",{\"1\":{\"370\":1}}],[\"覆盖\",{\"1\":{\"195\":1}}],[\"覆盖原数组\",{\"1\":{\"54\":1}}],[\"待删除节点在\",{\"1\":{\"195\":2}}],[\"允许你从周围作用域中捕捉变量\",{\"1\":{\"379\":1}}],[\"允许将资源的所有权从一个对象移动到另一个对象\",{\"1\":{\"379\":1}}],[\"允许间接访问和操作结构体的成员\",{\"1\":{\"302\":1}}],[\"允许自定义复合数据类型\",{\"1\":{\"302\":1}}],[\"允许使用下面方法重新赋值\",{\"1\":{\"263\":1}}],[\"允许随机访问节点\",{\"1\":{\"191\":1}}],[\"允许在头部和尾部执行元素的添加或删除操作\",{\"1\":{\"162\":1}}],[\"映射公式的角色相当于链表中的节点引用\",{\"1\":{\"189\":1}}],[\"映射公式\",{\"1\":{\"189\":1}}],[\"映射到索引范围\",{\"1\":{\"50\":1}}],[\"走\",{\"1\":{\"187\":1,\"361\":1}}],[\"走到尽头再返回\",{\"1\":{\"225\":1}}],[\"走到\",{\"1\":{\"102\":1}}],[\"保持对实参的引用\",{\"1\":{\"379\":2}}],[\"保护继承\",{\"1\":{\"373\":2}}],[\"保护成员\",{\"1\":{\"361\":1}}],[\"保证正确释放资源\",{\"1\":{\"376\":1}}],[\"保证一个资源在任何时候都只有一个对象在对其进行管理\",{\"1\":{\"351\":1}}],[\"保证多个相等的元素仅被选择一次\",{\"1\":{\"82\":1}}],[\"保存需要被监视读事件是否就绪的文件描述符\",{\"1\":{\"438\":1}}],[\"保存信息到文件\",{\"1\":{\"345\":1}}],[\"保存文件失败\",{\"1\":{\"344\":1}}],[\"保存通讯录文件\",{\"1\":{\"344\":1}}],[\"保存数据的地方\",{\"1\":{\"308\":1}}],[\"保存上一轮循环的节点\",{\"1\":{\"194\":1}}],[\"保存节点值\",{\"1\":{\"186\":1}}],[\"辅助函数\",{\"1\":{\"206\":1,\"207\":1}}],[\"辅助数组\",{\"1\":{\"186\":1}}],[\"辅助队列\",{\"1\":{\"186\":2}}],[\"辅助哈希表\",{\"1\":{\"30\":1}}],[\"层序遍历序列\",{\"1\":{\"190\":1}}],[\"层序遍历序列就可以唯一表示二叉树了\",{\"1\":{\"190\":1}}],[\"层序遍历本质上属于广度优先遍历\",{\"1\":{\"186\":1}}],[\"层序遍历\",{\"0\":{\"186\":1},\"1\":{\"186\":2,\"190\":1}}],[\"高位地址减去低位地址\",{\"1\":{\"262\":1}}],[\"高级语言\",{\"1\":{\"240\":1}}],[\"高度等达到极大值或极小值\",{\"1\":{\"184\":1}}],[\"高于\",{\"1\":{\"51\":1}}],[\"达到\",{\"1\":{\"184\":1}}],[\"达到最佳查询效率\",{\"1\":{\"175\":1}}],[\"达到最差递归深度n\",{\"1\":{\"43\":1}}],[\"呈现标准的指数级关系\",{\"1\":{\"183\":1}}],[\"满16进1\",{\"1\":{\"325\":1}}],[\"满10进1\",{\"1\":{\"325\":1}}],[\"满2进1\",{\"1\":{\"325\":1}}],[\"满足条件时\",{\"1\":{\"321\":1}}],[\"满足以下条件\",{\"1\":{\"192\":1}}],[\"满足均匀分布不一定满足抗碰撞性\",{\"1\":{\"176\":1}}],[\"满二叉树是一个特例\",{\"1\":{\"190\":1}}],[\"满二叉树是理想情况\",{\"1\":{\"184\":1}}],[\"满二叉树\",{\"1\":{\"183\":2}}],[\"连续步骤的构造+拷贝构造或者拷贝构造+拷贝构造\",{\"1\":{\"361\":1}}],[\"连续与分散\",{\"0\":{\"15\":1}}],[\"连接事件就绪\",{\"1\":{\"390\":1,\"397\":1,\"440\":1}}],[\"连接关系\",{\"1\":{\"214\":1}}],[\"连接两个节点的线段\",{\"1\":{\"181\":1}}],[\"边总数为m\",{\"1\":{\"219\":1}}],[\"边索引越界或相等\",{\"1\":{\"218\":2}}],[\"边序列\",{\"1\":{\"214\":1}}],[\"边具有方向性\",{\"1\":{\"214\":1}}],[\"边表示两顶点之间的\",{\"1\":{\"214\":1}}],[\"边\",{\"1\":{\"181\":1,\"199\":1}}],[\"及其以下节点形成的树\",{\"1\":{\"180\":2}}],[\"视为父节点\",{\"1\":{\"180\":1}}],[\"视频等\",{\"1\":{\"325\":1}}],[\"视频\",{\"1\":{\"16\":1}}],[\"体现了\",{\"1\":{\"180\":1}}],[\"体现了数据之间的线性关系\",{\"1\":{\"14\":1}}],[\"近一个世纪以来\",{\"1\":{\"178\":1}}],[\"脆弱\",{\"1\":{\"178\":1}}],[\"利用lambda函数的捕捉列表以引用的方式对外部实参进行捕捉\",{\"1\":{\"379\":2}}],[\"利用对象的生命周期来控制资源\",{\"1\":{\"351\":1}}],[\"利用指针自减再次遍历数组\",{\"1\":{\"262\":1}}],[\"利用指针自增遍历数组元素\",{\"1\":{\"262\":1}}],[\"利用中序遍历升序的性质\",{\"1\":{\"196\":1}}],[\"利用乘法的不相关性\",{\"1\":{\"177\":1}}],[\"利用该规律\",{\"1\":{\"89\":1}}],[\"利用该索引可将\",{\"1\":{\"67\":1}}],[\"乘以16的\",{\"1\":{\"326\":1}}],[\"乘以2的\",{\"1\":{\"326\":1}}],[\"乘\",{\"1\":{\"276\":1}}],[\"乘法哈希\",{\"1\":{\"177\":2}}],[\"乘积为1\",{\"1\":{\"128\":1}}],[\"雪崩效应\",{\"1\":{\"176\":1}}],[\"抗碰撞性\",{\"1\":{\"176\":2}}],[\"密码存储\",{\"1\":{\"176\":1}}],[\"均匀分布\",{\"1\":{\"176\":2}}],[\"效率很低\",{\"1\":{\"219\":1}}],[\"效率较低\",{\"1\":{\"191\":1}}],[\"效率高\",{\"1\":{\"176\":1}}],[\"效率评估方法主要分为两种\",{\"1\":{\"135\":1}}],[\"固定时\",{\"1\":{\"175\":1}}],[\"试图缓解线性探测的聚集效应\",{\"1\":{\"173\":1}}],[\"机器数可以是有符号的\",{\"1\":{\"327\":1}}],[\"机器数\",{\"1\":{\"327\":1}}],[\"机器数和真值\",{\"1\":{\"327\":1}}],[\"机器语言\",{\"1\":{\"240\":1}}],[\"机器人以左上角单元格为起始点\",{\"1\":{\"102\":1}}],[\"机制\",{\"1\":{\"172\":1}}],[\"聚集现象\",{\"1\":{\"172\":1}}],[\"平衡树\",{\"1\":{\"205\":1}}],[\"平衡二叉树\",{\"0\":{\"198\":1},\"1\":{\"183\":2,\"200\":1}}],[\"平方探测也可能无法访问到它\",{\"1\":{\"173\":1}}],[\"平方探测可能不会探测整个哈希表\",{\"1\":{\"173\":1}}],[\"平方探测并不是完美的仍然存在聚集现象\",{\"1\":{\"173\":1}}],[\"平方探测会跳过更大的距离来寻找空位置\",{\"1\":{\"173\":1}}],[\"平方探测通过跳过探测次数平方的距离\",{\"1\":{\"173\":1}}],[\"平方探测主要具有以下优势\",{\"1\":{\"173\":1}}],[\"平方探测不是简单地跳过一个固定的步数\",{\"1\":{\"173\":1}}],[\"平方探测与线性探测类似\",{\"1\":{\"173\":1}}],[\"平方探测\",{\"0\":{\"173\":1}}],[\"平方探测和多次哈希等\",{\"1\":{\"171\":1}}],[\"平均时间复杂度并不完全相等\",{\"1\":{\"33\":1}}],[\"桶数组\",{\"1\":{\"170\":1,\"172\":1}}],[\"桶排序的基本思想是将数据分散到多个桶\",{\"1\":{\"63\":1}}],[\"桶排序的时间复杂度理论上可以达到o\",{\"1\":{\"51\":1}}],[\"桶排序的流程如下图\",{\"1\":{\"50\":1}}],[\"桶排序\",{\"1\":{\"49\":1,\"50\":1,\"62\":1,\"63\":1}}],[\"桶排序算法流程\",{\"0\":{\"50\":1}}],[\"桶排序算法\",{\"0\":{\"49\":1}}],[\"接着再将客户端也运行起来\",{\"1\":{\"403\":1}}],[\"接着遍历链表以查找目标节点并将其删除\",{\"1\":{\"170\":1}}],[\"接受两个参数并返回它们的值\",{\"1\":{\"379\":1}}],[\"接口类\",{\"1\":{\"376\":2}}],[\"接收shape的基类指针\",{\"1\":{\"376\":1}}],[\"接收方可以重新计算接收到的数据的哈希值\",{\"1\":{\"176\":1}}],[\"接近自然语言\",{\"1\":{\"240\":1}}],[\"接下来将子问题继续分解为更小的子问题\",{\"1\":{\"136\":1}}],[\"接下来思考哪个因子是最优的\",{\"1\":{\"127\":1}}],[\"接下来\",{\"1\":{\"20\":1,\"38\":1,\"49\":1,\"53\":1,\"61\":1,\"74\":1,\"77\":2,\"291\":1}}],[\"才去判断表达式2是否成立\",{\"1\":{\"297\":1}}],[\"才能找到目标元素\",{\"1\":{\"172\":1}}],[\"才执行扩容操作\",{\"1\":{\"169\":1}}],[\"才有可能使容量变大\",{\"1\":{\"123\":1}}],[\"负数转为无符号整数\",{\"1\":{\"337\":1}}],[\"负数的原码\",{\"1\":{\"327\":1}}],[\"负数的补码\",{\"1\":{\"327\":2}}],[\"负数的补码是在其反码的基础上加1\",{\"1\":{\"17\":1}}],[\"负数的反码\",{\"1\":{\"327\":2}}],[\"负数的反码是对其原码除符号位外的所有位取反\",{\"1\":{\"17\":1}}],[\"负载因子\",{\"1\":{\"168\":1,\"170\":1,\"172\":1}}],[\"编译会给他们分配1byte占位\",{\"1\":{\"361\":2}}],[\"编译错误\",{\"1\":{\"348\":2}}],[\"编译内部的语句\",{\"1\":{\"321\":1}}],[\"编译器可能优化\",{\"1\":{\"361\":1}}],[\"编译器自动生成一个构造函数\",{\"1\":{\"361\":1}}],[\"编译器默认float类型显示6位有效数字\",{\"1\":{\"348\":1}}],[\"编译器是会产生警告的\",{\"1\":{\"338\":1}}],[\"编译器足够智能\",{\"1\":{\"334\":1}}],[\"编译器\",{\"1\":{\"330\":1}}],[\"编译器会根据传入的实际类型自动生成相应的函数\",{\"1\":{\"367\":1}}],[\"编译器会处理成对应重载运算符调用if\",{\"1\":{\"361\":1}}],[\"编译器会自动为它们分配值\",{\"1\":{\"301\":1}}],[\"编译器会自动加上\",{\"1\":{\"287\":1}}],[\"编译器会报错\",{\"1\":{\"299\":1}}],[\"编译器接受预处理后的源代码文件\",{\"1\":{\"271\":1}}],[\"编译\",{\"1\":{\"271\":1}}],[\"编写完代码后\",{\"1\":{\"406\":1}}],[\"编写c语言源程序代码\",{\"1\":{\"271\":1}}],[\"编写\",{\"1\":{\"271\":1}}],[\"编程学习\",{\"0\":{\"529\":1}}],[\"编程中一般使用循环结构对数组进行遍历\",{\"1\":{\"244\":1}}],[\"编程语言通常会预留足够大的哈希表容量\",{\"1\":{\"168\":1}}],[\"编码长度\",{\"1\":{\"117\":1}}],[\"编码某些非英文字符\",{\"1\":{\"18\":1}}],[\"编码与\",{\"1\":{\"18\":1}}],[\"编码\",{\"1\":{\"18\":2}}],[\"编码可以向下兼容\",{\"1\":{\"18\":1}}],[\"编码方法\",{\"1\":{\"18\":2}}],[\"编码下的两倍\",{\"1\":{\"18\":1}}],[\"编码英文只需\",{\"1\":{\"18\":1}}],[\"改良哈希表数据结构\",{\"1\":{\"169\":1}}],[\"改变\",{\"1\":{\"168\":1}}],[\"改为浮点数类型\",{\"1\":{\"27\":1}}],[\"发生冲突\",{\"1\":{\"168\":1}}],[\"冲突就越少\",{\"1\":{\"168\":1}}],[\"展示了哈希函数的工作原理\",{\"1\":{\"167\":1}}],[\"易得哈希函数为\",{\"1\":{\"167\":1}}],[\"易得左子树和右子树的节点数量分别为\",{\"1\":{\"67\":1}}],[\"取代以前的null和0表示空指针\",{\"1\":{\"379\":1}}],[\"取消宏定义\",{\"1\":{\"318\":2}}],[\"取值为\",{\"1\":{\"310\":1}}],[\"取别名原则\",{\"1\":{\"348\":1}}],[\"取别名为\",{\"1\":{\"304\":1}}],[\"取别名\",{\"1\":{\"304\":2}}],[\"取两个数字中的最大值\",{\"1\":{\"286\":2}}],[\"取址运算符\",{\"1\":{\"261\":1}}],[\"取址运算符和取值运算符\",{\"1\":{\"261\":1}}],[\"取名为\",{\"1\":{\"250\":2,\"251\":2}}],[\"取决于数组的长度和数组中元素的类型数组中的元素在内存中是依次紧密排列的且有序的数组一旦初始化完成\",{\"1\":{\"243\":1}}],[\"取模\",{\"1\":{\"167\":1,\"276\":1}}],[\"取余操作\",{\"1\":{\"161\":1}}],[\"定位new表达式是c++中的一种特殊形式的new表达式\",{\"1\":{\"364\":1}}],[\"定位new表达式\",{\"1\":{\"364\":1}}],[\"定位到文件末尾\",{\"1\":{\"310\":1}}],[\"定位对应的桶呢\",{\"1\":{\"167\":1}}],[\"定义lambda函数\",{\"1\":{\"379\":1}}],[\"定义的\",{\"1\":{\"361\":2}}],[\"定义的标识符常量和const\",{\"1\":{\"254\":1}}],[\"定义了bool代表\",{\"1\":{\"333\":1}}],[\"定义了数据的格式结构体变量是根据结构体类型创建的变量\",{\"1\":{\"302\":1}}],[\"定义整型指针\",{\"1\":{\"314\":1}}],[\"定义共用体类型的同时定义共用体变量\",{\"1\":{\"303\":1}}],[\"定义结构体的同时定义\",{\"1\":{\"302\":1}}],[\"定义结构体变量\",{\"1\":{\"302\":1}}],[\"定义结构体\",{\"1\":{\"302\":2}}],[\"定义枚举变量的语法\",{\"1\":{\"301\":1}}],[\"定义枚举类型的同时声明枚举变量\",{\"1\":{\"301\":2}}],[\"定义枚举类型\",{\"1\":{\"301\":3}}],[\"定义变量保存半径\",{\"1\":{\"318\":1}}],[\"定义变量\",{\"1\":{\"309\":1}}],[\"定义变量时指定类型是我们所定义的枚举类型\",{\"1\":{\"301\":1}}],[\"定义变量记录价格\",{\"1\":{\"297\":1}}],[\"定义变量记录成绩\",{\"1\":{\"297\":1}}],[\"定义循环变量\",{\"1\":{\"298\":1}}],[\"定义局部数组不进行初始化\",{\"1\":{\"288\":1}}],[\"定义局部变量不进行初始化赋值\",{\"1\":{\"288\":1}}],[\"定义全局数组不进行初始化\",{\"1\":{\"288\":1}}],[\"定义全局变量不进行初始化赋值\",{\"1\":{\"288\":1}}],[\"定义常量记录数组长度\",{\"1\":{\"262\":1}}],[\"定义常量时\",{\"1\":{\"255\":1}}],[\"定义常量\",{\"1\":{\"255\":1,\"318\":1}}],[\"定义一个日期类date\",{\"1\":{\"361\":1}}],[\"定义一个结构体变量stu1\",{\"1\":{\"304\":1}}],[\"定义一个枚举就是定义了一种枚举数据类型\",{\"1\":{\"301\":1}}],[\"定义一个标签\",{\"1\":{\"299\":1}}],[\"定义一个\",{\"1\":{\"246\":1}}],[\"定义一个4行6列的二维数组\",{\"1\":{\"246\":3}}],[\"定义字符串\",{\"1\":{\"245\":1}}],[\"定义完数组直接进行初始化\",{\"1\":{\"244\":1}}],[\"定义完成后再给元素赋值\",{\"1\":{\"244\":1}}],[\"定义数组长度\",{\"1\":{\"314\":1}}],[\"定义数组\",{\"1\":{\"244\":4,\"304\":1}}],[\"定义\",{\"1\":{\"161\":1,\"244\":1}}],[\"定义状态\",{\"1\":{\"102\":1}}],[\"定义为节点左子树的高度减去右子树的高度\",{\"1\":{\"199\":1}}],[\"定义为\",{\"1\":{\"21\":1}}],[\"假两种状态\",{\"1\":{\"333\":1}}],[\"假如输入\",{\"1\":{\"298\":1}}],[\"假如我们希望实现\",{\"1\":{\"166\":1}}],[\"假\",{\"1\":{\"281\":1}}],[\"假设有\",{\"1\":{\"261\":1}}],[\"假设放入一部分物品i\",{\"1\":{\"118\":1}}],[\"假设你有一些任务\",{\"1\":{\"117\":1}}],[\"假设\",{\"1\":{\"113\":1}}],[\"假设只有一个数组\",{\"1\":{\"111\":1}}],[\"假设元素两两之间互不相同\",{\"1\":{\"82\":1}}],[\"假设输入数组为\",{\"1\":{\"81\":1,\"82\":1}}],[\"假设二叉树中没有值重复的节点\",{\"1\":{\"65\":1}}],[\"假设我们选择右子树的最小节点\",{\"1\":{\"195\":1}}],[\"假设我们想在相邻的两个节点\",{\"1\":{\"148\":1}}],[\"假设我们第一轮选择\",{\"1\":{\"81\":1}}],[\"假设我们按照下图所示的方式\",{\"1\":{\"61\":1}}],[\"假设我们有一个存储学生信息的表格\",{\"1\":{\"33\":1}}],[\"假设数字的最低位是第1位\",{\"1\":{\"56\":1}}],[\"假设数组中存在多个\",{\"1\":{\"24\":1}}],[\"假设使用非稳定排序算法按年龄排序列表\",{\"1\":{\"33\":1}}],[\"暂存原哈希表\",{\"1\":{\"170\":1,\"172\":1}}],[\"暂存尾节点值\",{\"1\":{\"163\":1}}],[\"暂存头节点值\",{\"1\":{\"163\":1}}],[\"越过根节点\",{\"1\":{\"211\":1}}],[\"越过叶节点后跳出\",{\"1\":{\"193\":1,\"194\":1,\"195\":1}}],[\"越过尾部则返回头部\",{\"1\":{\"172\":1}}],[\"越过数组头部回到尾部\",{\"1\":{\"164\":1}}],[\"越过数组头部后\",{\"1\":{\"164\":1}}],[\"越过数组尾部时\",{\"1\":{\"164\":1}}],[\"越过数组尾部后回到头部\",{\"1\":{\"161\":1}}],[\"越界\",{\"1\":{\"48\":1,\"212\":1}}],[\"环形数组\",{\"1\":{\"161\":1,\"172\":1}}],[\"环形链表\",{\"1\":{\"153\":1}}],[\"入度\",{\"1\":{\"214\":1}}],[\"入队和出队操作都只需进行一次操作\",{\"1\":{\"161\":1}}],[\"入队操作\",{\"1\":{\"161\":1,\"223\":1}}],[\"入队\",{\"1\":{\"159\":1,\"160\":1,\"161\":1,\"163\":1}}],[\"入栈操作需要初始化节点对象并修改指针\",{\"1\":{\"158\":1}}],[\"入栈和出栈操作都在预先分配好的连续内存中进行\",{\"1\":{\"158\":1}}],[\"入栈与出栈操作分别对应在数组尾部添加元素与删除元素\",{\"1\":{\"157\":1}}],[\"入栈\",{\"1\":{\"155\":1,\"156\":1,\"157\":1}}],[\"队尾出队\",{\"1\":{\"163\":1,\"164\":2}}],[\"队尾出队操作\",{\"1\":{\"163\":1}}],[\"队尾入队\",{\"1\":{\"163\":1,\"164\":1}}],[\"队尾入队操作\",{\"1\":{\"163\":1}}],[\"队尾\",{\"1\":{\"159\":1,\"160\":1}}],[\"队首顶点出队\",{\"1\":{\"223\":1}}],[\"队首出队\",{\"1\":{\"163\":1,\"164\":1}}],[\"队首出队操作\",{\"1\":{\"163\":1}}],[\"队首入队\",{\"1\":{\"163\":1,\"164\":2}}],[\"队首入队操作\",{\"1\":{\"163\":1}}],[\"队首指针向左移动一位\",{\"1\":{\"164\":1}}],[\"队首指针向后移动一位\",{\"1\":{\"161\":1,\"164\":1}}],[\"队首指针\",{\"1\":{\"161\":1,\"164\":1}}],[\"队首仅可删除节点\",{\"1\":{\"160\":1}}],[\"队首\",{\"1\":{\"159\":1,\"160\":1}}],[\"队列用于实现\",{\"1\":{\"223\":1}}],[\"队列具有\",{\"1\":{\"223\":1}}],[\"队列出队\",{\"1\":{\"186\":1}}],[\"队列指针\",{\"1\":{\"186\":1}}],[\"队列遵循\",{\"1\":{\"186\":1}}],[\"队列中最多同时存在\",{\"1\":{\"186\":1}}],[\"队列已满\",{\"1\":{\"161\":1}}],[\"队列容量\",{\"1\":{\"161\":1,\"164\":1}}],[\"队列的顺序实现\",{\"0\":{\"161\":1}}],[\"队列的链式实现\",{\"0\":{\"160\":1}}],[\"队列模拟了排队现象\",{\"1\":{\"159\":1}}],[\"队列\",{\"0\":{\"159\":1,\"450\":1},\"1\":{\"13\":1,\"14\":1,\"15\":2,\"159\":1,\"186\":1,\"223\":1}}],[\"倍\",{\"1\":{\"158\":1}}],[\"导致线程不断切入切出\",{\"1\":{\"354\":1}}],[\"导致所有其它函数都必须在main\",{\"1\":{\"287\":1}}],[\"导致该次入栈操作的时间复杂度变为o\",{\"1\":{\"158\":1}}],[\"导致两者的相对顺序发生改变\",{\"1\":{\"36\":1}}],[\"支持多个对象一起对同一个资源进行管理\",{\"1\":{\"351\":1}}],[\"支持操作\",{\"1\":{\"158\":1}}],[\"支持随机访问\",{\"1\":{\"138\":1}}],[\"析构函数重写例子\",{\"1\":{\"376\":1}}],[\"析构函数重写\",{\"1\":{\"376\":2}}],[\"析构函数\",{\"1\":{\"156\":1,\"157\":1,\"160\":1,\"161\":1,\"163\":2,\"164\":1,\"167\":1,\"170\":1,\"172\":1,\"190\":1,\"218\":1,\"219\":1,\"361\":2}}],[\"头文件为\",{\"1\":{\"314\":1,\"348\":1,\"370\":1}}],[\"头文件\",{\"1\":{\"314\":1,\"344\":1}}],[\"头文件中函数原型\",{\"1\":{\"310\":8}}],[\"头文件中的常量\",{\"1\":{\"309\":1,\"310\":1}}],[\"头部和尾部都可以执行入队和出队操作\",{\"1\":{\"163\":1}}],[\"头插法\",{\"1\":{\"156\":1,\"219\":1}}],[\"头节点\",{\"1\":{\"146\":1,\"160\":1,\"163\":1}}],[\"出度\",{\"1\":{\"214\":1}}],[\"出发\",{\"1\":{\"193\":1}}],[\"出队操作\",{\"1\":{\"161\":1,\"223\":1}}],[\"出队\",{\"1\":{\"159\":1,\"160\":1,\"161\":1,\"163\":1}}],[\"出栈\",{\"1\":{\"155\":1,\"156\":1,\"157\":1}}],[\"出现false替换成0\",{\"1\":{\"318\":1}}],[\"出现true会替换成1\",{\"1\":{\"318\":1}}],[\"出现冲突\",{\"1\":{\"174\":1}}],[\"出现了重复子集\",{\"1\":{\"86\":1}}],[\"出现个数\",{\"1\":{\"56\":1}}],[\"出现次数\",{\"1\":{\"54\":1}}],[\"出现最差情况的概率很低\",{\"1\":{\"44\":1}}],[\"单链表\",{\"1\":{\"379\":1}}],[\"单继承\",{\"1\":{\"373\":3}}],[\"单参数的构造函数\",{\"1\":{\"361\":1}}],[\"单例对象释放\",{\"1\":{\"354\":2}}],[\"单例对象创建在静态区后没办法主动释放\",{\"1\":{\"354\":1}}],[\"单例对象定义在静态区\",{\"1\":{\"354\":1}}],[\"单例模式实现方式\",{\"1\":{\"354\":1}}],[\"单例模式是一种设计模式\",{\"1\":{\"354\":1}}],[\"单例模式\",{\"1\":{\"354\":2}}],[\"单独命名空间\",{\"1\":{\"348\":1}}],[\"单位是字节\",{\"1\":{\"335\":1}}],[\"单引号\",{\"1\":{\"332\":1}}],[\"单精度\",{\"1\":{\"331\":1}}],[\"单行注释\",{\"1\":{\"273\":1}}],[\"单元测试\",{\"1\":{\"270\":1}}],[\"单向分支\",{\"1\":{\"297\":1}}],[\"单向性\",{\"1\":{\"176\":1}}],[\"单向链表的节点包含值和指向下一节点的引用两项数据\",{\"1\":{\"153\":1}}],[\"单向链表\",{\"1\":{\"153\":1}}],[\"单调栈\",{\"0\":{\"3\":1}}],[\"仍然是0\",{\"1\":{\"327\":2}}],[\"仍然是0十进制的正负1\",{\"1\":{\"327\":1}}],[\"仍然指向\",{\"1\":{\"149\":1}}],[\"仍可以在程序运行过程中对其长度进行调整\",{\"1\":{\"15\":1}}],[\"构成内存泄漏\",{\"1\":{\"314\":1}}],[\"构成的输入空间映射到数组所有索引构成的输出空间\",{\"1\":{\"168\":1}}],[\"构造函数禁止隐式转换\",{\"1\":{\"357\":1}}],[\"构造函数\",{\"1\":{\"146\":1,\"153\":1,\"156\":1,\"157\":1,\"160\":1,\"161\":1,\"163\":2,\"164\":1,\"167\":1,\"170\":1,\"172\":1,\"180\":1,\"190\":1,\"198\":1,\"218\":1,\"219\":1,\"223\":1,\"361\":2,\"367\":1}}],[\"构建节点之间的引用\",{\"1\":{\"147\":1,\"182\":1}}],[\"构建出原问题的解\",{\"1\":{\"95\":1}}],[\"构建右子树\",{\"1\":{\"66\":1,\"69\":1}}],[\"构建左子树\",{\"1\":{\"66\":1,\"69\":1}}],[\"构建二叉树\",{\"1\":{\"66\":1,\"69\":2}}],[\"构建树问题代码实现\",{\"0\":{\"69\":1}}],[\"构建树问题\",{\"0\":{\"65\":1}}],[\"节点队列结构体\",{\"1\":{\"223\":1}}],[\"节点数量\",{\"1\":{\"219\":1}}],[\"节点数组\",{\"1\":{\"219\":1}}],[\"节点结构体\",{\"1\":{\"219\":1}}],[\"节点无须修复\",{\"1\":{\"211\":1}}],[\"节点指针通过索引映射公式来实现\",{\"1\":{\"209\":1}}],[\"节点下方为平衡因子\",{\"1\":{\"201\":1}}],[\"节点平衡因子\",{\"1\":{\"199\":2}}],[\"节点之间通过指针相连接\",{\"1\":{\"188\":1}}],[\"节点总数\",{\"1\":{\"184\":1}}],[\"节点所在的层\",{\"1\":{\"181\":1}}],[\"节点高度等于最高子树高度\",{\"1\":{\"199\":1}}],[\"节点高度\",{\"1\":{\"180\":1,\"199\":2}}],[\"节点\",{\"1\":{\"180\":5,\"201\":1}}],[\"节点值\",{\"1\":{\"146\":1,\"153\":1,\"163\":1,\"180\":1}}],[\"节点的平衡因子\",{\"1\":{\"199\":1}}],[\"节点的值\",{\"1\":{\"190\":1}}],[\"节点的高度\",{\"1\":{\"181\":1}}],[\"节点的深度\",{\"1\":{\"181\":1}}],[\"节点的子节点的数量\",{\"1\":{\"181\":1}}],[\"节点的度\",{\"1\":{\"181\":1}}],[\"节点的\",{\"1\":{\"146\":1}}],[\"扩容哈希表\",{\"1\":{\"170\":1,\"172\":1}}],[\"扩容倍数\",{\"1\":{\"170\":1,\"172\":1}}],[\"扩容后冲突消失\",{\"1\":{\"168\":1}}],[\"扩容后的容量也可能超出实际需求\",{\"1\":{\"158\":1}}],[\"扩容前键值对\",{\"1\":{\"168\":1}}],[\"扩容机制通常是按照特定倍率\",{\"1\":{\"158\":1}}],[\"扩容数组\",{\"0\":{\"145\":1}}],[\"扩容数组需要将所有数据复制到新数组\",{\"1\":{\"138\":1}}],[\"扩展数组长度\",{\"1\":{\"145\":1}}],[\"丢失精度\",{\"1\":{\"357\":1}}],[\"丢失的末尾元素都是\",{\"1\":{\"142\":1}}],[\"丢失元素\",{\"1\":{\"142\":1}}],[\"赋为null\",{\"1\":{\"266\":1}}],[\"赋给pstr\",{\"1\":{\"263\":1}}],[\"赋给\",{\"1\":{\"141\":1,\"265\":2}}],[\"赋值重载\",{\"1\":{\"361\":3}}],[\"赋值给e\",{\"1\":{\"348\":1}}],[\"赋值给目标索引\",{\"1\":{\"40\":1}}],[\"赋值是0先拷贝给临时变量\",{\"1\":{\"348\":1}}],[\"赋值号\",{\"1\":{\"337\":1}}],[\"赋值时的隐式转换\",{\"1\":{\"337\":1}}],[\"赋值语句中的逗号表达式\",{\"1\":{\"282\":1}}],[\"赋值运算符重载特性\",{\"1\":{\"361\":1}}],[\"赋值运算符的第一个操作数\",{\"1\":{\"279\":1}}],[\"赋值运算符\",{\"0\":{\"279\":1},\"1\":{\"283\":1}}],[\"赋值和比较等表达式\",{\"1\":{\"275\":1}}],[\"赋值的元素的个数等于该数组的长度\",{\"1\":{\"245\":1}}],[\"赋值的元素个数小于字符数组的长度\",{\"1\":{\"245\":1}}],[\"赋值为true\",{\"1\":{\"81\":1}}],[\"赋值\",{\"1\":{\"44\":1,\"337\":2}}],[\"赋值到正确位置\",{\"1\":{\"41\":1}}],[\"处理机调度\",{\"0\":{\"500\":1}}],[\"处理方法3种\",{\"1\":{\"361\":1}}],[\"处理代码\",{\"1\":{\"317\":1}}],[\"处理预处理指令\",{\"1\":{\"271\":1}}],[\"处\",{\"1\":{\"299\":1}}],[\"处的元素\",{\"1\":{\"141\":1,\"142\":1}}],[\"处插入元素\",{\"1\":{\"141\":1}}],[\"处在首列的状态只能从其上边的状态得来\",{\"1\":{\"102\":1}}],[\"处在首行的状态只能从其左边的状态得来\",{\"1\":{\"102\":1}}],[\"紧挨着的\",{\"1\":{\"141\":1}}],[\"紧密结合\",{\"1\":{\"133\":1}}],[\"随机值\",{\"1\":{\"361\":1,\"373\":1}}],[\"随机性\",{\"1\":{\"267\":1}}],[\"随机访问元素\",{\"1\":{\"140\":1}}],[\"随着\",{\"1\":{\"172\":1}}],[\"随着计算机技术的蓬勃发展\",{\"1\":{\"18\":1}}],[\"随着计算机的全球化\",{\"1\":{\"18\":1}}],[\"随后\",{\"1\":{\"167\":1}}],[\"缓存局部性\",{\"1\":{\"138\":1}}],[\"缓存使用效率高\",{\"1\":{\"44\":1}}],[\"触发扩容的负载因子阈值\",{\"1\":{\"170\":1,\"172\":1}}],[\"触发\",{\"1\":{\"136\":1}}],[\"程序员有时需要精准的字节宽度\",{\"1\":{\"330\":1}}],[\"程序从上到下逐行地执行\",{\"1\":{\"296\":1}}],[\"程序从最深层的递归函数开始逐层返回\",{\"1\":{\"136\":1}}],[\"程序控制语句\",{\"0\":{\"295\":1}}],[\"程序就无法启动主函数中可以调用其它函数\",{\"1\":{\"287\":1}}],[\"程序总是从这个函数开始执行\",{\"1\":{\"287\":1}}],[\"程序\",{\"1\":{\"271\":1}}],[\"程序在定义字符串指针pstr时只是把字符串首地址\",{\"1\":{\"263\":1}}],[\"程序运行时\",{\"1\":{\"253\":1}}],[\"程序设计语言\",{\"1\":{\"241\":1}}],[\"程序的编译\",{\"0\":{\"237\":1}}],[\"程序可能误判这些元素不存在\",{\"1\":{\"172\":1}}],[\"程序需要从头节点出发\",{\"1\":{\"150\":1}}],[\"程序难以保证数组之后的内存空间是可用的\",{\"1\":{\"145\":1}}],[\"程序不断深入地调用自身\",{\"1\":{\"136\":1}}],[\"程序会在满足一定的条件下重复执行某段代码\",{\"1\":{\"136\":1}}],[\"程序便可以访问内存中的数据\",{\"1\":{\"15\":1}}],[\"寻求最优解法\",{\"1\":{\"135\":1}}],[\"寻找全局最优解非常困难\",{\"1\":{\"114\":1}}],[\"寻找使得所有皇后之间无法相互攻击的摆放方案\",{\"1\":{\"87\":1}}],[\"寻找最近点对\",{\"1\":{\"63\":1}}],[\"结构的指针\",{\"1\":{\"310\":6}}],[\"结构\",{\"1\":{\"303\":1}}],[\"结构很大程度上提供了对象和类的功能\",{\"1\":{\"302\":1}}],[\"结构这些被称为块级变量\",{\"1\":{\"288\":1}}],[\"结构体成员\",{\"1\":{\"302\":1}}],[\"结构体变量所占内存长度\",{\"1\":{\"303\":1}}],[\"结构体变量\",{\"1\":{\"302\":2}}],[\"结构体指针使用\",{\"1\":{\"302\":1}}],[\"结构体指针通过解引用访问成员\",{\"1\":{\"302\":1}}],[\"结构体指针可以通过\",{\"1\":{\"302\":1}}],[\"结构体指针变量名\",{\"1\":{\"302\":1}}],[\"结构体指针是指向结构体的指针变量\",{\"1\":{\"302\":1}}],[\"结构体指针\",{\"1\":{\"302\":1}}],[\"结构体使用点号\",{\"1\":{\"302\":1}}],[\"结构体的成员也可以称为属性结构体和数组类似\",{\"1\":{\"302\":1}}],[\"结构体等\",{\"1\":{\"302\":1}}],[\"结构体等要素命名时使用的字符序列\",{\"1\":{\"256\":1}}],[\"结构体是一种自定义的数据类型\",{\"1\":{\"302\":1}}],[\"结构体名\",{\"1\":{\"302\":2}}],[\"结构体\",{\"0\":{\"233\":1,\"302\":1},\"1\":{\"160\":1,\"163\":1,\"302\":2,\"303\":1,\"361\":1}}],[\"结束~\",{\"1\":{\"297\":1}}],[\"结束\",{\"1\":{\"272\":1}}],[\"结束堆化\",{\"1\":{\"211\":1}}],[\"结合算法才能解决特定问题\",{\"1\":{\"133\":1}}],[\"结果为\",{\"1\":{\"379\":2}}],[\"结果是5\",{\"1\":{\"338\":1}}],[\"结果只保留整数部分而舍弃小数部分\",{\"1\":{\"276\":1}}],[\"结果\",{\"1\":{\"77\":1,\"379\":2}}],[\"结果中\",{\"1\":{\"33\":1}}],[\"下例中\",{\"1\":{\"304\":3}}],[\"下次调用再创建新的局部数据\",{\"1\":{\"288\":1}}],[\"下标越界\",{\"1\":{\"367\":2}}],[\"下标是5的元素\",{\"1\":{\"244\":2}}],[\"下标是\",{\"1\":{\"244\":2}}],[\"下标是4的元素\",{\"1\":{\"244\":2}}],[\"下标是0的元素\",{\"1\":{\"244\":2}}],[\"下标\",{\"1\":{\"243\":1,\"244\":1}}],[\"下面本质上是一个隐式类型转换\",{\"1\":{\"361\":1}}],[\"下面示例中\",{\"1\":{\"321\":7}}],[\"下面代码中使用宏定义声明了bool\",{\"1\":{\"318\":1}}],[\"下面代码中\",{\"1\":{\"318\":1}}],[\"下面演示一个静态全局变量的案例\",{\"1\":{\"289\":1}}],[\"下面我们利用指针的自增自减实现数组的遍历\",{\"1\":{\"262\":1}}],[\"下面详细介绍这些旋转操作\",{\"1\":{\"200\":1}}],[\"下面举两个例子\",{\"1\":{\"132\":1}}],[\"下\",{\"1\":{\"176\":1}}],[\"下一个节点\",{\"1\":{\"153\":1}}],[\"下图所示\",{\"1\":{\"213\":1}}],[\"下图所示为4皇后问题的逐行放置过程\",{\"1\":{\"88\":1}}],[\"下图所示为将数组\",{\"1\":{\"85\":1}}],[\"下图展示的四种失衡情况与上述案例逐个对应\",{\"1\":{\"205\":1}}],[\"下图展示了一个使用邻接表存储的图的示例\",{\"1\":{\"217\":1}}],[\"下图展示了一个例子\",{\"1\":{\"102\":1}}],[\"下图展示了对二叉树进行深度优先遍历的工作原理\",{\"1\":{\"187\":1}}],[\"下图展示了二叉树的理想结构与退化结构\",{\"1\":{\"184\":1}}],[\"下图展示了贪心策略的执行过程\",{\"1\":{\"123\":1}}],[\"下图展示了在实际应用中常见的哈希算法\",{\"1\":{\"178\":1}}],[\"下图展示了在单个数组下从第i=1行转换至第i=2行的过程\",{\"1\":{\"111\":1}}],[\"下图展示了在记忆化搜索中被剪掉的搜索分支\",{\"1\":{\"109\":1}}],[\"下图展示了最小路径和的状态转移过程\",{\"1\":{\"105\":1}}],[\"下图展示了以上代码的动态规划过程\",{\"1\":{\"98\":1}}],[\"下图展示了暴力搜索形成的递归树\",{\"1\":{\"93\":1}}],[\"下图展示了该递推关系\",{\"1\":{\"93\":1}}],[\"下图展示了本题的三个约束条件\",{\"1\":{\"87\":1}}],[\"下图展示了数组\",{\"1\":{\"86\":1}}],[\"下图展示了数组插入元素的操作流程\",{\"1\":{\"40\":1}}],[\"下图展示了两个剪枝条件的生效范围\",{\"1\":{\"83\":1}}],[\"下图展示了构建二叉树的递归过程\",{\"1\":{\"69\":1}}],[\"下图给出了一个例子\",{\"1\":{\"190\":1}}],[\"下图给出了一个示例\",{\"1\":{\"182\":1}}],[\"下图给出了以dp\",{\"1\":{\"103\":1}}],[\"下图模拟了以上代码的执行过程\",{\"1\":{\"95\":1}}],[\"下图仅展开了第一行的其中一个搜索分支\",{\"1\":{\"88\":1}}],[\"下图列举了几个示例数据\",{\"1\":{\"80\":1}}],[\"下图对比了保留或删除\",{\"1\":{\"77\":1}}],[\"往往需要在另一方面作出妥协\",{\"1\":{\"132\":1}}],[\"往往还可以提升算法效率\",{\"1\":{\"60\":1}}],[\"删除联系人成功\",{\"1\":{\"344\":1}}],[\"删除联系人\",{\"1\":{\"342\":1,\"344\":3}}],[\"删除所有包含\",{\"1\":{\"219\":1}}],[\"删除某一顶点之后就无须改动其他顶点了\",{\"1\":{\"219\":1}}],[\"删除包含指定顶点的所有边\",{\"1\":{\"219\":1}}],[\"删除边辅助函数\",{\"1\":{\"219\":1}}],[\"删除边\",{\"1\":{\"218\":2,\"219\":4}}],[\"删除顶点\",{\"1\":{\"218\":3,\"219\":3}}],[\"删除节点操作同样使用o\",{\"1\":{\"195\":1}}],[\"删除节点\",{\"1\":{\"182\":1,\"195\":2,\"207\":1,\"212\":1}}],[\"删除标记\",{\"1\":{\"172\":1}}],[\"删除操作\",{\"1\":{\"167\":1,\"170\":1,\"172\":1}}],[\"删除队首元素的操作称为\",{\"1\":{\"159\":1}}],[\"删除栈顶元素的操作叫作\",{\"1\":{\"155\":1}}],[\"删除链表的节点\",{\"1\":{\"149\":1}}],[\"删除结点\",{\"0\":{\"149\":1,\"195\":1}}],[\"删除索引\",{\"1\":{\"142\":1}}],[\"删除元素完成后\",{\"1\":{\"142\":1}}],[\"删除元素\",{\"0\":{\"142\":1},\"1\":{\"170\":1}}],[\"删除\",{\"1\":{\"132\":1,\"344\":1}}],[\"删除和堆化\",{\"1\":{\"63\":1}}],[\"添加读事件到events当中\",{\"1\":{\"389\":1,\"390\":1}}],[\"添加自定义成员或行为\",{\"1\":{\"382\":1}}],[\"添加联系人成功\",{\"1\":{\"344\":1}}],[\"添加联系人\",{\"1\":{\"342\":1,\"344\":3}}],[\"添加第\",{\"1\":{\"218\":1}}],[\"添加边辅助函数\",{\"1\":{\"219\":1}}],[\"添加边\",{\"1\":{\"218\":2,\"219\":4}}],[\"添加顶点\",{\"1\":{\"218\":3,\"219\":3}}],[\"添加或删除边\",{\"1\":{\"218\":1}}],[\"添加节点\",{\"1\":{\"211\":1}}],[\"添加之后\",{\"1\":{\"211\":1}}],[\"添加到链表中\",{\"1\":{\"170\":1}}],[\"添加到队首\",{\"1\":{\"164\":1}}],[\"添加元素\",{\"1\":{\"170\":1}}],[\"添加操作\",{\"1\":{\"167\":1,\"170\":1,\"172\":1}}],[\"添加至链表尾部\",{\"1\":{\"163\":1}}],[\"添加至链表头部\",{\"1\":{\"163\":1}}],[\"添加至队尾\",{\"1\":{\"161\":1,\"164\":1}}],[\"添加\",{\"1\":{\"132\":1}}],[\"添加进哈希表\",{\"1\":{\"30\":1}}],[\"涵盖数据访问\",{\"1\":{\"132\":1}}],[\"必须有目标变量在才能用\",{\"1\":{\"348\":1}}],[\"必须有一个明显的结束条件必须有一个趋近于结束条件的趋势\",{\"1\":{\"290\":1}}],[\"必须加const\",{\"1\":{\"348\":1}}],[\"必须使用括号将数据类型关键字包裹起来\",{\"1\":{\"335\":1}}],[\"必须是变量的形式\",{\"1\":{\"279\":1}}],[\"必须切分出一个\",{\"1\":{\"128\":1}}],[\"必须拆分出一个1\",{\"1\":{\"128\":1}}],[\"恒成立\",{\"1\":{\"127\":1}}],[\"现在使用\",{\"1\":{\"367\":1}}],[\"现在的写法\",{\"1\":{\"304\":1}}],[\"现在我们基于分治\",{\"1\":{\"64\":1}}],[\"现选取一个状态\",{\"1\":{\"123\":1}}],[\"面积\",{\"1\":{\"122\":1,\"255\":4}}],[\"容易想到\",{\"1\":{\"168\":1}}],[\"容易发现其中存在重叠子问题\",{\"1\":{\"108\":1}}],[\"容器插入\",{\"1\":{\"379\":1}}],[\"容器新方法\",{\"1\":{\"379\":2}}],[\"容器由任意两个隔板围成\",{\"1\":{\"122\":1}}],[\"容器的容量等于高度和宽度的乘积\",{\"1\":{\"122\":1}}],[\"除非在行尾使用反斜杠\",{\"1\":{\"317\":1}}],[\"除\",{\"1\":{\"276\":1}}],[\"除第一个单词外\",{\"1\":{\"258\":1}}],[\"除叶节点外\",{\"1\":{\"180\":1}}],[\"除排序之外\",{\"1\":{\"120\":1}}],[\"除了需要重新设置readfds还需要重新设置writefds\",{\"1\":{\"442\":1}}],[\"除了使用下划线连接\",{\"1\":{\"258\":1}}],[\"除了包含值\",{\"1\":{\"146\":1}}],[\"除了上述双闭区间外\",{\"1\":{\"21\":1}}],[\"除了\",{\"1\":{\"18\":1,\"325\":1}}],[\"创建套接字\",{\"1\":{\"436\":1}}],[\"创建文件file\",{\"1\":{\"406\":1}}],[\"创建命名管道并以读的方式打开该命名管道\",{\"1\":{\"406\":1}}],[\"创建epoll模型\",{\"1\":{\"395\":1}}],[\"创建并启动一个新线程\",{\"1\":{\"379\":1}}],[\"创建线程时需要指定新线程要执行的函数\",{\"1\":{\"379\":1}}],[\"创建派生类\",{\"1\":{\"376\":1}}],[\"创建派生类对象\",{\"1\":{\"373\":3}}],[\"创建对象\",{\"1\":{\"376\":1}}],[\"创建对象时才定义\",{\"1\":{\"361\":1}}],[\"创建10个\",{\"1\":{\"364\":1}}],[\"创建单例对象时需要使用互斥锁进行保护\",{\"1\":{\"354\":1}}],[\"创建两个源文件\",{\"1\":{\"289\":1}}],[\"创建整数数组\",{\"1\":{\"263\":1}}],[\"创建一个长度为3的指针数组\",{\"1\":{\"263\":1}}],[\"创建一个临时数组\",{\"1\":{\"46\":1}}],[\"创建三个变量\",{\"1\":{\"263\":1}}],[\"创建指针指向数组arr\",{\"1\":{\"263\":1}}],[\"创建指针指向数组的第一个元素\",{\"1\":{\"263\":1}}],[\"创建指针指向变量n的地址\",{\"1\":{\"262\":1}}],[\"创建指针也向数组第一个元素的地址\",{\"1\":{\"262\":1}}],[\"创建指针并指向数组第四个元素的地址\",{\"1\":{\"262\":2}}],[\"创建指针并指向数组第一个元素的地址\",{\"1\":{\"262\":4}}],[\"创建数组\",{\"1\":{\"262\":4,\"263\":1}}],[\"创建数组时会在内存中开辟一整块连续的空间\",{\"1\":{\"243\":1}}],[\"创建物品列表\",{\"1\":{\"120\":1}}],[\"物理层\",{\"0\":{\"512\":1,\"513\":1}}],[\"物理结构从底层决定了数据的访问\",{\"1\":{\"15\":1}}],[\"物理结构反映了数据在计算机内存中的存储方式\",{\"1\":{\"15\":1}}],[\"物理结构\",{\"1\":{\"13\":1}}],[\"物品价值\",{\"1\":{\"120\":1}}],[\"物品重量\",{\"1\":{\"120\":1}}],[\"物品\",{\"1\":{\"120\":1}}],[\"简化硬件设计和提高计算效率\",{\"1\":{\"328\":1}}],[\"简化写法\",{\"1\":{\"245\":1}}],[\"简言之\",{\"1\":{\"328\":1}}],[\"简单地讲\",{\"1\":{\"291\":2}}],[\"简单实现\",{\"1\":{\"53\":1}}],[\"简称实参参数作用域\",{\"1\":{\"286\":1}}],[\"简称形参实参\",{\"1\":{\"286\":1}}],[\"简称vs\",{\"1\":{\"270\":1}}],[\"简称\",{\"1\":{\"270\":1}}],[\"简称字符指针\",{\"1\":{\"263\":1}}],[\"简称宏替换\",{\"1\":{\"255\":1}}],[\"简称为k\",{\"1\":{\"241\":1}}],[\"简称单位价值\",{\"1\":{\"118\":1}}],[\"简而言之\",{\"1\":{\"135\":1}}],[\"霍夫曼编码是一种用于无损数据压缩的贪心算法\",{\"1\":{\"117\":1}}],[\"霍夫曼编码\",{\"1\":{\"117\":1}}],[\"股票买卖问题\",{\"1\":{\"117\":1}}],[\"价值根据选择的重量比例计算\",{\"1\":{\"118\":1}}],[\"价值\",{\"1\":{\"117\":1,\"120\":1}}],[\"价值为val\",{\"1\":{\"107\":1,\"118\":1}}],[\"能形象地表示出行列关系\",{\"1\":{\"246\":1}}],[\"能够在指定时间内进行加锁操作\",{\"1\":{\"379\":1}}],[\"能够在有限步骤\",{\"1\":{\"131\":1}}],[\"能够有效地降低源文件之间的耦合\",{\"1\":{\"289\":1}}],[\"能够表示\",{\"1\":{\"18\":1}}],[\"能以较高效率找到次优解也是非常不错的\",{\"1\":{\"114\":1}}],[\"你好\",{\"1\":{\"367\":2}}],[\"你的成绩不及格\",{\"1\":{\"297\":1}}],[\"你的年龄不大这次放过你了\",{\"1\":{\"297\":1}}],[\"你的目标是选择一组物品\",{\"1\":{\"117\":1}}],[\"你的目标是完成尽可能多的任务\",{\"1\":{\"117\":1}}],[\"你年龄大于18\",{\"1\":{\"297\":1}}],[\"你需要逐级给指针赋值\",{\"1\":{\"265\":1}}],[\"你可以将它指向不同的数组\",{\"1\":{\"263\":1}}],[\"你可以进行多次买卖\",{\"1\":{\"117\":1}}],[\"你可能会发现一个问题\",{\"1\":{\"161\":1}}],[\"你可能会不由地发出感叹\",{\"1\":{\"113\":1}}],[\"你每步可以上1阶或2阶\",{\"1\":{\"92\":1,\"98\":1,\"99\":1}}],[\"贪心地切分出\",{\"1\":{\"128\":1}}],[\"贪心策略确定\",{\"0\":{\"119\":1,\"123\":1,\"127\":1}}],[\"贪心\",{\"0\":{\"112\":1},\"1\":{\"113\":1,\"120\":1,\"124\":1,\"128\":1}}],[\"贪心算法总是可以得到最优解\",{\"1\":{\"117\":1}}],[\"贪心算法常常应用在满足贪心选择性质和最优子结构的优化问题中\",{\"1\":{\"117\":1}}],[\"贪心算法经典问题\",{\"0\":{\"117\":1}}],[\"贪心算法解题步骤\",{\"0\":{\"116\":1}}],[\"贪心算法特征\",{\"0\":{\"115\":1}}],[\"贪心算法在这种情况下也是可用的\",{\"1\":{\"114\":1}}],[\"贪心算法在这种情况下往往是最优选择\",{\"1\":{\"114\":1}}],[\"贪心算法的适用情况分以下两种\",{\"1\":{\"114\":1}}],[\"贪心算法的优点与缺点\",{\"0\":{\"114\":1}}],[\"贪心算法无法保证找到全局最优解\",{\"1\":{\"114\":1}}],[\"贪心算法仅用约十行代码就解决了零钱兑换问题\",{\"1\":{\"113\":1}}],[\"贪心算法不会考虑过去的决策\",{\"1\":{\"113\":1}}],[\"贪心算法和动态规划都常用于解决优化问题\",{\"1\":{\"113\":1}}],[\"贪心算法简洁且高效\",{\"1\":{\"113\":1}}],[\"贪心算法\",{\"0\":{\"12\":1,\"113\":1},\"1\":{\"113\":1}}],[\"值为\",{\"1\":{\"367\":2}}],[\"值为随机值\",{\"1\":{\"361\":1}}],[\"值为0\",{\"1\":{\"348\":1}}],[\"值范围\",{\"1\":{\"330\":1,\"331\":1}}],[\"值通过用户输入获取\",{\"1\":{\"318\":1}}],[\"值通常为\",{\"1\":{\"309\":1,\"310\":1}}],[\"值相同\",{\"1\":{\"310\":1}}],[\"值是好的编程习惯小心指针越界避免返回指向局部变量的指针指针使用之前检查指针是否为\",{\"1\":{\"267\":1}}],[\"值是好的编程习惯\",{\"1\":{\"266\":1}}],[\"值的指针被称为空指针\",{\"1\":{\"266\":1}}],[\"值输出\",{\"1\":{\"251\":3}}],[\"值\",{\"1\":{\"146\":1}}],[\"值可能已经被覆盖\",{\"1\":{\"111\":1}}],[\"值得思考的是\",{\"1\":{\"177\":1}}],[\"值得注意的是\",{\"1\":{\"15\":1,\"18\":1,\"20\":1,\"48\":1,\"51\":1,\"87\":1,\"170\":1,\"172\":1}}],[\"值得说明的是\",{\"1\":{\"15\":1,\"75\":1,\"190\":1}}],[\"进程同步\",{\"0\":{\"501\":1}}],[\"进程管理\",{\"0\":{\"497\":1,\"498\":1}}],[\"进程程序替换\",{\"1\":{\"405\":1}}],[\"进制的转换\",{\"0\":{\"326\":1}}],[\"进制\",{\"0\":{\"325\":1}}],[\"进而执行客户端发送过来的命令\",{\"1\":{\"405\":1}}],[\"进而影响程序运行效率\",{\"1\":{\"354\":1}}],[\"进而决定了键值对在哈希表中的分布情况\",{\"1\":{\"175\":1}}],[\"进而指导算法设计与优化过程\",{\"1\":{\"135\":1}}],[\"进一步思考\",{\"1\":{\"111\":1}}],[\"进行操作\",{\"1\":{\"379\":1}}],[\"进行原子操作\",{\"1\":{\"379\":1}}],[\"进行一些线程安全的操作\",{\"1\":{\"379\":1}}],[\"进行初始化\",{\"1\":{\"379\":2}}],[\"进行初始化赋值\",{\"1\":{\"246\":1}}],[\"进行切片\",{\"1\":{\"373\":1}}],[\"进行比较\",{\"1\":{\"262\":1}}],[\"进行比较并将较小的元素复制到临时数组中\",{\"1\":{\"46\":1}}],[\"进行赋值\",{\"1\":{\"250\":1,\"251\":1}}],[\"进行探测\",{\"1\":{\"174\":1}}],[\"进行扩容的\",{\"1\":{\"158\":1}}],[\"进行排序\",{\"1\":{\"85\":1,\"86\":1}}],[\"进行下一轮选择\",{\"1\":{\"77\":1,\"81\":1,\"82\":1,\"85\":2,\"86\":1}}],[\"引入目的\",{\"1\":{\"379\":1}}],[\"引入标准库头文件需要使用尖括号将文件名包裹起来\",{\"1\":{\"320\":1}}],[\"引入模块化语言等\",{\"1\":{\"241\":1}}],[\"引入许多特性如\",{\"1\":{\"241\":1}}],[\"引入记忆化之后\",{\"1\":{\"109\":1}}],[\"引用成员变量\",{\"1\":{\"361\":1}}],[\"引用要求类型相同\",{\"1\":{\"348\":1}}],[\"引用记录了下一个节点的内存地址\",{\"1\":{\"146\":1}}],[\"引用\",{\"1\":{\"69\":1,\"146\":3,\"361\":1,\"373\":1}}],[\"尤其是嵌入式开发中\",{\"1\":{\"330\":1}}],[\"尤其是相同重量的物品较多时\",{\"1\":{\"108\":1}}],[\"尤其是当\",{\"1\":{\"85\":1}}],[\"writefds与exceptfds一样\",{\"1\":{\"439\":1}}],[\"write\",{\"1\":{\"403\":1,\"406\":2}}],[\"writing\",{\"1\":{\"370\":1}}],[\"wronly\",{\"1\":{\"403\":1,\"406\":2}}],[\"what\",{\"1\":{\"382\":7}}],[\"whitespace\",{\"1\":{\"293\":2}}],[\"while实现\",{\"1\":{\"345\":1}}],[\"while均可以作为外层循环和内层循环\",{\"1\":{\"298\":1}}],[\"while后面的分号不能省略\",{\"1\":{\"298\":1}}],[\"while循环是先执行再判断\",{\"1\":{\"298\":1}}],[\"while循环\",{\"1\":{\"298\":2}}],[\"while\",{\"1\":{\"20\":1,\"21\":1,\"23\":1,\"24\":1,\"41\":1,\"42\":3,\"43\":3,\"46\":3,\"48\":1,\"50\":2,\"113\":2,\"124\":1,\"136\":1,\"151\":1,\"156\":1,\"160\":1,\"170\":6,\"172\":1,\"186\":1,\"193\":1,\"194\":1,\"195\":2,\"207\":1,\"211\":1,\"212\":1,\"219\":4,\"223\":2,\"225\":1,\"259\":1,\"292\":1,\"298\":5,\"310\":4,\"319\":2,\"344\":1,\"345\":1,\"361\":4,\"370\":1,\"403\":3,\"404\":2,\"405\":1,\"406\":2}}],[\"waitpid\",{\"1\":{\"405\":1}}],[\"wait函数在检测到监听套接字的读事件就绪后就会调用accept获取建立好的连接\",{\"1\":{\"398\":1}}],[\"wait函数后进行阻塞等待\",{\"1\":{\"398\":1}}],[\"wait函数时\",{\"1\":{\"398\":1}}],[\"wait\",{\"1\":{\"379\":4,\"396\":2}}],[\"wait系列成员函数\",{\"1\":{\"379\":1}}],[\"with\",{\"1\":{\"379\":4}}],[\"windows\",{\"1\":{\"320\":1,\"406\":1}}],[\"windows系统\",{\"1\":{\"320\":1}}],[\"windows环境需要安装mingw\",{\"1\":{\"270\":1}}],[\"winter\",{\"1\":{\"301\":1}}],[\"wb\",{\"1\":{\"310\":1,\"344\":2}}],[\"weakptr\",{\"1\":{\"351\":4}}],[\"weak\",{\"1\":{\"351\":8}}],[\"weight\",{\"1\":{\"304\":1,\"361\":26}}],[\"weighted\",{\"1\":{\"214\":1}}],[\"wed\",{\"1\":{\"301\":3}}],[\"wednesday\",{\"1\":{\"301\":1}}],[\"weekday\",{\"1\":{\"301\":1}}],[\"wo\",{\"1\":{\"292\":3}}],[\"world\",{\"1\":{\"245\":1,\"288\":4,\"292\":1,\"294\":1}}],[\"w\",{\"1\":{\"120\":6,\"245\":1,\"310\":4,\"361\":10}}],[\"wgtsize\",{\"1\":{\"110\":2,\"111\":2}}],[\"wgt\",{\"1\":{\"108\":6,\"109\":6,\"110\":3,\"111\":3,\"118\":2,\"120\":2}}],[\"背包容量较大\",{\"1\":{\"108\":1}}],[\"背包\",{\"1\":{\"108\":1,\"109\":1,\"110\":1,\"111\":1}}],[\"背包问题整体上非常相似\",{\"1\":{\"118\":1}}],[\"背包问题看作一个由n轮决策组成的过程\",{\"1\":{\"107\":1}}],[\"背包问题是一个非常好的动态规划入门题目\",{\"1\":{\"107\":1}}],[\"背包问题通常使用动态规划解决\",{\"1\":{\"79\":1}}],[\"背包问题\",{\"1\":{\"79\":1,\"107\":2}}],[\"终止递归并返回价值0\",{\"1\":{\"108\":1}}],[\"终止条件\",{\"1\":{\"46\":1,\"108\":1,\"136\":2}}],[\"问在限定背包容量下背包中物品的最大价值\",{\"1\":{\"118\":1}}],[\"问在限定背包容量下能放入物品的最大价值\",{\"1\":{\"107\":1}}],[\"问能够凑出目标金额的最少硬币数量\",{\"1\":{\"113\":1}}],[\"问题是明确的\",{\"1\":{\"131\":1}}],[\"问题求解步骤\",{\"0\":{\"102\":1}}],[\"问题描述中有明显的排列组合的特征\",{\"1\":{\"101\":1}}],[\"问题的目标是找出所有可能的解决方案\",{\"1\":{\"101\":1}}],[\"问题的状态能够使用一个列表\",{\"1\":{\"101\":1}}],[\"问题包含最大\",{\"1\":{\"101\":1}}],[\"问题判断\",{\"0\":{\"101\":1}}],[\"问题3\",{\"1\":{\"76\":1}}],[\"问题2\",{\"1\":{\"75\":1}}],[\"问题定义为从\",{\"1\":{\"66\":1}}],[\"问题\",{\"1\":{\"64\":1,\"65\":1,\"70\":1,\"74\":1,\"79\":1,\"81\":1,\"82\":1,\"85\":1,\"86\":1,\"87\":1,\"102\":1,\"107\":1,\"113\":1,\"118\":1,\"122\":1,\"126\":1,\"379\":1}}],[\"问题可以分解\",{\"1\":{\"59\":2,\"64\":1,\"66\":1}}],[\"造成重叠子问题的原因为\",{\"1\":{\"103\":1}}],[\"造成这种重复的原因是相等元素在某轮中被多次选择\",{\"1\":{\"86\":1}}],[\"guard在这里离开作用域\",{\"1\":{\"379\":1}}],[\"guard<std\",{\"1\":{\"379\":2}}],[\"guard的使用\",{\"1\":{\"379\":1}}],[\"guard不同\",{\"1\":{\"379\":1}}],[\"guard是一个轻量级的互斥锁封装类\",{\"1\":{\"379\":1}}],[\"guard和unique\",{\"1\":{\"379\":1}}],[\"gcc\",{\"1\":{\"287\":1}}],[\"g++等工具\",{\"1\":{\"270\":1}}],[\"gender1\",{\"1\":{\"361\":3}}],[\"gender=m\",{\"1\":{\"302\":3}}],[\"gender=\",{\"1\":{\"302\":3}}],[\"gender\",{\"1\":{\"302\":15,\"361\":2}}],[\"genericcontainer\",{\"1\":{\"367\":2}}],[\"generic\",{\"1\":{\"241\":1,\"259\":1,\"382\":1}}],[\"getline\",{\"1\":{\"370\":1}}],[\"getmonthday\",{\"1\":{\"361\":8}}],[\"getdata\",{\"1\":{\"357\":1}}],[\"getinstance函数第一次调用需要对static指针进行写入操作\",{\"1\":{\"354\":1}}],[\"getinstance\",{\"1\":{\"354\":4}}],[\"getc\",{\"1\":{\"310\":1}}],[\"getchar\",{\"1\":{\"309\":3}}],[\"getchar和putchar函数\",{\"1\":{\"309\":1}}],[\"gets\",{\"1\":{\"309\":4,\"310\":1}}],[\"gets和puts函数\",{\"1\":{\"309\":1}}],[\"getaverage\",{\"1\":{\"264\":3}}],[\"get\",{\"1\":{\"170\":1,\"172\":1,\"367\":5,\"379\":4,\"382\":1,\"390\":1,\"397\":1,\"440\":1}}],[\"goto语句是一种跳转语句\",{\"1\":{\"299\":1}}],[\"goto语句\",{\"1\":{\"299\":1}}],[\"goto\",{\"1\":{\"259\":1,\"299\":5}}],[\"go\",{\"1\":{\"146\":1}}],[\"greeting\",{\"1\":{\"245\":6}}],[\"greedy\",{\"1\":{\"113\":1}}],[\"graphdfs\",{\"1\":{\"225\":1}}],[\"graphbfs\",{\"1\":{\"223\":1}}],[\"graphadjlist\",{\"1\":{\"219\":12,\"223\":1,\"225\":2}}],[\"graphadjmat\",{\"1\":{\"218\":11}}],[\"graph\",{\"1\":{\"213\":1,\"214\":5,\"218\":43,\"219\":41,\"223\":2,\"225\":5}}],[\"grandchild\",{\"1\":{\"201\":3,\"202\":3,\"207\":1}}],[\"grand\",{\"1\":{\"201\":2,\"202\":2}}],[\"grid\",{\"1\":{\"103\":6,\"104\":6,\"105\":5,\"106\":5}}],[\"gbk\",{\"1\":{\"18\":2}}],[\"gbk字符集\",{\"1\":{\"18\":1}}],[\"gb2312\",{\"1\":{\"18\":3}}],[\"自己实现拷贝构造\",{\"1\":{\"361\":1}}],[\"自动推导类型\",{\"1\":{\"379\":1}}],[\"自动生成\",{\"1\":{\"361\":1}}],[\"自动判断结束\",{\"1\":{\"348\":1}}],[\"自动获取array中的数据\",{\"1\":{\"348\":1}}],[\"自动类型转换\",{\"1\":{\"336\":1}}],[\"自动初始化为空字符\",{\"1\":{\"288\":1}}],[\"自动初始化为0\",{\"1\":{\"288\":2}}],[\"自定义派生类异常\",{\"1\":{\"382\":1}}],[\"自定义基类异常\",{\"1\":{\"382\":1}}],[\"自定义异常体系\",{\"1\":{\"382\":1}}],[\"自定义类型成员变量\",{\"1\":{\"361\":1}}],[\"自定义类型成员会去调用它的析构函数\",{\"1\":{\"361\":1}}],[\"自定义头文件的文件名写在双引号里面\",{\"1\":{\"320\":1}}],[\"自定义头文件的扩展名都是\",{\"1\":{\"320\":1}}],[\"自定义头文件或其他外部源代码文件\",{\"1\":{\"320\":1}}],[\"自定义数据类型时\",{\"1\":{\"304\":1}}],[\"自定义数据类型\",{\"0\":{\"300\":1}}],[\"自定义函数\",{\"1\":{\"285\":1}}],[\"自增\",{\"1\":{\"276\":1}}],[\"自增和自减\",{\"1\":{\"276\":1}}],[\"自增地址后移\",{\"1\":{\"262\":1}}],[\"自减运算符可以写在操作数的前面也可以写在操作数后面\",{\"1\":{\"276\":1}}],[\"自减运算\",{\"1\":{\"263\":1}}],[\"自减运算数组名的指向不可更改\",{\"1\":{\"263\":1}}],[\"自减地址前移\",{\"1\":{\"262\":1}}],[\"自减本质上就是指针加减整数\",{\"1\":{\"262\":1}}],[\"自底向上执行旋转操作\",{\"1\":{\"206\":1}}],[\"自上而下\",{\"1\":{\"136\":1}}],[\"自下而上\",{\"1\":{\"136\":1}}],[\"自此\",{\"1\":{\"102\":1}}],[\"自适应搜索\",{\"1\":{\"64\":1}}],[\"自适应排序\",{\"1\":{\"37\":1,\"41\":1,\"43\":1}}],[\"自适应排序的时间复杂度会受输入数据的影响\",{\"1\":{\"33\":1}}],[\"自适应性需要根据具体情况来评估\",{\"1\":{\"33\":1}}],[\"自适应性\",{\"1\":{\"33\":1}}],[\"确保每个级别的指针指向正确的目标\",{\"1\":{\"265\":1}}],[\"确保每个内存空间都有唯一的内存地址\",{\"1\":{\"15\":1}}],[\"确保了可移植性\",{\"1\":{\"241\":1}}],[\"确定性\",{\"1\":{\"176\":1}}],[\"确定边界条件等\",{\"1\":{\"102\":1}}],[\"描述决策\",{\"1\":{\"102\":1}}],[\"少\",{\"1\":{\"101\":1}}],[\"少数字符需要用到\",{\"1\":{\"18\":1}}],[\"加载当前值\",{\"1\":{\"379\":1}}],[\"加载文件信息\",{\"1\":{\"344\":1}}],[\"加载文件失败\",{\"1\":{\"344\":1}}],[\"加载通讯录文件\",{\"1\":{\"344\":1}}],[\"加地域号4位\",{\"1\":{\"344\":1}}],[\"加\",{\"1\":{\"262\":1,\"276\":1}}],[\"加入队列\",{\"1\":{\"223\":1}}],[\"加入根节点\",{\"1\":{\"186\":1}}],[\"加法哈希\",{\"1\":{\"177\":2}}],[\"加分项\",{\"1\":{\"101\":2}}],[\"加上一步操作\",{\"1\":{\"66\":1}}],[\"决定了输出值\",{\"1\":{\"175\":1}}],[\"决定排除哪一半区间\",{\"1\":{\"63\":1}}],[\"决策树模型\",{\"1\":{\"101\":1}}],[\"穷举\",{\"1\":{\"101\":1}}],[\"某些问题具有非常严重的\",{\"1\":{\"99\":1}}],[\"爬上3阶仅剩下2种可行方案\",{\"1\":{\"99\":1}}],[\"爬楼梯最小代价\",{\"1\":{\"98\":2}}],[\"爬楼梯做小代价问题\",{\"1\":{\"98\":1}}],[\"爬楼梯\",{\"1\":{\"92\":1,\"93\":1,\"94\":1,\"95\":1,\"96\":1}}],[\"爬楼梯问题的状态定义为当前所在楼梯阶数i\",{\"1\":{\"95\":1}}],[\"爬楼梯问题\",{\"1\":{\"92\":1}}],[\"情况就不一样了\",{\"1\":{\"99\":1}}],[\"情况变得稍微复杂了一些\",{\"1\":{\"72\":1}}],[\"滚动数组\",{\"1\":{\"96\":1}}],[\"滚动变量\",{\"1\":{\"96\":1}}],[\"降维\",{\"1\":{\"96\":1}}],[\"降低至o\",{\"1\":{\"96\":1}}],[\"降至o\",{\"1\":{\"30\":1,\"98\":1,\"111\":1}}],[\"细心的读者可能发现了\",{\"1\":{\"96\":1}}],[\"概念来表示问题求解的特定阶段\",{\"1\":{\"95\":1}}],[\"预处理命令总结\",{\"0\":{\"322\":1}}],[\"预处理程序对它不作任何检查\",{\"1\":{\"318\":1}}],[\"预处理过程中会执行预处理指令\",{\"1\":{\"317\":1}}],[\"预处理指令通常不能写在函数内部\",{\"1\":{\"317\":1}}],[\"预处理指令不需要分号作为结束符\",{\"1\":{\"317\":1}}],[\"预处理指令都是一行的\",{\"1\":{\"317\":1}}],[\"预处理指令都以\",{\"1\":{\"317\":1}}],[\"预处理指令应该放在代码的开头部分2\",{\"1\":{\"317\":1}}],[\"预处理指令具有如下特点\",{\"1\":{\"317\":1}}],[\"预处理指令以\",{\"1\":{\"317\":1}}],[\"预处理指令\",{\"1\":{\"317\":1}}],[\"预处理器会将它替换为对应的文本\",{\"1\":{\"318\":1}}],[\"预处理器会处理源代码文件\",{\"1\":{\"271\":1}}],[\"预处理器基本介绍\",{\"0\":{\"317\":1}}],[\"预处理器\",{\"0\":{\"316\":1},\"1\":{\"317\":1}}],[\"预处理\",{\"0\":{\"237\":1},\"1\":{\"271\":1,\"319\":1}}],[\"预设最小子问题的解\",{\"1\":{\"95\":1,\"98\":1,\"99\":1}}],[\"预期向每个桶分配\",{\"1\":{\"50\":1}}],[\"叶节点高度为\",{\"1\":{\"199\":1}}],[\"叶节点的高度为0\",{\"1\":{\"199\":1}}],[\"叶节点的度为0\",{\"1\":{\"183\":1}}],[\"叶节点\",{\"1\":{\"95\":1,\"181\":1}}],[\"方式一\",{\"1\":{\"303\":1}}],[\"方式三不指定成员名\",{\"1\":{\"303\":1}}],[\"方式三\",{\"1\":{\"302\":1,\"303\":2}}],[\"方式二\",{\"1\":{\"302\":1,\"303\":2}}],[\"方便后续操作\",{\"1\":{\"367\":1}}],[\"方便后续使用\",{\"1\":{\"199\":1,\"209\":1}}],[\"方便用户使用\",{\"1\":{\"270\":1}}],[\"方案数量加\",{\"1\":{\"92\":1}}],[\"方法\",{\"1\":{\"382\":2}}],[\"方法三\",{\"0\":{\"95\":1,\"105\":1,\"110\":1},\"1\":{\"244\":1}}],[\"方法二\",{\"0\":{\"94\":1,\"104\":1,\"109\":1},\"1\":{\"27\":1,\"30\":1,\"244\":1,\"245\":1,\"246\":1,\"354\":3}}],[\"方法一\",{\"0\":{\"93\":1,\"103\":1,\"108\":1},\"1\":{\"27\":1,\"29\":1,\"354\":3}}],[\"皆使用o\",{\"1\":{\"90\":1}}],[\"受画幅限制\",{\"1\":{\"88\":1}}],[\"棋盘每行都允许且只允许放置一个皇后\",{\"1\":{\"88\":1}}],[\"棋盘状态在不断地变化\",{\"1\":{\"87\":1}}],[\"皇后\",{\"1\":{\"90\":2}}],[\"皇后的数量和棋盘的行数都为n\",{\"1\":{\"88\":1}}],[\"皇后可以攻击与同处一行\",{\"1\":{\"87\":1}}],[\"逐字符读取并输出文件内容\",{\"1\":{\"310\":1}}],[\"逐字符读取文件\",{\"1\":{\"310\":1}}],[\"逐行读取文件\",{\"1\":{\"310\":1}}],[\"逐行放置n次\",{\"1\":{\"90\":1}}],[\"逐行放置策略起到了剪枝的作用\",{\"1\":{\"88\":1}}],[\"逐行放置策略\",{\"0\":{\"88\":1}}],[\"逐层推进\",{\"1\":{\"186\":1}}],[\"逐个向后遍历\",{\"1\":{\"150\":1}}],[\"逐步了解回溯算法的工作原理\",{\"1\":{\"74\":1}}],[\"多线程最主要的问题就是共享数据带来的线程安全问题\",{\"1\":{\"379\":1}}],[\"多继承\",{\"1\":{\"373\":3}}],[\"多重循环\",{\"1\":{\"298\":1}}],[\"多重背包问题等\",{\"1\":{\"107\":1}}],[\"多向分支\",{\"1\":{\"297\":2}}],[\"多了一个参数\",{\"1\":{\"291\":2}}],[\"多行注释\",{\"1\":{\"273\":1}}],[\"多级指针的定义与使用\",{\"1\":{\"265\":1}}],[\"多级指针基本介绍指向指针的指针是一种多级间接寻址的形式\",{\"1\":{\"265\":1}}],[\"多级指针\",{\"0\":{\"265\":1}}],[\"多维数组的介绍\",{\"1\":{\"246\":1}}],[\"多维数组\",{\"0\":{\"246\":1}}],[\"多维矩阵或树来表示\",{\"1\":{\"101\":1}}],[\"多对多\",{\"1\":{\"221\":1}}],[\"多次哈希方法不易产生聚集\",{\"1\":{\"174\":1}}],[\"多次哈希方法使用多个哈希函数f1\",{\"1\":{\"174\":1}}],[\"多次哈希\",{\"0\":{\"174\":1}}],[\"多次探测\",{\"1\":{\"171\":1}}],[\"多个shared\",{\"1\":{\"351\":1}}],[\"多个单词组成的标识符\",{\"1\":{\"258\":1}}],[\"多个\",{\"1\":{\"168\":1}}],[\"多个输入对应相同输出\",{\"1\":{\"168\":1}}],[\"多个皇后不能在同一行\",{\"1\":{\"87\":1}}],[\"多万个字符\",{\"1\":{\"18\":1}}],[\"给右值取别名\",{\"1\":{\"379\":1}}],[\"给左值取别名\",{\"1\":{\"379\":1}}],[\"给预先分配内存块的buffer中构造myclass对象类型\",{\"1\":{\"364\":2}}],[\"给编译器自己生成的默认构造函数使用\",{\"1\":{\"361\":1}}],[\"给的缺省值\",{\"1\":{\"361\":1}}],[\"给\",{\"1\":{\"304\":1}}],[\"给int\",{\"1\":{\"304\":1}}],[\"给首成员赋值\",{\"1\":{\"303\":1}}],[\"给任一成员赋值\",{\"1\":{\"303\":1}}],[\"给出了所有的选择\",{\"1\":{\"87\":1}}],[\"给定某顶点\",{\"1\":{\"225\":1}}],[\"给定某节点\",{\"1\":{\"190\":1}}],[\"给定元素\",{\"1\":{\"211\":1}}],[\"给定索引i\",{\"1\":{\"209\":1}}],[\"给定目标节点值\",{\"1\":{\"193\":1}}],[\"给定目标金额\",{\"1\":{\"113\":1}}],[\"给定初始值\",{\"1\":{\"139\":1}}],[\"给定n种硬币\",{\"1\":{\"113\":1}}],[\"给定n个学生\",{\"1\":{\"166\":1}}],[\"给定n个物品\",{\"1\":{\"107\":1,\"118\":1}}],[\"给定n个皇后和一个nxn大小的棋盘\",{\"1\":{\"87\":1}}],[\"给定网格的最小路径和为13\",{\"1\":{\"102\":1}}],[\"给定状态i\",{\"1\":{\"99\":1}}],[\"给定输入数组\",{\"1\":{\"85\":1}}],[\"给定数组中的任意一个节点\",{\"1\":{\"189\":1}}],[\"给定数组内存地址\",{\"1\":{\"140\":1}}],[\"给定数组\",{\"1\":{\"86\":1}}],[\"给定数组可能包含重复元素\",{\"1\":{\"86\":1}}],[\"给定数组无重复元素\",{\"1\":{\"85\":1}}],[\"给定数组不包含小数\",{\"1\":{\"27\":1}}],[\"给定三根柱子和一系列大小不同的圆盘\",{\"1\":{\"79\":1}}],[\"给定三根柱子\",{\"1\":{\"70\":1}}],[\"给定一棵非完美二叉树\",{\"1\":{\"190\":1}}],[\"给定一棵满二叉树\",{\"1\":{\"189\":1}}],[\"给定一棵二叉树\",{\"1\":{\"74\":1}}],[\"给定一棵二叉树的前序遍历\",{\"1\":{\"65\":1}}],[\"给定一组股票的历史价格\",{\"1\":{\"117\":1}}],[\"给定一组物品和一个载重量\",{\"1\":{\"117\":1}}],[\"给定一组物品和一个背包\",{\"1\":{\"79\":1}}],[\"给定一个顶点数量为n的无向图\",{\"1\":{\"218\":1}}],[\"给定一个待插入元素\",{\"1\":{\"194\":1}}],[\"给定一个正整数n\",{\"1\":{\"126\":1}}],[\"给定一个正整数数组\",{\"1\":{\"85\":1,\"86\":1}}],[\"给定一个nxm的二维网络grid\",{\"1\":{\"102\":1}}],[\"给定一个共有n个楼梯\",{\"1\":{\"99\":1}}],[\"给定一个共有n阶的楼梯\",{\"1\":{\"92\":1}}],[\"给定一个确定的状态\",{\"1\":{\"99\":1}}],[\"给定一个非负整数数组cost\",{\"1\":{\"98\":1}}],[\"给定一个楼梯\",{\"1\":{\"98\":1}}],[\"给定一个无向图\",{\"1\":{\"79\":2}}],[\"给定一个集合和一个目标和\",{\"1\":{\"79\":1}}],[\"给定一个集合\",{\"1\":{\"79\":1}}],[\"给定一个长度为n的数组\",{\"1\":{\"53\":1}}],[\"共用头文件的代码和之前的一样\",{\"1\":{\"406\":1}}],[\"共用体起别名\",{\"1\":{\"304\":1}}],[\"共用体也使用点号\",{\"1\":{\"303\":1}}],[\"共用体内存分析\",{\"1\":{\"303\":1}}],[\"共用体类型名称\",{\"1\":{\"303\":1}}],[\"共用体\",{\"0\":{\"303\":1},\"1\":{\"303\":1}}],[\"共享数据支持多个线程同时对其进行读操作\",{\"1\":{\"379\":1}}],[\"共有3种方案可以爬到楼顶\",{\"1\":{\"92\":1}}],[\"共可以找到两个解\",{\"1\":{\"87\":1}}],[\"共包含四种剪枝操作\",{\"1\":{\"86\":1}}],[\"共循环n\",{\"1\":{\"48\":1}}],[\"幸运的是\",{\"1\":{\"86\":1}}],[\"^=\",{\"1\":{\"177\":1}}],[\"^\",{\"1\":{\"86\":1,\"177\":2,\"280\":1}}],[\"^2\",{\"1\":{\"61\":1,\"90\":1,\"218\":1}}],[\"xshell\",{\"1\":{\"406\":1}}],[\"xxxxx\",{\"1\":{\"348\":1}}],[\"xxxx\",{\"1\":{\"348\":2}}],[\"xxx\",{\"1\":{\"348\":2}}],[\"xx\",{\"1\":{\"348\":2}}],[\"x的值为\",{\"1\":{\"348\":4}}],[\"x32=45933945\",{\"1\":{\"330\":1}}],[\"x32=\",{\"1\":{\"330\":1}}],[\"x32\",{\"1\":{\"330\":3}}],[\"x>y\",{\"1\":{\"319\":1}}],[\"x和c\",{\"1\":{\"303\":1}}],[\"xorhash\",{\"1\":{\"177\":1}}],[\"x\",{\"1\":{\"109\":1,\"110\":1,\"118\":1,\"127\":1,\"128\":1,\"174\":5,\"276\":2,\"286\":3,\"303\":4,\"304\":4,\"319\":6,\"321\":3,\"325\":11,\"348\":23,\"357\":8,\"361\":7,\"379\":17}}],[\"xim\",{\"1\":{\"85\":1}}],[\"xi2\",{\"1\":{\"85\":1}}],[\"xi1\",{\"1\":{\"85\":1}}],[\"xn\",{\"1\":{\"85\":1}}],[\"x2=12\",{\"1\":{\"276\":1}}],[\"x2=\",{\"1\":{\"276\":1}}],[\"x2\",{\"1\":{\"85\":1,\"276\":2}}],[\"x1=\",{\"1\":{\"276\":2}}],[\"x1\",{\"1\":{\"85\":1,\"276\":2}}],[\"会提示没声明\",{\"1\":{\"379\":1}}],[\"会根据动态类型调用响应的实现\",{\"1\":{\"376\":1}}],[\"会先用20作为参数构造一个临时对象\",{\"1\":{\"361\":1}}],[\"会先使用预处理器\",{\"1\":{\"317\":1}}],[\"会造成精度损失\",{\"1\":{\"337\":1}}],[\"会造成可读性降低如果外层循环次数为m次\",{\"1\":{\"298\":1}}],[\"会发生数据类型转换\",{\"1\":{\"337\":1}}],[\"会执行两次\",{\"1\":{\"319\":1}}],[\"会执行下一个case\",{\"1\":{\"297\":1}}],[\"会被替换成1\",{\"1\":{\"321\":1}}],[\"会被宏替换为\",{\"1\":{\"319\":1}}],[\"会被编译器默认处理成void\",{\"1\":{\"361\":1}}],[\"会被编译\",{\"1\":{\"319\":1}}],[\"会给它分配内存\",{\"1\":{\"319\":1}}],[\"会进行隐式类型转换\",{\"1\":{\"379\":1}}],[\"会进行字符串的替换\",{\"1\":{\"319\":1}}],[\"会进行类型检查\",{\"1\":{\"255\":1}}],[\"会替换成\",{\"1\":{\"318\":1}}],[\"会导致无法访问未回收的内存块\",{\"1\":{\"314\":1}}],[\"会报错\",{\"1\":{\"286\":1,\"313\":1}}],[\"会有警告\",{\"1\":{\"263\":1}}],[\"会出现\",{\"1\":{\"255\":1}}],[\"会自动转为\",{\"1\":{\"337\":1}}],[\"会自动匹配到各行各列\",{\"1\":{\"246\":1}}],[\"会自动添加一个\",{\"1\":{\"245\":1}}],[\"会包括相邻内存的数据\",{\"1\":{\"245\":1}}],[\"会触发扩容机制\",{\"1\":{\"158\":1}}],[\"会产生两个重复的搜索分支\",{\"1\":{\"86\":1}}],[\"会生成包含这两个元素的所有子集\",{\"1\":{\"85\":1}}],[\"会更加高效\",{\"1\":{\"18\":1}}],[\"输出系统\",{\"0\":{\"492\":1}}],[\"输出客户端发来的信息\",{\"1\":{\"403\":1}}],[\"输出修改后的值\",{\"1\":{\"379\":4}}],[\"输出语句的顺序可能会有所不同\",{\"1\":{\"379\":1}}],[\"输出modified\",{\"1\":{\"379\":2}}],[\"输出45\",{\"1\":{\"351\":1}}],[\"输出42\",{\"1\":{\"351\":1}}],[\"输出x的类型名字\",{\"1\":{\"348\":1}}],[\"输出型参数\",{\"1\":{\"348\":1}}],[\"输出不合格的成绩\",{\"1\":{\"314\":1}}],[\"输出数组的元素的值\",{\"1\":{\"314\":1}}],[\"输出到屏幕终端\",{\"1\":{\"309\":1}}],[\"输出流\",{\"1\":{\"308\":1}}],[\"输出操作以\",{\"1\":{\"308\":1}}],[\"输出10次\",{\"1\":{\"298\":4}}],[\"输出提取的数据\",{\"1\":{\"291\":1}}],[\"输出格式化后的字符串\",{\"1\":{\"291\":1}}],[\"输出局部变量\",{\"1\":{\"288\":1}}],[\"输出全局变量\",{\"1\":{\"288\":1}}],[\"输出\",{\"1\":{\"276\":2,\"297\":1,\"309\":1,\"310\":1,\"361\":1,\"379\":1}}],[\"输出返回值\",{\"1\":{\"264\":1}}],[\"输出指针指向的地址\",{\"1\":{\"262\":1}}],[\"输出结果\",{\"1\":{\"251\":1,\"379\":1}}],[\"输出结果为9\",{\"1\":{\"379\":1}}],[\"输出结果为\",{\"1\":{\"85\":1}}],[\"输出列表是程序需要输出的一些数据\",{\"1\":{\"251\":1}}],[\"输出变量的值\",{\"1\":{\"251\":2}}],[\"输出变量\",{\"0\":{\"251\":1}}],[\"输出该字符不会有任何效果\",{\"1\":{\"245\":1}}],[\"输出该节点在链表中的索引\",{\"1\":{\"151\":1}}],[\"输出空间为数组容量大小\",{\"1\":{\"169\":1}}],[\"输出空间是所有桶\",{\"1\":{\"167\":1}}],[\"输出始终相同\",{\"1\":{\"131\":1}}],[\"输入输出管理\",{\"0\":{\"507\":1}}],[\"输入输出系统\",{\"0\":{\"491\":1}}],[\"输入输出\",{\"1\":{\"331\":1}}],[\"输入5个学生的成绩\",{\"1\":{\"314\":1}}],[\"输入流\",{\"1\":{\"308\":1}}],[\"输入列数和行数\",{\"1\":{\"298\":1}}],[\"输入无效\",{\"1\":{\"297\":1}}],[\"输入年龄\",{\"1\":{\"297\":2}}],[\"输入赋值变量\",{\"0\":{\"252\":1}}],[\"输入的微小变化应当导致输出的显著且不可预测的变化\",{\"1\":{\"176\":1}}],[\"输入\",{\"0\":{\"492\":1},\"1\":{\"170\":1,\"309\":1}}],[\"输入空间为全体整数\",{\"1\":{\"169\":1}}],[\"输入空间是所有\",{\"1\":{\"167\":1}}],[\"输入一个float类型数据时使用\",{\"1\":{\"331\":1}}],[\"输入一个\",{\"1\":{\"167\":2}}],[\"输入一个学号\",{\"1\":{\"166\":1}}],[\"输入一个数组\",{\"1\":{\"122\":1}}],[\"输入一个整数数组\",{\"1\":{\"81\":1,\"82\":1}}],[\"输入集合中的元素可以被无限次重复选取\",{\"1\":{\"85\":1}}],[\"输入集合\",{\"1\":{\"85\":1}}],[\"输入数组并建立大顶堆\",{\"1\":{\"48\":1}}],[\"输入数组并建立小顶堆\",{\"1\":{\"47\":1}}],[\"输入数据范围为\",{\"1\":{\"50\":1}}],[\"输入数据按姓名排序的性质丢失\",{\"1\":{\"33\":1}}],[\"输入数据是按照姓名排序好的\",{\"1\":{\"33\":1}}],[\"初步得到解题代码\",{\"1\":{\"85\":1}}],[\"初始容量\",{\"1\":{\"158\":1}}],[\"初始最大容量为\",{\"1\":{\"124\":1}}],[\"初始状态\",{\"1\":{\"95\":1,\"98\":1,\"99\":1}}],[\"初始状态下\",{\"1\":{\"36\":1,\"41\":1,\"123\":1}}],[\"初始化的方法用来简单化列表初始化和其他初始化\",{\"1\":{\"379\":1}}],[\"初始化为1\",{\"1\":{\"364\":1}}],[\"初始化列表特性\",{\"1\":{\"361\":1}}],[\"初始化列表\",{\"1\":{\"361\":1}}],[\"初始化类的成员变量\",{\"1\":{\"361\":1}}],[\"初始化互斥锁\",{\"1\":{\"354\":2}}],[\"初始化通讯录\",{\"1\":{\"345\":2}}],[\"初始化通讯录文件\",{\"1\":{\"344\":1}}],[\"初始化多级指针时\",{\"1\":{\"265\":1}}],[\"初始化邻接表\",{\"1\":{\"219\":1}}],[\"初始化邻接矩阵\",{\"1\":{\"218\":1}}],[\"初始化长度为n的顶点列表\",{\"1\":{\"218\":1}}],[\"初始化节点\",{\"1\":{\"182\":1,\"194\":1}}],[\"初始化二叉树\",{\"1\":{\"182\":2}}],[\"初始化扩容后的新哈希表\",{\"1\":{\"170\":1,\"172\":1}}],[\"初始化扩展后的空间\",{\"1\":{\"145\":1}}],[\"初始化一个列表\",{\"1\":{\"186\":1}}],[\"初始化一个大容量\",{\"1\":{\"157\":1}}],[\"初始化一个扩展长度后的数组\",{\"1\":{\"145\":1}}],[\"初始化各个节点\",{\"1\":{\"147\":1}}],[\"初始化完成后\",{\"1\":{\"147\":1}}],[\"初始化链表\",{\"0\":{\"147\":1},\"1\":{\"147\":1}}],[\"初始化两指针\",{\"1\":{\"123\":1}}],[\"初始化两个指针i和j分别指向数组的两端\",{\"1\":{\"42\":1}}],[\"初始化解的数量为0\",{\"1\":{\"85\":1}}],[\"初始化哈希表\",{\"1\":{\"69\":1}}],[\"初始化每一个节点\",{\"1\":{\"69\":1}}],[\"初始化根节点\",{\"1\":{\"66\":1,\"69\":1}}],[\"初始化位数k=1\",{\"1\":{\"56\":1}}],[\"初始化数组\",{\"0\":{\"139\":1},\"1\":{\"54\":1,\"139\":1,\"161\":1,\"164\":1}}],[\"初始化\",{\"1\":{\"50\":1,\"90\":1,\"95\":1,\"98\":1,\"99\":1,\"105\":1,\"106\":1,\"110\":1,\"111\":1,\"124\":1,\"218\":2,\"219\":1}}],[\"初始化k个桶\",{\"1\":{\"50\":1}}],[\"初始化左子数组和右子数组的起始索引\",{\"1\":{\"46\":1}}],[\"初始化左闭右开区间\",{\"1\":{\"21\":1}}],[\"初始化双闭区间\",{\"1\":{\"20\":1,\"23\":1,\"24\":1}}],[\"布尔值用于表示真\",{\"1\":{\"333\":1}}],[\"布尔列表来记录元素是否已被选择\",{\"1\":{\"85\":1}}],[\"布尔类型\",{\"0\":{\"333\":1},\"1\":{\"16\":1}}],[\"解析\",{\"1\":{\"361\":1}}],[\"解引用\",{\"1\":{\"313\":1}}],[\"解引用三次\",{\"1\":{\"265\":1}}],[\"解引用两次\",{\"1\":{\"265\":1}}],[\"解引用一次\",{\"1\":{\"265\":1}}],[\"解引用多级指针时\",{\"1\":{\"265\":1}}],[\"解记为dp\",{\"1\":{\"102\":1}}],[\"解决线程安全问题\",{\"1\":{\"379\":1}}],[\"解决办法\",{\"1\":{\"379\":1}}],[\"解决菱形继承数据冗余和二义性问题\",{\"1\":{\"373\":1}}],[\"解决方案\",{\"1\":{\"361\":1}}],[\"解决shared\",{\"1\":{\"351\":1}}],[\"解决具体需求而自己定义的函数\",{\"1\":{\"285\":1}}],[\"解决\",{\"1\":{\"101\":1}}],[\"解决子问题\",{\"1\":{\"60\":1}}],[\"解为\",{\"1\":{\"85\":1}}],[\"整型转为浮点型\",{\"1\":{\"337\":1}}],[\"整型与浮点型运算\",{\"1\":{\"337\":1}}],[\"整型提升\",{\"1\":{\"337\":1}}],[\"整型分为有符号signed和无符号unsigned两种\",{\"1\":{\"330\":1}}],[\"整形类型\",{\"0\":{\"330\":1}}],[\"整个表达式的值是表达式2\",{\"1\":{\"281\":1}}],[\"整个表达式的值是表达式1\",{\"1\":{\"281\":1}}],[\"整个搜索过程中只有一个\",{\"1\":{\"83\":1}}],[\"整数自动转换为浮点数\",{\"1\":{\"337\":1}}],[\"整数与浮点数进行运算\",{\"1\":{\"337\":1}}],[\"整数值\",{\"1\":{\"313\":2}}],[\"整数之间做除法时\",{\"1\":{\"276\":1}}],[\"整数类型\",{\"1\":{\"16\":1}}],[\"重写基类的析构函数\",{\"1\":{\"376\":1}}],[\"重写了clone\",{\"1\":{\"376\":1}}],[\"重新编译后运行服务器\",{\"1\":{\"441\":1}}],[\"重新锁定互斥锁\",{\"1\":{\"379\":1}}],[\"重新解释转换\",{\"1\":{\"357\":1}}],[\"重新选择剪枝\",{\"1\":{\"81\":1}}],[\"重载函数\",{\"1\":{\"348\":1}}],[\"重量为w\",{\"1\":{\"118\":1}}],[\"重量\",{\"1\":{\"117\":1,\"120\":1}}],[\"重叠子问题的数量将会大幅增多\",{\"1\":{\"108\":1}}],[\"重复节点不插入\",{\"1\":{\"206\":1}}],[\"重复执行某个任务是很常见的\",{\"1\":{\"136\":1}}],[\"重复子集是在以不同顺序选择数组元素时产生的\",{\"1\":{\"85\":1}}],[\"重复子集剪枝\",{\"1\":{\"85\":1}}],[\"重复选择剪枝\",{\"1\":{\"83\":1}}],[\"阶的方案总数\",{\"1\":{\"94\":1}}],[\"阶开始爬\",{\"1\":{\"92\":1}}],[\"阶或\",{\"1\":{\"92\":1}}],[\"阶\",{\"1\":{\"92\":2}}],[\"阶时\",{\"1\":{\"92\":1}}],[\"阶乘\",{\"1\":{\"82\":1}}],[\"阶段\",{\"1\":{\"45\":1}}],[\"种排列\",{\"1\":{\"82\":1}}],[\"同类型\",{\"1\":{\"357\":2}}],[\"同类型指针相减\",{\"1\":{\"262\":1}}],[\"同名命名空间会合并\",{\"1\":{\"348\":1}}],[\"同结构体一样\",{\"1\":{\"303\":1}}],[\"同while循环一样\",{\"1\":{\"298\":1}}],[\"同全局变量的初始化规则一致\",{\"1\":{\"289\":1}}],[\"同假为假\",{\"1\":{\"280\":1}}],[\"同真为真\",{\"1\":{\"280\":1}}],[\"同printf一样\",{\"1\":{\"252\":1}}],[\"同时声明和定义类的方法\",{\"1\":{\"361\":1}}],[\"同时声明多个整型变量并赋值\",{\"1\":{\"250\":1,\"251\":1}}],[\"同时会使用实参\",{\"1\":{\"319\":1}}],[\"同时使用typedef命令\",{\"1\":{\"304\":1}}],[\"同时也可以被称为局部变量\",{\"1\":{\"288\":1}}],[\"同时进行初始化\",{\"1\":{\"244\":1}}],[\"同时规定空节点的平衡因子为0\",{\"1\":{\"199\":1}}],[\"同时满足这两类二叉树的所有性质\",{\"1\":{\"198\":1}}],[\"同时实现在两端添加和删除节点的功能\",{\"1\":{\"163\":1}}],[\"同一权限级\",{\"1\":{\"348\":1}}],[\"同一作用域下\",{\"1\":{\"348\":1}}],[\"同一个数组中的元素必须是相同的数据类型下标\",{\"1\":{\"243\":1}}],[\"同一个问题可能存在多种解法\",{\"1\":{\"135\":1}}],[\"同一条对角线上\",{\"1\":{\"87\":1}}],[\"同一列\",{\"1\":{\"87\":1}}],[\"同一时刻最多共有n个duplicated\",{\"1\":{\"82\":1}}],[\"同一种语言存在多种字符集标准\",{\"1\":{\"18\":1}}],[\"同理可得右子树\",{\"1\":{\"180\":1}}],[\"同理\",{\"1\":{\"82\":1,\"86\":1,\"89\":1,\"142\":1,\"202\":1}}],[\"想清楚以上信息之后\",{\"1\":{\"81\":1}}],[\"减\",{\"1\":{\"262\":1,\"276\":1}}],[\"减少拷贝\",{\"1\":{\"348\":1}}],[\"减少\",{\"1\":{\"161\":1}}],[\"减少因为编码标准不同而产生的乱码问题自\",{\"1\":{\"18\":1}}],[\"减分项\",{\"1\":{\"101\":1}}],[\"减小至o\",{\"1\":{\"81\":1}}],[\"跳转到指定的标签\",{\"1\":{\"299\":1}}],[\"跳转控制语句\",{\"0\":{\"299\":1},\"1\":{\"295\":1}}],[\"跳过无效的位置\",{\"1\":{\"390\":1,\"438\":1,\"440\":1}}],[\"跳过已被访问的顶点\",{\"1\":{\"223\":1,\"225\":1}}],[\"跳过所有已被选择的节点\",{\"1\":{\"81\":1}}],[\"跳出循环\",{\"1\":{\"193\":1,\"195\":1}}],[\"跳出循环并返回该节点\",{\"1\":{\"193\":1}}],[\"跳出\",{\"1\":{\"48\":1,\"212\":1}}],[\"候选集合\",{\"1\":{\"81\":1}}],[\"旅行商是一个著名的\",{\"1\":{\"79\":1}}],[\"旅行商问题\",{\"1\":{\"79\":1}}],[\"访问\",{\"1\":{\"379\":1}}],[\"访问派生类中的同名成员\",{\"1\":{\"373\":1}}],[\"访问基类中的同名成员\",{\"1\":{\"373\":1}}],[\"访问基类成员\",{\"1\":{\"373\":1}}],[\"访问基类的成员\",{\"1\":{\"373\":1}}],[\"访问的内存空间不在数组有效范围内\",{\"1\":{\"267\":1}}],[\"访问二维数组的元素\",{\"1\":{\"246\":1}}],[\"访问数组元素\",{\"1\":{\"244\":1}}],[\"访问当前顶点的某个邻接顶点\",{\"1\":{\"224\":1}}],[\"访问堆顶元素\",{\"0\":{\"210\":1},\"1\":{\"210\":1}}],[\"访问与遍历速度较快\",{\"1\":{\"191\":1}}],[\"访问优先级\",{\"1\":{\"187\":3}}],[\"访问异常\",{\"1\":{\"164\":2}}],[\"访问队尾元素\",{\"1\":{\"163\":1,\"164\":1}}],[\"访问队首元素\",{\"1\":{\"160\":1,\"161\":1,\"163\":1,\"164\":1}}],[\"访问栈顶元素\",{\"1\":{\"156\":1,\"157\":1}}],[\"访问链表中索引为\",{\"1\":{\"150\":1}}],[\"访问链表的第i个节点需要循环i\",{\"1\":{\"150\":1}}],[\"访问结点\",{\"0\":{\"150\":1}}],[\"访问元素\",{\"0\":{\"140\":1}}],[\"访问所有其他点恰好一次后返回起点\",{\"1\":{\"79\":1}}],[\"访问每个节点都代表一次\",{\"1\":{\"75\":1}}],[\"组合优化问题\",{\"1\":{\"79\":1}}],[\"组成\",{\"1\":{\"16\":1,\"213\":1}}],[\"用命名管道实现文件拷贝\",{\"0\":{\"406\":1}}],[\"用命名管道实现进程遥控\",{\"0\":{\"405\":1}}],[\"用命名管道实现派发计算任务\",{\"0\":{\"404\":1}}],[\"用命名管道实现server\",{\"0\":{\"403\":1}}],[\"用=delete修饰的函数称为删除函数\",{\"1\":{\"379\":1}}],[\"用=default修饰的函数称为显式缺省函数\",{\"1\":{\"379\":1}}],[\"用的时候查文档\",{\"1\":{\"379\":1}}],[\"用户输入\",{\"1\":{\"382\":1}}],[\"用户从键盘读取输入\",{\"1\":{\"370\":1}}],[\"用户不必自己定义\",{\"1\":{\"285\":1}}],[\"用一个int类型变量给a类型对象赋值\",{\"1\":{\"361\":1}}],[\"用n标记数\",{\"1\":{\"361\":1}}],[\"用nul表示\",{\"1\":{\"245\":1}}],[\"用8位二进制的补码表示如下\",{\"1\":{\"327\":1}}],[\"用8位二进制的反码表示如下\",{\"1\":{\"327\":1}}],[\"用8位二进制的原码表示如下\",{\"1\":{\"327\":1}}],[\"用机器数的最高位存放符号位\",{\"1\":{\"327\":1}}],[\"用integer作为int类型别名\",{\"1\":{\"304\":1}}],[\"用来自定义可以灵活变更的数据结构\",{\"1\":{\"303\":1}}],[\"用来表示一周中的一天\",{\"1\":{\"301\":1}}],[\"用来注释一块内容\",{\"1\":{\"273\":1}}],[\"用来注释一行内容\",{\"1\":{\"273\":1}}],[\"用在switch语句或者循环语句中\",{\"1\":{\"299\":1}}],[\"用以用于数据的运算\",{\"1\":{\"275\":1}}],[\"用字符指针指向一个字符串\",{\"1\":{\"263\":1}}],[\"用矩阵形式\",{\"1\":{\"246\":1}}],[\"用总字节长度除以单个元素的字节长度\",{\"1\":{\"244\":1}}],[\"用整个数组的字节长度除以单个元素的字节长度就可以得到数组的长度\",{\"1\":{\"244\":1}}],[\"用列表索引来区分不同顶点\",{\"1\":{\"219\":1}}],[\"用1或0表示两个顶点之间是否存在边\",{\"1\":{\"216\":1}}],[\"用\",{\"1\":{\"195\":2}}],[\"用取模运算得到余数b\",{\"1\":{\"128\":1}}],[\"用最少的颜色给图的每个顶点着色\",{\"1\":{\"79\":1}}],[\"用于返回异常的描述信息\",{\"1\":{\"382\":2}}],[\"用于唤醒等待队列中所有线程\",{\"1\":{\"379\":1}}],[\"用于唤醒等待队列中首个线程\",{\"1\":{\"379\":1}}],[\"用于唤醒等待的线程\",{\"1\":{\"379\":1}}],[\"用于让调用线程进行等待\",{\"1\":{\"379\":1}}],[\"用于新线程的创建\",{\"1\":{\"379\":2}}],[\"用于某些情况下高效的移动资源\",{\"1\":{\"379\":1}}],[\"用于提高容器中插入的效率\",{\"1\":{\"379\":2}}],[\"用于支持列表初始化\",{\"1\":{\"379\":2}}],[\"用于检查是否存在于基类虚函数相匹配的函数\",{\"1\":{\"376\":1}}],[\"用于输出错误信息\",{\"1\":{\"370\":1}}],[\"用于安全的向下转型\",{\"1\":{\"357\":1}}],[\"用于添加或移除变量的const性质\",{\"1\":{\"357\":1}}],[\"用于基类和派生类的转换\",{\"1\":{\"357\":2}}],[\"用于相近类型转换\",{\"1\":{\"357\":2}}],[\"用于对一个资源进行管理\",{\"1\":{\"351\":1}}],[\"用于对一组数据按照特定顺序进行排列\",{\"1\":{\"32\":1}}],[\"用于声明一个变量或函数\",{\"1\":{\"334\":1}}],[\"用于声明静态变量和函数\",{\"1\":{\"334\":1}}],[\"用于建议编译器将变量存储在寄存器中\",{\"1\":{\"334\":1}}],[\"用于直接表示数据\",{\"1\":{\"330\":1}}],[\"用于指针或引用去除const性质\",{\"1\":{\"357\":1}}],[\"用于指针或引用之间的转换\",{\"1\":{\"357\":2}}],[\"用于指导预处理器执行不同的任务\",{\"1\":{\"317\":1}}],[\"用于指定调用函数时\",{\"1\":{\"379\":1}}],[\"用于指定判断条件不成立时\",{\"1\":{\"321\":1}}],[\"用于指定从哪里读取数据\",{\"1\":{\"310\":1}}],[\"用于指定堆的当前有效长度\",{\"1\":{\"48\":1}}],[\"用于二进制写\",{\"1\":{\"310\":1}}],[\"用于二进制读\",{\"1\":{\"310\":1}}],[\"用于将错误信息输出到屏幕\",{\"1\":{\"370\":1}}],[\"用于将数据输出到屏幕\",{\"1\":{\"370\":1}}],[\"用于将字符串输出到标准输出流\",{\"1\":{\"309\":1}}],[\"用于将一个字符写入到标准输出流\",{\"1\":{\"309\":1}}],[\"用于将格式化数据写入字符串\",{\"1\":{\"291\":1}}],[\"用于从标准输入流\",{\"1\":{\"309\":2}}],[\"用于从一个字符串中按照指定的格式提取数据\",{\"1\":{\"291\":1}}],[\"用于网络发包时节约空间\",{\"1\":{\"305\":1}}],[\"用于定义一组相关的常量\",{\"1\":{\"301\":1}}],[\"用于接收调用函数时传递进来的值返回值\",{\"1\":{\"286\":1}}],[\"用于实现函数的具体功能和操作参数\",{\"1\":{\"286\":1}}],[\"用于执行特定的任务或操作函数允许我们将代码逻辑组织成独立的单元\",{\"1\":{\"285\":1}}],[\"用于判断文件读取是否结束\",{\"1\":{\"310\":1}}],[\"用于判断数组指针与指针数组\",{\"1\":{\"283\":1}}],[\"用于判断最大位数\",{\"1\":{\"56\":1}}],[\"用于通知系统\",{\"1\":{\"261\":1}}],[\"用于保存遍历序列\",{\"1\":{\"186\":1}}],[\"用于衡量哈希冲突的严重程度\",{\"1\":{\"168\":1}}],[\"用于存储读取的字符串\",{\"1\":{\"310\":2}}],[\"用于存储读取的字符\",{\"1\":{\"310\":1}}],[\"用于存储读取的输入数据\",{\"1\":{\"309\":1}}],[\"用于存储数据\",{\"1\":{\"302\":1}}],[\"用于存储时间戳时间戳是指从1970年1月1日\",{\"1\":{\"291\":1}}],[\"用于存储格式化后的字符串\",{\"1\":{\"291\":1}}],[\"用于存储队列元素的数组\",{\"1\":{\"161\":1,\"164\":1}}],[\"用于存储子问题的解\",{\"1\":{\"95\":1,\"98\":1,\"99\":1}}],[\"用于存放合并后的结果\",{\"1\":{\"46\":1}}],[\"用于记录队列长度\",{\"1\":{\"161\":1}}],[\"用于记录各个子问题的解\",{\"1\":{\"104\":1}}],[\"用于记录该轮中已经尝试过的元素\",{\"1\":{\"82\":1}}],[\"用于记录结果\",{\"1\":{\"54\":1}}],[\"用于剪枝的辅助变量等\",{\"1\":{\"78\":1}}],[\"用于查找左右边界\",{\"1\":{\"27\":1}}],[\"用于表示\",{\"1\":{\"16\":1}}],[\"用于表示各种语言的字母\",{\"1\":{\"16\":1}}],[\"用于表示小数\",{\"1\":{\"16\":1}}],[\"使其在后台运行\",{\"1\":{\"379\":1}}],[\"使其分列数组两端\",{\"1\":{\"124\":1}}],[\"使其分列容器两端\",{\"1\":{\"123\":1}}],[\"使数据更加结构化和有组织多维数组可以分为二维数组\",{\"1\":{\"246\":1}}],[\"使所有失衡节点恢复平衡\",{\"1\":{\"206\":1,\"207\":1}}],[\"使该子树重新恢复平衡\",{\"1\":{\"205\":1,\"206\":1,\"207\":1}}],[\"使失衡节点重新恢复平衡\",{\"1\":{\"200\":1,\"205\":1}}],[\"使之更加适合展示最优子结构概念\",{\"1\":{\"98\":1}}],[\"使得线程间数据的同步变得非常高效\",{\"1\":{\"379\":1}}],[\"使得shape成为抽象类\",{\"1\":{\"376\":1}}],[\"使得智能指针具有和指针一样的行为\",{\"1\":{\"351\":1}}],[\"使得它们的哈希值相同\",{\"1\":{\"176\":1}}],[\"使得它们互不攻击\",{\"1\":{\"79\":1}}],[\"使得哈希表可以在出现哈希冲突时正常工作\",{\"1\":{\"169\":1}}],[\"使得组成的容器的容量最大\",{\"1\":{\"122\":1}}],[\"使得组合中的元素和等于\",{\"1\":{\"85\":1,\"86\":1}}],[\"使得总重量不超过载重量\",{\"1\":{\"117\":1}}],[\"使得问题重新满足无后效性\",{\"1\":{\"99\":1}}],[\"使得空间复杂度从o\",{\"1\":{\"98\":1}}],[\"使得相邻顶点颜色不同\",{\"1\":{\"79\":1}}],[\"使得每行\",{\"1\":{\"79\":1}}],[\"使用管道实现文件的拷贝有什么意义\",{\"1\":{\"406\":1}}],[\"使用ll命令看到命名管道文件的大小依旧为0\",{\"1\":{\"403\":1}}],[\"使用lambda表达式\",{\"1\":{\"379\":1}}],[\"使用lambda表达式捕获外部变量\",{\"1\":{\"379\":1}}],[\"使用lambda函数\",{\"1\":{\"379\":1}}],[\"使用mkfifo创建命名管道文件\",{\"1\":{\"403\":2,\"404\":1,\"405\":1,\"406\":1}}],[\"使用raii原则\",{\"1\":{\"379\":1}}],[\"使用完美转发\",{\"1\":{\"379\":1}}],[\"使用完对象后手动调用析构函数\",{\"1\":{\"364\":1}}],[\"使用移动语义将资源从source移动到destination\",{\"1\":{\"379\":1}}],[\"使用emplace在map中就地构造元素\",{\"1\":{\"379\":1}}],[\"使用emplace在vector中就地构造元素\",{\"1\":{\"379\":1}}],[\"使用explicit\",{\"1\":{\"379\":1}}],[\"使用extern外部声明后\",{\"1\":{\"289\":1}}],[\"使用基类指针删除对象\",{\"1\":{\"376\":2}}],[\"使用基类指针指向派生类对象\",{\"1\":{\"376\":2}}],[\"使用基类指针调用虚函数\",{\"1\":{\"376\":2}}],[\"使用cbegin和cend获取const迭代器\",{\"1\":{\"379\":1}}],[\"使用clog输出日志信息\",{\"1\":{\"370\":1}}],[\"使用cerr输出错误信息\",{\"1\":{\"370\":1}}],[\"使用cout\",{\"1\":{\"370\":1}}],[\"使用函数模板\",{\"1\":{\"367\":1}}],[\"使用函数原型进行声明\",{\"1\":{\"287\":1}}],[\"使用typename\",{\"1\":{\"367\":1}}],[\"使用定位new在已分配的内存块中构造对象\",{\"1\":{\"364\":1}}],[\"使用值调用的析构函数\",{\"1\":{\"364\":3}}],[\"使用值调用的构造函数\",{\"1\":{\"364\":3}}],[\"使用全缺省构造函数\",{\"1\":{\"361\":1}}],[\"使用构造函数显示创建对象\",{\"1\":{\"357\":1}}],[\"使用weak\",{\"1\":{\"351\":1}}],[\"使用std\",{\"1\":{\"351\":4,\"379\":6}}],[\"使用sizeof\",{\"1\":{\"335\":1}}],[\"使用sizeof运算符计算出整个数组的字节长度\",{\"1\":{\"244\":1}}],[\"使用auto必须初始化\",{\"1\":{\"348\":1}}],[\"使用精确宽度类型可以确保代码在各种平台上的一致性\",{\"1\":{\"330\":1}}],[\"使用这种语法\",{\"1\":{\"321\":1}}],[\"使用绝对路径\",{\"1\":{\"320\":1}}],[\"使用相对路径\",{\"1\":{\"320\":1}}],[\"使用整型表示真假两种状态\",{\"1\":{\"318\":1}}],[\"使用宏定义数据类型\",{\"1\":{\"318\":1}}],[\"使用宏定义声明了n\",{\"1\":{\"318\":1}}],[\"使用宏定义常量\",{\"1\":{\"318\":1}}],[\"使用解引用赋值并输出\",{\"1\":{\"314\":1}}],[\"使用隐式转换即可\",{\"1\":{\"313\":1}}],[\"使用空白字符\",{\"1\":{\"310\":1}}],[\"使用空格分隔\",{\"1\":{\"252\":1}}],[\"使用fclose\",{\"1\":{\"310\":1}}],[\"使用fopen\",{\"1\":{\"310\":1}}],[\"使用别名指向数组\",{\"1\":{\"304\":1}}],[\"使用别名定义数组指针\",{\"1\":{\"304\":1}}],[\"使用的时候要小心\",{\"1\":{\"304\":1}}],[\"使用枚举类型定义枚举变量\",{\"1\":{\"301\":1}}],[\"使用if\",{\"1\":{\"297\":1}}],[\"使用void\",{\"1\":{\"286\":1}}],[\"使用口诀\",{\"1\":{\"280\":1}}],[\"使用案例\",{\"1\":{\"265\":1}}],[\"使用该函数时\",{\"1\":{\"264\":1}}],[\"使用数组指针遍历数组\",{\"1\":{\"263\":1}}],[\"使用数组实现栈时\",{\"1\":{\"157\":1}}],[\"使用下划线连接多个单词组成的标识符\",{\"1\":{\"258\":1}}],[\"使用有意义的单词\",{\"1\":{\"258\":1}}],[\"使用标识符作为常量名\",{\"1\":{\"254\":1}}],[\"使用输出语句\",{\"1\":{\"251\":3}}],[\"使用指令编写程序\",{\"1\":{\"240\":1}}],[\"使用助记符表示\",{\"1\":{\"240\":1}}],[\"使用二进制表示\",{\"1\":{\"240\":1}}],[\"使用邻接表来表示图\",{\"1\":{\"223\":1,\"225\":1}}],[\"使用邻接矩阵表示图时\",{\"1\":{\"216\":1}}],[\"使用哈希表来存储邻接表\",{\"1\":{\"219\":1}}],[\"使用n个链表来表示图\",{\"1\":{\"217\":1}}],[\"使用一个nxn大小的矩阵来表示图\",{\"1\":{\"216\":1}}],[\"使用大质数作为模数\",{\"1\":{\"177\":1}}],[\"使用列表\",{\"1\":{\"170\":1}}],[\"使用链表实现栈时\",{\"1\":{\"156\":1}}],[\"使用结果覆盖原数组\",{\"1\":{\"56\":1}}],[\"使用结果数组\",{\"1\":{\"54\":1}}],[\"使用o\",{\"1\":{\"43\":1,\"46\":2,\"69\":1,\"82\":4,\"90\":3,\"186\":1,\"187\":1,\"193\":1,\"218\":4,\"219\":5,\"223\":3,\"225\":2}}],[\"使用\",{\"1\":{\"18\":4,\"50\":1,\"69\":1,\"92\":1,\"190\":1,\"223\":1,\"225\":1,\"255\":1,\"261\":2,\"263\":1,\"287\":1,\"289\":2,\"291\":2,\"304\":2,\"310\":14,\"320\":2}}],[\"要避免=delete或=default与explicit一起使用\",{\"1\":{\"379\":1}}],[\"要用这个单例对象进行一些线程不安全的操作\",{\"1\":{\"354\":1}}],[\"要用const+引用\",{\"1\":{\"348\":1}}],[\"要用它们去替换形参\",{\"1\":{\"319\":1}}],[\"要对自己的行为负责\",{\"1\":{\"297\":2}}],[\"要删除索引i处的元素\",{\"1\":{\"142\":1}}],[\"要求在背包容量限制内\",{\"1\":{\"79\":1}}],[\"要求将所有圆盘从一根柱子移动到另一根柱子\",{\"1\":{\"79\":1}}],[\"要将其放到当前桶的后面\",{\"1\":{\"50\":1}}],[\"全特化为int和值为5\",{\"1\":{\"367\":2}}],[\"全特化\",{\"1\":{\"367\":1}}],[\"全特化和偏特化\",{\"1\":{\"367\":1}}],[\"全缺省\",{\"1\":{\"361\":1}}],[\"全缺省构造函数\",{\"1\":{\"361\":3}}],[\"全缺省参数时\",{\"1\":{\"348\":2}}],[\"全部释放成员\",{\"1\":{\"348\":1}}],[\"全部释放c空间成员\",{\"1\":{\"348\":2}}],[\"全局显式实例化为int类型的版本\",{\"1\":{\"367\":1}}],[\"全局operator\",{\"1\":{\"361\":2}}],[\"全局的operator==\",{\"1\":{\"361\":1}}],[\"全局和局部运算符重载\",{\"1\":{\"361\":1}}],[\"全局静态区域\",{\"1\":{\"288\":1}}],[\"全局函数\",{\"1\":{\"288\":1}}],[\"全局数组\",{\"1\":{\"288\":1,\"289\":1}}],[\"全局数组等存储在全局静态区\",{\"1\":{\"288\":1}}],[\"全局数组等\",{\"1\":{\"288\":1}}],[\"全局变量\",{\"1\":{\"288\":3}}],[\"全局常量等\",{\"1\":{\"289\":1}}],[\"全局常量\",{\"1\":{\"288\":2}}],[\"全局作用域\",{\"1\":{\"288\":1}}],[\"全称是argument\",{\"1\":{\"287\":2}}],[\"全称分而治之\",{\"1\":{\"58\":1}}],[\"全排列\",{\"1\":{\"81\":2,\"82\":2}}],[\"全排列问题是回溯算法的一个典型应用\",{\"1\":{\"80\":1}}],[\"全排列问题\",{\"0\":{\"80\":1},\"1\":{\"79\":1}}],[\"约束满足问题\",{\"1\":{\"79\":1}}],[\"约束满足问题和组合优化问题\",{\"1\":{\"79\":1}}],[\"约束条件通常可用于\",{\"1\":{\"76\":1}}],[\"避免昂贵的拷贝操作\",{\"1\":{\"379\":1}}],[\"避免这样用\",{\"1\":{\"373\":1}}],[\"避免因为疏忽或错误造成程序未能释放已经不再使用的内存的情况\",{\"1\":{\"351\":1}}],[\"避免分配大量的小内存块\",{\"1\":{\"315\":1}}],[\"避免不同文件同名变量的冲突此外static关键字还可以修饰函数\",{\"1\":{\"289\":1}}],[\"避免扩容\",{\"1\":{\"157\":1}}],[\"避免重复选择同一元素\",{\"1\":{\"86\":1}}],[\"避免生成重复子集\",{\"1\":{\"85\":1,\"86\":1}}],[\"避免搜索那些肯定不会产生解的路径\",{\"1\":{\"78\":1}}],[\"避免许多无意义的尝试\",{\"1\":{\"76\":1}}],[\"具有如下特点\",{\"1\":{\"301\":1}}],[\"具有一些指针的特性\",{\"1\":{\"263\":1}}],[\"具有以下特性\",{\"1\":{\"208\":1}}],[\"具有以下设计目标\",{\"1\":{\"132\":1}}],[\"具有很好的缓存本地性\",{\"1\":{\"158\":1}}],[\"具有很高的效率\",{\"1\":{\"78\":1}}],[\"具有可行性\",{\"1\":{\"131\":1}}],[\"具体查文档\",{\"1\":{\"382\":1}}],[\"具体用的时候查\",{\"1\":{\"379\":1}}],[\"具体执行顺序可能受到多个因素的影响\",{\"1\":{\"379\":1}}],[\"具体是哪个类型的别名\",{\"1\":{\"335\":1}}],[\"具体取决于编译器\",{\"1\":{\"310\":2}}],[\"具体的函数实现可以后面再补上\",{\"1\":{\"287\":1}}],[\"具体关键字\",{\"1\":{\"259\":1}}],[\"具体而言\",{\"1\":{\"166\":1}}],[\"具体表现在以下三个方面\",{\"1\":{\"133\":1}}],[\"具体划分方式可根据数据特点灵活选择\",{\"1\":{\"51\":1}}],[\"具体来说\",{\"1\":{\"40\":1,\"42\":1,\"92\":1,\"172\":1}}],[\"具体方法为\",{\"1\":{\"27\":1}}],[\"优先使用本作用域中定义的数据\",{\"1\":{\"288\":1}}],[\"优化的编译器\",{\"1\":{\"361\":1}}],[\"优化至o\",{\"1\":{\"217\":1}}],[\"优化后\",{\"1\":{\"37\":1}}],[\"优点\",{\"1\":{\"138\":1}}],[\"优点与缺点\",{\"0\":{\"78\":1,\"191\":1}}],[\"检查通讯录容量\",{\"1\":{\"344\":1}}],[\"检查字符是否为空格字符\",{\"1\":{\"293\":1}}],[\"检查字符是否为数字\",{\"1\":{\"293\":1}}],[\"检查字符是否为字母\",{\"1\":{\"293\":1}}],[\"检查字符是否为大写字母\",{\"1\":{\"293\":1}}],[\"检查字符是否为小写字母\",{\"1\":{\"293\":1}}],[\"检查顶点是否已被访问\",{\"1\":{\"223\":1,\"225\":1}}],[\"检查选择是否合法\",{\"1\":{\"77\":1}}],[\"检查是否为解\",{\"1\":{\"77\":1}}],[\"恢复状态\",{\"1\":{\"77\":1}}],[\"恢复到之前的状态\",{\"1\":{\"77\":2,\"81\":1,\"82\":1,\"85\":2,\"86\":1}}],[\"该现象说明服务端是能够通过命名管道获取到客户端发来的信息的\",{\"1\":{\"403\":1}}],[\"该位置没有被使用\",{\"1\":{\"389\":1,\"390\":1,\"440\":1}}],[\"该实例被所有程序模块共享\",{\"1\":{\"354\":1}}],[\"该模式保证系统中该类只有一个实例\",{\"1\":{\"354\":1}}],[\"该接口在栈上创建一个对象返回\",{\"1\":{\"354\":1}}],[\"该语句编译错误\",{\"1\":{\"348\":3}}],[\"该字符串中可以使用形参\",{\"1\":{\"319\":1}}],[\"该字符既不能显示\",{\"1\":{\"245\":1}}],[\"该函数无参\",{\"1\":{\"361\":1}}],[\"该函数是如何知道应该设置s1对象\",{\"1\":{\"361\":1}}],[\"该函数可以获取指定内存块的大小\",{\"1\":{\"314\":1}}],[\"该函数位于标准库的stdio\",{\"1\":{\"310\":2}}],[\"该函数位于标准库的\",{\"1\":{\"310\":2}}],[\"该结构表示文件流\",{\"1\":{\"310\":1}}],[\"该变量称为枚举变量\",{\"1\":{\"301\":1}}],[\"该变量的值只能从七个有效值中选择\",{\"1\":{\"301\":1}}],[\"该头文件中\",{\"1\":{\"291\":2}}],[\"该代码块中具有块级作用域\",{\"1\":{\"288\":1}}],[\"该符号称为取地址符\",{\"1\":{\"252\":1}}],[\"该区域的数据可以在同一类型范围内不断变化\",{\"1\":{\"249\":1}}],[\"该子节点\",{\"1\":{\"195\":1}}],[\"该节点被称为这两个子节点的父节点\",{\"1\":{\"180\":1}}],[\"该容量可能超出实际需求\",{\"1\":{\"158\":1}}],[\"该数组存储的仍然是第i\",{\"1\":{\"111\":1}}],[\"该问题的目标是求解\",{\"1\":{\"107\":1}}],[\"该剪枝操作将搜索空间大小从o\",{\"1\":{\"81\":1}}],[\"该选择是否合法\",{\"1\":{\"77\":1}}],[\"该算法首先将点集分成两部分\",{\"1\":{\"63\":1}}],[\"许多回溯问题可以在该框架下解决\",{\"1\":{\"77\":1}}],[\"许多工具和库优先支持utf\",{\"1\":{\"18\":1}}],[\"语言的整数类型\",{\"1\":{\"330\":1}}],[\"语言把所有的设备都当作文件\",{\"1\":{\"309\":1}}],[\"语法如下\",{\"1\":{\"301\":1}}],[\"语法规则\",{\"1\":{\"263\":2}}],[\"语句\",{\"1\":{\"299\":2,\"318\":1}}],[\"语句的执行流程\",{\"1\":{\"299\":1}}],[\"语句的搜索过程\",{\"1\":{\"77\":1}}],[\"语句块\",{\"1\":{\"297\":1}}],[\"语句块n\",{\"1\":{\"297\":2}}],[\"语句块2\",{\"1\":{\"297\":1}}],[\"语句块1\",{\"1\":{\"297\":1}}],[\"语句删除\",{\"1\":{\"77\":1}}],[\"语音\",{\"1\":{\"16\":1}}],[\"状态包含当前物品i和容量c\",{\"1\":{\"118\":1}}],[\"状态应包含行索引和列索引两个变量\",{\"1\":{\"102\":1}}],[\"状态转移可以正确进行\",{\"1\":{\"111\":1}}],[\"状态转移\",{\"1\":{\"95\":1,\"98\":1,\"99\":1,\"105\":3,\"106\":4,\"110\":1,\"111\":1}}],[\"状态\",{\"1\":{\"77\":1,\"81\":1,\"95\":1,\"102\":1,\"108\":1}}],[\"框架代码\",{\"0\":{\"77\":1}}],[\"剪掉\",{\"1\":{\"76\":1}}],[\"剪枝四\",{\"1\":{\"86\":1}}],[\"剪枝三\",{\"1\":{\"86\":1}}],[\"剪枝一\",{\"1\":{\"85\":1,\"86\":1}}],[\"剪枝二\",{\"1\":{\"85\":1,\"86\":1}}],[\"剪枝\",{\"0\":{\"76\":1},\"1\":{\"76\":3,\"77\":3,\"78\":1,\"81\":1,\"82\":3,\"85\":1,\"90\":1,\"92\":1,\"108\":1}}],[\"撤销选择\",{\"1\":{\"77\":2,\"81\":1,\"82\":1,\"85\":2,\"86\":1}}],[\"撤销\",{\"1\":{\"75\":1}}],[\"尝试锁定互斥量\",{\"1\":{\"379\":1}}],[\"尝试\",{\"1\":{\"75\":4,\"76\":1,\"77\":3,\"81\":1,\"82\":1,\"85\":2,\"86\":1,\"90\":1,\"92\":1}}],[\"尝试与回退\",{\"0\":{\"75\":1}}],[\"例题\",{\"1\":{\"361\":1}}],[\"例题三\",{\"1\":{\"76\":1,\"77\":1}}],[\"例题二\",{\"1\":{\"75\":1}}],[\"例题一\",{\"1\":{\"74\":1}}],[\"例如内存不足\",{\"1\":{\"314\":2}}],[\"例如文件\",{\"1\":{\"308\":2}}],[\"例如在\",{\"1\":{\"214\":1}}],[\"例如在下图中\",{\"1\":{\"123\":1}}],[\"例如微博或抖音上的\",{\"1\":{\"214\":1}}],[\"例如微信或\",{\"1\":{\"214\":1}}],[\"例如当负载因子超过0\",{\"1\":{\"168\":1}}],[\"例如dp\",{\"1\":{\"108\":1}}],[\"例如以下情况\",{\"1\":{\"85\":1}}],[\"例如路径\",{\"1\":{\"78\":1}}],[\"例如上图的树对应\",{\"1\":{\"67\":2}}],[\"例如二分查找和树\",{\"1\":{\"64\":1}}],[\"例如二叉搜索树\",{\"1\":{\"63\":1}}],[\"例如中文\",{\"1\":{\"18\":1}}],[\"例如给定一个长度为\",{\"1\":{\"18\":1}}],[\"例如\",{\"1\":{\"15\":1,\"51\":1,\"63\":3,\"85\":1,\"86\":1,\"95\":1,\"107\":1,\"158\":1,\"168\":1,\"176\":1,\"178\":2,\"240\":2,\"304\":1,\"379\":3}}],[\"章节讲过\",{\"1\":{\"209\":1}}],[\"章节中\",{\"1\":{\"74\":1}}],[\"章节相同的从顶至底堆化\",{\"1\":{\"48\":1}}],[\"剩余一个圆盘移到\",{\"1\":{\"73\":1}}],[\"只写\",{\"1\":{\"370\":1}}],[\"只读\",{\"1\":{\"370\":1}}],[\"只是用于区分\",{\"1\":{\"361\":1}}],[\"只是被继承后无法实例化出对象\",{\"1\":{\"354\":1}}],[\"只是简单地文本替换\",{\"1\":{\"255\":1}}],[\"只要名字相同就构成覆盖\",{\"1\":{\"373\":1}}],[\"只要\",{\"1\":{\"321\":1}}],[\"只要使用完堆上的内存块\",{\"1\":{\"315\":1}}],[\"只要有一个操作数为真\",{\"1\":{\"278\":1}}],[\"只用于字符串\",{\"1\":{\"292\":1}}],[\"只用前面一部分\",{\"1\":{\"142\":1}}],[\"只关注空间大小\",{\"1\":{\"292\":1}}],[\"只关心输入输出\",{\"1\":{\"285\":1}}],[\"只有基类指针指向派生类的对象才是安全的\",{\"1\":{\"373\":1}}],[\"只有类需要管理空间才自己写析构函数\",{\"1\":{\"361\":1}}],[\"只有在该代码块内部才能被访问\",{\"1\":{\"288\":1}}],[\"只有在该函数内部才能被访问\",{\"1\":{\"288\":1}}],[\"只有最底层的节点未被填满\",{\"1\":{\"183\":1}}],[\"只能创建一个对象\",{\"1\":{\"354\":2}}],[\"只能在定义的时候初始化\",{\"1\":{\"361\":1}}],[\"只能在栈上创建对象\",{\"1\":{\"354\":2}}],[\"只能在堆上创建对象\",{\"1\":{\"354\":2}}],[\"只能在编译已被宏展开后的源程序时发现\",{\"1\":{\"318\":1}}],[\"只能通过指针来引用\",{\"1\":{\"312\":1}}],[\"只能由大小写组成\",{\"1\":{\"257\":1}}],[\"只能表示一行的状态\",{\"1\":{\"106\":1}}],[\"只入队未访问的顶点\",{\"1\":{\"223\":1}}],[\"只出现在最底层且靠右的位置\",{\"1\":{\"190\":1}}],[\"只与dp\",{\"1\":{\"96\":1}}],[\"只剩下一个圆盘\",{\"1\":{\"73\":1}}],[\"只需让服务端从管道当中读取命令后创建子进程\",{\"1\":{\"405\":1}}],[\"只需改变服务端处理通信信息的逻辑即可\",{\"1\":{\"404\":1,\"405\":1}}],[\"只需改变一个节点的引用\",{\"1\":{\"149\":1}}],[\"只需要调整对应的函数代码隔离细节\",{\"1\":{\"285\":1}}],[\"只需将\",{\"1\":{\"161\":1}}],[\"只需将头节点从链表中删除即可\",{\"1\":{\"156\":1}}],[\"只需一次移动操作即可\",{\"1\":{\"72\":1}}],[\"只需遍历\",{\"1\":{\"53\":1}}],[\"按位右移\",{\"1\":{\"280\":2}}],[\"按位左移\",{\"1\":{\"280\":2}}],[\"按位非\",{\"1\":{\"280\":1}}],[\"按位取反\",{\"1\":{\"280\":1}}],[\"按位异或\",{\"1\":{\"280\":1}}],[\"按位或\",{\"1\":{\"280\":1}}],[\"按位与\",{\"1\":{\"280\":1}}],[\"按功能分类\",{\"1\":{\"275\":1}}],[\"按操作数个数分类\",{\"1\":{\"275\":1}}],[\"按顺序解决这三个子问题之后\",{\"1\":{\"72\":1}}],[\"按照用户需求排序联系人\",{\"1\":{\"342\":1}}],[\"按照用户需求查看指定联系人信息\",{\"1\":{\"342\":1}}],[\"按照用户需求重新修改指定联系人\",{\"1\":{\"342\":1}}],[\"按照用户需求进行删除指定联系人\",{\"1\":{\"342\":1}}],[\"按照一般数组的方式访问和遍历即可\",{\"1\":{\"245\":1}}],[\"按照单位价值\",{\"1\":{\"120\":1}}],[\"按照从低位到高位的顺序遍历\",{\"1\":{\"56\":1}}],[\"按照桶从小到大的顺序合并结果\",{\"1\":{\"50\":1}}],[\"令\",{\"1\":{\"72\":1}}],[\"令前缀和自减\",{\"1\":{\"54\":1}}],[\"了不满足约束条件的搜索分支\",{\"1\":{\"76\":1}}],[\"了\",{\"1\":{\"72\":1,\"81\":1,\"142\":1}}],[\"执行除法运算\",{\"1\":{\"382\":1}}],[\"执行defaultbreak语句可以使程序跳出switch语句块\",{\"1\":{\"297\":1}}],[\"执行代码块n\",{\"1\":{\"297\":1}}],[\"执行代码块2\",{\"1\":{\"297\":2}}],[\"执行代码块1\",{\"1\":{\"297\":3}}],[\"执行代码块\",{\"1\":{\"297\":1}}],[\"执行该\",{\"1\":{\"271\":1}}],[\"执行时机\",{\"1\":{\"255\":1}}],[\"执行旋转操作\",{\"1\":{\"205\":1,\"206\":1,\"207\":1}}],[\"执行\",{\"1\":{\"201\":1,\"203\":2,\"204\":2,\"291\":2}}],[\"执行对应的删除节点操作\",{\"1\":{\"195\":1}}],[\"执行扩容\",{\"1\":{\"170\":1,\"172\":1}}],[\"执行下图所示的步骤\",{\"1\":{\"72\":1}}],[\"执行一个递归函数\",{\"1\":{\"69\":1}}],[\"移到\",{\"1\":{\"73\":3}}],[\"移动构造函数\",{\"1\":{\"379\":1}}],[\"移动语义用途\",{\"1\":{\"379\":1}}],[\"移动语义\",{\"1\":{\"379\":1}}],[\"移动指针到下一个位置\",{\"1\":{\"364\":1}}],[\"移动内存数据\",{\"1\":{\"294\":1}}],[\"移动短板后面积变大\",{\"1\":{\"123\":1}}],[\"移动后的短板i可能会变长\",{\"1\":{\"123\":1}}],[\"移动后的j成为短板\",{\"1\":{\"123\":1}}],[\"移动一个圆盘\",{\"1\":{\"73\":1}}],[\"移动至目标柱\",{\"1\":{\"73\":1}}],[\"移动至\",{\"1\":{\"71\":1}}],[\"移至\",{\"1\":{\"71\":3,\"72\":5}}],[\"上面示例中\",{\"1\":{\"321\":3}}],[\"上面案例中\",{\"1\":{\"263\":1}}],[\"上一节介绍了链表表示下的二叉树的各项基本操作\",{\"1\":{\"188\":1}}],[\"上一个节点\",{\"1\":{\"153\":1}}],[\"上图展示了开放寻址\",{\"1\":{\"172\":1}}],[\"上图展示了一个计算机内存条\",{\"1\":{\"15\":1}}],[\"上述数组表示方法已经失效\",{\"1\":{\"190\":1}}],[\"上述\",{\"1\":{\"146\":1}}],[\"上述方法生成的排列有一半是重复的\",{\"1\":{\"82\":1}}],[\"上\",{\"1\":{\"70\":1}}],[\"上套着n个圆盘\",{\"1\":{\"70\":1}}],[\"柱子\",{\"1\":{\"70\":1}}],[\"查看当前epoll服务器的文件描述符的使用情况\",{\"1\":{\"398\":1}}],[\"查询联系人的下标\",{\"1\":{\"344\":1}}],[\"查询联系人\",{\"1\":{\"342\":1,\"344\":2}}],[\"查询效率o\",{\"1\":{\"170\":1}}],[\"查询效率降低\",{\"1\":{\"170\":1}}],[\"查询操作\",{\"1\":{\"170\":1,\"172\":1}}],[\"查询操作就是找到\",{\"1\":{\"167\":1}}],[\"查询元素\",{\"1\":{\"170\":1}}],[\"查询学号为\",{\"1\":{\"168\":1}}],[\"查询\",{\"1\":{\"69\":1}}],[\"查找\",{\"0\":{\"467\":1,\"468\":1}}],[\"查找指定联系人\",{\"1\":{\"344\":1}}],[\"查找联系人\",{\"1\":{\"344\":1}}],[\"查找字符串\",{\"1\":{\"292\":1}}],[\"查找顶点对应的节点\",{\"1\":{\"219\":2}}],[\"查找插入位置并插入节点\",{\"1\":{\"206\":1}}],[\"查找插入位置\",{\"1\":{\"194\":1}}],[\"查找节点并删除\",{\"1\":{\"207\":1}}],[\"查找节点\",{\"1\":{\"193\":1}}],[\"查找其中值为\",{\"1\":{\"151\":1}}],[\"查找结点\",{\"0\":{\"151\":1,\"193\":1}}],[\"查找元素\",{\"0\":{\"144\":1},\"1\":{\"172\":1,\"174\":1}}],[\"查找根节点\",{\"1\":{\"67\":1}}],[\"查找最右一个\",{\"1\":{\"27\":1}}],[\"查找最左一个\",{\"1\":{\"27\":1}}],[\"查找完成后\",{\"1\":{\"27\":1}}],[\"查找右边界\",{\"0\":{\"27\":1}}],[\"查找左边界\",{\"0\":{\"26\":1}}],[\"osi参考模型\",{\"0\":{\"511\":1}}],[\"ostream\",{\"1\":{\"361\":4}}],[\"o管理\",{\"0\":{\"508\":1}}],[\"occurred\",{\"1\":{\"382\":5}}],[\"oct\",{\"1\":{\"291\":1}}],[\"override\",{\"1\":{\"376\":6,\"382\":2}}],[\"other\",{\"1\":{\"361\":3}}],[\"obj3\",{\"1\":{\"357\":1}}],[\"obj2\",{\"1\":{\"357\":1}}],[\"obj1\",{\"1\":{\"357\":1}}],[\"obj\",{\"1\":{\"354\":1,\"379\":3}}],[\"object\",{\"1\":{\"302\":1,\"351\":1}}],[\"one\",{\"1\":{\"379\":8}}],[\"onlystackclass2\",{\"1\":{\"354\":2}}],[\"onlystackclass\",{\"1\":{\"354\":5}}],[\"once\",{\"1\":{\"344\":1,\"361\":1,\"388\":1,\"389\":1,\"390\":1,\"403\":1,\"406\":1,\"436\":1,\"437\":1,\"438\":1,\"440\":1}}],[\"opt\",{\"1\":{\"436\":3}}],[\"option\",{\"1\":{\"344\":1}}],[\"operation\",{\"1\":{\"370\":2}}],[\"operator>>\",{\"1\":{\"361\":2}}],[\"operator>=\",{\"1\":{\"361\":1}}],[\"operator>\",{\"1\":{\"361\":1}}],[\"operator<<\",{\"1\":{\"361\":2}}],[\"operator<=\",{\"1\":{\"361\":1}}],[\"operator<\",{\"1\":{\"361\":2}}],[\"operator++\",{\"1\":{\"361\":2}}],[\"operator+=\",{\"1\":{\"361\":3}}],[\"operator+\",{\"1\":{\"361\":4}}],[\"operator=或std\",{\"1\":{\"379\":1}}],[\"operator==\",{\"1\":{\"361\":10}}],[\"operator=\",{\"1\":{\"354\":6,\"361\":2}}],[\"operator\",{\"1\":{\"354\":4,\"361\":13,\"379\":1}}],[\"opening\",{\"1\":{\"310\":5}}],[\"open\",{\"1\":{\"171\":1,\"370\":4,\"403\":6,\"404\":2,\"405\":2,\"406\":8}}],[\"oill\",{\"1\":{\"297\":6}}],[\"oiln\",{\"1\":{\"297\":3}}],[\"ok4\",{\"1\":{\"299\":2}}],[\"ok3\",{\"1\":{\"299\":2}}],[\"ok2\",{\"1\":{\"278\":1,\"299\":1}}],[\"ok100\",{\"1\":{\"278\":3}}],[\"ok1\",{\"1\":{\"278\":2,\"299\":1}}],[\"ok\",{\"1\":{\"263\":1,\"318\":1}}],[\"ofstream\",{\"1\":{\"370\":2}}],[\"offset是相对origin的偏移量\",{\"1\":{\"310\":1}}],[\"offset\",{\"1\":{\"310\":1}}],[\"of\",{\"1\":{\"257\":1,\"265\":4,\"292\":3,\"293\":2,\"309\":1,\"344\":1,\"345\":1,\"367\":4,\"376\":1,\"406\":1}}],[\"outfile2\",{\"1\":{\"370\":1}}],[\"outfile\",{\"1\":{\"370\":7}}],[\"output\",{\"1\":{\"308\":1,\"310\":17}}],[\"outputstring\",{\"1\":{\"291\":3}}],[\"out\",{\"1\":{\"214\":1,\"370\":4}}],[\"origin表示开始添加偏移offset的位置\",{\"1\":{\"310\":1}}],[\"origin\",{\"1\":{\"310\":1}}],[\"or\",{\"1\":{\"195\":1}}],[\"order\",{\"1\":{\"186\":1,\"190\":6}}],[\"oldbuckets\",{\"1\":{\"170\":3}}],[\"oldcapacity\",{\"1\":{\"170\":2,\"172\":2}}],[\"o\",{\"1\":{\"69\":1,\"157\":1,\"166\":2,\"223\":1,\"225\":1,\"245\":4,\"309\":1,\"370\":1,\"379\":1,\"403\":3,\"404\":1,\"405\":1,\"406\":5}}],[\"归\",{\"1\":{\"69\":1,\"136\":1}}],[\"归并排序满足以上三个判断依据\",{\"1\":{\"59\":1}}],[\"归并排序的实现如以下代码所示\",{\"1\":{\"46\":1}}],[\"归并排序与二叉树后序遍历的递归顺序是一致的\",{\"1\":{\"46\":1}}],[\"归并排序算法流程\",{\"0\":{\"46\":1}}],[\"归并排序算法\",{\"0\":{\"45\":1}}],[\"归并排序\",{\"1\":{\"44\":1,\"45\":1,\"46\":2,\"60\":1,\"63\":1}}],[\"递\",{\"1\":{\"69\":1,\"136\":1}}],[\"递归方式\",{\"0\":{\"455\":1}}],[\"递归互斥锁\",{\"1\":{\"379\":1}}],[\"递归函数成功执行需满足以下两个条件\",{\"1\":{\"290\":1}}],[\"递归函数\",{\"0\":{\"290\":1}}],[\"递归访问邻接顶点\",{\"1\":{\"225\":1}}],[\"递归插入节点\",{\"1\":{\"206\":1}}],[\"递归删除节点\",{\"1\":{\"195\":1,\"207\":1}}],[\"递归树\",{\"1\":{\"136\":1}}],[\"递归参数\",{\"1\":{\"108\":1}}],[\"递归深度最大为|v|\",{\"1\":{\"225\":1}}],[\"递归深度达到n\",{\"1\":{\"69\":1,\"187\":1}}],[\"递归深度为logn\",{\"1\":{\"46\":1}}],[\"递归子问题\",{\"1\":{\"64\":2}}],[\"递归\",{\"1\":{\"64\":1,\"136\":2}}],[\"递归地将较大子问题分解为较小子问题\",{\"1\":{\"95\":1}}],[\"递归地将一个较大问题拆解为两个较小问题的和\",{\"1\":{\"93\":1}}],[\"递归地将数组\",{\"1\":{\"59\":1}}],[\"递归地将原问题分解为两个或多个子问题\",{\"1\":{\"58\":1}}],[\"递归右子数组\",{\"1\":{\"46\":1}}],[\"递归执行步骤\",{\"1\":{\"46\":1}}],[\"递归划分左子数组\",{\"1\":{\"46\":1}}],[\"递归左子数组\",{\"1\":{\"43\":1,\"46\":1}}],[\"建议将头文件放置在源文件所在目录或子目录中\",{\"1\":{\"320\":1}}],[\"建议把所有的常量\",{\"1\":{\"320\":1}}],[\"建议使用double型\",{\"1\":{\"331\":1}}],[\"建议使用显式类型转换\",{\"1\":{\"313\":1}}],[\"建议使用swtich语句如果判断条件是区间判断\",{\"1\":{\"297\":1}}],[\"建议一般使用两层\",{\"1\":{\"298\":1}}],[\"建议最多不要超过3层\",{\"1\":{\"297\":1}}],[\"建议开发者尽量避免使用下划线开头的标识符\",{\"1\":{\"258\":1}}],[\"建议分开声明\",{\"1\":{\"250\":1}}],[\"建议对照下图来加深理解\",{\"1\":{\"223\":1}}],[\"建议结合下图理解\",{\"1\":{\"68\":1}}],[\"建立链表分为两步\",{\"1\":{\"147\":1}}],[\"建立dp表\",{\"1\":{\"102\":1}}],[\"建堆操作使用o\",{\"1\":{\"48\":1}}],[\"建堆操作\",{\"1\":{\"47\":1,\"48\":1}}],[\"｜\",{\"1\":{\"67\":2}}],[\"|=\",{\"1\":{\"389\":1,\"390\":1}}],[\"|v|+|e|\",{\"1\":{\"223\":1,\"225\":1}}],[\"|v|\",{\"1\":{\"223\":2,\"225\":2}}],[\"|\",{\"1\":{\"67\":10,\"280\":1,\"370\":2,\"406\":1}}],[\"||\",{\"1\":{\"26\":1,\"27\":1,\"76\":1,\"93\":1,\"94\":1,\"95\":1,\"96\":1,\"98\":2,\"99\":1,\"103\":1,\"104\":1,\"108\":1,\"109\":1,\"190\":1,\"195\":1,\"207\":1,\"211\":1,\"218\":9,\"278\":2,\"361\":4}}],[\"根本原因就是因为我们没有定制协议\",{\"1\":{\"442\":1}}],[\"根本原因就是因为select函数调用后会告知select服务器是哪个客户端对应的连接事件就绪了\",{\"1\":{\"441\":1}}],[\"根\",{\"1\":{\"196\":1,\"225\":3}}],[\"根节点的值\",{\"1\":{\"192\":1}}],[\"根节点所在层为\",{\"1\":{\"181\":1}}],[\"根节点\",{\"1\":{\"67\":2,\"95\":1,\"181\":1,\"187\":3,\"194\":1,\"195\":2,\"196\":1,\"208\":1}}],[\"根据传入的参数自动实例化\",{\"1\":{\"367\":1}}],[\"根据解决拷贝问题方式的不同\",{\"1\":{\"351\":1}}],[\"根据文件指针的位置和偏移量来定位文件指针\",{\"1\":{\"310\":1}}],[\"根据格式化字符串中的格式指定要存储数据的变量\",{\"1\":{\"310\":1}}],[\"根据格式化字符串中的格式占位符对应\",{\"1\":{\"310\":1}}],[\"根据成绩进行判断\",{\"1\":{\"297\":1}}],[\"根据age的值来处理\",{\"1\":{\"297\":1}}],[\"根据所有顶点是否连通\",{\"1\":{\"214\":1}}],[\"根据边是否具有方向\",{\"1\":{\"214\":1}}],[\"根据节点失衡情况的不同\",{\"1\":{\"200\":1}}],[\"根据当前节点值和\",{\"1\":{\"194\":1}}],[\"根据层序遍历的特性\",{\"1\":{\"189\":1}}],[\"根据此哈希函数\",{\"1\":{\"172\":1}}],[\"根据哈希函数的结果访问链表头部\",{\"1\":{\"170\":1}}],[\"根据对角线约束的剪枝也能够大幅缩小搜索空间\",{\"1\":{\"90\":1}}],[\"根据国际象棋的规则\",{\"1\":{\"87\":1}}],[\"根据题意\",{\"1\":{\"77\":1}}],[\"根据以上内容\",{\"1\":{\"95\":1}}],[\"根据以上划分方法\",{\"1\":{\"68\":1}}],[\"根据以上分析\",{\"1\":{\"67\":1}}],[\"根据定义\",{\"1\":{\"67\":1}}],[\"根据桶内统计结果\",{\"1\":{\"56\":1}}],[\"根据\",{\"1\":{\"56\":1,\"67\":1}}],[\"根据各数字出现次数从小到大的顺序填入\",{\"1\":{\"53\":1}}],[\"根据字符的复杂性而变\",{\"1\":{\"18\":1}}],[\"都与基类析构函数构成重写\",{\"1\":{\"376\":1}}],[\"都不访问用private\",{\"1\":{\"373\":1}}],[\"都需要通过调用getinstance函数来获取\",{\"1\":{\"354\":1}}],[\"都打印为10进制整数\",{\"1\":{\"325\":1}}],[\"都以一系列字节的形式存在\",{\"1\":{\"310\":1}}],[\"都会大量使用这种别名\",{\"1\":{\"304\":1}}],[\"都会被映射到相同的桶\",{\"1\":{\"172\":1}}],[\"都是文件\",{\"1\":{\"308\":1}}],[\"都是深度优先遍历\",{\"1\":{\"225\":1}}],[\"都是每轮排除一半情况\",{\"1\":{\"193\":1}}],[\"都是开放寻址的常见策略之一\",{\"1\":{\"173\":1}}],[\"都可以放置键值对\",{\"1\":{\"172\":1}}],[\"都可以划分为三个部分\",{\"1\":{\"67\":1}}],[\"都代表空桶\",{\"1\":{\"172\":1}}],[\"都指向node\",{\"1\":{\"163\":1}}],[\"都在向右移动\",{\"1\":{\"161\":1}}],[\"都选择当前看起来最优的选择\",{\"1\":{\"113\":1}}],[\"都包含一个\",{\"1\":{\"83\":1}}],[\"都用于剪枝\",{\"1\":{\"83\":1}}],[\"都用\",{\"1\":{\"18\":1}}],[\"空类\",{\"1\":{\"361\":1}}],[\"空格\",{\"1\":{\"293\":1,\"310\":1}}],[\"空白符指\",{\"1\":{\"293\":1}}],[\"空指针\",{\"0\":{\"266\":1}}],[\"空节点平衡因子为\",{\"1\":{\"199\":1}}],[\"空节点高度为\",{\"1\":{\"199\":1}}],[\"空\",{\"1\":{\"146\":1}}],[\"空子树\",{\"1\":{\"66\":1}}],[\"空间利用率较低\",{\"1\":{\"191\":1}}],[\"空间浪费\",{\"1\":{\"138\":1}}],[\"空间效率高\",{\"1\":{\"138\":1}}],[\"空间效率\",{\"1\":{\"135\":1,\"158\":1}}],[\"空间占用尽量少\",{\"1\":{\"132\":1}}],[\"空间优化后的动态规划\",{\"1\":{\"96\":1,\"98\":1,\"106\":1,\"111\":1}}],[\"空间优化\",{\"0\":{\"96\":1,\"106\":1,\"111\":1}}],[\"空间需求可能会变得很大\",{\"1\":{\"78\":1}}],[\"空间\",{\"1\":{\"48\":1,\"78\":1,\"82\":2,\"90\":2,\"186\":1,\"223\":1,\"225\":1}}],[\"空间复杂度为o\",{\"1\":{\"29\":1,\"37\":1,\"41\":1,\"46\":1,\"56\":1,\"69\":1,\"73\":1,\"90\":1}}],[\"请重新选择功能\",{\"1\":{\"345\":1}}],[\"请选选择功能\",{\"1\":{\"345\":1}}],[\"请输入修改后的地址\",{\"1\":{\"344\":1}}],[\"请输入修改后的电话\",{\"1\":{\"344\":1}}],[\"请输入修改后的性别\",{\"1\":{\"344\":1}}],[\"请输入修改后的年龄\",{\"1\":{\"344\":1}}],[\"请输入要查找的联系人名字\",{\"1\":{\"344\":1}}],[\"请输入要修改的联系人名字\",{\"1\":{\"344\":1}}],[\"请输入要删除的联系人名字\",{\"1\":{\"344\":1}}],[\"请输入地址\",{\"1\":{\"344\":1}}],[\"请输入电话\",{\"1\":{\"344\":1}}],[\"请输入性别\",{\"1\":{\"344\":1}}],[\"请输入名字\",{\"1\":{\"344\":1}}],[\"请输入半径\",{\"1\":{\"318\":1}}],[\"请输入5个成绩\",{\"1\":{\"314\":1}}],[\"请输入列数\",{\"1\":{\"298\":1}}],[\"请输入行数\",{\"1\":{\"298\":1}}],[\"请输入油量\",{\"1\":{\"297\":1}}],[\"请输入油号\",{\"1\":{\"297\":1}}],[\"请输入一个字符\",{\"1\":{\"297\":1}}],[\"请输入你的成绩\",{\"1\":{\"297\":1}}],[\"请输入年龄\",{\"1\":{\"297\":2,\"344\":1}}],[\"请在数组中选择两个隔板\",{\"1\":{\"122\":1}}],[\"请计算最少需要付出多少代价才能到达顶部\",{\"1\":{\"98\":1}}],[\"请问有多少种方案可以爬到楼顶\",{\"1\":{\"92\":1,\"99\":1}}],[\"请你将图示与代码注释相结合\",{\"1\":{\"86\":1}}],[\"请以列表形式返回这些组合\",{\"1\":{\"85\":1,\"86\":1}}],[\"请找出所有可能的组合\",{\"1\":{\"85\":1,\"86\":1}}],[\"请返回从左上角到右下角的最小路径和\",{\"1\":{\"102\":1}}],[\"请返回根节点到这些节点的路径\",{\"1\":{\"75\":1,\"76\":1}}],[\"请返回节点列表\",{\"1\":{\"74\":1}}],[\"请从中构建二叉树\",{\"1\":{\"65\":1}}],[\"请注意\",{\"1\":{\"20\":1,\"26\":1,\"27\":1,\"46\":1,\"68\":1,\"79\":1,\"81\":1,\"83\":1,\"90\":1,\"103\":1,\"106\":1,\"128\":1,\"142\":1,\"149\":1,\"176\":1}}],[\"迭代一般分为\",{\"1\":{\"136\":1}}],[\"迭代与递归\",{\"0\":{\"136\":1}}],[\"迭代地构建更大子问题的解\",{\"1\":{\"95\":1}}],[\"迭代\",{\"1\":{\"64\":1,\"136\":3}}],[\"甚至o\",{\"1\":{\"64\":1}}],[\"暴力搜索所有可能的解决方案\",{\"1\":{\"74\":1}}],[\"暴力搜索\",{\"0\":{\"93\":1,\"103\":1,\"108\":1},\"1\":{\"64\":1,\"103\":1,\"108\":1}}],[\"暴力枚举\",{\"1\":{\"29\":1}}],[\"润物细无声\",{\"1\":{\"63\":1}}],[\"链接器将多个目标文件\",{\"1\":{\"271\":1}}],[\"链接\",{\"0\":{\"237\":1},\"1\":{\"271\":1}}],[\"链式地址哈希表\",{\"1\":{\"170\":1}}],[\"链式地址存在以下局限性\",{\"1\":{\"170\":1}}],[\"链式地址\",{\"0\":{\"170\":1},\"1\":{\"169\":1,\"170\":1,\"217\":1}}],[\"链式地址中的长链表会被转化为红黑树\",{\"1\":{\"63\":1}}],[\"链表则是另一个极端\",{\"1\":{\"184\":1}}],[\"链表则不然\",{\"1\":{\"150\":1}}],[\"链表包含节点指针\",{\"1\":{\"170\":1}}],[\"链表比数组占用更多的内存空间\",{\"1\":{\"146\":1}}],[\"链表节点表示顶点\",{\"1\":{\"217\":1}}],[\"链表节点结构体\",{\"1\":{\"146\":1}}],[\"链表节点\",{\"1\":{\"146\":1,\"170\":1}}],[\"链表的扩容非常灵活\",{\"1\":{\"158\":1}}],[\"链表的首个节点被称为\",{\"1\":{\"146\":1}}],[\"链表的组成单位是节点\",{\"1\":{\"146\":1}}],[\"链表的设计使得各个节点可以分散存储在内存各处\",{\"1\":{\"146\":1}}],[\"链表相较于数组\",{\"1\":{\"132\":1}}],[\"链表在初始化后\",{\"1\":{\"15\":1}}],[\"链表或二者的组合实现的\",{\"1\":{\"15\":1}}],[\"链表\",{\"0\":{\"5\":1,\"146\":1},\"1\":{\"13\":1,\"14\":1,\"15\":1,\"146\":1,\"184\":1,\"213\":1,\"219\":1}}],[\"虽然当前的select服务器是一个单进程的服务器\",{\"1\":{\"441\":1}}],[\"虽然静态类型变成了基类shape\",{\"1\":{\"376\":1}}],[\"虽然包含三个属性\",{\"1\":{\"303\":1}}],[\"虽然两个语句都可以使用\",{\"1\":{\"297\":1}}],[\"虽然二者值是相同的\",{\"1\":{\"263\":1}}],[\"虽然成功找出了所有和为9的子集\",{\"1\":{\"85\":1}}],[\"虽然\",{\"1\":{\"83\":1}}],[\"虽然哈希表并不直接应用分治\",{\"1\":{\"63\":1}}],[\"虽然快速排序的最差时间复杂度为o\",{\"1\":{\"44\":1}}],[\"红黑树\",{\"1\":{\"63\":1}}],[\"本质就是遍历fd\",{\"1\":{\"440\":1}}],[\"本质就是需要引入互斥锁\",{\"1\":{\"354\":1}}],[\"本质上是一个标识符常量\",{\"1\":{\"243\":1}}],[\"本质上是最大化单位重量下的物品价值\",{\"1\":{\"119\":1}}],[\"本质上是因为暴力搜索每轮只能排除一个选项\",{\"1\":{\"64\":1}}],[\"本质上是给每个字符分配一个编号\",{\"1\":{\"18\":1}}],[\"本加油站没有您所需油号\",{\"1\":{\"297\":1}}],[\"本题允许只选择物品的一部分\",{\"1\":{\"118\":1}}],[\"本题采取的贪心策略如下图所示\",{\"1\":{\"113\":1}}],[\"本题也可以进行空间优化\",{\"1\":{\"98\":1}}],[\"本题的每一轮的决策就是从当前格子向下或向右走一步\",{\"1\":{\"102\":1}}],[\"本题的目标是求解方案数量\",{\"1\":{\"92\":1}}],[\"本题的输入数组可能包含重复元素\",{\"1\":{\"86\":1}}],[\"本题规定每个数组元素只能被选择一次\",{\"1\":{\"86\":1}}],[\"本题集合中的元素可以被无限次选取\",{\"1\":{\"85\":1}}],[\"本节开头已介绍\",{\"1\":{\"63\":1}}],[\"汉诺塔问题形成一棵高度为n的递归树\",{\"1\":{\"73\":1}}],[\"汉诺塔问题代码实现\",{\"0\":{\"73\":1}}],[\"汉诺塔问题可以通过递归解决\",{\"1\":{\"63\":1}}],[\"汉诺塔问题\",{\"0\":{\"70\":1},\"1\":{\"63\":1,\"79\":1}}],[\"汉字使用两个字节表示\",{\"1\":{\"18\":1}}],[\"还是打印的1\",{\"1\":{\"348\":1}}],[\"还用它的地址\",{\"1\":{\"348\":1}}],[\"还引入了字母\",{\"1\":{\"325\":1}}],[\"还要用实参去替换形参带参宏定义的一般形式为\",{\"1\":{\"319\":1}}],[\"还不确定会有什么类型的数据写入内存\",{\"1\":{\"313\":1}}],[\"还可以加入\",{\"1\":{\"321\":1}}],[\"还可以把链表转换为哈希表\",{\"1\":{\"217\":1}}],[\"还可用于解决许多变种问题\",{\"1\":{\"22\":1}}],[\"还广泛应用于其他领域中\",{\"1\":{\"176\":1}}],[\"还需额外保存一个引用\",{\"1\":{\"146\":1}}],[\"还会缓存其周围的其他数据\",{\"1\":{\"138\":1}}],[\"还具有另外两大特性\",{\"1\":{\"97\":1}}],[\"还有利于操作系统的并行优化\",{\"1\":{\"62\":1}}],[\"子类成员将屏蔽父类同名成员\",{\"1\":{\"373\":1}}],[\"子类\",{\"1\":{\"373\":4}}],[\"子树恢复平衡\",{\"1\":{\"201\":1}}],[\"子树区间为空时终止\",{\"1\":{\"69\":1}}],[\"子节点数量\",{\"1\":{\"195\":2,\"207\":3}}],[\"子节点\",{\"1\":{\"189\":1,\"190\":1}}],[\"子集和一定超过\",{\"1\":{\"85\":1}}],[\"子集和等于\",{\"1\":{\"85\":2,\"86\":1}}],[\"子集和\",{\"1\":{\"85\":2,\"86\":1}}],[\"子集和问题\",{\"0\":{\"84\":1},\"1\":{\"79\":1}}],[\"子集不区分元素顺序\",{\"1\":{\"85\":1}}],[\"子问题分解是一种通用的算法思路\",{\"1\":{\"97\":1}}],[\"子问题分解\",{\"0\":{\"72\":1}}],[\"子问题的解dp\",{\"1\":{\"108\":1}}],[\"子问题的解无须合并\",{\"1\":{\"64\":1}}],[\"子问题的解\",{\"1\":{\"59\":1,\"66\":1}}],[\"子问题的解可以合并\",{\"1\":{\"59\":2,\"66\":1}}],[\"子问题可以独立进行求解\",{\"1\":{\"59\":1}}],[\"子问题\",{\"1\":{\"59\":1,\"66\":2,\"69\":2,\"73\":3}}],[\"子问题之间没有重叠\",{\"1\":{\"59\":1}}],[\"子问题是独立的\",{\"1\":{\"59\":2,\"64\":1,\"66\":1}}],[\"子数组长度为\",{\"1\":{\"43\":1}}],[\"治\",{\"1\":{\"58\":2}}],[\"据为d进制\",{\"1\":{\"56\":1}}],[\"得到起始时间\",{\"1\":{\"291\":1}}],[\"得到的是不确定结果\",{\"1\":{\"244\":2}}],[\"得到原问题的解\",{\"1\":{\"66\":1}}],[\"得到下次放置\",{\"1\":{\"54\":1}}],[\"得到未排序的左子数组和右子数组\",{\"1\":{\"43\":1}}],[\"倒序遍历\",{\"1\":{\"54\":1,\"56\":1,\"111\":1}}],[\"尾指针\",{\"1\":{\"161\":1,\"164\":1}}],[\"尾部称为\",{\"1\":{\"159\":1}}],[\"尾节点都指向该节点\",{\"1\":{\"160\":1}}],[\"尾节点处添加\",{\"1\":{\"160\":1}}],[\"尾节点视为栈底\",{\"1\":{\"156\":1}}],[\"尾节点指向空\",{\"1\":{\"153\":1}}],[\"尾节点指向的是\",{\"1\":{\"146\":1}}],[\"尾节点\",{\"1\":{\"146\":1,\"160\":1,\"163\":1}}],[\"尾递归\",{\"1\":{\"136\":1}}],[\"尾索引\",{\"1\":{\"54\":1}}],[\"尾元素+1\",{\"1\":{\"21\":1}}],[\"尾元素\",{\"1\":{\"20\":1}}],[\"转发为右值引用\",{\"1\":{\"379\":1}}],[\"转发为左值引用\",{\"1\":{\"379\":1}}],[\"转长双精度浮点型\",{\"1\":{\"379\":1}}],[\"转长整型\",{\"1\":{\"379\":1}}],[\"转双精度浮点型\",{\"1\":{\"379\":1}}],[\"转单精度浮点型\",{\"1\":{\"379\":1}}],[\"转无符号长长整型\",{\"1\":{\"379\":1}}],[\"转无符号长整型\",{\"1\":{\"379\":1}}],[\"转整型\",{\"1\":{\"379\":1}}],[\"转型失败\",{\"1\":{\"357\":1}}],[\"转型成功\",{\"1\":{\"357\":1}}],[\"转换shared\",{\"1\":{\"351\":1}}],[\"转换格式\",{\"1\":{\"338\":1}}],[\"转换为\",{\"1\":{\"54\":1,\"56\":1}}],[\"转义字符\",{\"1\":{\"332\":1}}],[\"转成对应的4位的一个二进制数即可\",{\"1\":{\"326\":1}}],[\"转成对应的十六进制数即可\",{\"1\":{\"326\":1}}],[\"转化为\",{\"1\":{\"128\":1}}],[\"转化为查找元素\",{\"1\":{\"27\":1}}],[\"转化为查找最左一个\",{\"1\":{\"27\":2}}],[\"求字符串长度\",{\"1\":{\"292\":1}}],[\"求切分后所有整数的乘积最大是多少\",{\"1\":{\"126\":1}}],[\"求最短路径\",{\"1\":{\"79\":1}}],[\"求出其所有可能的排列组合\",{\"1\":{\"79\":1}}],[\"求解\",{\"1\":{\"90\":1}}],[\"求解子集和\",{\"1\":{\"85\":2,\"86\":1}}],[\"求解汉诺塔问题\",{\"1\":{\"73\":2}}],[\"求解问题\",{\"1\":{\"64\":1}}],[\"求解逆序对问题可以利用分治的思想\",{\"1\":{\"63\":1}}],[\"求解逆序对\",{\"1\":{\"63\":1}}],[\"求前缀和\",{\"1\":{\"56\":1}}],[\"求\",{\"1\":{\"54\":1}}],[\"求和得到\",{\"1\":{\"41\":1}}],[\"求和为\",{\"1\":{\"36\":1}}],[\"完美转发\",{\"1\":{\"379\":1}}],[\"完美二叉树\",{\"1\":{\"184\":1}}],[\"完全二叉树非常适合用数组来表示\",{\"1\":{\"209\":1}}],[\"完全二叉树非常适合使用数组来表示\",{\"1\":{\"190\":1}}],[\"完全二叉树\",{\"1\":{\"183\":2}}],[\"完全背包问题\",{\"1\":{\"107\":1}}],[\"完形填空\",{\"1\":{\"81\":1}}],[\"完整实现\",{\"1\":{\"54\":1}}],[\"完成右旋后\",{\"1\":{\"201\":1}}],[\"完成堆化后\",{\"1\":{\"48\":1}}],[\"完成交换后\",{\"1\":{\"48\":1}}],[\"完成后再合并结果\",{\"1\":{\"62\":1}}],[\"完成后\",{\"1\":{\"36\":2,\"48\":1,\"56\":1}}],[\"增删节点需要通过数组插入与删除操作实现\",{\"1\":{\"191\":1}}],[\"增删等操作方法\",{\"1\":{\"15\":1}}],[\"增加容量\",{\"1\":{\"344\":1}}],[\"增加\",{\"1\":{\"161\":2,\"241\":1}}],[\"增加1即可\",{\"1\":{\"53\":1}}],[\"统一调用std\",{\"1\":{\"379\":1}}],[\"统一码\",{\"1\":{\"18\":1}}],[\"统计有效键值对数量\",{\"1\":{\"167\":3}}],[\"统计数字\",{\"1\":{\"56\":1}}],[\"统计数组最大元素\",{\"1\":{\"53\":1,\"54\":1}}],[\"统计各数字的出现次数\",{\"1\":{\"53\":1,\"54\":1}}],[\"统计方法很简单\",{\"1\":{\"53\":1}}],[\"统计\",{\"1\":{\"53\":1,\"56\":1}}],[\"借助std\",{\"1\":{\"379\":2}}],[\"借助于宏定义\",{\"1\":{\"318\":1}}],[\"借助归并排序进行求解\",{\"1\":{\"63\":1}}],[\"借助\",{\"1\":{\"53\":1}}],[\"找出其中元素的所有可能的排列\",{\"1\":{\"80\":1}}],[\"找出其中的最大数字\",{\"1\":{\"53\":1}}],[\"找到一个没有被使用的位置将该文件描述符添加进去即可\",{\"1\":{\"440\":1}}],[\"找到了联系人\",{\"1\":{\"344\":1}}],[\"找到待删除节点\",{\"1\":{\"195\":1}}],[\"找到待删除节点在\",{\"1\":{\"195\":1}}],[\"找到重复节点\",{\"1\":{\"194\":1}}],[\"找到目标节点\",{\"1\":{\"193\":1}}],[\"找到目标元素\",{\"1\":{\"20\":1,\"21\":1,\"64\":1}}],[\"找到问题解法\",{\"1\":{\"135\":1}}],[\"找到小于且最接近剩余金额的硬币\",{\"1\":{\"113\":1}}],[\"找到最大的完全子图\",{\"1\":{\"79\":1}}],[\"找到集合中所有和为目标和的子集\",{\"1\":{\"79\":1}}],[\"找到未排序区间内的最小元素\",{\"1\":{\"36\":1}}],[\"找到\",{\"1\":{\"23\":1,\"26\":1,\"27\":1}}],[\"先运行服务端\",{\"1\":{\"406\":1}}],[\"先将服务端进程运行起来\",{\"1\":{\"403\":1}}],[\"先将上面的小圆盘从\",{\"1\":{\"71\":1}}],[\"先于\",{\"1\":{\"379\":1}}],[\"先走\",{\"1\":{\"361\":1}}],[\"先走到尽头\",{\"1\":{\"187\":1}}],[\"先列表初始化\",{\"1\":{\"361\":1}}],[\"先拷贝构造一个临时变量\",{\"1\":{\"361\":1}}],[\"先调用构造函数创建对象\",{\"1\":{\"357\":1}}],[\"先判断这个static指针是否为空\",{\"1\":{\"354\":1}}],[\"先定义共用体类型\",{\"1\":{\"303\":1}}],[\"先定义结构体\",{\"1\":{\"302\":1}}],[\"先定义枚举类型\",{\"1\":{\"301\":1}}],[\"先定义再初始化\",{\"1\":{\"246\":1}}],[\"先使用i\",{\"1\":{\"276\":1}}],[\"先使用\",{\"1\":{\"276\":1}}],[\"先自减\",{\"1\":{\"276\":1}}],[\"先自增\",{\"1\":{\"276\":1}}],[\"先顺序存放第一行的元素\",{\"1\":{\"246\":1}}],[\"先指定元素的个数和类型\",{\"1\":{\"244\":1}}],[\"先往哪个方向探索都可以\",{\"1\":{\"225\":1}}],[\"先入先出\",{\"1\":{\"223\":1}}],[\"先右旋再左旋\",{\"0\":{\"204\":1}}],[\"先右旋后左旋\",{\"1\":{\"200\":1,\"205\":2}}],[\"先左旋再右旋\",{\"0\":{\"203\":1}}],[\"先左旋后右旋\",{\"1\":{\"200\":1,\"205\":2}}],[\"先在二叉树中查找到目标节点\",{\"1\":{\"195\":1}}],[\"先分析一个简单案例\",{\"1\":{\"189\":1}}],[\"先进先出\",{\"1\":{\"186\":1}}],[\"先计算哈希值\",{\"1\":{\"175\":1}}],[\"先观察问题是否适合使用回溯\",{\"1\":{\"101\":1}}],[\"先给出它的暴力回溯解法\",{\"1\":{\"92\":1}}],[\"先选4后选5与先选5后选4是不同的分支\",{\"1\":{\"85\":1}}],[\"先来看一个简单的例子\",{\"1\":{\"53\":1}}],[\"先递归左子数组\",{\"1\":{\"46\":1}}],[\"先递归左子树\",{\"1\":{\"46\":1}}],[\"计数排序的整体流程如下图所示\",{\"1\":{\"53\":1}}],[\"计数排序\",{\"1\":{\"52\":1,\"53\":1,\"54\":1,\"56\":2}}],[\"计数排序算法的完整实现\",{\"0\":{\"54\":1}}],[\"计数排序算法的简单实现\",{\"0\":{\"53\":1}}],[\"计数排序算法\",{\"0\":{\"52\":1}}],[\"计算线程函数的参数为引用类型\",{\"1\":{\"379\":1}}],[\"计算类的长度\",{\"1\":{\"361\":1}}],[\"计算变量的大小\",{\"1\":{\"335\":1}}],[\"计算字面量数据的大小\",{\"1\":{\"335\":1}}],[\"计算字符串的长度\",{\"1\":{\"292\":2}}],[\"计算字符串长度\",{\"1\":{\"245\":1}}],[\"计算数据类型的大小\",{\"1\":{\"335\":1}}],[\"计算数组长度\",{\"1\":{\"244\":1,\"288\":2}}],[\"计算数组长度数组长度\",{\"1\":{\"244\":1}}],[\"计算数组总的字节长度\",{\"1\":{\"244\":1}}],[\"计算数组中点\",{\"1\":{\"46\":1}}],[\"计算面积并输出\",{\"1\":{\"318\":1}}],[\"计算两个时间值的差\",{\"1\":{\"291\":1}}],[\"计算过程分析\",{\"1\":{\"280\":3}}],[\"计算后a的值变为11\",{\"1\":{\"279\":1}}],[\"计算后c的值变为53\",{\"1\":{\"279\":1}}],[\"计算后c的值变为33\",{\"1\":{\"279\":1}}],[\"计算所有元素的和\",{\"1\":{\"246\":1}}],[\"计算第二维度的长度\",{\"1\":{\"246\":1}}],[\"计算第一维度的长度\",{\"1\":{\"246\":1}}],[\"计算步骤如下\",{\"1\":{\"244\":1}}],[\"计算开销越小\",{\"1\":{\"176\":1}}],[\"计算哈希值的过程应该足够快\",{\"1\":{\"176\":1}}],[\"计算桶索引\",{\"1\":{\"172\":1}}],[\"计算得到哈希值\",{\"1\":{\"167\":1}}],[\"计算环形数组索引\",{\"1\":{\"164\":1}}],[\"计算队尾指针\",{\"1\":{\"161\":1,\"164\":1}}],[\"计算当前状态的容量cap\",{\"1\":{\"123\":1}}],[\"计算不放入和放入物品\",{\"1\":{\"108\":1,\"109\":1}}],[\"计算从左上角到\",{\"1\":{\"103\":1}}],[\"计算该格子对应的主对角线和次对角线\",{\"1\":{\"90\":1}}],[\"计算中点\",{\"1\":{\"46\":1}}],[\"计算中点索引\",{\"1\":{\"20\":1,\"21\":1,\"23\":1,\"24\":1,\"64\":1}}],[\"计算中点索引m=\",{\"1\":{\"20\":1}}],[\"计算机网络\",{\"0\":{\"536\":1}}],[\"计算机网络体系结构\",{\"0\":{\"509\":1,\"510\":1}}],[\"计算机组成原理\",{\"0\":{\"534\":1}}],[\"计算机基础理论\",{\"0\":{\"533\":1}}],[\"计算机的性能指标\",{\"0\":{\"479\":1}}],[\"计算机系统概述\",{\"0\":{\"477\":1,\"478\":1}}],[\"计算机中基本存储单元\",{\"1\":{\"330\":1}}],[\"计算机中的最小存储单位\",{\"1\":{\"330\":1}}],[\"计算机中程序的运行都是在内存中进行的\",{\"1\":{\"261\":1}}],[\"计算机为什么要用补码\",{\"0\":{\"328\":1}}],[\"计算机底层存储数据时使用的是二进制数字\",{\"1\":{\"327\":1}}],[\"计算机世界中只有二进制\",{\"1\":{\"325\":1}}],[\"计算机语言简史\",{\"0\":{\"240\":1}}],[\"计算机不仅会加载它\",{\"1\":{\"138\":1}}],[\"计算机就可以通过查表完成二进制数到字符的转换\",{\"1\":{\"18\":1}}],[\"计算机可以用同样的电路和操作来处理正数和负数的加法\",{\"1\":{\"17\":1}}],[\"计算机使用补码的原因\",{\"1\":{\"17\":1}}],[\"计算机根据特定规则为表格中的每个单元格分配编号\",{\"1\":{\"15\":1}}],[\"目标函数\",{\"1\":{\"379\":1}}],[\"目标文件是二进制文件\",{\"1\":{\"271\":1}}],[\"目标节点在\",{\"1\":{\"193\":2}}],[\"目标是求限定背包容量下的最大价值\",{\"1\":{\"118\":1}}],[\"目标是获取最大利润\",{\"1\":{\"117\":1}}],[\"目标是让叶节点的值尽可能平均\",{\"1\":{\"51\":1}}],[\"目标金额为amt\",{\"1\":{\"113\":1}}],[\"目前\",{\"1\":{\"18\":1}}],[\"再运行客户端\",{\"1\":{\"406\":1}}],[\"再以读的方式打开file\",{\"1\":{\"406\":1}}],[\"再让服务端将管道当中的命令读取出来并执行下面我们只实现了让服务端执行不带选项的命令\",{\"1\":{\"405\":1}}],[\"再让临时变量赋值给num2\",{\"1\":{\"348\":1}}],[\"再用临时对象拷贝构造新对象a2\",{\"1\":{\"361\":1}}],[\"再\",{\"1\":{\"361\":2}}],[\"再拷贝给赋的值\",{\"1\":{\"361\":1}}],[\"再调用拷贝构造拷贝值给obj3\",{\"1\":{\"357\":1}}],[\"再次调整内存大小\",{\"1\":{\"314\":1}}],[\"再次修订\",{\"1\":{\"241\":1}}],[\"再向编译器补充说明\",{\"1\":{\"313\":1}}],[\"再赋值\",{\"1\":{\"303\":1}}],[\"再定义一个函数检测成绩低于60分的\",{\"1\":{\"314\":1}}],[\"再定义共用体变量\",{\"1\":{\"303\":1}}],[\"再定义枚举变量\",{\"1\":{\"301\":1}}],[\"再创建一个名为file\",{\"1\":{\"406\":1}}],[\"再创建结构体指针\",{\"1\":{\"302\":1}}],[\"再创建两个指针进行相减\",{\"1\":{\"262\":1}}],[\"再自减\",{\"1\":{\"276\":1}}],[\"再自增\",{\"1\":{\"276\":1}}],[\"再使用ii++\",{\"1\":{\"276\":1}}],[\"再使用i\",{\"1\":{\"276\":1}}],[\"再存放第二行的元素\",{\"1\":{\"246\":1}}],[\"再进行初始化\",{\"1\":{\"244\":1}}],[\"再继续走到尽头并返回\",{\"1\":{\"224\":1}}],[\"再回溯继续\",{\"1\":{\"187\":1}}],[\"再对\",{\"1\":{\"203\":1,\"204\":1}}],[\"再对数组长度取模\",{\"1\":{\"175\":1}}],[\"再对这两部分进行相同的划分操作\",{\"1\":{\"63\":1}}],[\"再逐步导出更高效的动态规划解法\",{\"1\":{\"92\":1}}],[\"再比较数组中每个元素的异同\",{\"1\":{\"85\":1}}],[\"再选择3\",{\"1\":{\"81\":1}}],[\"再将服务端想象成\",{\"1\":{\"406\":1}}],[\"再将其删除\",{\"1\":{\"195\":1}}],[\"再将大圆盘从\",{\"1\":{\"71\":1}}],[\"再将商品较多的桶继续划分为\",{\"1\":{\"51\":1}}],[\"再递归右子数组\",{\"1\":{\"46\":1}}],[\"再递归右子树\",{\"1\":{\"46\":1}}],[\"各类型存储大小受到操作系统\",{\"1\":{\"330\":1}}],[\"各功能模块都是抽离出来适用的\",{\"1\":{\"297\":1}}],[\"各元素是连续存放的\",{\"1\":{\"246\":1}}],[\"各项操作都变为线性操作\",{\"1\":{\"184\":1}}],[\"各种操作的实现方法如下图所示\",{\"1\":{\"161\":1}}],[\"各种操作的时间复杂度皆为o\",{\"1\":{\"64\":1}}],[\"各步骤都有确定的含义\",{\"1\":{\"131\":1}}],[\"各个节点通过\",{\"1\":{\"146\":1}}],[\"各个节点是在向下\",{\"1\":{\"69\":1}}],[\"各个桶中的商品数量差距会非常大\",{\"1\":{\"51\":1}}],[\"各数字的出现次数\",{\"1\":{\"56\":1}}],[\"各轮\",{\"1\":{\"37\":1}}],[\"元的非常少\",{\"1\":{\"51\":1}}],[\"元的非常多\",{\"1\":{\"51\":1}}],[\"元素值\",{\"1\":{\"262\":12}}],[\"元素地址\",{\"1\":{\"262\":12}}],[\"元素都是short类型\",{\"1\":{\"262\":1}}],[\"元素个数\",{\"1\":{\"244\":1}}],[\"元素个数是\",{\"1\":{\"244\":1}}],[\"元素类型是\",{\"1\":{\"244\":1}}],[\"元素索引\",{\"1\":{\"218\":2,\"262\":12}}],[\"元素出堆\",{\"1\":{\"212\":1}}],[\"元素出堆操作\",{\"1\":{\"47\":1}}],[\"元素入堆操作的时间复杂度为o\",{\"1\":{\"211\":1}}],[\"元素入堆\",{\"0\":{\"211\":1},\"1\":{\"211\":1}}],[\"元素代表节点值\",{\"1\":{\"209\":1}}],[\"元素会被移动至距离理想位置\",{\"1\":{\"172\":1}}],[\"元素和\",{\"1\":{\"85\":1}}],[\"元素到索引的映射\",{\"1\":{\"69\":2}}],[\"元素交换和堆化操作都是在原数组上进行的非稳定排序\",{\"1\":{\"48\":1}}],[\"元素交换\",{\"1\":{\"42\":1}}],[\"元素\",{\"1\":{\"36\":1}}],[\"元素nums\",{\"1\":{\"26\":1}}],[\"元素之间是一对一的顺序关系非线性数据结构\",{\"1\":{\"14\":1}}],[\"释放堆上的空间\",{\"1\":{\"361\":1}}],[\"释放c++标准库std\",{\"1\":{\"348\":1}}],[\"释放分配的内存\",{\"1\":{\"314\":2}}],[\"释放辅助数组空间\",{\"1\":{\"186\":1}}],[\"释放\",{\"1\":{\"160\":1,\"163\":1}}],[\"释放所有节点\",{\"1\":{\"160\":1,\"163\":1}}],[\"释放上述分配的内存\",{\"1\":{\"50\":1}}],[\"释放内存\",{\"1\":{\"46\":1,\"53\":1,\"54\":1,\"98\":1,\"99\":1,\"105\":1,\"106\":1,\"110\":1,\"111\":1,\"149\":1,\"156\":1,\"170\":2,\"195\":1,\"219\":1,\"223\":1,\"314\":1,\"351\":3}}],[\"qq\",{\"1\":{\"214\":1,\"344\":1,\"345\":1,\"348\":1,\"351\":1,\"354\":1,\"357\":1,\"361\":1,\"364\":1,\"367\":1,\"370\":1,\"373\":1,\"376\":1,\"379\":1,\"382\":1}}],[\"quit\",{\"1\":{\"390\":1,\"397\":1,\"403\":1,\"404\":1,\"405\":1,\"406\":1,\"440\":1}}],[\"quicksort\",{\"1\":{\"43\":3}}],[\"quick\",{\"1\":{\"42\":1}}],[\"quantity\",{\"1\":{\"304\":1}}],[\"que\",{\"1\":{\"223\":1}}],[\"quecapacity\",{\"1\":{\"161\":1,\"164\":1}}],[\"quesize\",{\"1\":{\"160\":1,\"161\":1,\"163\":1,\"164\":1}}],[\"queue\",{\"1\":{\"159\":1,\"160\":38,\"161\":34,\"162\":1,\"186\":7,\"223\":15}}],[\"q\",{\"1\":{\"90\":2,\"223\":19}}],[\"qsort\",{\"1\":{\"50\":1,\"85\":1,\"86\":1,\"120\":1}}],[\"前置\",{\"1\":{\"361\":2}}],[\"前面的比后面的字母大\",{\"1\":{\"344\":1}}],[\"前面介绍了哈希表的工作原理和哈希冲突的处理方法\",{\"1\":{\"175\":1}}],[\"前序\",{\"0\":{\"187\":1},\"1\":{\"187\":1}}],[\"前序遍历的首元素\",{\"1\":{\"67\":1}}],[\"前序遍历\",{\"1\":{\"67\":1,\"74\":1,\"75\":1,\"76\":1,\"185\":1,\"187\":1,\"190\":2}}],[\"前驱节点\",{\"1\":{\"163\":1}}],[\"前两轮选择4和5\",{\"1\":{\"85\":1}}],[\"前两轮选择3和5\",{\"1\":{\"85\":1}}],[\"前进\",{\"1\":{\"75\":1}}],[\"前\",{\"1\":{\"75\":1}}],[\"前述几种排序算法都属于\",{\"1\":{\"49\":1}}],[\"前n\",{\"1\":{\"38\":1}}],[\"轮\",{\"1\":{\"48\":1}}],[\"记住最重要的就行了\",{\"1\":{\"283\":1}}],[\"记忆化搜索是一种\",{\"1\":{\"95\":1}}],[\"记忆化搜索\",{\"0\":{\"94\":1,\"104\":1,\"109\":1},\"1\":{\"94\":2,\"104\":1,\"109\":1}}],[\"记录访问顶点\",{\"1\":{\"223\":1,\"225\":1}}],[\"记录访问过的节点路径\",{\"1\":{\"75\":1}}],[\"记录遇到的首个删除标记\",{\"1\":{\"172\":1}}],[\"记录并返回两种方案中价值更大的那一个\",{\"1\":{\"109\":1}}],[\"记录并返回左上角到\",{\"1\":{\"104\":1}}],[\"记录爬到第\",{\"1\":{\"94\":1}}],[\"记录\",{\"1\":{\"94\":1}}],[\"记录方案数量\",{\"1\":{\"92\":1}}],[\"记录次对角线上是否有皇后\",{\"1\":{\"90\":1}}],[\"记录主对角线上是否有皇后\",{\"1\":{\"90\":1}}],[\"记录列是否有皇后\",{\"1\":{\"90\":1}}],[\"记录每条主对角线上是否有皇后\",{\"1\":{\"89\":1}}],[\"记录每一列是否有皇后\",{\"1\":{\"89\":1}}],[\"记录选择过的元素值\",{\"1\":{\"82\":1}}],[\"记录解\",{\"1\":{\"74\":1,\"75\":1,\"76\":1,\"77\":3,\"81\":1,\"82\":1,\"85\":2,\"86\":1,\"90\":1}}],[\"记录最小元素的索引\",{\"1\":{\"36\":1}}],[\"记为m\",{\"1\":{\"53\":1}}],[\"记为\",{\"1\":{\"48\":1,\"56\":1,\"70\":1,\"85\":1,\"102\":1,\"122\":1,\"195\":1,\"201\":1,\"202\":1,\"212\":1}}],[\"函数对象\",{\"1\":{\"379\":1}}],[\"函数包装器\",{\"1\":{\"379\":1}}],[\"函数模板特化为char类型\",{\"1\":{\"367\":1}}],[\"函数模板实例化\",{\"1\":{\"367\":1}}],[\"函数模板定义\",{\"1\":{\"367\":1}}],[\"函数参数以对象传递\",{\"1\":{\"361\":1}}],[\"函数实现\",{\"1\":{\"319\":1}}],[\"函数等\",{\"1\":{\"318\":1}}],[\"函数所获得的内存块的大小\",{\"1\":{\"314\":1}}],[\"函数从文件中逐行读取\",{\"1\":{\"310\":1}}],[\"函数从标准输入流stdin读取输入\",{\"1\":{\"309\":1}}],[\"函数用于释放动态分配的内存\",{\"1\":{\"314\":1}}],[\"函数用于重新分配malloc\",{\"1\":{\"314\":1}}],[\"函数用于分配内存并将其初始化为零\",{\"1\":{\"314\":1}}],[\"函数用于分配一块连续的内存空间\",{\"1\":{\"314\":1}}],[\"函数用于从文件中解析数据并存储到变量中\",{\"1\":{\"310\":1}}],[\"函数用于从文件中逐字符读取\",{\"1\":{\"310\":1}}],[\"函数用于格式化写入文件\",{\"1\":{\"310\":1}}],[\"函数用于将字符串写入文件\",{\"1\":{\"310\":1}}],[\"函数用于逐字符写入文件\",{\"1\":{\"310\":1}}],[\"函数可以关闭文件\",{\"1\":{\"310\":1}}],[\"函数可以分类两类\",{\"1\":{\"285\":1}}],[\"函数来创建一个新的文件或者打开一个已有的文件\",{\"1\":{\"310\":1}}],[\"函数来统计程序的执行时间\",{\"1\":{\"291\":1}}],[\"函数把输出写入到标准输出流stdout\",{\"1\":{\"309\":1}}],[\"函数功能实现\",{\"1\":{\"344\":1}}],[\"函数功能\",{\"1\":{\"292\":1,\"293\":1,\"294\":1,\"344\":14}}],[\"函数耗用了\",{\"1\":{\"291\":2}}],[\"函数执行结束后得到时间\",{\"1\":{\"291\":1}}],[\"函数执行完毕后\",{\"1\":{\"286\":1}}],[\"函数外部使用局部变量\",{\"1\":{\"288\":1}}],[\"函数作用域的概念\",{\"1\":{\"288\":1}}],[\"函数作用域\",{\"0\":{\"288\":1}}],[\"函数之前声明如果想将函数声明写在后面\",{\"1\":{\"287\":1}}],[\"函数之间可以相互调用\",{\"1\":{\"285\":1}}],[\"函数必须先声明\",{\"1\":{\"287\":1}}],[\"函数体中没有关于不同对象的区分\",{\"1\":{\"361\":1}}],[\"函数体\",{\"1\":{\"287\":2}}],[\"函数体语句都会执行一遍\",{\"1\":{\"286\":1}}],[\"函数返回值以对象返回\",{\"1\":{\"361\":1}}],[\"函数返回值分为以下三种情况\",{\"1\":{\"286\":1}}],[\"函数返回一个不确定的值\",{\"1\":{\"286\":1}}],[\"函数每调用一次\",{\"1\":{\"286\":1}}],[\"函数被调用时使用的名字\",{\"1\":{\"286\":1}}],[\"函数名相同\",{\"1\":{\"348\":1}}],[\"函数名后面括号\",{\"1\":{\"286\":2}}],[\"函数名后面加上圆括号即是函数的调用\",{\"1\":{\"286\":1}}],[\"函数名要符合标识符规范函数体\",{\"1\":{\"286\":1}}],[\"函数名\",{\"1\":{\"286\":1,\"292\":1,\"293\":1,\"294\":1,\"344\":14}}],[\"函数基本语法\",{\"0\":{\"286\":1}}],[\"函数基本概念\",{\"0\":{\"285\":1}}],[\"函数的例子\",{\"1\":{\"310\":2}}],[\"函数的形参也是局部变量\",{\"1\":{\"288\":1}}],[\"函数的参数函数的参数分为形参与实参\",{\"1\":{\"286\":1}}],[\"函数的返回值\",{\"1\":{\"286\":1}}],[\"函数的调用\",{\"1\":{\"286\":1}}],[\"函数的分类c语言中\",{\"1\":{\"285\":1}}],[\"函数的功能\",{\"1\":{\"285\":1}}],[\"函数是c程序基本的组成单位注意\",{\"1\":{\"285\":1}}],[\"函数是一种可重复使用的代码块\",{\"1\":{\"285\":1}}],[\"函数调用后数能得到一个确定的值\",{\"1\":{\"286\":1}}],[\"函数调用中同时传递多个参数\",{\"1\":{\"282\":1}}],[\"函数调用结束局部变量会被销毁\",{\"1\":{\"267\":1}}],[\"函数将返回值赋给p\",{\"1\":{\"267\":1}}],[\"函数定义\",{\"1\":{\"264\":1,\"287\":1,\"314\":1}}],[\"函数声明\",{\"1\":{\"264\":2}}],[\"函数原型声明\",{\"1\":{\"314\":1}}],[\"函数原型\",{\"1\":{\"264\":1,\"287\":2,\"292\":1,\"293\":1,\"294\":1,\"310\":5,\"314\":4}}],[\"函数中的格式化字符串\",{\"1\":{\"310\":2}}],[\"函数中使用全局数据\",{\"1\":{\"288\":3}}],[\"函数中所包含的代码块\",{\"1\":{\"286\":1}}],[\"函数中\",{\"1\":{\"81\":1}}],[\"函数添加一个长度参数n\",{\"1\":{\"48\":1}}],[\"函数\",{\"0\":{\"228\":1,\"284\":1},\"1\":{\"48\":1,\"73\":1,\"83\":1,\"256\":1,\"272\":1,\"287\":1,\"288\":6,\"291\":1,\"314\":2,\"348\":1,\"376\":4}}],[\"步骤三\",{\"1\":{\"354\":1}}],[\"步骤一\",{\"1\":{\"354\":2}}],[\"步骤二\",{\"1\":{\"354\":2}}],[\"步长通常为1\",{\"1\":{\"172\":1}}],[\"步\",{\"1\":{\"48\":1,\"173\":1}}],[\"步和第\",{\"1\":{\"48\":1}}],[\"依次递增定义枚举的时候也可以为枚举元素自定义值\",{\"1\":{\"301\":1}}],[\"依次访问所有节点\",{\"1\":{\"147\":1}}],[\"依次对每一位进行排序\",{\"1\":{\"55\":1}}],[\"依次记录出堆元素\",{\"1\":{\"47\":1}}],[\"依次比较相邻元素大小\",{\"1\":{\"37\":1}}],[\"观察可知\",{\"1\":{\"111\":1}}],[\"观察递归树\",{\"1\":{\"108\":1}}],[\"观察以上公式\",{\"1\":{\"175\":1}}],[\"观察以上代码\",{\"1\":{\"96\":1}}],[\"观察以下代码\",{\"1\":{\"24\":1,\"93\":1}}],[\"观察其中包含的重叠子问题\",{\"1\":{\"92\":1}}],[\"观察下图\",{\"1\":{\"82\":1,\"85\":1}}],[\"观察下图所示的过程\",{\"1\":{\"75\":1}}],[\"观察上图发现\",{\"1\":{\"81\":1}}],[\"观察发现\",{\"1\":{\"46\":1,\"177\":1}}],[\"大写的字母a是65\",{\"1\":{\"332\":1}}],[\"大写\",{\"1\":{\"325\":1}}],[\"大写字符转小写\",{\"1\":{\"293\":1}}],[\"大约\",{\"1\":{\"261\":1}}],[\"大顶堆\",{\"1\":{\"208\":1}}],[\"大多数编程语言会将数组元素初始化为0\",{\"1\":{\"139\":1}}],[\"大小端存储\",{\"0\":{\"339\":1}}],[\"大小判断等\",{\"1\":{\"297\":1}}],[\"大小决定\",{\"1\":{\"110\":1}}],[\"大小的棋盘\",{\"1\":{\"90\":1}}],[\"大小的额外空间稳定排序\",{\"1\":{\"46\":1}}],[\"大小的栈帧空间\",{\"1\":{\"46\":1}}],[\"大整数乘法\",{\"1\":{\"63\":1}}],[\"大幅提升运行效率由于需要维护一个额外的哈希表\",{\"1\":{\"30\":1}}],[\"持续地将左右两个较短的有序数组合并为一个较长的有序数组\",{\"1\":{\"45\":1}}],[\"持续递归\",{\"1\":{\"43\":1}}],[\"开空间是定义\",{\"1\":{\"361\":1}}],[\"开辟空间失败\",{\"1\":{\"344\":1}}],[\"开发中用到浮点型数字\",{\"1\":{\"331\":1}}],[\"开发中使用整型一般用int型\",{\"1\":{\"330\":1}}],[\"开发工具选择\",{\"0\":{\"270\":1}}],[\"开头的路径\",{\"1\":{\"320\":2}}],[\"开头\",{\"1\":{\"317\":1}}],[\"开源的代码编辑器\",{\"1\":{\"270\":1}}],[\"开放寻址哈希表\",{\"1\":{\"172\":1}}],[\"开放寻址\",{\"0\":{\"171\":1},\"1\":{\"169\":1,\"171\":1}}],[\"开销很大\",{\"1\":{\"138\":1}}],[\"开始循环\",{\"1\":{\"298\":1}}],[\"开始回溯\",{\"1\":{\"86\":1}}],[\"开始遍历\",{\"1\":{\"85\":1,\"86\":2}}],[\"开始\",{\"1\":{\"48\":1,\"95\":1,\"211\":1,\"212\":1,\"320\":1}}],[\"开始合并\",{\"1\":{\"45\":1}}],[\"开启一个循环\",{\"1\":{\"36\":1}}],[\"划分为两个子问题f\",{\"1\":{\"72\":2}}],[\"划分为两个子数组\",{\"1\":{\"59\":1}}],[\"划分为\",{\"1\":{\"67\":2}}],[\"划分产生高度为logn的递归树\",{\"1\":{\"46\":1}}],[\"划分阶段\",{\"1\":{\"45\":1,\"46\":2,\"58\":1}}],[\"划分\",{\"1\":{\"45\":1}}],[\"包装器\",{\"1\":{\"379\":1}}],[\"包含纯虚函数的类叫做抽象类\",{\"1\":{\"376\":1}}],[\"包含c语言所有常用基础知识和文件系统\",{\"1\":{\"342\":1}}],[\"包含自定义头文件\",{\"1\":{\"320\":1}}],[\"包含标准库头文件\",{\"1\":{\"320\":1}}],[\"包含\",{\"1\":{\"292\":1}}],[\"包含多个桶\",{\"1\":{\"170\":1}}],[\"包含元素\",{\"1\":{\"147\":1}}],[\"包含清晰的输入和输出定义\",{\"1\":{\"131\":1}}],[\"包含两个属性\",{\"1\":{\"120\":1}}],[\"包含重复子集\",{\"1\":{\"85\":1}}],[\"包含图下图所示的\",{\"1\":{\"45\":1}}],[\"包括系统调度策略和处理器的状态\",{\"1\":{\"379\":1}}],[\"包括数字\",{\"1\":{\"325\":1}}],[\"包括字符串终止符\",{\"1\":{\"310\":1}}],[\"包括c标准库文件和其他库文件\",{\"1\":{\"271\":1}}],[\"包括去掉多余的空格和注释\",{\"1\":{\"271\":1}}],[\"包括修改指向内存的数据的值\",{\"1\":{\"267\":1}}],[\"包括整数常量\",{\"1\":{\"254\":1}}],[\"包括以下几种操作\",{\"1\":{\"190\":1}}],[\"包括输入数组和对应的所有排列\",{\"1\":{\"80\":1}}],[\"包括\",{\"1\":{\"58\":1,\"254\":1,\"379\":2}}],[\"包括各种语言的字符\",{\"1\":{\"18\":1}}],[\"65\",{\"1\":{\"291\":2,\"330\":2}}],[\"64位\",{\"1\":{\"330\":3,\"331\":2}}],[\"647\",{\"1\":{\"330\":2}}],[\"648\",{\"1\":{\"330\":2}}],[\"64\",{\"1\":{\"270\":1,\"325\":1,\"330\":2,\"396\":1,\"397\":2}}],[\"670000\",{\"1\":{\"337\":1}}],[\"67\",{\"1\":{\"244\":2,\"276\":2,\"337\":1,\"357\":1}}],[\"6763\",{\"1\":{\"18\":1}}],[\"60分\",{\"1\":{\"297\":1}}],[\"60000\",{\"1\":{\"246\":1}}],[\"6000\",{\"1\":{\"246\":1}}],[\"600\",{\"1\":{\"246\":1}}],[\"60\",{\"1\":{\"244\":1,\"246\":2,\"278\":1,\"297\":2,\"303\":1,\"314\":1}}],[\"6\",{\"0\":{\"45\":1,\"46\":1,\"65\":1,\"66\":1,\"67\":1,\"68\":1,\"69\":1,\"80\":1,\"81\":1,\"82\":1,\"83\":1,\"106\":1,\"118\":1,\"119\":1,\"120\":1,\"121\":1,\"144\":1,\"221\":1,\"222\":1,\"223\":1,\"224\":1,\"225\":1,\"232\":1,\"280\":1,\"290\":1,\"306\":1,\"322\":1,\"459\":1,\"466\":1},\"1\":{\"190\":1,\"244\":2,\"245\":1,\"246\":6,\"261\":1,\"271\":1,\"276\":2,\"288\":1,\"294\":1,\"297\":1,\"298\":4,\"299\":1,\"302\":1,\"310\":1,\"318\":1,\"331\":1,\"338\":2,\"342\":1,\"344\":2,\"348\":9,\"361\":3,\"364\":1,\"367\":2,\"379\":3}}],[\"交换排序\",{\"0\":{\"473\":1}}],[\"交换两个线程对象\",{\"1\":{\"379\":1}}],[\"交换两节点\",{\"1\":{\"48\":1,\"211\":1,\"212\":1}}],[\"交换完成后\",{\"1\":{\"212\":1}}],[\"交换堆顶元素与堆底元素\",{\"1\":{\"212\":1}}],[\"交换位置\",{\"1\":{\"172\":1}}],[\"交换首元素与尾元素\",{\"1\":{\"48\":1,\"212\":1}}],[\"交换根节点与最右叶节点\",{\"1\":{\"48\":1,\"212\":2}}],[\"交换\",{\"1\":{\"48\":1}}],[\"交换等操作的总数量最少\",{\"1\":{\"44\":1}}],[\"交换这两个元素\",{\"1\":{\"42\":1,\"43\":1}}],[\"复习代码\",{\"0\":{\"348\":1,\"351\":1,\"354\":1,\"357\":1,\"361\":1,\"364\":1,\"367\":1,\"370\":1,\"373\":1,\"376\":1,\"379\":1,\"382\":1}}],[\"复习思维导图\",{\"0\":{\"226\":1}}],[\"复制拷贝\",{\"1\":{\"361\":1}}],[\"复制字符串\",{\"1\":{\"292\":2}}],[\"复制操作使用o\",{\"1\":{\"90\":1}}],[\"复杂度分析\",{\"0\":{\"134\":1}}],[\"复杂度的常数系数小\",{\"1\":{\"44\":1}}],[\"复杂的回溯问题通常包含一个或多个约束条件\",{\"1\":{\"76\":1}}],[\"复用查找左边界\",{\"1\":{\"27\":1}}],[\"p++\",{\"1\":{\"404\":1}}],[\"placeholders\",{\"1\":{\"379\":5}}],[\"place\",{\"1\":{\"364\":1}}],[\"pleaase\",{\"1\":{\"252\":1}}],[\"please\",{\"1\":{\"252\":1,\"309\":1,\"403\":1}}],[\"pdata\",{\"1\":{\"361\":1}}],[\"pf\",{\"1\":{\"344\":4}}],[\"pf=\",{\"1\":{\"344\":1}}],[\"pf=null\",{\"1\":{\"344\":1}}],[\"pf==null\",{\"1\":{\"344\":2}}],[\"pf=fopen\",{\"1\":{\"344\":1}}],[\"p指向的值\",{\"1\":{\"314\":2}}],[\"p指向的地址\",{\"1\":{\"314\":2}}],[\"psl\",{\"1\":{\"344\":95}}],[\"psl指向contact结构体的指针\",{\"1\":{\"344\":13}}],[\"ps\",{\"1\":{\"302\":7}}],[\"pstr=\",{\"1\":{\"263\":1}}],[\"p为野指针\",{\"1\":{\"267\":1}}],[\"p=34\",{\"1\":{\"266\":1}}],[\"p=000000000061fe14\",{\"1\":{\"266\":1}}],[\"p=\",{\"1\":{\"266\":2}}],[\"ppptr=3000\",{\"1\":{\"265\":1}}],[\"ppptr=0000000cffbffdec\",{\"1\":{\"265\":1}}],[\"ppptr=0000000cffbffde0\",{\"1\":{\"265\":1}}],[\"ppptr=\",{\"1\":{\"265\":3}}],[\"ppptr`s\",{\"1\":{\"265\":3}}],[\"ppptr\",{\"1\":{\"265\":12}}],[\"pptr=3000\",{\"1\":{\"265\":1}}],[\"pptr=0000000cffbffdec\",{\"1\":{\"265\":1}}],[\"pptr=\",{\"1\":{\"265\":2}}],[\"pptr`s\",{\"1\":{\"265\":3}}],[\"pptr\",{\"1\":{\"265\":15}}],[\"p2=1\",{\"1\":{\"262\":2}}],[\"p2=\",{\"1\":{\"262\":1}}],[\"p2\",{\"1\":{\"262\":6}}],[\"p1=\",{\"1\":{\"262\":3}}],[\"p1\",{\"1\":{\"262\":6}}],[\"ptr6\",{\"1\":{\"364\":2}}],[\"ptr5\",{\"1\":{\"364\":2}}],[\"ptr指向对象不是myderivedclass类型\",{\"1\":{\"357\":1}}],[\"ptr指向的对象是myderivedclass类型\",{\"1\":{\"357\":1}}],[\"ptr对应的就是boost中的scope\",{\"1\":{\"351\":1}}],[\"ptr和weak\",{\"1\":{\"351\":1}}],[\"ptr等\",{\"1\":{\"351\":1}}],[\"ptr不影响内存释放\",{\"1\":{\"351\":1}}],[\"ptr离开作用域时\",{\"1\":{\"351\":1}}],[\"ptr离开作用域后\",{\"1\":{\"351\":3}}],[\"ptr时需要通过lock\",{\"1\":{\"351\":1}}],[\"ptr共享同一个对象\",{\"1\":{\"351\":1}}],[\"ptr<int>\",{\"1\":{\"351\":6}}],[\"ptr头文件\",{\"1\":{\"351\":1}}],[\"ptr的使用\",{\"1\":{\"351\":1}}],[\"ptr的循环引用问题\",{\"1\":{\"351\":1}}],[\"ptr必须是malloc\",{\"1\":{\"314\":1}}],[\"ptr是左值\",{\"1\":{\"379\":1}}],[\"ptr是指向要释放的内存块的指针\",{\"1\":{\"314\":1}}],[\"ptr是要重新分配的内存块的指针\",{\"1\":{\"314\":1}}],[\"ptr`s\",{\"1\":{\"265\":3}}],[\"ptr+1=000000f6d35ff9d4\",{\"1\":{\"263\":1}}],[\"ptr+1=\",{\"1\":{\"263\":1}}],[\"ptr++\",{\"1\":{\"262\":1,\"263\":1}}],[\"ptrarr\",{\"1\":{\"263\":6}}],[\"ptr4>ptr1\",{\"1\":{\"262\":2}}],[\"ptr4=000000d4385ffd08\",{\"1\":{\"262\":1}}],[\"ptr4=\",{\"1\":{\"262\":1}}],[\"ptr4\",{\"1\":{\"262\":3,\"364\":2}}],[\"ptr3=000000d4385ffd10\",{\"1\":{\"262\":1}}],[\"ptr3=\",{\"1\":{\"262\":1}}],[\"ptr3\",{\"1\":{\"262\":3,\"364\":2}}],[\"ptr2=000000d4385ffd1c\",{\"1\":{\"262\":1}}],[\"ptr2=\",{\"1\":{\"262\":4}}],[\"ptr2\",{\"1\":{\"262\":10,\"364\":2,\"379\":1}}],[\"ptr1<ptr2\",{\"1\":{\"262\":2}}],[\"ptr1>ptr2\",{\"1\":{\"262\":2}}],[\"ptr1=000000d4385ffd10\",{\"1\":{\"262\":1}}],[\"ptr1==ptr3\",{\"1\":{\"262\":2}}],[\"ptr1=3\",{\"1\":{\"262\":2}}],[\"ptr1=\",{\"1\":{\"262\":2}}],[\"ptr1\",{\"1\":{\"262\":12}}],[\"ptrdiff\",{\"1\":{\"262\":2}}],[\"ptr=3000\",{\"1\":{\"265\":1}}],[\"ptr=000000f6d35ff9c0\",{\"1\":{\"263\":1}}],[\"ptr=000000000061fe04\",{\"1\":{\"262\":1}}],[\"ptr=000000000061fe0c\",{\"1\":{\"262\":1}}],[\"ptr=000000000061fe00\",{\"1\":{\"262\":1}}],[\"ptr=20\",{\"1\":{\"262\":1}}],[\"ptr=40\",{\"1\":{\"262\":1}}],[\"ptr=10\",{\"1\":{\"262\":1}}],[\"ptr=\",{\"1\":{\"262\":6,\"263\":1,\"265\":1}}],[\"ptr\",{\"1\":{\"262\":15,\"263\":21,\"264\":2,\"265\":14,\"292\":3,\"302\":1,\"304\":1,\"314\":2,\"351\":26,\"354\":2,\"357\":7,\"364\":2,\"373\":1,\"376\":2,\"379\":3}}],[\"p取值运算符\",{\"1\":{\"261\":1}}],[\"pid\",{\"1\":{\"398\":1}}],[\"pi02\",{\"1\":{\"289\":3}}],[\"pi01\",{\"1\":{\"289\":3}}],[\"pi=62\",{\"1\":{\"288\":1}}],[\"pi=3\",{\"1\":{\"288\":3,\"318\":1}}],[\"pi=\",{\"1\":{\"288\":4,\"318\":2}}],[\"pi\",{\"1\":{\"255\":5,\"288\":12,\"310\":2,\"313\":2,\"317\":2,\"318\":9,\"321\":1}}],[\"pivot\",{\"1\":{\"43\":3}}],[\"public\",{\"1\":{\"354\":10,\"357\":4,\"361\":23,\"364\":1,\"367\":5,\"373\":22,\"376\":14,\"379\":1,\"382\":5,\"388\":1,\"389\":1,\"390\":1,\"395\":1,\"396\":1,\"397\":1,\"436\":1,\"437\":1,\"438\":1,\"440\":1}}],[\"puts\",{\"1\":{\"309\":3}}],[\"putchar\",{\"1\":{\"309\":3,\"310\":1}}],[\"put\",{\"1\":{\"167\":1,\"170\":2,\"172\":2}}],[\"pushlast\",{\"1\":{\"163\":1,\"164\":1}}],[\"pushfirst\",{\"1\":{\"163\":1,\"164\":1}}],[\"push\",{\"1\":{\"50\":1,\"156\":1,\"157\":1,\"160\":1,\"161\":1,\"163\":3,\"211\":1}}],[\"port\",{\"1\":{\"388\":5,\"389\":1,\"390\":4,\"391\":3,\"395\":5,\"396\":1,\"397\":4,\"398\":3,\"436\":3,\"437\":5,\"438\":1,\"439\":3,\"440\":4}}],[\"poll服务器也是一个单进程服务器\",{\"1\":{\"391\":1}}],[\"poll服务器调用的poll函数在检测到监听套接字的读事件就绪后就会调用accept获取建立好的连接\",{\"1\":{\"391\":1}}],[\"poll服务器测试\",{\"0\":{\"391\":1}}],[\"poll服务器代码\",{\"0\":{\"387\":1}}],[\"pollin\",{\"1\":{\"389\":1,\"390\":3}}],[\"poll\",{\"1\":{\"389\":2,\"390\":1,\"391\":1}}],[\"pollfd\",{\"1\":{\"389\":3,\"390\":3}}],[\"pollserver\",{\"1\":{\"388\":2,\"389\":1,\"390\":1,\"391\":2}}],[\"pollserver类\",{\"0\":{\"388\":1}}],[\"points\",{\"1\":{\"348\":1,\"351\":1,\"354\":1,\"357\":1,\"361\":1,\"364\":1,\"367\":1,\"370\":1,\"373\":1,\"376\":1,\"379\":1,\"382\":1}}],[\"pointer\",{\"1\":{\"263\":2}}],[\"pos\",{\"1\":{\"344\":10,\"390\":4}}],[\"pos是元素的下标\",{\"1\":{\"344\":1}}],[\"pos==\",{\"1\":{\"344\":3}}],[\"pos=\",{\"1\":{\"344\":3}}],[\"position\",{\"1\":{\"292\":1}}],[\"post\",{\"1\":{\"190\":2}}],[\"postorder\",{\"1\":{\"187\":3,\"190\":1}}],[\"poplast\",{\"1\":{\"163\":1,\"164\":1}}],[\"popfirst\",{\"1\":{\"163\":1,\"164\":1}}],[\"pop\",{\"1\":{\"156\":1,\"157\":1,\"160\":1,\"161\":1,\"163\":3,\"212\":1}}],[\"pow\",{\"1\":{\"128\":3,\"291\":1}}],[\"peer\",{\"1\":{\"390\":11,\"397\":11,\"440\":11}}],[\"peeklast\",{\"1\":{\"163\":2,\"164\":2}}],[\"peekfirst\",{\"1\":{\"163\":2,\"164\":2}}],[\"peek\",{\"1\":{\"156\":2,\"157\":2,\"160\":2,\"161\":2,\"210\":1}}],[\"pegasus\",{\"1\":{\"373\":1}}],[\"person\",{\"1\":{\"373\":6}}],[\"perror\",{\"1\":{\"310\":3,\"403\":5,\"404\":2,\"405\":2,\"406\":5}}],[\"per\",{\"1\":{\"258\":1,\"373\":2}}],[\"permutationsii\",{\"1\":{\"82\":1}}],[\"permutationsi\",{\"1\":{\"81\":1}}],[\"p\",{\"1\":{\"148\":5,\"149\":7,\"182\":5,\"211\":5,\"257\":1,\"262\":9,\"263\":9,\"264\":3,\"265\":10,\"266\":5,\"267\":15,\"302\":2,\"314\":31,\"373\":1,\"404\":3}}],[\"python\",{\"1\":{\"146\":1}}],[\"pragma\",{\"1\":{\"344\":1,\"361\":1,\"388\":1,\"389\":1,\"390\":1,\"403\":1,\"406\":1,\"436\":1,\"437\":1,\"438\":1,\"440\":1}}],[\"private在类外不能访问\",{\"1\":{\"373\":1}}],[\"private继承方式派生类不可见\",{\"1\":{\"373\":1}}],[\"private\",{\"1\":{\"354\":9,\"357\":1,\"361\":18,\"364\":1,\"367\":2,\"373\":2,\"379\":1,\"382\":1,\"388\":1,\"389\":2,\"390\":2,\"395\":1,\"396\":2,\"397\":2,\"437\":1,\"438\":2,\"440\":2}}],[\"price\",{\"1\":{\"297\":7}}],[\"printgraphadjmat\",{\"1\":{\"218\":1}}],[\"print\",{\"1\":{\"167\":1,\"170\":1,\"172\":1,\"251\":1,\"318\":2,\"344\":1,\"345\":1,\"361\":5,\"367\":10,\"379\":2}}],[\"printlinkedlistdeque\",{\"1\":{\"163\":1}}],[\"printlinkedlistqueue\",{\"1\":{\"160\":1}}],[\"printarray\",{\"1\":{\"160\":1,\"163\":1,\"218\":2}}],[\"printf\",{\"1\":{\"156\":1,\"157\":2,\"161\":1,\"164\":2,\"167\":1,\"170\":3,\"172\":3,\"211\":1,\"212\":1,\"218\":2,\"244\":11,\"245\":10,\"246\":3,\"251\":6,\"252\":4,\"255\":2,\"262\":18,\"263\":13,\"264\":4,\"265\":8,\"266\":2,\"267\":3,\"271\":1,\"276\":17,\"277\":6,\"278\":7,\"279\":1,\"280\":9,\"281\":3,\"286\":11,\"287\":3,\"288\":33,\"289\":15,\"290\":2,\"291\":15,\"292\":12,\"293\":12,\"294\":5,\"297\":24,\"298\":9,\"299\":7,\"302\":13,\"309\":10,\"310\":27,\"313\":4,\"314\":11,\"318\":10,\"319\":7,\"321\":10,\"325\":7,\"330\":5,\"331\":4,\"332\":5,\"335\":17,\"337\":7,\"338\":3,\"344\":39,\"345\":3,\"357\":2,\"403\":4,\"404\":4,\"405\":3,\"406\":4}}],[\"proc\",{\"1\":{\"391\":2,\"398\":3,\"439\":2}}],[\"producerthread\",{\"1\":{\"379\":2}}],[\"producer\",{\"1\":{\"379\":2}}],[\"protected在类外不能访问\",{\"1\":{\"373\":1}}],[\"protected继承派生类可见\",{\"1\":{\"373\":1}}],[\"protected\",{\"1\":{\"373\":4}}],[\"project\",{\"1\":{\"320\":1}}],[\"pro\",{\"1\":{\"297\":2}}],[\"programming\",{\"1\":{\"92\":1}}],[\"preparation\",{\"1\":{\"320\":1}}],[\"preprocessor\",{\"1\":{\"317\":1}}],[\"pre\",{\"1\":{\"170\":4,\"190\":2,\"194\":6,\"195\":5,\"219\":9}}],[\"prev\",{\"1\":{\"153\":1,\"163\":1}}],[\"preordersize\",{\"1\":{\"69\":1}}],[\"preorder\",{\"1\":{\"65\":1,\"66\":1,\"67\":3,\"68\":3,\"69\":8,\"74\":3,\"75\":3,\"76\":3,\"187\":3,\"190\":1}}],[\"pass\",{\"1\":{\"318\":1}}],[\"partially\",{\"1\":{\"379\":2}}],[\"partiallybound\",{\"1\":{\"379\":2}}],[\"partialspecializecontainer\",{\"1\":{\"367\":2}}],[\"partition\",{\"1\":{\"42\":1,\"43\":2}}],[\"parameter\",{\"1\":{\"379\":4}}],[\"parameters\",{\"1\":{\"379\":2}}],[\"param\",{\"1\":{\"367\":7}}],[\"parent\",{\"1\":{\"180\":1,\"209\":1,\"211\":1}}],[\"pair<int\",{\"1\":{\"379\":1}}],[\"pairset\",{\"1\":{\"167\":2}}],[\"pair\",{\"1\":{\"167\":14,\"170\":5,\"172\":42,\"379\":9}}],[\"pathsize\",{\"1\":{\"75\":2,\"76\":2,\"77\":4}}],[\"pathsize++\",{\"1\":{\"75\":1,\"76\":1,\"77\":1}}],[\"path\",{\"1\":{\"75\":6,\"76\":2,\"77\":3,\"214\":1}}],[\"pan\",{\"1\":{\"73\":2}}],[\"总线\",{\"0\":{\"489\":1,\"490\":1}}],[\"总是确保释放已分配的内存\",{\"1\":{\"315\":1}}],[\"总是会优先遍历下一个最小节点\",{\"1\":{\"196\":1}}],[\"总结\",{\"1\":{\"302\":1}}],[\"总结来看\",{\"1\":{\"85\":1}}],[\"总的来看\",{\"1\":{\"142\":1}}],[\"总的来说\",{\"1\":{\"101\":1}}],[\"总体上\",{\"1\":{\"283\":1}}],[\"总体时间复杂度为o\",{\"1\":{\"90\":1}}],[\"总体时间复杂度为\",{\"1\":{\"61\":1}}],[\"总体使用o\",{\"1\":{\"43\":2,\"223\":1,\"225\":1}}],[\"总和为\",{\"1\":{\"37\":1}}],[\"为5个myclass对象分配足够的空间\",{\"1\":{\"364\":1}}],[\"为129\",{\"1\":{\"327\":1}}],[\"为数组指针取别名\",{\"1\":{\"304\":1}}],[\"为字符指针起别名为\",{\"1\":{\"304\":1}}],[\"为struct\",{\"1\":{\"304\":1}}],[\"为类型\",{\"1\":{\"304\":1}}],[\"为避免死循环\",{\"1\":{\"298\":1}}],[\"为真\",{\"1\":{\"297\":1}}],[\"为扩展名\",{\"1\":{\"272\":1}}],[\"为指针变量赋一个\",{\"1\":{\"267\":1}}],[\"为指针变量赋一个null\",{\"1\":{\"266\":1}}],[\"为防止冲突\",{\"1\":{\"258\":1}}],[\"为起点\",{\"1\":{\"223\":1}}],[\"为该顶点的邻接顶点列表\",{\"1\":{\"219\":1}}],[\"为顶点实例\",{\"1\":{\"219\":1}}],[\"为原点\",{\"1\":{\"201\":1,\"202\":1}}],[\"为什么要强调对质数取模\",{\"1\":{\"177\":1}}],[\"为什么分治可以提升算法效率\",{\"1\":{\"60\":1}}],[\"为余数\",{\"1\":{\"128\":1}}],[\"为\",{\"1\":{\"128\":1,\"304\":2,\"327\":1}}],[\"为根节点的递归树\",{\"1\":{\"103\":1}}],[\"为地面\",{\"1\":{\"98\":1}}],[\"为此\",{\"1\":{\"94\":1,\"163\":1,\"168\":1,\"172\":1}}],[\"为为起始点\",{\"1\":{\"93\":1}}],[\"为解决此问题\",{\"1\":{\"86\":1}}],[\"为解释这一点\",{\"1\":{\"75\":1}}],[\"为当前节点的左子节点和右子节点\",{\"1\":{\"77\":1}}],[\"为节点遍历路径\",{\"1\":{\"77\":1}}],[\"为缓冲柱\",{\"1\":{\"72\":2}}],[\"为目标柱\",{\"1\":{\"72\":2}}],[\"为例\",{\"1\":{\"61\":1}}],[\"为实现平均分配\",{\"1\":{\"51\":1}}],[\"为基准数\",{\"1\":{\"42\":1,\"43\":1}}],[\"为了避免这种情况\",{\"1\":{\"321\":1}}],[\"为了避免大数越界\",{\"1\":{\"20\":1}}],[\"为了能够有效地访问到每个内存单元\",{\"1\":{\"261\":1}}],[\"为了有效的使用内存\",{\"1\":{\"261\":1}}],[\"为了提高阅读性\",{\"1\":{\"258\":1}}],[\"为了提升效率\",{\"1\":{\"169\":1}}],[\"为了提升算法效率\",{\"1\":{\"94\":1}}],[\"为了提升查询m的效率\",{\"1\":{\"69\":1}}],[\"为了防止头文件myheader\",{\"1\":{\"321\":1}}],[\"为了防止重复遍历顶点\",{\"1\":{\"223\":1}}],[\"为了防止从哈希值推导出原始密码等逆向工程\",{\"1\":{\"176\":1}}],[\"为了方便添加与删除顶点\",{\"1\":{\"219\":1}}],[\"为了方便区分两个重复元素1\",{\"1\":{\"82\":1}}],[\"为了尽量减少元素索引的变动\",{\"1\":{\"212\":1}}],[\"为了便于使用\",{\"1\":{\"205\":1}}],[\"为了保持二叉搜索树\",{\"1\":{\"194\":1}}],[\"为了保护用户密码的安全\",{\"1\":{\"176\":1}}],[\"为了保证重叠子问题只被计算一次\",{\"1\":{\"109\":1}}],[\"为了实现插入节点\",{\"1\":{\"194\":1}}],[\"为了实现\",{\"1\":{\"176\":1}}],[\"为了实现每个元素只被选择一次\",{\"1\":{\"81\":1}}],[\"为了降低哈希冲突的发生概率\",{\"1\":{\"175\":1}}],[\"为了更加充分地使用哈希表的空间\",{\"1\":{\"172\":1}}],[\"为了更形象地展示解题步骤\",{\"1\":{\"102\":1}}],[\"为了解决该问题\",{\"1\":{\"169\":1,\"172\":1}}],[\"为了解决此问题\",{\"1\":{\"161\":1,\"190\":1}}],[\"为了满足列约束\",{\"1\":{\"89\":1}}],[\"为了满足以上约束条件\",{\"1\":{\"76\":1}}],[\"为了去除重复子集\",{\"1\":{\"85\":1}}],[\"为了缩短整体代码\",{\"1\":{\"81\":1}}],[\"为了表示字符\",{\"1\":{\"18\":1}}],[\"rdonly\",{\"1\":{\"403\":2,\"404\":1,\"405\":1,\"406\":2}}],[\"run\",{\"1\":{\"389\":1,\"396\":1,\"438\":1}}],[\"runtime\",{\"1\":{\"382\":8}}],[\"running\",{\"1\":{\"379\":13}}],[\"rust\",{\"1\":{\"146\":1}}],[\"rtt1机制\",{\"1\":{\"357\":1}}],[\"rb\",{\"1\":{\"310\":1,\"344\":1}}],[\"rh\",{\"1\":{\"199\":3}}],[\"rprev\",{\"1\":{\"163\":4}}],[\"range是遍历的范围\",{\"1\":{\"379\":1}}],[\"range\",{\"1\":{\"379\":1}}],[\"rand\",{\"1\":{\"140\":1}}],[\"randomnum\",{\"1\":{\"140\":2}}],[\"randomindex\",{\"1\":{\"140\":2}}],[\"randomaccess\",{\"1\":{\"140\":1}}],[\"radius\",{\"1\":{\"318\":3}}],[\"radixsort\",{\"1\":{\"56\":1}}],[\"radix\",{\"1\":{\"55\":1}}],[\"rate\",{\"1\":{\"257\":1}}],[\"round\",{\"1\":{\"291\":2}}],[\"rotate\",{\"1\":{\"205\":1,\"206\":1,\"207\":1}}],[\"rothash\",{\"1\":{\"177\":1}}],[\"rows\",{\"1\":{\"246\":3,\"298\":3}}],[\"row+col的范围是\",{\"1\":{\"90\":1}}],[\"row\",{\"1\":{\"89\":1,\"90\":7}}],[\"root\",{\"1\":{\"69\":9,\"74\":6,\"75\":6,\"76\":7,\"181\":1,\"186\":2,\"187\":15,\"193\":1,\"195\":2,\"207\":1}}],[\"r\",{\"1\":{\"48\":6,\"68\":1,\"69\":3,\"161\":1,\"164\":2,\"212\":6,\"241\":3,\"245\":1,\"255\":6,\"293\":1,\"310\":4,\"332\":1}}],[\"rights\",{\"1\":{\"344\":1,\"345\":1,\"348\":1,\"351\":1,\"354\":1,\"357\":1,\"361\":1,\"364\":1,\"367\":1,\"370\":1,\"373\":1,\"376\":1,\"379\":1,\"382\":1}}],[\"rightrotate\",{\"1\":{\"201\":1,\"205\":3}}],[\"right\",{\"1\":{\"42\":2,\"43\":6,\"46\":13,\"180\":3,\"190\":1,\"193\":1,\"198\":1,\"202\":2,\"209\":1,\"212\":1,\"379\":2}}],[\"reuseaddr\",{\"1\":{\"436\":1}}],[\"revs\",{\"1\":{\"396\":3,\"397\":4}}],[\"revents\",{\"1\":{\"389\":1,\"390\":3}}],[\"revalue\",{\"1\":{\"379\":2}}],[\"review\",{\"1\":{\"348\":1,\"351\":1,\"354\":1,\"357\":1,\"361\":1,\"364\":1,\"367\":1,\"370\":1,\"373\":1,\"376\":1,\"379\":1,\"382\":1}}],[\"reference\",{\"1\":{\"379\":8}}],[\"ref\",{\"1\":{\"373\":1,\"379\":4}}],[\"ret\",{\"1\":{\"361\":18,\"404\":7}}],[\"returnsize\",{\"1\":{\"29\":3,\"30\":3,\"81\":3,\"82\":3,\"90\":3,\"190\":8}}],[\"return\",{\"1\":{\"20\":2,\"21\":2,\"23\":2,\"24\":1,\"26\":2,\"27\":2,\"29\":2,\"30\":3,\"42\":1,\"43\":2,\"46\":1,\"56\":1,\"64\":5,\"69\":3,\"73\":1,\"74\":1,\"75\":2,\"76\":1,\"77\":5,\"81\":2,\"82\":2,\"85\":2,\"86\":1,\"90\":2,\"92\":1,\"93\":3,\"94\":4,\"95\":2,\"96\":2,\"98\":4,\"99\":2,\"103\":3,\"104\":4,\"105\":1,\"106\":1,\"108\":3,\"109\":4,\"110\":1,\"111\":1,\"113\":1,\"120\":1,\"124\":1,\"128\":4,\"140\":1,\"144\":2,\"145\":1,\"146\":1,\"149\":1,\"150\":2,\"151\":2,\"153\":1,\"156\":6,\"157\":7,\"160\":5,\"161\":7,\"163\":10,\"164\":11,\"167\":1,\"170\":7,\"172\":9,\"177\":4,\"180\":1,\"186\":1,\"187\":3,\"190\":9,\"193\":1,\"194\":2,\"195\":2,\"198\":1,\"199\":4,\"201\":1,\"202\":1,\"205\":5,\"206\":3,\"207\":3,\"209\":3,\"210\":1,\"211\":1,\"212\":2,\"218\":5,\"219\":7,\"223\":5,\"225\":2,\"244\":4,\"245\":3,\"246\":1,\"250\":1,\"251\":1,\"252\":1,\"255\":2,\"259\":1,\"262\":4,\"263\":3,\"264\":3,\"265\":1,\"266\":1,\"267\":2,\"276\":4,\"277\":1,\"278\":1,\"279\":1,\"280\":3,\"281\":1,\"286\":11,\"287\":3,\"288\":6,\"289\":2,\"290\":1,\"291\":5,\"292\":1,\"293\":1,\"294\":1,\"297\":5,\"298\":4,\"299\":3,\"302\":2,\"309\":3,\"310\":12,\"313\":1,\"314\":6,\"317\":1,\"318\":5,\"319\":5,\"325\":2,\"330\":2,\"331\":1,\"332\":1,\"335\":1,\"337\":2,\"338\":1,\"344\":10,\"345\":1,\"348\":16,\"351\":1,\"354\":7,\"357\":7,\"361\":44,\"364\":2,\"367\":10,\"370\":3,\"373\":2,\"376\":6,\"379\":36,\"382\":6,\"389\":2,\"390\":2,\"391\":1,\"398\":1,\"403\":8,\"404\":3,\"405\":3,\"406\":7,\"436\":1,\"439\":1,\"440\":2}}],[\"reinterpret\",{\"1\":{\"357\":3}}],[\"regular\",{\"1\":{\"321\":3}}],[\"register\",{\"1\":{\"259\":1,\"334\":2}}],[\"rewind\",{\"1\":{\"310\":3}}],[\"reallco函数realloc\",{\"1\":{\"314\":1}}],[\"realloc\",{\"1\":{\"186\":1,\"314\":4,\"344\":1}}],[\"readfds\",{\"1\":{\"438\":5,\"439\":4,\"440\":3}}],[\"ready\",{\"1\":{\"379\":2}}],[\"reading\",{\"1\":{\"370\":1}}],[\"read\",{\"1\":{\"310\":3,\"370\":2,\"390\":2,\"403\":3,\"404\":2,\"405\":2,\"406\":5,\"440\":2}}],[\"rear++\",{\"1\":{\"186\":3}}],[\"rear\",{\"1\":{\"160\":1,\"161\":9,\"163\":3,\"164\":2,\"186\":3,\"223\":1}}],[\"removeedgehelper\",{\"1\":{\"219\":3}}],[\"removeedge\",{\"1\":{\"218\":1,\"219\":1}}],[\"removevertex\",{\"1\":{\"218\":1,\"219\":1}}],[\"removehelper\",{\"1\":{\"207\":5}}],[\"removeitem\",{\"1\":{\"142\":1,\"149\":1,\"167\":1,\"170\":1,\"172\":1,\"195\":2,\"207\":1}}],[\"remove\",{\"1\":{\"142\":1,\"149\":1,\"195\":1,\"207\":1}}],[\"recv\",{\"1\":{\"397\":2}}],[\"recursive\",{\"1\":{\"379\":2}}],[\"recursion\",{\"1\":{\"136\":1}}],[\"recordsolution\",{\"1\":{\"77\":3}}],[\"reserved\",{\"1\":{\"344\":1,\"345\":1,\"348\":1,\"351\":1,\"354\":1,\"357\":1,\"361\":1,\"364\":1,\"367\":1,\"370\":1,\"373\":1,\"376\":1,\"379\":1,\"382\":1}}],[\"res=99\",{\"1\":{\"281\":1}}],[\"res=\",{\"1\":{\"281\":1}}],[\"res4\",{\"1\":{\"276\":2}}],[\"res3\",{\"1\":{\"276\":2}}],[\"res2\",{\"1\":{\"276\":2}}],[\"res1\",{\"1\":{\"276\":2}}],[\"restrict\",{\"1\":{\"259\":1}}],[\"res使用常数大小的额外空间\",{\"1\":{\"124\":1}}],[\"result3\",{\"1\":{\"310\":6}}],[\"result2\",{\"1\":{\"310\":6}}],[\"result1\",{\"1\":{\"310\":6}}],[\"result第三代\",{\"1\":{\"240\":1}}],[\"result\",{\"1\":{\"92\":2,\"94\":2,\"95\":2,\"357\":4,\"367\":4,\"379\":2,\"382\":3}}],[\"rescolsizes\",{\"1\":{\"85\":2,\"86\":1}}],[\"ressize\",{\"1\":{\"75\":1,\"76\":1,\"77\":1,\"81\":5,\"82\":5,\"85\":3,\"86\":1,\"90\":6,\"223\":2,\"225\":6}}],[\"ressize++\",{\"1\":{\"74\":1,\"75\":1,\"76\":1,\"77\":1,\"85\":2,\"86\":1}}],[\"res\",{\"1\":{\"29\":4,\"30\":4,\"54\":7,\"56\":5,\"74\":2,\"75\":3,\"76\":1,\"77\":5,\"81\":7,\"82\":7,\"85\":2,\"86\":1,\"90\":9,\"92\":9,\"98\":2,\"99\":2,\"105\":2,\"106\":2,\"110\":2,\"111\":2,\"120\":4,\"124\":4,\"145\":4,\"190\":18,\"223\":3,\"225\":9,\"278\":3,\"281\":2}}],[\"≤右子数组任意元素\",{\"1\":{\"42\":1}}],[\"≤\",{\"1\":{\"42\":1,\"85\":3,\"128\":1,\"208\":1}}],[\"且不可见\",{\"1\":{\"373\":1}}],[\"且不能将大圆盘放在小圆盘上\",{\"1\":{\"79\":1}}],[\"且最左边位变为1\",{\"1\":{\"327\":1}}],[\"且最底层节点尽量靠左填充\",{\"1\":{\"183\":1}}],[\"且省略枚举名称\",{\"1\":{\"301\":1}}],[\"且循环开始前就执行循环条件表达式每次循环都执行\",{\"1\":{\"298\":1}}],[\"且随着循环次数增加\",{\"1\":{\"298\":1}}],[\"且与函数中的局部变量\",{\"1\":{\"288\":1}}],[\"且高度ht\",{\"1\":{\"123\":1}}],[\"且总价值最大\",{\"1\":{\"117\":1}}],[\"且总体操作数量较少\",{\"1\":{\"33\":1}}],[\"且\",{\"1\":{\"82\":1}}],[\"且满足\",{\"1\":{\"42\":1}}],[\"相差32\",{\"1\":{\"332\":1}}],[\"相等\",{\"1\":{\"263\":2}}],[\"相等元素剪枝\",{\"1\":{\"82\":1,\"83\":1,\"86\":1}}],[\"相等元素的相对位置可能发生变化\",{\"1\":{\"48\":1}}],[\"相等元素的次序保持不变\",{\"1\":{\"46\":1}}],[\"相等元素在数组中的相对顺序不发生改变\",{\"1\":{\"33\":1}}],[\"相关代码示例如下\",{\"1\":{\"288\":1}}],[\"相关案例如下\",{\"1\":{\"262\":1}}],[\"相关过程实现如下图和以下代码所示\",{\"1\":{\"74\":1}}],[\"相较于线性关系\",{\"1\":{\"213\":1}}],[\"相较于单向链表\",{\"1\":{\"153\":1}}],[\"相反\",{\"1\":{\"212\":1}}],[\"相连接\",{\"1\":{\"146\":1}}],[\"相应地\",{\"1\":{\"101\":1,\"187\":1,\"202\":1}}],[\"相比于\",{\"1\":{\"291\":2}}],[\"相比于上题\",{\"1\":{\"86\":1}}],[\"相比之下\",{\"1\":{\"148\":1}}],[\"相比基于前序遍历的代码实现\",{\"1\":{\"77\":1}}],[\"相当于保留一部分给你修改\",{\"1\":{\"367\":1}}],[\"相当于定死模板特化内容\",{\"1\":{\"367\":1}}],[\"相当于操作的变量别名\",{\"1\":{\"348\":1}}],[\"相当于操作的是临时变量\",{\"1\":{\"348\":1}}],[\"相当于返回的n的别名\",{\"1\":{\"348\":1}}],[\"相当于\",{\"1\":{\"50\":1,\"304\":2}}],[\"相同或更大\",{\"1\":{\"331\":1}}],[\"相同为假\",{\"1\":{\"280\":1}}],[\"相同类型的指针可以进行减法运算\",{\"1\":{\"262\":1}}],[\"相同尺寸的记忆列表\",{\"1\":{\"104\":1}}],[\"相同的记录作用\",{\"1\":{\"95\":1}}],[\"相同\",{\"1\":{\"44\":1}}],[\"相遇时停止\",{\"1\":{\"42\":1}}],[\"小张\",{\"1\":{\"361\":2}}],[\"小写\",{\"1\":{\"325\":1}}],[\"小写字符转大写\",{\"1\":{\"293\":1}}],[\"小顶堆\",{\"1\":{\"208\":2}}],[\"小圆盘必须时刻位于大圆盘之上\",{\"1\":{\"70\":1}}],[\"小\",{\"1\":{\"42\":1,\"101\":1}}],[\"小于\",{\"1\":{\"27\":1}}],[\"哨兵划分的递归层数为logn\",{\"1\":{\"43\":1}}],[\"哨兵划分的流程如下图所示\",{\"1\":{\"42\":1}}],[\"哨兵划分完成后\",{\"1\":{\"42\":1}}],[\"哨兵划分\",{\"1\":{\"42\":2,\"43\":4}}],[\"应用层\",{\"0\":{\"520\":1,\"521\":1}}],[\"应用广泛\",{\"1\":{\"42\":1}}],[\"应该先存储到一个输出缓冲区当中\",{\"1\":{\"442\":1}}],[\"应该将读取到的数据存储到一个输入缓冲区当中\",{\"1\":{\"442\":1}}],[\"应该使用传入的参数的哪些位置\",{\"1\":{\"379\":1}}],[\"应该越来越趋向于不成立\",{\"1\":{\"298\":1}}],[\"应被替换为\",{\"1\":{\"146\":1}}],[\"应当极难找到两个不同的输入\",{\"1\":{\"176\":1}}],[\"应当剪枝\",{\"1\":{\"85\":1}}],[\"应当提前识别并剪枝\",{\"1\":{\"82\":1}}],[\"应运而生unicode\",{\"1\":{\"18\":1}}],[\"快速排序是选取一个基准值\",{\"1\":{\"63\":1}}],[\"快速排序能在o\",{\"1\":{\"44\":1}}],[\"快速排序在效率方面应该具有一定的优势\",{\"1\":{\"44\":1}}],[\"快速排序为什么快\",{\"0\":{\"44\":1}}],[\"快速排序的比较\",{\"1\":{\"44\":1}}],[\"快速排序的整体流程如下图所示\",{\"1\":{\"43\":1}}],[\"快速排序的核心操作是\",{\"1\":{\"42\":1}}],[\"快速排序类\",{\"1\":{\"42\":2,\"43\":3}}],[\"快速排序\",{\"1\":{\"42\":1,\"43\":1,\"60\":1,\"63\":1}}],[\"快速排序算法流程\",{\"0\":{\"43\":1}}],[\"快速排序算法\",{\"0\":{\"42\":1}}],[\"向上转型进行了切片\",{\"1\":{\"376\":1}}],[\"向上转型切片\",{\"1\":{\"376\":1}}],[\"向上转型\",{\"1\":{\"373\":2}}],[\"向上转型本来就安全\",{\"1\":{\"357\":1}}],[\"向外提供一个获取对象的static接口\",{\"1\":{\"354\":1}}],[\"向通讯录中添加联系人\",{\"1\":{\"342\":1}}],[\"向前移动\",{\"1\":{\"262\":2}}],[\"向后移动\",{\"1\":{\"262\":2}}],[\"向左上移动\",{\"1\":{\"218\":1}}],[\"向左旋转\",{\"1\":{\"202\":1}}],[\"向下整除\",{\"1\":{\"209\":1}}],[\"向下取整\",{\"1\":{\"20\":1}}],[\"向右旋转\",{\"1\":{\"201\":2}}],[\"向右移动一位\",{\"1\":{\"41\":1}}],[\"向内移动短板\",{\"1\":{\"124\":1}}],[\"向以上代码输入数组\",{\"1\":{\"85\":1}}],[\"然后再进行进程程序替换即可这里也无需更改客户端的代码\",{\"1\":{\"405\":1}}],[\"然后再调用base类的虚析构函数\",{\"1\":{\"376\":1}}],[\"然后再创建结构体变量\",{\"1\":{\"302\":1}}],[\"然后求和\",{\"1\":{\"326\":2}}],[\"然后遍历下一个顶点的所有邻接顶点\",{\"1\":{\"222\":1}}],[\"然后遍历链表并对比\",{\"1\":{\"170\":1}}],[\"然后循环执行此操作\",{\"1\":{\"212\":1}}],[\"然后继续执行此操作\",{\"1\":{\"211\":1}}],[\"然后构建引用\",{\"1\":{\"182\":1}}],[\"然后与存储的哈希值进行比较\",{\"1\":{\"176\":1}}],[\"然后把原数组元素依次复制到新数组\",{\"1\":{\"145\":1}}],[\"然后把数组分为两个子数组\",{\"1\":{\"63\":1}}],[\"然后不断重复或累加这些步骤\",{\"1\":{\"136\":1}}],[\"然后对每个桶内的元素进行排序\",{\"1\":{\"63\":1}}],[\"然后根据目标值与中间元素值比较结果\",{\"1\":{\"63\":1}}],[\"然后分别找出两部分中的最近点对\",{\"1\":{\"63\":1}}],[\"然后返回步骤\",{\"1\":{\"56\":1}}],[\"然后创建一个长度为m+1的辅助数组\",{\"1\":{\"53\":1}}],[\"然后\",{\"1\":{\"43\":1,\"49\":1,\"321\":1,\"361\":1}}],[\"然后交换这两个元素\",{\"1\":{\"42\":1}}],[\"然后将每步得到的余数倒过来\",{\"1\":{\"326\":2}}],[\"然后将其显示在屏幕上函数原型\",{\"1\":{\"309\":1}}],[\"然后将该顶点的所有邻接顶点加入到队列尾部\",{\"1\":{\"223\":1}}],[\"然后将节点\",{\"1\":{\"170\":1}}],[\"然后将\",{\"1\":{\"40\":1}}],[\"然而这三者都属于深度优先遍历\",{\"1\":{\"225\":1}}],[\"然而这样做不够优雅\",{\"1\":{\"82\":1}}],[\"然而矩阵的空间复杂度为o\",{\"1\":{\"216\":1}}],[\"然而对于某些要求不高的场景\",{\"1\":{\"177\":1}}],[\"然而对于汉诺塔问题\",{\"1\":{\"70\":1}}],[\"然而该哈希算法过于简单\",{\"1\":{\"176\":1}}],[\"然而无论是开放寻址还是链式地址\",{\"1\":{\"175\":1}}],[\"然而子集不区分选择顺序\",{\"1\":{\"85\":1}}],[\"然而\",{\"1\":{\"18\":1,\"78\":1,\"99\":2,\"101\":1,\"158\":1,\"161\":1,\"172\":2,\"173\":1,\"185\":1,\"191\":1,\"217\":1}}],[\"设置端口复用\",{\"1\":{\"436\":1}}],[\"设置标识\",{\"1\":{\"361\":1}}],[\"设置学生基本信息\",{\"1\":{\"361\":1}}],[\"设置指定字符\",{\"1\":{\"294\":1}}],[\"设置一个循环\",{\"1\":{\"42\":1}}],[\"设无向图的顶点总数为n\",{\"1\":{\"219\":1}}],[\"设邻接矩阵为m\",{\"1\":{\"216\":1}}],[\"设图的顶点数量为n\",{\"1\":{\"216\":1}}],[\"设节点总数为n\",{\"1\":{\"211\":1}}],[\"设当前格子的行列索引为\",{\"1\":{\"102\":1}}],[\"设当前数字为\",{\"1\":{\"53\":1}}],[\"设棋盘中某个格子的行列索引为\",{\"1\":{\"89\":1}}],[\"设定下一轮从索引i+1开始向后遍历\",{\"1\":{\"86\":1}}],[\"设搜索过程中的选择序列为\",{\"1\":{\"85\":1}}],[\"设树的节点数量为n\",{\"1\":{\"69\":1}}],[\"设数组长度\",{\"1\":{\"167\":1}}],[\"设数组的长度n\",{\"1\":{\"38\":1}}],[\"设数组的长度为n\",{\"1\":{\"36\":1,\"48\":1}}],[\"设数据量为n\",{\"1\":{\"56\":1}}],[\"设基准元素为\",{\"1\":{\"40\":1}}],[\"插入位置在\",{\"1\":{\"194\":2}}],[\"插入节点\",{\"1\":{\"194\":2,\"206\":1}}],[\"插入节点使用o\",{\"1\":{\"194\":1}}],[\"插入操作流程如下图所示\",{\"1\":{\"194\":1}}],[\"插入操作会提前终止\",{\"1\":{\"41\":1}}],[\"插入结点\",{\"0\":{\"148\":1,\"194\":1}}],[\"插入元素\",{\"0\":{\"141\":1},\"1\":{\"172\":1,\"174\":1}}],[\"插入与删除节点\",{\"1\":{\"182\":2}}],[\"插入与删除操作需要移动大量的元素\",{\"1\":{\"138\":1}}],[\"插入与删除效率低\",{\"1\":{\"138\":1}}],[\"插入和删除等操作都可以视为分治策略的应用\",{\"1\":{\"63\":1}}],[\"插入到已排序区间\",{\"1\":{\"41\":1}}],[\"插入排序更快\",{\"1\":{\"60\":1}}],[\"插入排序达到最佳时间复杂度o\",{\"1\":{\"41\":1}}],[\"插入排序的整体流程如下图所示\",{\"1\":{\"41\":1}}],[\"插入排序\",{\"0\":{\"472\":1},\"1\":{\"40\":1,\"41\":1,\"44\":1}}],[\"插入排序算法流程\",{\"0\":{\"41\":1}}],[\"插入排序算法\",{\"0\":{\"40\":1}}],[\"插入点的索引i越界\",{\"1\":{\"26\":1}}],[\"标准日志输出流\",{\"1\":{\"370\":1}}],[\"标准错误输出流\",{\"1\":{\"370\":1}}],[\"标准输出和标准错误\",{\"1\":{\"398\":1}}],[\"标准输出流\",{\"1\":{\"370\":1}}],[\"标准输入流\",{\"1\":{\"370\":1}}],[\"标准库异常体系\",{\"1\":{\"382\":1}}],[\"标准库的头文件\",{\"1\":{\"330\":1}}],[\"标准库头文件是系统提供的头文件\",{\"1\":{\"320\":1}}],[\"标准文件\",{\"1\":{\"309\":1}}],[\"标准语法规则如下\",{\"1\":{\"251\":1}}],[\"标签名\",{\"1\":{\"299\":2}}],[\"标签\",{\"1\":{\"299\":1}}],[\"标识符命名规范\",{\"0\":{\"257\":1}}],[\"标识符\",{\"0\":{\"256\":1}}],[\"标识符常量\",{\"1\":{\"254\":1,\"288\":4}}],[\"标记该顶点已被访问\",{\"1\":{\"223\":1}}],[\"标志优化\",{\"1\":{\"39\":1}}],[\"标点符号甚至表情符号等\",{\"1\":{\"16\":1}}],[\"经过的边构成的序列被称为从\",{\"1\":{\"214\":1}}],[\"经过哈希函数得到桶索引\",{\"1\":{\"170\":1}}],[\"经过记忆化处理后\",{\"1\":{\"94\":1}}],[\"经过三轮选择后到达叶节点\",{\"1\":{\"81\":1}}],[\"经过优化\",{\"1\":{\"39\":1}}],[\"经过n\",{\"1\":{\"36\":1,\"38\":1}}],[\"对端连接关闭\",{\"1\":{\"390\":1,\"397\":1,\"440\":1}}],[\"对其进行等待\",{\"1\":{\"379\":1}}],[\"对该线程进行等待\",{\"1\":{\"379\":1}}],[\"对该地址释放第二次如果忘记调用free\",{\"1\":{\"314\":1}}],[\"对齐数1\",{\"1\":{\"361\":1}}],[\"对齐数4\",{\"1\":{\"361\":1}}],[\"对齐数\",{\"1\":{\"361\":1}}],[\"对getinstance函数中创建单例对象的过程进行保护\",{\"1\":{\"354\":1}}],[\"对原引用变量\",{\"1\":{\"348\":1}}],[\"对原数组执行一次\",{\"1\":{\"43\":1}}],[\"对我们并不陌生\",{\"1\":{\"308\":1}}],[\"对操作数的副作用是一致的++i\",{\"1\":{\"276\":1}}],[\"对字符数组只能对各个元素赋值\",{\"1\":{\"263\":1}}],[\"对变量\",{\"1\":{\"250\":1,\"251\":1}}],[\"对上图\",{\"1\":{\"219\":1}}],[\"对缓存友好\",{\"1\":{\"191\":1}}],[\"对输入的每个字符的\",{\"1\":{\"177\":1}}],[\"对象整体定义调用构造函数\",{\"1\":{\"361\":1}}],[\"对象定义\",{\"1\":{\"361\":1}}],[\"对象初始化\",{\"1\":{\"361\":2}}],[\"对象后面不用跟括号\",{\"1\":{\"361\":1}}],[\"对象\",{\"1\":{\"146\":1}}],[\"对象列表\",{\"1\":{\"120\":1}}],[\"对角线分为主对角线\",{\"1\":{\"87\":1}}],[\"对\",{\"1\":{\"85\":1,\"86\":1,\"351\":1}}],[\"对应科学计数法表示的浮点数\",{\"1\":{\"331\":1}}],[\"对应double类型\",{\"1\":{\"331\":1}}],[\"对应dp\",{\"1\":{\"109\":1}}],[\"对应节点从链表中删除\",{\"1\":{\"219\":1}}],[\"对应节点\",{\"1\":{\"219\":1}}],[\"对应\",{\"1\":{\"218\":2}}],[\"对应的是long\",{\"1\":{\"331\":1}}],[\"对应的链表\",{\"1\":{\"219\":1}}],[\"对应的数组索引\",{\"1\":{\"167\":1}}],[\"对应的键值对在数组中的存储位置\",{\"1\":{\"167\":1}}],[\"对应的桶索引\",{\"1\":{\"172\":4}}],[\"对应的桶\",{\"1\":{\"167\":1}}],[\"对应的子问题是\",{\"1\":{\"102\":1}}],[\"对应一个开启的\",{\"1\":{\"73\":1}}],[\"对应数字\",{\"1\":{\"53\":1}}],[\"对数组元素的第\",{\"1\":{\"56\":1}}],[\"对学号的第k位执行\",{\"1\":{\"56\":1}}],[\"对各个桶执行排序\",{\"1\":{\"50\":1}}],[\"对每个桶分别执行排序\",{\"1\":{\"50\":1}}],[\"对左子数组和右子数组分别递归执行\",{\"1\":{\"43\":1}}],[\"对剩余n\",{\"1\":{\"38\":1}}],[\"对n个元素执行\",{\"1\":{\"38\":1}}],[\"对于全局变量\",{\"1\":{\"288\":1}}],[\"对于无向图\",{\"1\":{\"216\":1}}],[\"对于有向图\",{\"1\":{\"214\":1}}],[\"对于非连通图\",{\"1\":{\"214\":1}}],[\"对于连通图\",{\"1\":{\"214\":1}}],[\"对于大顶堆\",{\"1\":{\"208\":1}}],[\"对于大数据量的情况\",{\"1\":{\"33\":1}}],[\"对于上述失衡二叉树的镜像情况\",{\"1\":{\"204\":1}}],[\"对于上述示例中的哈希函数\",{\"1\":{\"168\":1}}],[\"对于下图中的失衡节点\",{\"1\":{\"203\":1}}],[\"对于根节点\",{\"1\":{\"192\":1}}],[\"对于密码学的相关应用\",{\"1\":{\"176\":1}}],[\"对于相同的输入\",{\"1\":{\"176\":1}}],[\"对于链式地址哈希表\",{\"1\":{\"175\":1}}],[\"对于双向队列而言\",{\"1\":{\"163\":1}}],[\"对于环形数组\",{\"1\":{\"161\":1}}],[\"对于入栈操作\",{\"1\":{\"156\":1}}],[\"对于n\",{\"1\":{\"128\":1}}],[\"对于物品i\",{\"1\":{\"118\":1}}],[\"对于很多复杂问题来说\",{\"1\":{\"114\":1}}],[\"对于零钱兑换问题\",{\"1\":{\"114\":1}}],[\"对于每个物体都有不放入和放入两种决策\",{\"1\":{\"107\":1}}],[\"对于问题dp\",{\"1\":{\"93\":1}}],[\"对于问题f\",{\"1\":{\"71\":2,\"72\":1}}],[\"对于一个3阶楼梯\",{\"1\":{\"92\":1}}],[\"对于许多组合优化问题\",{\"1\":{\"79\":1}}],[\"对于这种只有第一次需要加锁保护的场景可以使用双检查加锁\",{\"1\":{\"354\":1}}],[\"对于这些问题\",{\"1\":{\"78\":1}}],[\"对于这两个子问题f\",{\"1\":{\"72\":1}}],[\"对于例题一\",{\"1\":{\"75\":1}}],[\"对于此题\",{\"1\":{\"74\":1}}],[\"对于\",{\"1\":{\"18\":1}}],[\"对于长度为n字节的字符\",{\"1\":{\"18\":1}}],[\"对于长度为\",{\"1\":{\"18\":1}}],[\"对于以上问题\",{\"1\":{\"18\":1}}],[\"冒牌排序算法流程\",{\"0\":{\"38\":1}}],[\"冒泡过程可以利用元素交换操作来模拟\",{\"1\":{\"37\":1}}],[\"冒泡\",{\"1\":{\"37\":2,\"38\":3,\"39\":1,\"60\":1}}],[\"冒泡排序的最差时间复杂度和平均时间复杂度仍为o\",{\"1\":{\"39\":1}}],[\"冒泡排序的步骤如下图所示\",{\"1\":{\"38\":1}}],[\"冒泡排序效率优化\",{\"0\":{\"39\":1}}],[\"冒泡排序\",{\"1\":{\"37\":1,\"38\":1,\"39\":1,\"44\":1,\"61\":1}}],[\"冒泡排序算法\",{\"0\":{\"37\":1}}],[\"遍历指针数组\",{\"1\":{\"263\":1}}],[\"遍历输出每个元素\",{\"1\":{\"246\":1}}],[\"遍历二维数组\",{\"1\":{\"246\":1}}],[\"遍历字符串\",{\"1\":{\"245\":1}}],[\"遍历该顶点的所有邻接顶点\",{\"1\":{\"223\":1,\"225\":1}}],[\"遍历查找节点\",{\"1\":{\"223\":1,\"225\":1}}],[\"遍历其他顶点的链表\",{\"1\":{\"219\":1}}],[\"遍历至\",{\"1\":{\"194\":1}}],[\"遍历到最底层之前\",{\"1\":{\"186\":1}}],[\"遍历桶\",{\"1\":{\"170\":2}}],[\"遍历桶合并结果\",{\"1\":{\"50\":1}}],[\"遍历链表\",{\"1\":{\"151\":1}}],[\"遍历所有物品\",{\"1\":{\"119\":1}}],[\"遍历所有列\",{\"1\":{\"90\":1}}],[\"遍历所有选择\",{\"1\":{\"77\":2,\"81\":1,\"82\":1,\"85\":2,\"86\":1,\"92\":1}}],[\"遍历起始点\",{\"1\":{\"85\":1}}],[\"遍历选择列表\",{\"1\":{\"81\":1}}],[\"遍历\",{\"1\":{\"53\":1}}],[\"遍历数组中的元素\",{\"1\":{\"244\":3}}],[\"遍历数组遍历数组是指按顺序访问数组中的每个元素\",{\"1\":{\"244\":1}}],[\"遍历数组\",{\"0\":{\"143\":1},\"1\":{\"53\":1,\"143\":1,\"288\":2}}],[\"遍历完成后\",{\"1\":{\"37\":1,\"75\":1}}],[\"遍历的数组长度依次为n\",{\"1\":{\"37\":1}}],[\"就绪的文件描述符\",{\"1\":{\"397\":1}}],[\"就相当于调用add\",{\"1\":{\"379\":1}}],[\"就调用特化为char类型的模板\",{\"1\":{\"367\":1}}],[\"就需要用到强制\",{\"1\":{\"338\":1}}],[\"就需要及时释放它\",{\"1\":{\"315\":1}}],[\"就说明该头文件没有加载过\",{\"1\":{\"321\":1}}],[\"就会收到操作系统发来的13号信号\",{\"1\":{\"403\":1}}],[\"就会进行大量无意义的加锁解锁操作\",{\"1\":{\"354\":1}}],[\"就会返回1\",{\"1\":{\"321\":1}}],[\"就会执行\",{\"1\":{\"321\":1}}],[\"就会执行代码块语句\",{\"1\":{\"297\":1}}],[\"就会打印一行提示\",{\"1\":{\"321\":1}}],[\"就表示判断条件为真\",{\"1\":{\"321\":1}}],[\"就表示运行失败\",{\"1\":{\"287\":1}}],[\"就要确定好在代码的什么地方释放内存\",{\"1\":{\"315\":1}}],[\"就不应该再次操作已经释放的地址\",{\"1\":{\"314\":1}}],[\"就不能修改我们可以直接通过索引\",{\"1\":{\"243\":1}}],[\"就可以轻易辨别该变量是字符串\",{\"1\":{\"304\":1}}],[\"就像给人起\",{\"1\":{\"304\":1}}],[\"就形成了嵌套循环\",{\"1\":{\"298\":1}}],[\"就执行循环体语句\",{\"1\":{\"298\":1}}],[\"就执行代码块2\",{\"1\":{\"297\":1}}],[\"就属于非法访问内存空间\",{\"1\":{\"267\":1}}],[\"就给内存单元进行了编号\",{\"1\":{\"261\":1}}],[\"就把内存划分成一个个小的内存单元\",{\"1\":{\"261\":1}}],[\"就是使用\",{\"1\":{\"379\":2}}],[\"就是调用initializer\",{\"1\":{\"379\":1}}],[\"就是它对应的二进制数\",{\"1\":{\"327\":1}}],[\"就是对应的十六进制\",{\"1\":{\"326\":1}}],[\"就是对应的二进制\",{\"1\":{\"326\":1}}],[\"就是执行这块内存中的代码\",{\"1\":{\"319\":1}}],[\"就是形参\",{\"1\":{\"319\":1}}],[\"就是带参数的宏\",{\"1\":{\"319\":1}}],[\"就是用一个标识符\",{\"1\":{\"318\":1}}],[\"就是用一个标识符来表示一个常量值\",{\"1\":{\"255\":1}}],[\"就是可以取到值的那个属性\",{\"1\":{\"303\":1}}],[\"就是提前告诉编译器\",{\"1\":{\"287\":1}}],[\"就是标准库提供的\",{\"1\":{\"271\":1}}],[\"就是因为它们应用了分治策略\",{\"1\":{\"60\":1}}],[\"就将子集记录至结果列表\",{\"1\":{\"85\":1}}],[\"就交换二者\",{\"1\":{\"37\":1}}],[\"就地性\",{\"1\":{\"33\":1}}],[\"右值经过一次参数传递后\",{\"1\":{\"379\":1}}],[\"右值引用和移动语义\",{\"1\":{\"379\":1}}],[\"右值引用可以使用std\",{\"1\":{\"379\":1}}],[\"右值引用\",{\"1\":{\"379\":3}}],[\"右值\",{\"1\":{\"379\":1}}],[\"右移操作符\",{\"1\":{\"280\":1}}],[\"右边抛弃\",{\"1\":{\"280\":1}}],[\"右边补0\",{\"1\":{\"280\":1}}],[\"右边界不包含自身\",{\"1\":{\"21\":1}}],[\"右偏树\",{\"1\":{\"205\":1}}],[\"右旋和左旋操作在逻辑上是镜像对称的\",{\"1\":{\"202\":1}}],[\"右旋操作\",{\"1\":{\"201\":1}}],[\"右旋\",{\"0\":{\"201\":1},\"1\":{\"200\":1,\"201\":1,\"203\":1,\"204\":1,\"205\":1}}],[\"右\",{\"1\":{\"189\":1,\"190\":1,\"196\":1,\"225\":3}}],[\"右子节点的索引为2i+2\",{\"1\":{\"209\":1}}],[\"右子节点\",{\"1\":{\"196\":1}}],[\"右子节点索引为2i+2\",{\"1\":{\"189\":1}}],[\"右子节点入队\",{\"1\":{\"186\":1}}],[\"右子节点指针\",{\"1\":{\"180\":1}}],[\"右子树高度\",{\"1\":{\"199\":1}}],[\"右子树也是二叉搜索树\",{\"1\":{\"192\":1}}],[\"右子树中所有节点的值\",{\"1\":{\"192\":1}}],[\"右子树是\",{\"1\":{\"180\":1}}],[\"右子树根节点索引中的\",{\"1\":{\"68\":1}}],[\"右子树在\",{\"1\":{\"68\":1}}],[\"右子树\",{\"1\":{\"67\":2,\"187\":3,\"194\":1,\"195\":2}}],[\"右子树同理\",{\"1\":{\"66\":1}}],[\"右子数组区间为\",{\"1\":{\"46\":1}}],[\"右子数组\",{\"1\":{\"42\":1,\"43\":1}}],[\"右元素\",{\"1\":{\"37\":1}}],[\"左操作数是this指向的调用函数的对象\",{\"1\":{\"361\":1}}],[\"左边补符号位\",{\"1\":{\"280\":1}}],[\"左边抛弃\",{\"1\":{\"280\":1}}],[\"左边和上边单元格的最小路径代价\",{\"1\":{\"104\":1}}],[\"左移操作符\",{\"1\":{\"280\":1}}],[\"左值引用\",{\"1\":{\"379\":2}}],[\"左值引用和右值引用\",{\"1\":{\"379\":1}}],[\"左值和右值\",{\"1\":{\"379\":1}}],[\"左值\",{\"1\":{\"279\":1,\"379\":1}}],[\"左偏树\",{\"1\":{\"205\":1}}],[\"左旋的操作\",{\"1\":{\"205\":1}}],[\"左旋操作\",{\"1\":{\"202\":1}}],[\"左旋\",{\"0\":{\"202\":1},\"1\":{\"200\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":1}}],[\"左\",{\"1\":{\"190\":1,\"196\":1,\"225\":3}}],[\"左上方dp\",{\"1\":{\"111\":1}}],[\"左子节点\",{\"1\":{\"196\":1}}],[\"左子节点入队\",{\"1\":{\"186\":1}}],[\"左子节点指针\",{\"1\":{\"180\":1}}],[\"左子节点引用和右子节点引用\",{\"1\":{\"180\":1}}],[\"左子树高度\",{\"1\":{\"199\":1}}],[\"左子树中所有节点的值\",{\"1\":{\"192\":1}}],[\"左子树是\",{\"1\":{\"180\":1}}],[\"左子树的节点数量\",{\"1\":{\"68\":1}}],[\"左子树\",{\"1\":{\"67\":2,\"68\":1,\"187\":3,\"194\":1,\"195\":2}}],[\"左子树和右子树是相互独立的\",{\"1\":{\"66\":1}}],[\"左子数组区间为\",{\"1\":{\"46\":1}}],[\"左子数组任意元素\",{\"1\":{\"42\":1}}],[\"左子数组\",{\"1\":{\"42\":1}}],[\"左元素\",{\"1\":{\"37\":1}}],[\"左闭右开区间\",{\"1\":{\"21\":1}}],[\"左闭右开\",{\"1\":{\"21\":1}}],[\"knowledge\",{\"1\":{\"348\":1,\"351\":1,\"354\":1,\"357\":1,\"361\":1,\"364\":1,\"367\":1,\"370\":1,\"373\":1,\"376\":1,\"379\":1,\"382\":1}}],[\"knapsackdpcomp\",{\"1\":{\"111\":1}}],[\"knapsackdp\",{\"1\":{\"110\":1}}],[\"knapsackdfsmem\",{\"1\":{\"109\":4}}],[\"knapsackdfs\",{\"1\":{\"108\":4}}],[\"karatsuba\",{\"1\":{\"63\":1}}],[\"k++\",{\"1\":{\"46\":4}}],[\"k\",{\"1\":{\"36\":5,\"46\":5,\"50\":10,\"56\":10,\"241\":1,\"245\":1,\"361\":3}}],[\"keys\",{\"1\":{\"167\":4}}],[\"keyset\",{\"1\":{\"167\":1}}],[\"key\",{\"1\":{\"30\":7,\"166\":2,\"167\":21,\"168\":3,\"170\":19,\"172\":19,\"175\":1,\"176\":4,\"177\":12,\"219\":1}}],[\"内置类型转string\",{\"1\":{\"379\":1}}],[\"内置类型成员不做处理\",{\"1\":{\"361\":1}}],[\"内层为n次\",{\"1\":{\"298\":1}}],[\"内部类可以使用外部类对象成员\",{\"1\":{\"361\":1}}],[\"内部类可以直接使用外部类的static成员\",{\"1\":{\"361\":1}}],[\"内部类\",{\"1\":{\"361\":1}}],[\"内部的变量定义语句会被编译器忽略\",{\"1\":{\"321\":1}}],[\"内部的行会被编译\",{\"1\":{\"321\":1}}],[\"内部\",{\"1\":{\"288\":3}}],[\"内的浮点数\",{\"1\":{\"50\":1}}],[\"内循环遍历各列\",{\"1\":{\"102\":1}}],[\"内循环\",{\"1\":{\"36\":1,\"38\":1,\"39\":1,\"41\":1}}],[\"内存管理\",{\"0\":{\"503\":1,\"504\":1}}],[\"内存泄漏会导致系统中的可用内存逐渐减少\",{\"1\":{\"314\":1}}],[\"内存分配基本原则\",{\"0\":{\"315\":1}}],[\"内存分配案例\",{\"1\":{\"314\":1}}],[\"内存分配失败\",{\"1\":{\"314\":2}}],[\"内存分配相关函数\",{\"0\":{\"314\":1}}],[\"内存\",{\"1\":{\"308\":2}}],[\"内存对齐规则\",{\"0\":{\"306\":1}}],[\"内存操作函数的例子\",{\"1\":{\"294\":1}}],[\"内存示意\",{\"1\":{\"262\":1}}],[\"内存地址通常是64位二进制数字\",{\"1\":{\"261\":1}}],[\"内存地址通常是32位二进制数字\",{\"1\":{\"261\":1}}],[\"内存地址\",{\"1\":{\"261\":1}}],[\"内存是电脑上特别重要的存储器\",{\"1\":{\"261\":1}}],[\"内存是所有程序的共享资源\",{\"1\":{\"15\":1}}],[\"内存占用较多\",{\"1\":{\"216\":1}}],[\"内存浪费\",{\"1\":{\"142\":1}}],[\"内存资源是一个重要的考虑因素\",{\"1\":{\"15\":1}}],[\"未成年人请在家长陪同下访问\",{\"1\":{\"297\":2}}],[\"未加入新功能\",{\"1\":{\"241\":1}}],[\"未借助额外数组非稳定排序\",{\"1\":{\"43\":1}}],[\"未排序区间为\",{\"1\":{\"36\":1,\"38\":1,\"39\":1}}],[\"未找到\",{\"1\":{\"23\":1,\"26\":1,\"27\":1}}],[\"未找到目标元素\",{\"1\":{\"20\":1,\"21\":1}}],[\"仅在需要时分配内存\",{\"1\":{\"315\":1}}],[\"仅在必要时\",{\"1\":{\"169\":1}}],[\"仅使用左旋或右旋都无法使子树恢复平衡\",{\"1\":{\"203\":1}}],[\"仅用一个数组来实现哈希表\",{\"1\":{\"167\":1}}],[\"仅需增加\",{\"1\":{\"164\":1}}],[\"仅需单层循环即可\",{\"1\":{\"30\":1}}],[\"仅剩的一个元素必定是最小元素\",{\"1\":{\"38\":1}}],[\"仅剩的一个元素必定是最大元素\",{\"1\":{\"36\":1}}],[\"选定矩阵中的某条主对角线\",{\"1\":{\"89\":1}}],[\"选择错误\",{\"1\":{\"345\":1}}],[\"选择合适的数据结构是关键\",{\"1\":{\"133\":1}}],[\"选择1或选择1^\",{\"1\":{\"82\":1}}],[\"选择物品使得总价值最大\",{\"1\":{\"79\":1}}],[\"选择\",{\"1\":{\"77\":1,\"113\":1}}],[\"选择数组中的某个元素作为\",{\"1\":{\"42\":1}}],[\"选择排序的算法流程如图下图所示\",{\"1\":{\"36\":1}}],[\"选择排序\",{\"0\":{\"474\":1},\"1\":{\"36\":2}}],[\"选择排序原理\",{\"0\":{\"36\":1}}],[\"选择排序算法\",{\"0\":{\"35\":1}}],[\"选取数组最左端元素作为基准数\",{\"1\":{\"42\":1}}],[\"选取数组的第\",{\"1\":{\"41\":1}}],[\"选取最后一个元素作为\",{\"1\":{\"41\":1}}],[\"选取第\",{\"1\":{\"41\":1}}],[\"选取区间\",{\"1\":{\"36\":2}}],[\"索引代表节点在二叉树中的位置\",{\"1\":{\"209\":1}}],[\"索引处\",{\"1\":{\"161\":1}}],[\"索引本质上是内存地址的偏移量\",{\"1\":{\"140\":1}}],[\"索引变为\",{\"1\":{\"102\":1}}],[\"索引\",{\"1\":{\"36\":1,\"243\":2,\"246\":1}}],[\"迄今为止尚未发现兼具以上所有特性的排序算法\",{\"1\":{\"34\":1}}],[\"通信是在内存当中进行的\",{\"1\":{\"403\":1}}],[\"通信完毕\",{\"1\":{\"403\":3,\"404\":1,\"405\":1,\"406\":2}}],[\"通知等待的线程\",{\"1\":{\"379\":1}}],[\"通用类模板\",{\"1\":{\"367\":2}}],[\"通用函数模板\",{\"1\":{\"367\":1}}],[\"通用模板\",{\"1\":{\"367\":3}}],[\"通用性好\",{\"1\":{\"34\":1}}],[\"通讯录系统\",{\"1\":{\"344\":1}}],[\"通讯录系统功能\",{\"1\":{\"342\":1}}],[\"通讯录即将按照联系人姓氏升序进行排序\",{\"1\":{\"344\":1}}],[\"通讯录为空\",{\"1\":{\"344\":2}}],[\"通讯录功能函数\",{\"1\":{\"344\":1}}],[\"通讯录功能界面选择\",{\"1\":{\"344\":1}}],[\"通讯录容量\",{\"1\":{\"344\":1}}],[\"通讯录大小\",{\"1\":{\"344\":1}}],[\"通讯录结构体\",{\"1\":{\"344\":1}}],[\"通讯录结构体成员最大值宏\",{\"1\":{\"344\":1}}],[\"通讯录联系人基本信息结构体\",{\"1\":{\"344\":1}}],[\"通讯录管理系统\",{\"0\":{\"340\":1}}],[\"通常与右值引用一起使用\",{\"1\":{\"379\":1}}],[\"通常在抽象类中声明为虚析构函数\",{\"1\":{\"376\":1}}],[\"通常在头文件中声明全局变量\",{\"1\":{\"334\":1}}],[\"通常用\",{\"1\":{\"335\":1}}],[\"通常用于逻辑运算和条件判断\",{\"1\":{\"333\":1}}],[\"通常用于处理字符串\",{\"1\":{\"263\":1}}],[\"通常使用大写字母表示\",{\"1\":{\"318\":1}}],[\"通常使用printf\",{\"1\":{\"309\":1}}],[\"通常返回的原先的地址参数说明\",{\"1\":{\"314\":1}}],[\"通常以\",{\"1\":{\"310\":1}}],[\"通常以整数形式表示\",{\"1\":{\"310\":1}}],[\"通常为零\",{\"1\":{\"310\":1}}],[\"通常需要先定义一个结构体变量\",{\"1\":{\"302\":1}}],[\"通常是临时量\",{\"1\":{\"379\":1}}],[\"通常是变量或对象的名称\",{\"1\":{\"379\":1}}],[\"通常是\",{\"1\":{\"335\":1}}],[\"通常是一个表达式\",{\"1\":{\"321\":1}}],[\"通常是安全的void\",{\"1\":{\"313\":1}}],[\"通常是标准输入流\",{\"1\":{\"310\":1}}],[\"通常是str的长度\",{\"1\":{\"310\":1}}],[\"通常是文件指针\",{\"1\":{\"310\":1}}],[\"通常是成功写入的字符数\",{\"1\":{\"310\":2}}],[\"通常是写入的字符的ascii码值\",{\"1\":{\"310\":1}}],[\"通常是屏幕\",{\"1\":{\"309\":2}}],[\"通常是int如果没有为枚举元素指定值\",{\"1\":{\"301\":1}}],[\"通常是键盘输入\",{\"1\":{\"309\":1}}],[\"通常是键盘\",{\"1\":{\"252\":1,\"309\":1}}],[\"通常称为unix纪元\",{\"1\":{\"291\":1}}],[\"通常称它们为局部变量\",{\"1\":{\"288\":1}}],[\"通常称它们为全局变量\",{\"1\":{\"288\":1}}],[\"通常带有\",{\"1\":{\"271\":1}}],[\"通常带有扩展名\",{\"1\":{\"271\":2}}],[\"通常\",{\"1\":{\"265\":1}}],[\"通常跟在类型关键字的后面\",{\"1\":{\"261\":1}}],[\"通常简称为指针\",{\"1\":{\"261\":1}}],[\"通常借助队列来实现\",{\"1\":{\"223\":1}}],[\"通常传入更小或更简化的参数\",{\"1\":{\"136\":1}}],[\"通常可以使用回溯来解决\",{\"1\":{\"101\":1}}],[\"通常可以参考以下几个判断依据\",{\"1\":{\"59\":1}}],[\"通常应用于整数数组\",{\"1\":{\"52\":1}}],[\"通常情况下哈希函数的输入空间远大于输出空间\",{\"1\":{\"169\":1}}],[\"通常情况下\",{\"1\":{\"33\":1,\"56\":1}}],[\"通过atomic类模板定义\",{\"1\":{\"379\":2}}],[\"通过原子类型名称定义\",{\"1\":{\"379\":2}}],[\"通过基类指针调用clone\",{\"1\":{\"376\":1}}],[\"通过虚基表指针和虚基表找到公共虚基类\",{\"1\":{\"373\":1}}],[\"通过菱形虚拟继承解决\",{\"1\":{\"373\":1}}],[\"通过模板特化对一些特殊的类型进行特殊化实现\",{\"1\":{\"367\":1}}],[\"通过非类型模板参数给array数组一个初始size\",{\"1\":{\"367\":1}}],[\"通过不增加\",{\"1\":{\"351\":1}}],[\"通过引用计数的方式\",{\"1\":{\"351\":1}}],[\"通过引用指向\",{\"1\":{\"147\":1}}],[\"通过防拷贝的方式\",{\"1\":{\"351\":1}}],[\"通过管理权限转移的方式\",{\"1\":{\"351\":1}}],[\"通过判断宏mavis是否定义过\",{\"1\":{\"321\":1}}],[\"通过这个宏\",{\"1\":{\"321\":1}}],[\"通过结构体变量访问成员\",{\"1\":{\"302\":1}}],[\"通过函数调用可以隐藏实现细节\",{\"1\":{\"285\":1}}],[\"通过函数调用自身来解决问题\",{\"1\":{\"136\":1}}],[\"通过该指针可以间接访问变量\",{\"1\":{\"261\":1}}],[\"通过指针来实现\",{\"1\":{\"261\":1}}],[\"通过变量名\",{\"1\":{\"249\":1}}],[\"通过哈希函数计算桶索引\",{\"1\":{\"172\":1}}],[\"通过某种哈希算法\",{\"1\":{\"167\":1}}],[\"通过取余操作实现数组首尾相连\",{\"1\":{\"164\":1}}],[\"通过取余操作实现\",{\"1\":{\"161\":1,\"164\":1}}],[\"通过它可以从当前节点访问到下一个节点\",{\"1\":{\"146\":1}}],[\"通过索引遍历数组\",{\"1\":{\"143\":1}}],[\"通过构建霍夫曼树\",{\"1\":{\"117\":1}}],[\"通过\",{\"1\":{\"96\":1,\"244\":1,\"321\":1,\"373\":1}}],[\"通过回溯逐层收集子问题的解\",{\"1\":{\"95\":1}}],[\"通过试探和剪枝\",{\"1\":{\"93\":1}}],[\"通过以上变量即可表示根节点在\",{\"1\":{\"68\":1}}],[\"通过分治提高效率\",{\"0\":{\"60\":1}}],[\"通过统计元素数量来实现排序\",{\"1\":{\"52\":1}}],[\"通过递归不断地将数组从中点处分开\",{\"1\":{\"45\":1}}],[\"通过连续地比较与交换相邻元素实现排序\",{\"1\":{\"37\":1}}],[\"理解为是一个数组\",{\"1\":{\"287\":1}}],[\"理解整个搜索过程\",{\"1\":{\"86\":1}}],[\"理想情况下键值对均匀分布在各个桶中\",{\"1\":{\"175\":1}}],[\"理想的排序算法\",{\"0\":{\"34\":1}}],[\"理论上一定存在\",{\"1\":{\"168\":1}}],[\"理论上能容纳\",{\"1\":{\"18\":1}}],[\"理论估算\",{\"1\":{\"135\":1}}],[\"理论最优时间复杂度为o\",{\"1\":{\"33\":1}}],[\"但有可能fd\",{\"1\":{\"440\":1}}],[\"但每次检测时读事件都不就绪\",{\"1\":{\"439\":1}}],[\"但我们若是将这里的管道想象成\",{\"1\":{\"406\":1}}],[\"但我们需要掌握\",{\"1\":{\"299\":1}}],[\"但实际只有getinstance函数第一次被调用\",{\"1\":{\"354\":1}}],[\"但实际上遍历此链表已经无法访问到\",{\"1\":{\"149\":1}}],[\"但与一般整型不同的是\",{\"1\":{\"333\":1}}],[\"但与分治算法的主要区别是\",{\"1\":{\"97\":1}}],[\"但强烈不建议这么干\",{\"1\":{\"317\":1}}],[\"但同一时间只能有一个属性\",{\"1\":{\"303\":1}}],[\"但只有第一次循环语句的执行没有经过判断\",{\"1\":{\"298\":1}}],[\"但限制最大长度\",{\"1\":{\"292\":3}}],[\"但函数中没有return语句\",{\"1\":{\"286\":1}}],[\"但在运算中会表现出不同\",{\"1\":{\"263\":1}}],[\"但在绝大多数情况下\",{\"1\":{\"44\":1}}],[\"但多个哈希函数会带来额外的计算量\",{\"1\":{\"174\":1}}],[\"但不支持多个线程同时对其进程写操作\",{\"1\":{\"379\":1}}],[\"但不推荐不加\",{\"1\":{\"376\":1}}],[\"但不写又会报错\",{\"1\":{\"304\":1}}],[\"但不同的是\",{\"1\":{\"172\":1}}],[\"但不能连续两轮跳1阶\",{\"1\":{\"99\":1}}],[\"但效率太低\",{\"1\":{\"169\":1}}],[\"但由于扩容是低频操作\",{\"1\":{\"158\":1}}],[\"但是管道当中的数据并没有被刷新到磁盘\",{\"1\":{\"403\":1}}],[\"但是它可以同时为多个客户端提供服务\",{\"1\":{\"398\":1}}],[\"但是它也可以同时为多个客户端提供服务\",{\"1\":{\"391\":1}}],[\"但是动态类型还是派生类circle\",{\"1\":{\"376\":1}}],[\"但是circle对象赋值给shape\",{\"1\":{\"376\":1}}],[\"但是又不能将构造函数设置为私有\",{\"1\":{\"354\":1}}],[\"但是计算机在存储一个数字时并不是直接存储该数字对应的二进制数字\",{\"1\":{\"327\":1}}],[\"但是宏名和形参列表之间不能有空格出现在带参宏定义中\",{\"1\":{\"319\":1}}],[\"但是为了兼容老的编译器\",{\"1\":{\"317\":1}}],[\"但是为了保持统一的代码风格\",{\"1\":{\"287\":1}}],[\"但是同一时间只能取到一个属性\",{\"1\":{\"303\":1}}],[\"但是\",{\"1\":{\"158\":1,\"244\":1,\"263\":1,\"313\":1}}],[\"但相应地也需要占用更多的内存空间\",{\"1\":{\"153\":1}}],[\"但这并\",{\"1\":{\"379\":1}}],[\"但这已超出了栈的定义范畴\",{\"1\":{\"158\":1}}],[\"但这样做会造成部分内存空间浪费\",{\"1\":{\"142\":1}}],[\"但这个方法效率很低\",{\"1\":{\"85\":1}}],[\"但从地址计算公式的角度看\",{\"1\":{\"140\":1}}],[\"但执行效率可能相差很大\",{\"1\":{\"133\":1}}],[\"但需要注意的是\",{\"1\":{\"331\":1}}],[\"但需要占用更大的内存空间\",{\"1\":{\"132\":1}}],[\"但需要借助一个额外数组来保存弹出的元素\",{\"1\":{\"47\":1}}],[\"但牺牲了数据访问速度图相较于链表\",{\"1\":{\"132\":1}}],[\"但高度可能会变大\",{\"1\":{\"123\":1}}],[\"但可以选择物品的一部分\",{\"1\":{\"118\":1}}],[\"但如果你已经持有股票\",{\"1\":{\"117\":1}}],[\"但如何通过前序遍历\",{\"1\":{\"67\":1}}],[\"但工作原理不同\",{\"1\":{\"113\":1}}],[\"但更加简洁\",{\"1\":{\"93\":1}}],[\"但对应同一个子集\",{\"1\":{\"85\":1}}],[\"但其它函数不能反过来调用主函数\",{\"1\":{\"287\":1}}],[\"但其中存在重复的子集\",{\"1\":{\"85\":1}}],[\"但其通用性相对较差\",{\"1\":{\"33\":1}}],[\"但两者的目标不同\",{\"1\":{\"83\":1}}],[\"但通常遵循以下步骤\",{\"1\":{\"102\":1}}],[\"但通常快速排序的效率更高\",{\"1\":{\"44\":1}}],[\"但通用性更好\",{\"1\":{\"77\":1}}],[\"但某些哈希冲突解决方案间接应用了分治策略\",{\"1\":{\"63\":1}}],[\"但商品价格分布不均\",{\"1\":{\"51\":1}}],[\"但当输入数组完全有序时\",{\"1\":{\"39\":1}}],[\"但它却可以同时为多个客户端提供服务\",{\"1\":{\"441\":1}}],[\"但它们的含义是不同的\",{\"1\":{\"303\":1}}],[\"但它们都由各种基本数据类型构成\",{\"1\":{\"16\":1}}],[\"但它并没有规定在计算机中如何存储这些字符码点\",{\"1\":{\"18\":1}}],[\"dfl\",{\"1\":{\"389\":3,\"390\":4,\"438\":4,\"440\":5}}],[\"dfs的算法实现\",{\"0\":{\"225\":1}}],[\"dfs\",{\"0\":{\"224\":1},\"1\":{\"64\":5,\"69\":5,\"73\":6,\"93\":4,\"94\":4,\"187\":1,\"190\":6,\"225\":3}}],[\"dummy\",{\"1\":{\"382\":1}}],[\"duplicated\",{\"1\":{\"82\":4,\"83\":2}}],[\"drawshape\",{\"1\":{\"376\":3}}],[\"drawing\",{\"1\":{\"376\":7}}],[\"draw\",{\"1\":{\"376\":5}}],[\"d打印\",{\"1\":{\"335\":1}}],[\"d3=20000\",{\"1\":{\"330\":2}}],[\"d3=\",{\"1\":{\"330\":1}}],[\"d3\",{\"1\":{\"330\":2,\"337\":2,\"361\":2}}],[\"date类中有setdate与display两个成员函数\",{\"1\":{\"361\":1}}],[\"date\",{\"1\":{\"344\":1,\"345\":1,\"348\":1,\"351\":1,\"354\":1,\"357\":1,\"361\":119,\"364\":1,\"367\":1,\"370\":1,\"373\":1,\"376\":1,\"379\":1,\"382\":1}}],[\"data2\",{\"1\":{\"404\":2}}],[\"data1\",{\"1\":{\"404\":2}}],[\"dataready\",{\"1\":{\"379\":3}}],[\"data=data\",{\"1\":{\"361\":1}}],[\"data开空间\",{\"1\":{\"361\":1}}],[\"data必须初始化引用类型的成员\",{\"1\":{\"361\":1}}],[\"datatype\",{\"1\":{\"361\":3}}],[\"data\",{\"1\":{\"132\":1,\"157\":1,\"303\":7,\"344\":1,\"357\":3,\"361\":11,\"379\":9,\"396\":1,\"397\":2}}],[\"day=day\",{\"1\":{\"361\":1}}],[\"day=0\",{\"1\":{\"361\":1}}],[\"day\",{\"1\":{\"301\":6,\"361\":100}}],[\"d个韭菜馅的包子\",{\"1\":{\"298\":3}}],[\"d天吃了\",{\"1\":{\"298\":3}}],[\"d岁\",{\"1\":{\"291\":1}}],[\"d2和d1的值也是一样的\",{\"1\":{\"361\":1}}],[\"d2转为4\",{\"1\":{\"338\":1}}],[\"d2=\",{\"1\":{\"330\":3}}],[\"d2\",{\"1\":{\"262\":2,\"330\":3,\"337\":2,\"338\":3,\"361\":30}}],[\"d1++\",{\"1\":{\"361\":1}}],[\"d1+d2=6\",{\"1\":{\"338\":1}}],[\"d1转为1\",{\"1\":{\"338\":1}}],[\"d1==d2\",{\"1\":{\"361\":1}}],[\"d1=10000\",{\"1\":{\"330\":2}}],[\"d1=\",{\"1\":{\"330\":1}}],[\"d1\",{\"1\":{\"262\":2,\"330\":3,\"338\":3,\"361\":34}}],[\"denominator\",{\"1\":{\"382\":8}}],[\"detach\",{\"1\":{\"379\":3}}],[\"declaration是变量声明随便定名字\",{\"1\":{\"379\":1}}],[\"declaration\",{\"1\":{\"379\":1}}],[\"decltype用于推演类型\",{\"1\":{\"357\":1}}],[\"decltype\",{\"1\":{\"357\":3,\"379\":3}}],[\"decltype的使用\",{\"1\":{\"357\":1}}],[\"dervivedptr\",{\"1\":{\"357\":2}}],[\"derivedref\",{\"1\":{\"382\":1}}],[\"derivedptr\",{\"1\":{\"357\":1}}],[\"derived\",{\"1\":{\"357\":3,\"373\":10,\"376\":4,\"382\":2}}],[\"description\",{\"1\":{\"344\":1,\"345\":1,\"348\":1,\"351\":1,\"354\":1,\"357\":1,\"361\":1,\"364\":1,\"367\":1,\"370\":1,\"373\":1,\"376\":1,\"379\":1,\"382\":1}}],[\"destination\",{\"1\":{\"379\":1}}],[\"destructor\",{\"1\":{\"376\":8}}],[\"dest\",{\"1\":{\"292\":1,\"294\":13}}],[\"demo\",{\"1\":{\"287\":2}}],[\"default\",{\"1\":{\"259\":1,\"297\":3,\"345\":1,\"389\":3,\"438\":3,\"439\":2}}],[\"defined是一个预处理运算符\",{\"1\":{\"321\":1}}],[\"defined\",{\"1\":{\"321\":8}}],[\"define宏名\",{\"1\":{\"319\":1}}],[\"define是预处理指令\",{\"1\":{\"255\":1}}],[\"define和const定义常量的区别\",{\"1\":{\"255\":1}}],[\"define定义一个空的宏\",{\"1\":{\"321\":1}}],[\"define定义宏常量相比\",{\"1\":{\"255\":1}}],[\"define定义常量不用指定类型\",{\"1\":{\"255\":1}}],[\"define定义常量的格式\",{\"1\":{\"255\":1}}],[\"define定义常量\",{\"1\":{\"255\":2}}],[\"define必须写在main函数外面\",{\"1\":{\"255\":1}}],[\"define\",{\"1\":{\"254\":1,\"255\":2,\"310\":2,\"317\":1,\"318\":10,\"319\":3,\"321\":5,\"333\":3,\"344\":5,\"348\":2,\"388\":1,\"389\":3,\"390\":3,\"395\":2,\"396\":3,\"397\":3,\"403\":1,\"406\":1,\"437\":1,\"438\":3,\"440\":3}}],[\"depth\",{\"1\":{\"181\":1,\"187\":2}}],[\"degree\",{\"1\":{\"181\":1,\"214\":3}}],[\"dequeue\",{\"1\":{\"223\":2}}],[\"dequeindex\",{\"1\":{\"164\":5}}],[\"deque\",{\"1\":{\"163\":62,\"164\":55}}],[\"delevent\",{\"1\":{\"397\":3}}],[\"delete函数\",{\"1\":{\"354\":1}}],[\"delete\",{\"1\":{\"354\":17,\"357\":1,\"364\":6,\"376\":3,\"382\":1}}],[\"deletion\",{\"1\":{\"172\":1}}],[\"delinstance\",{\"1\":{\"354\":1}}],[\"delim\",{\"1\":{\"292\":1}}],[\"del\",{\"1\":{\"344\":1,\"345\":1,\"397\":1}}],[\"delgraphadjlist\",{\"1\":{\"219\":1}}],[\"delgraphadjmat\",{\"1\":{\"218\":1}}],[\"delhashmapopenaddressing\",{\"1\":{\"172\":1}}],[\"delhashmapchaining\",{\"1\":{\"170\":1}}],[\"deldoublylistnode\",{\"1\":{\"163\":3}}],[\"delarraybinarytree\",{\"1\":{\"190\":1}}],[\"delarrayhashmap\",{\"1\":{\"167\":1}}],[\"delarraydeque\",{\"1\":{\"164\":1}}],[\"delarrayqueue\",{\"1\":{\"161\":1}}],[\"delarraystack\",{\"1\":{\"157\":1}}],[\"dellinkedlistdeque\",{\"1\":{\"163\":1}}],[\"dellinkedlistqueue\",{\"1\":{\"160\":1}}],[\"dellinkedliststack\",{\"1\":{\"156\":1}}],[\"dp解题思路\",{\"0\":{\"100\":1}}],[\"dp问题特性\",{\"0\":{\"97\":1}}],[\"dp\",{\"1\":{\"93\":6,\"94\":7,\"95\":13,\"96\":2,\"98\":9,\"99\":16,\"105\":13,\"106\":13,\"110\":11,\"111\":8}}],[\"dynamicarray\",{\"1\":{\"382\":2}}],[\"dynamic\",{\"1\":{\"92\":1,\"357\":5,\"382\":2}}],[\"dispaly\",{\"1\":{\"361\":1}}],[\"displaying\",{\"1\":{\"376\":2}}],[\"display\",{\"1\":{\"361\":6,\"376\":1}}],[\"disconnected\",{\"1\":{\"214\":1}}],[\"diff\",{\"1\":{\"291\":3}}],[\"difftime\",{\"1\":{\"291\":2}}],[\"directed\",{\"1\":{\"214\":1}}],[\"dijkstra\",{\"1\":{\"117\":1}}],[\"diag2\",{\"1\":{\"90\":4}}],[\"diag1\",{\"1\":{\"90\":4}}],[\"diags2\",{\"1\":{\"89\":1,\"90\":9}}],[\"diags1\",{\"1\":{\"89\":1,\"90\":8}}],[\"divide\",{\"1\":{\"58\":1}}],[\"digit\",{\"1\":{\"56\":3,\"293\":2}}],[\"d和k都相对较小\",{\"1\":{\"56\":1}}],[\"dog类中采用协变\",{\"1\":{\"376\":1}}],[\"dog\",{\"1\":{\"361\":1,\"373\":6,\"376\":6}}],[\"doughnut\",{\"1\":{\"304\":1}}],[\"doublylistnode\",{\"1\":{\"163\":15}}],[\"doublecontainer\",{\"1\":{\"367\":4}}],[\"double转变为int类型\",{\"1\":{\"357\":1}}],[\"double类型强转为int类型\",{\"1\":{\"357\":1}}],[\"double类型字面量\",{\"1\":{\"331\":1}}],[\"double为11位有效数字\",{\"1\":{\"348\":1}}],[\"doubleptr\",{\"1\":{\"313\":3}}],[\"double\",{\"1\":{\"16\":1,\"162\":1,\"170\":4,\"172\":4,\"255\":5,\"259\":1,\"262\":5,\"264\":5,\"276\":2,\"278\":1,\"286\":1,\"288\":5,\"289\":4,\"291\":1,\"297\":2,\"313\":6,\"318\":1,\"321\":1,\"331\":11,\"335\":9,\"337\":4,\"338\":2,\"348\":4,\"357\":4,\"367\":4,\"382\":1}}],[\"do\",{\"1\":{\"259\":1,\"298\":5,\"345\":2}}],[\"don\",{\"1\":{\"257\":1}}],[\"down\",{\"1\":{\"48\":3}}],[\"d\",{\"1\":{\"33\":3,\"56\":9,\"167\":1,\"168\":1,\"170\":1,\"172\":1,\"244\":11,\"245\":2,\"246\":2,\"251\":10,\"252\":8,\"262\":11,\"263\":7,\"264\":2,\"265\":8,\"266\":1,\"267\":3,\"276\":17,\"277\":6,\"278\":1,\"279\":3,\"280\":9,\"281\":3,\"286\":7,\"287\":2,\"288\":18,\"289\":9,\"290\":2,\"292\":4,\"293\":1,\"297\":6,\"298\":5,\"299\":2,\"302\":7,\"309\":2,\"310\":9,\"313\":3,\"314\":5,\"318\":2,\"319\":8,\"325\":6,\"330\":8,\"332\":6,\"335\":4,\"337\":2,\"338\":3,\"344\":2,\"345\":1,\"357\":1,\"361\":66,\"404\":3}}],[\"非递归方式\",{\"0\":{\"456\":1}}],[\"非必要\",{\"1\":{\"373\":1}}],[\"非0的值都会被存储为1\",{\"1\":{\"333\":1}}],[\"非0时\",{\"1\":{\"297\":1}}],[\"非0为真逻辑与\",{\"1\":{\"278\":1}}],[\"非法标识符举例\",{\"1\":{\"257\":1}}],[\"非常相似\",{\"1\":{\"217\":1}}],[\"非常方便\",{\"1\":{\"190\":1}}],[\"非常耗时\",{\"1\":{\"168\":1}}],[\"非常高效\",{\"1\":{\"166\":1,\"196\":1}}],[\"非常浪费内存空间\",{\"1\":{\"18\":1}}],[\"非负整数\",{\"1\":{\"53\":1}}],[\"非比较排序算法\",{\"1\":{\"49\":1}}],[\"非原地排序\",{\"1\":{\"46\":1,\"56\":1}}],[\"非自适应排序\",{\"1\":{\"36\":1,\"46\":1,\"48\":1}}],[\"非稳定排序可能导致输入数据的有序性丧失\",{\"1\":{\"33\":1}}],[\"列的数组\",{\"1\":{\"246\":1}}],[\"列索引\",{\"1\":{\"246\":1}}],[\"列或更多的维度\",{\"1\":{\"246\":1}}],[\"列\",{\"1\":{\"216\":1}}],[\"列表统一初始化\",{\"1\":{\"379\":1}}],[\"列表初始化\",{\"1\":{\"361\":2}}],[\"列表\",{\"1\":{\"223\":1,\"225\":1}}],[\"列表容量\",{\"1\":{\"190\":1}}],[\"列表有序\",{\"1\":{\"113\":1}}],[\"列表中不应包含重复组合\",{\"1\":{\"85\":1,\"86\":1}}],[\"列与对角线剪枝\",{\"0\":{\"89\":1}}],[\"列分别是姓名和年龄\",{\"1\":{\"33\":1}}],[\"列和第\",{\"1\":{\"33\":1}}],[\"稳定\",{\"1\":{\"34\":1}}],[\"稳定排序是多级排序场景的必要条件\",{\"1\":{\"33\":1}}],[\"稳定排序在完成排序后\",{\"1\":{\"33\":1}}],[\"稳定性\",{\"1\":{\"33\":1}}],[\"原子存储\",{\"1\":{\"379\":2}}],[\"原子加法\",{\"1\":{\"379\":2}}],[\"原子类型变量定义方式\",{\"1\":{\"379\":1}}],[\"原子类\",{\"1\":{\"379\":1}}],[\"原子性操作库\",{\"1\":{\"379\":1}}],[\"原式等于int\",{\"1\":{\"379\":1}}],[\"原理\",{\"1\":{\"373\":1}}],[\"原因\",{\"1\":{\"348\":1}}],[\"原函数add\",{\"1\":{\"348\":1}}],[\"原先末尾的元素变得\",{\"1\":{\"142\":1}}],[\"原问题随之得到解决\",{\"1\":{\"72\":1}}],[\"原问题也会同时得到解决\",{\"1\":{\"64\":1}}],[\"原问题的解由一系列决策步骤构成\",{\"1\":{\"97\":1}}],[\"原问题的解\",{\"1\":{\"59\":1}}],[\"原问题的解通过合并子问题的解得来\",{\"1\":{\"59\":1}}],[\"原问题\",{\"1\":{\"59\":1}}],[\"原问题可以分解成规模更小\",{\"1\":{\"59\":1}}],[\"原数组被划分成三部分\",{\"1\":{\"42\":1}}],[\"原地\",{\"1\":{\"34\":1}}],[\"原地排序\",{\"1\":{\"36\":1,\"37\":1,\"41\":1,\"43\":1,\"48\":1}}],[\"原地排序的数据搬运操作较少\",{\"1\":{\"33\":1}}],[\"原地排序通过在原数组上直接操作实现排序\",{\"1\":{\"33\":1}}],[\"原码的表示与机器数真值表示的一样\",{\"1\":{\"327\":1}}],[\"原码\",{\"0\":{\"327\":1},\"1\":{\"17\":2,\"327\":8}}],[\"顾名思义\",{\"1\":{\"33\":1,\"159\":1,\"174\":1}}],[\"排序完成\",{\"1\":{\"344\":1}}],[\"排序中\",{\"1\":{\"344\":1}}],[\"排序通讯录\",{\"1\":{\"342\":1,\"344\":2}}],[\"排序每个子数组需要o\",{\"1\":{\"61\":1}}],[\"排序所有k位使用o\",{\"1\":{\"56\":1}}],[\"排序操作是在原数组上进行的\",{\"1\":{\"43\":1}}],[\"排序的判断规则可根据需求设定\",{\"1\":{\"32\":1}}],[\"排序算法总结\",{\"0\":{\"475\":1}}],[\"排序算法评价维度\",{\"0\":{\"33\":1}}],[\"排序算法中的数据类型可以是整数\",{\"1\":{\"32\":1}}],[\"排序算法有着广泛的应用\",{\"1\":{\"32\":1}}],[\"排序算法\",{\"1\":{\"32\":1}}],[\"排序算法概念\",{\"0\":{\"32\":1}}],[\"排序\",{\"0\":{\"31\":1,\"471\":1}}],[\"v=u\",{\"1\":{\"361\":1}}],[\"vdptr\",{\"1\":{\"313\":4}}],[\"virtual\",{\"1\":{\"357\":2,\"373\":2,\"376\":6,\"382\":1}}],[\"viptr\",{\"1\":{\"313\":4}}],[\"visual\",{\"1\":{\"270\":3}}],[\"visitedsize\",{\"1\":{\"223\":4}}],[\"visited\",{\"1\":{\"223\":8,\"225\":2}}],[\"vscode\",{\"1\":{\"270\":1}}],[\"vs\",{\"1\":{\"270\":2}}],[\"variable\",{\"1\":{\"379\":1}}],[\"variable>\",{\"1\":{\"379\":1}}],[\"variablename\",{\"1\":{\"357\":1}}],[\"var`s\",{\"1\":{\"265\":3}}],[\"var\",{\"1\":{\"265\":11}}],[\"vals\",{\"1\":{\"167\":4}}],[\"value作为参数传递给threadfunction\",{\"1\":{\"379\":2}}],[\"valueref2\",{\"1\":{\"379\":3}}],[\"valueref\",{\"1\":{\"379\":2}}],[\"value<char>\",{\"1\":{\"367\":1}}],[\"valueset\",{\"1\":{\"167\":1}}],[\"value\",{\"1\":{\"166\":1,\"167\":4,\"172\":1,\"219\":1,\"264\":2,\"265\":12,\"287\":1,\"309\":1,\"364\":4,\"367\":28,\"379\":36}}],[\"val\",{\"1\":{\"30\":4,\"108\":5,\"109\":5,\"110\":2,\"111\":2,\"118\":1,\"120\":2,\"146\":3,\"153\":3,\"156\":2,\"157\":2,\"163\":5,\"167\":7,\"170\":6,\"172\":9,\"180\":3,\"190\":7,\"193\":4,\"198\":3,\"206\":8,\"207\":7,\"211\":4,\"212\":2,\"218\":2,\"364\":2}}],[\"volume\",{\"1\":{\"304\":1}}],[\"volatile\",{\"1\":{\"259\":1}}],[\"void指针特点\",{\"1\":{\"313\":1}}],[\"void指针作用\",{\"1\":{\"313\":1}}],[\"void指针介绍\",{\"1\":{\"313\":1}}],[\"void指针\",{\"0\":{\"313\":1},\"1\":{\"313\":1}}],[\"void\",{\"1\":{\"30\":1,\"36\":1,\"38\":1,\"39\":1,\"41\":1,\"42\":1,\"43\":1,\"46\":2,\"48\":2,\"50\":1,\"53\":1,\"54\":1,\"56\":2,\"73\":3,\"74\":1,\"75\":1,\"76\":1,\"77\":8,\"81\":1,\"82\":1,\"85\":4,\"86\":2,\"90\":1,\"92\":1,\"141\":1,\"142\":1,\"143\":1,\"148\":1,\"149\":1,\"156\":2,\"157\":2,\"160\":3,\"161\":2,\"163\":6,\"164\":3,\"167\":7,\"170\":5,\"172\":5,\"187\":3,\"190\":2,\"194\":1,\"195\":1,\"199\":1,\"206\":1,\"207\":1,\"211\":2,\"212\":1,\"218\":6,\"219\":7,\"223\":2,\"225\":2,\"259\":1,\"264\":2,\"286\":4,\"288\":3,\"289\":6,\"290\":1,\"294\":10,\"309\":1,\"310\":3,\"313\":13,\"314\":9,\"318\":1,\"344\":26,\"348\":9,\"354\":7,\"357\":2,\"361\":20,\"367\":7,\"373\":7,\"376\":8,\"379\":19,\"382\":1,\"388\":1,\"389\":2,\"390\":2,\"391\":1,\"395\":1,\"396\":2,\"397\":3,\"398\":1,\"436\":2,\"437\":1,\"438\":2,\"439\":1,\"440\":1}}],[\"vector\",{\"1\":{\"379\":3}}],[\"vector<std\",{\"1\":{\"379\":1}}],[\"vector<int>\",{\"1\":{\"379\":5}}],[\"vec\",{\"1\":{\"379\":2}}],[\"vet2\",{\"1\":{\"219\":7}}],[\"vet1\",{\"1\":{\"219\":7}}],[\"vet\",{\"1\":{\"219\":18,\"223\":10,\"225\":5}}],[\"vertices\",{\"1\":{\"218\":4,\"223\":1}}],[\"vertex\",{\"1\":{\"213\":1,\"219\":14,\"223\":10,\"225\":6}}],[\"v\",{\"0\":{\"407\":1},\"1\":{\"120\":5,\"293\":1,\"361\":9,\"379\":1}}],[\"hpp\",{\"1\":{\"388\":1,\"389\":1,\"390\":1,\"391\":1,\"395\":1,\"396\":1,\"397\":1,\"398\":1,\"437\":1,\"438\":1,\"439\":1,\"440\":1}}],[\"horse\",{\"1\":{\"373\":2}}],[\"h里\",{\"1\":{\"361\":1}}],[\"h头文件\",{\"0\":{\"344\":1}}],[\"h的大写\",{\"1\":{\"321\":1}}],[\"h对应文件名myheader\",{\"1\":{\"321\":1}}],[\"h被重复加载\",{\"1\":{\"321\":1}}],[\"h>头文件中函数\",{\"1\":{\"291\":1}}],[\"h>头文件中的函数\",{\"1\":{\"291\":1}}],[\"h>中的函数\",{\"1\":{\"291\":1}}],[\"h>中的值为零的宏常量\",{\"1\":{\"266\":1}}],[\"h>\",{\"1\":{\"244\":4,\"245\":3,\"246\":1,\"250\":1,\"251\":1,\"252\":2,\"255\":2,\"262\":4,\"263\":3,\"264\":2,\"265\":1,\"266\":1,\"267\":1,\"271\":1,\"276\":4,\"277\":1,\"278\":1,\"279\":1,\"280\":3,\"281\":1,\"286\":4,\"287\":2,\"288\":6,\"289\":3,\"290\":1,\"291\":7,\"292\":2,\"293\":2,\"294\":2,\"297\":5,\"298\":4,\"299\":3,\"302\":2,\"309\":3,\"310\":10,\"313\":1,\"314\":11,\"317\":6,\"318\":5,\"319\":4,\"320\":1,\"325\":2,\"330\":4,\"331\":1,\"332\":1,\"333\":1,\"335\":1,\"337\":2,\"338\":1,\"344\":6,\"348\":1,\"357\":1,\"361\":1,\"388\":1,\"389\":1,\"390\":1,\"395\":1,\"396\":1,\"397\":1,\"403\":6,\"406\":6,\"436\":4,\"437\":1,\"438\":1,\"440\":1}}],[\"h+1\",{\"1\":{\"183\":1}}],[\"hello是不同的标识符\",{\"1\":{\"257\":1}}],[\"hello\",{\"1\":{\"245\":2,\"257\":1,\"263\":4,\"278\":3,\"286\":4,\"288\":1,\"289\":2,\"292\":1,\"294\":3,\"304\":2,\"310\":2,\"361\":1,\"370\":1,\"379\":1}}],[\"height\",{\"1\":{\"180\":1,\"181\":2,\"198\":2,\"199\":5}}],[\"head2\",{\"1\":{\"219\":8}}],[\"head1\",{\"1\":{\"219\":8}}],[\"heads\",{\"1\":{\"219\":1}}],[\"head\",{\"1\":{\"150\":5,\"151\":5,\"219\":10}}],[\"heaponlyclass\",{\"1\":{\"354\":8}}],[\"heapify\",{\"1\":{\"211\":1}}],[\"heapsort\",{\"1\":{\"48\":1}}],[\"heap\",{\"1\":{\"47\":1,\"208\":3,\"211\":1,\"212\":1}}],[\"http协议通过这种方式就避免了粘包问题\",{\"1\":{\"442\":1}}],[\"htons\",{\"1\":{\"436\":1}}],[\"htlength\",{\"1\":{\"124\":2}}],[\"ht\",{\"1\":{\"122\":1,\"123\":1,\"124\":5}}],[\"hmap\",{\"1\":{\"69\":1,\"167\":29}}],[\"h\",{\"1\":{\"30\":6,\"102\":1,\"142\":1,\"149\":1,\"195\":1,\"207\":1,\"245\":2,\"309\":1,\"310\":9,\"320\":15,\"321\":6,\"344\":1,\"345\":1,\"361\":5,\"379\":1,\"403\":4,\"404\":1,\"405\":1,\"406\":3}}],[\"hh\",{\"1\":{\"30\":1}}],[\"has\",{\"1\":{\"379\":14}}],[\"hashmapopenaddressing\",{\"1\":{\"172\":14}}],[\"hashmap\",{\"1\":{\"170\":51,\"172\":77}}],[\"hashmapchaining\",{\"1\":{\"170\":13}}],[\"hashfunc\",{\"1\":{\"167\":2,\"170\":4,\"172\":2}}],[\"hashtable\",{\"1\":{\"30\":13,\"167\":8}}],[\"hash\",{\"1\":{\"30\":3,\"166\":1,\"167\":4,\"168\":1,\"175\":3,\"177\":16}}],[\"happy是否被定义过\",{\"1\":{\"321\":1}}],[\"happy是否定义过\",{\"1\":{\"321\":1}}],[\"happy没有定义过\",{\"1\":{\"321\":1}}],[\"happy就是一个空的宏\",{\"1\":{\"321\":1}}],[\"happy\",{\"1\":{\"245\":4,\"321\":12}}],[\"hard\",{\"1\":{\"79\":1}}],[\"handlerevent\",{\"1\":{\"389\":1,\"390\":1,\"396\":1,\"397\":1,\"438\":1,\"439\":2,\"440\":1}}],[\"handle\",{\"1\":{\"30\":1}}],[\"实参包含了具体的数据\",{\"1\":{\"319\":1}}],[\"实参列表\",{\"1\":{\"319\":1}}],[\"实参的数量要与形参的数量一致\",{\"1\":{\"286\":1}}],[\"实例化\",{\"1\":{\"367\":1}}],[\"实例化新对象a1\",{\"1\":{\"361\":1}}],[\"实例化新对象的两种写法\",{\"1\":{\"361\":1}}],[\"实例\",{\"1\":{\"219\":1}}],[\"实例代码如下\",{\"1\":{\"193\":1}}],[\"实际使用中还是更多使用new\",{\"1\":{\"379\":1}}],[\"实际调用了派生类的实现\",{\"1\":{\"376\":1}}],[\"实际调用dog类的clone\",{\"1\":{\"376\":1}}],[\"实际参数\",{\"1\":{\"319\":1}}],[\"实际代码有以下不同\",{\"1\":{\"219\":1}}],[\"实际测试\",{\"1\":{\"135\":1}}],[\"实际上编译器\",{\"1\":{\"361\":1}}],[\"实际上需要通过修改节点指针来实现\",{\"1\":{\"201\":1}}],[\"实际上都隐含了分治的思想\",{\"1\":{\"63\":1}}],[\"实际上\",{\"1\":{\"27\":1,\"64\":1,\"77\":1,\"90\":1,\"97\":2,\"176\":1}}],[\"实现抽象类中的纯虚函数\",{\"1\":{\"376\":1}}],[\"实现多态性\",{\"1\":{\"376\":1}}],[\"实现方法\",{\"1\":{\"361\":1}}],[\"实现方式比较巧妙\",{\"1\":{\"86\":1}}],[\"实现放在\",{\"1\":{\"361\":1}}],[\"实现说明\",{\"1\":{\"354\":1}}],[\"实现姓氏升序排序\",{\"1\":{\"344\":1}}],[\"实现加载不同的头文件\",{\"1\":{\"321\":1}}],[\"实现两个数字相减\",{\"1\":{\"286\":2}}],[\"实现高效的元素查询\",{\"1\":{\"166\":1}}],[\"实现代码如下\",{\"1\":{\"109\":1,\"186\":1}}],[\"实现代码如下所示\",{\"1\":{\"30\":1,\"113\":1}}],[\"实现的\",{\"1\":{\"64\":1,\"167\":1}}],[\"实现堆排序\",{\"1\":{\"47\":1}}],[\"实现\",{\"1\":{\"30\":1}}],[\"tv\",{\"1\":{\"439\":2}}],[\"t>\",{\"1\":{\"367\":4,\"379\":1}}],[\"t来表示参数类型的占位符\",{\"1\":{\"367\":1}}],[\"types\",{\"1\":{\"403\":1,\"406\":1,\"436\":1}}],[\"type\",{\"1\":{\"364\":1,\"379\":2}}],[\"typeid的使用\",{\"1\":{\"357\":1}}],[\"typeid\",{\"1\":{\"348\":4,\"357\":2,\"379\":3,\"382\":5}}],[\"typedef也可以用来为数组类型起别名\",{\"1\":{\"304\":1}}],[\"typedef可以为指针起别名\",{\"1\":{\"304\":1}}],[\"typedef的应用场景\",{\"1\":{\"304\":1}}],[\"typedef介绍\",{\"1\":{\"304\":1}}],[\"typedef\",{\"0\":{\"304\":1},\"1\":{\"30\":1,\"120\":1,\"146\":1,\"153\":1,\"156\":1,\"157\":1,\"160\":1,\"161\":1,\"163\":2,\"164\":1,\"167\":2,\"170\":2,\"172\":1,\"180\":1,\"190\":1,\"218\":1,\"219\":2,\"223\":1,\"259\":1,\"304\":15,\"344\":2,\"361\":1}}],[\"t类型的无符号整数值\",{\"1\":{\"335\":1}}],[\"ture\",{\"1\":{\"318\":1,\"333\":1}}],[\"tue\",{\"1\":{\"301\":3}}],[\"tuesday\",{\"1\":{\"301\":1}}],[\"txt的文件\",{\"1\":{\"406\":1}}],[\"txt\",{\"1\":{\"310\":14,\"344\":2,\"370\":6,\"406\":3}}],[\"txt文件当中读取数据\",{\"1\":{\"406\":1}}],[\"txt文件当中的数据读取出来并写入管道当中即可\",{\"1\":{\"406\":1}}],[\"txt文件当中\",{\"1\":{\"406\":1}}],[\"txt文件当中即可\",{\"1\":{\"406\":1}}],[\"txt文件\",{\"1\":{\"308\":1,\"406\":4}}],[\"throw\",{\"1\":{\"382\":7}}],[\"throw的使用\",{\"1\":{\"382\":1}}],[\"thread提供的成员函数\",{\"1\":{\"379\":1}}],[\"thread2\",{\"1\":{\"379\":4}}],[\"thread1\",{\"1\":{\"379\":9}}],[\"threadfunction\",{\"1\":{\"379\":6}}],[\"thread\",{\"1\":{\"259\":1,\"379\":58}}],[\"three\",{\"1\":{\"252\":1}}],[\"the\",{\"1\":{\"310\":2,\"344\":1,\"345\":2,\"351\":1,\"376\":1}}],[\"thu\",{\"1\":{\"301\":3}}],[\"thursday\",{\"1\":{\"301\":1}}],[\"this指针\",{\"1\":{\"361\":1}}],[\"this谁调用就访问谁的成员\",{\"1\":{\"361\":1}}],[\"this\",{\"1\":{\"292\":1,\"361\":36,\"376\":2,\"379\":2}}],[\"timeval\",{\"1\":{\"439\":2}}],[\"timeout测试\",{\"0\":{\"439\":1}}],[\"timeout\",{\"1\":{\"389\":1,\"396\":1,\"438\":1,\"439\":10}}],[\"timed\",{\"1\":{\"379\":2}}],[\"time\",{\"1\":{\"291\":12,\"320\":1}}],[\"two\",{\"1\":{\"319\":1,\"370\":2,\"379\":5}}],[\"twosumhashtable\",{\"1\":{\"30\":1}}],[\"twosumbruteforce\",{\"1\":{\"29\":1}}],[\"twice\",{\"1\":{\"287\":3}}],[\"telephone\",{\"1\":{\"344\":5}}],[\"tel\",{\"1\":{\"344\":2}}],[\"text\",{\"1\":{\"309\":1,\"310\":6}}],[\"terminated\",{\"1\":{\"292\":1}}],[\"term\",{\"1\":{\"292\":1}}],[\"testdate\",{\"1\":{\"361\":1}}],[\"test\",{\"1\":{\"267\":2,\"290\":3,\"361\":3}}],[\"test函数的返回值是局部变量a的地址\",{\"1\":{\"267\":1}}],[\"template\",{\"1\":{\"367\":1}}],[\"template<>\",{\"1\":{\"367\":2}}],[\"template<int\",{\"1\":{\"367\":2}}],[\"template<typename\",{\"1\":{\"367\":5,\"379\":1}}],[\"template<typename>\",{\"1\":{\"367\":2}}],[\"template<class>\",{\"1\":{\"367\":2}}],[\"tempval\",{\"1\":{\"207\":2}}],[\"temp\",{\"1\":{\"36\":2,\"38\":2,\"39\":2,\"48\":2,\"50\":3,\"170\":3,\"207\":6,\"348\":2}}],[\"td\",{\"1\":{\"262\":5}}],[\"tax\",{\"1\":{\"257\":1}}],[\"table\",{\"1\":{\"166\":1}}],[\"tarsize\",{\"1\":{\"73\":8}}],[\"tar\",{\"1\":{\"73\":14}}],[\"target\",{\"1\":{\"20\":12,\"21\":5,\"23\":7,\"24\":11,\"26\":11,\"27\":20,\"29\":3,\"30\":3,\"64\":7,\"85\":22,\"86\":11,\"144\":2,\"151\":4}}],[\"toupper\",{\"1\":{\"293\":4}}],[\"tolower\",{\"1\":{\"293\":4}}],[\"token\",{\"1\":{\"292\":4}}],[\"to\",{\"1\":{\"292\":1,\"370\":2,\"379\":3}}],[\"tom\",{\"1\":{\"263\":5,\"278\":1,\"302\":2}}],[\"tombstone\",{\"1\":{\"172\":9}}],[\"top\",{\"1\":{\"156\":1}}],[\"total++\",{\"1\":{\"167\":3}}],[\"total\",{\"1\":{\"85\":5,\"167\":9}}],[\"try\",{\"1\":{\"379\":1,\"382\":5}}],[\"trunc\",{\"1\":{\"291\":2}}],[\"true代表1\",{\"1\":{\"333\":1}}],[\"true\",{\"1\":{\"39\":1,\"81\":1,\"82\":2,\"90\":1,\"163\":2,\"211\":1,\"212\":1,\"262\":1,\"318\":2,\"361\":1,\"379\":5,\"389\":1,\"390\":1,\"440\":1}}],[\"traversal\",{\"1\":{\"186\":2,\"187\":1}}],[\"traverse\",{\"1\":{\"143\":1}}],[\"tree\",{\"1\":{\"180\":1,\"183\":2,\"190\":2,\"192\":1,\"198\":1,\"206\":3,\"207\":2,\"304\":2}}],[\"treenode起了一个别名\",{\"1\":{\"304\":1}}],[\"treenode\",{\"1\":{\"69\":6,\"74\":1,\"75\":1,\"76\":1,\"77\":5,\"180\":8,\"182\":6,\"186\":5,\"187\":3,\"188\":1,\"193\":2,\"194\":2,\"195\":3,\"198\":9,\"199\":3,\"201\":3,\"202\":3,\"205\":2,\"206\":2,\"207\":5,\"304\":1}}],[\"t\",{\"1\":{\"30\":6,\"56\":1,\"120\":1,\"245\":1,\"246\":2,\"257\":1,\"262\":2,\"291\":13,\"292\":4,\"293\":1,\"294\":4,\"310\":9,\"314\":4,\"330\":10,\"332\":2,\"335\":1,\"337\":1,\"344\":12,\"354\":2,\"361\":2,\"367\":9,\"379\":4,\"390\":2,\"396\":1,\"397\":3,\"403\":2,\"404\":1,\"405\":1,\"406\":2,\"436\":1,\"440\":2}}],[\"tmp=x\",{\"1\":{\"348\":1}}],[\"tmp=psl\",{\"1\":{\"344\":1}}],[\"tmp=null\",{\"1\":{\"344\":1}}],[\"tmp=\",{\"1\":{\"344\":2}}],[\"tmpval\",{\"1\":{\"195\":2}}],[\"tmpsize\",{\"1\":{\"46\":3}}],[\"tmp\",{\"1\":{\"30\":7,\"42\":2,\"46\":10,\"48\":2,\"96\":2,\"98\":3,\"156\":2,\"160\":4,\"163\":2,\"170\":3,\"195\":11,\"344\":12,\"348\":1,\"361\":4}}],[\"考虑从入堆节点开始\",{\"1\":{\"211\":1}}],[\"考虑在线性探测中记录遇到的首个\",{\"1\":{\"172\":1}}],[\"考虑列约束\",{\"1\":{\"90\":1}}],[\"考虑重复元素情况\",{\"0\":{\"86\":1}}],[\"考虑相等元素情况\",{\"0\":{\"82\":1}}],[\"考虑基本情况\",{\"0\":{\"71\":1}}],[\"考虑一个长度为n的数组\",{\"1\":{\"50\":1}}],[\"考虑借助一个哈希表\",{\"1\":{\"30\":1,\"82\":1}}],[\"考虑直接遍历所有可能的组合\",{\"1\":{\"29\":1}}],[\"考虑通过查找插入点的函数实现查找左边界\",{\"1\":{\"26\":1}}],[\"哈希函数\",{\"1\":{\"170\":1,\"172\":1,\"176\":1}}],[\"哈希函数的输出结果也相同\",{\"1\":{\"168\":1}}],[\"哈希函数的作用是将所有\",{\"1\":{\"168\":1}}],[\"哈希函数的作用是将一个较大的输入空间映射到一个较小的输出空间\",{\"1\":{\"167\":1}}],[\"哈希函数的计算过程分为以下两步\",{\"1\":{\"167\":1}}],[\"哈希冲突的概率就越低\",{\"1\":{\"176\":1}}],[\"哈希冲突会导致查询结果错误\",{\"1\":{\"169\":1}}],[\"哈希冲突\",{\"0\":{\"169\":1}}],[\"哈希冲突与扩容\",{\"0\":{\"168\":1}}],[\"哈希算法处在不断升级与优化的过程中\",{\"1\":{\"178\":1}}],[\"哈希算法的设计是一个需要考虑许多因素的复杂问题\",{\"1\":{\"177\":1}}],[\"哈希算法的设计\",{\"0\":{\"177\":1}}],[\"哈希算法的目标\",{\"0\":{\"176\":1}}],[\"哈希算法需要具备更高等级的安全特性\",{\"1\":{\"176\":1}}],[\"哈希算法除了可以用于实现哈希表\",{\"1\":{\"176\":1}}],[\"哈希算法应使得键值对均匀分布在哈希表中\",{\"1\":{\"176\":1}}],[\"哈希算法应始终产生相同的输出\",{\"1\":{\"176\":1}}],[\"哈希算法应具备以下特点\",{\"1\":{\"176\":1}}],[\"哈希算法\",{\"0\":{\"175\":1},\"1\":{\"167\":1,\"175\":1}}],[\"哈希查找\",{\"0\":{\"30\":1}}],[\"哈希优化策略\",{\"0\":{\"28\":1}}],[\"哈希表容量\",{\"1\":{\"170\":1,\"172\":1}}],[\"哈希表容量n越大\",{\"1\":{\"168\":1}}],[\"哈希表的实用性越高\",{\"1\":{\"176\":1}}],[\"哈希表的性能则会急剧劣化\",{\"1\":{\"175\":1}}],[\"哈希表的键值对分布\",{\"1\":{\"172\":1}}],[\"哈希表的结构改良方法主要包括\",{\"1\":{\"169\":1}}],[\"哈希表的简单实现\",{\"0\":{\"167\":1}}],[\"哈希表扩容需将所有键值对从原哈希表迁移至新哈希表\",{\"1\":{\"168\":1}}],[\"哈希表存储\",{\"1\":{\"69\":1}}],[\"哈希表元素插入\",{\"1\":{\"30\":1}}],[\"哈希表查询\",{\"1\":{\"30\":1}}],[\"哈希表\",{\"0\":{\"6\":1,\"165\":1,\"166\":1},\"1\":{\"13\":1,\"14\":2,\"15\":2,\"30\":1,\"63\":1,\"166\":1,\"170\":1,\"172\":1,\"223\":1,\"225\":1}}],[\"所谓原子操作\",{\"1\":{\"379\":1}}],[\"所在的目录下打开命令行工具\",{\"1\":{\"287\":1}}],[\"所以运行服务器后如果没有客户端发来连接请求\",{\"1\":{\"439\":1}}],[\"所以看似没什么意义\",{\"1\":{\"406\":1}}],[\"所以成员函数中要成为inline最好直接在类里面定义\",{\"1\":{\"361\":1}}],[\"所以s1和s2的\",{\"1\":{\"361\":1}}],[\"所以下面的成员变量是声明\",{\"1\":{\"361\":1}}],[\"所以42可以隐式的传递给myclass的构造函数进行对象的构造\",{\"1\":{\"357\":1}}],[\"所以c++使用了nullptr\",{\"1\":{\"348\":1}}],[\"所以引用\",{\"1\":{\"348\":1}}],[\"所以机器数的形式值不等于其真实表示的值\",{\"1\":{\"327\":1}}],[\"所以计算机中存储和运算的所有数据都要转为二进制\",{\"1\":{\"325\":1}}],[\"所以分配许多小的内存块比分配几个大内存块的系统开销大\",{\"1\":{\"315\":1}}],[\"所以不加const也可以\",{\"1\":{\"348\":1}}],[\"所以不能用\",{\"1\":{\"313\":1}}],[\"所以不对局部变量\",{\"1\":{\"288\":1}}],[\"所以设备\",{\"1\":{\"309\":1}}],[\"所以只能为第一个成员进行赋值\",{\"1\":{\"303\":1}}],[\"所以共用体变量a的内存空间也为4个字节\",{\"1\":{\"303\":1}}],[\"所以\",{\"1\":{\"267\":1,\"321\":1}}],[\"所以结果是不可知的\",{\"1\":{\"267\":1}}],[\"所以会有一个警告\",{\"1\":{\"262\":1}}],[\"所以会更加安全和方便const定义常量的格式\",{\"1\":{\"255\":1}}],[\"所以变量也是有地址的\",{\"1\":{\"261\":1}}],[\"所以字符数组最后一个元素必须是\",{\"1\":{\"245\":1}}],[\"所以需要同时添加两个方向的边\",{\"1\":{\"219\":1}}],[\"所以需要将函数中的变量\",{\"1\":{\"27\":1}}],[\"所以上述查找操作被称为\",{\"1\":{\"144\":1}}],[\"所以我们无须特意去修改它\",{\"1\":{\"142\":1}}],[\"所以我们无法提前初始化首列状态\",{\"1\":{\"106\":1}}],[\"所以我们可从分治角度思考\",{\"1\":{\"72\":1}}],[\"所以最差时间复杂度为o\",{\"1\":{\"103\":1}}],[\"所以主对角线和次对角线的数量都为2n\",{\"1\":{\"90\":1}}],[\"所有标准库异常的基类\",{\"1\":{\"382\":1}}],[\"所有size位置没存元素\",{\"1\":{\"344\":1}}],[\"所有类型都可以使用\",{\"1\":{\"292\":1}}],[\"所有边都会被访问2次\",{\"1\":{\"225\":1}}],[\"所有顶点都会被访问1次\",{\"1\":{\"225\":1}}],[\"所有顶点都会入队并出队一次\",{\"1\":{\"223\":1}}],[\"所有结点被访问一次\",{\"1\":{\"186\":1,\"187\":1}}],[\"所有层的节点都被完全填满\",{\"1\":{\"183\":1}}],[\"所有后两位相等的\",{\"1\":{\"176\":1}}],[\"所有子问题的解只需计算一次\",{\"1\":{\"104\":1}}],[\"所有重叠子问题都只需计算一次\",{\"1\":{\"94\":1}}],[\"所有元素自动初始化为空字符\",{\"1\":{\"288\":1}}],[\"所有元素自动初始化为0\",{\"1\":{\"288\":1}}],[\"所有元素的和\",{\"1\":{\"246\":3}}],[\"所有元素均已排序\",{\"1\":{\"41\":1}}],[\"所有元素未排序\",{\"1\":{\"36\":1}}],[\"所有的\",{\"1\":{\"18\":1}}],[\"所有数据都是以二进制数的形式存储的\",{\"1\":{\"18\":1}}],[\"所有数据结构都是基于数组\",{\"1\":{\"15\":1}}],[\"并用telnet工具连接我们的服务器\",{\"1\":{\"441\":1}}],[\"并用该节点替换当前节点\",{\"1\":{\"207\":1}}],[\"并记录最大的文件描述符\",{\"1\":{\"438\":1}}],[\"并以写的方式打开该文件\",{\"1\":{\"406\":1}}],[\"并以文件的形式存储到磁盘中\",{\"1\":{\"271\":1}}],[\"并不是简单的发送字符串而已\",{\"1\":{\"404\":1}}],[\"并打印输出客户端的ip和端口号\",{\"1\":{\"391\":1,\"398\":1}}],[\"并关心其读事件\",{\"1\":{\"389\":1,\"390\":1,\"396\":1,\"397\":1}}],[\"并调用虚函数draw\",{\"1\":{\"376\":1}}],[\"并防止拷贝\",{\"1\":{\"354\":1}}],[\"并防拷贝\",{\"1\":{\"354\":2}}],[\"并提供一个全局访问点\",{\"1\":{\"354\":1}}],[\"并会定义宏myheader\",{\"1\":{\"321\":1}}],[\"并写入到输出文件中\",{\"1\":{\"310\":1}}],[\"并自动添加换行符\",{\"1\":{\"309\":1}}],[\"并取结构体变量的地址作为结构体指针的值\",{\"1\":{\"302\":1}}],[\"并给结构体成员赋值\",{\"1\":{\"302\":1}}],[\"并接收指定的字符串传给参数argv\",{\"1\":{\"287\":1}}],[\"并直接赋值\",{\"1\":{\"250\":1,\"251\":1}}],[\"并使用一个标识符命名\",{\"1\":{\"243\":1}}],[\"并使用过去子问题的解来构建当前子问题的解\",{\"1\":{\"113\":1}}],[\"并开启循环\",{\"1\":{\"223\":1}}],[\"并一层层向外扩张\",{\"1\":{\"222\":1}}],[\"并全部填0即可\",{\"1\":{\"218\":1}}],[\"并引起一些安全问题\",{\"1\":{\"178\":1}}],[\"并与接收到的哈希值进行比较\",{\"1\":{\"176\":1}}],[\"并返回dog\",{\"1\":{\"376\":1}}],[\"并返回\",{\"1\":{\"170\":2,\"172\":1,\"207\":1}}],[\"并返回指针j\",{\"1\":{\"27\":1}}],[\"并返回指针i\",{\"1\":{\"27\":1}}],[\"并维护一个变量\",{\"1\":{\"161\":1}}],[\"并更新最大容量\",{\"1\":{\"123\":1}}],[\"并按照重量比例来计算相应价值\",{\"1\":{\"118\":1}}],[\"并按照以下顺序解决这三个子问题\",{\"1\":{\"72\":1}}],[\"并具有较为明显的\",{\"1\":{\"101\":1}}],[\"并满足无后效性\",{\"1\":{\"101\":1}}],[\"并通过编号\",{\"1\":{\"243\":1}}],[\"并通过剪枝避免不必要的搜索分支\",{\"1\":{\"97\":1}}],[\"并通过存储子问题的解来避免重复计算\",{\"1\":{\"92\":1}}],[\"并添加进\",{\"1\":{\"90\":1}}],[\"并添加进结果列表\",{\"1\":{\"75\":1}}],[\"并在容器原有的插入方法基础上重载右值引用版本的插入函数\",{\"1\":{\"379\":2}}],[\"并在程序入口之前现将其初始化为空\",{\"1\":{\"354\":2}}],[\"并在程序入口之前完成单例对象的初始化\",{\"1\":{\"354\":1}}],[\"并在树中递归删除节点\",{\"1\":{\"195\":1}}],[\"并在每一层按照从左到右的顺序访问节点\",{\"1\":{\"186\":1}}],[\"并在桶中获取\",{\"1\":{\"167\":1}}],[\"并在求解过程中验证它\",{\"1\":{\"101\":1}}],[\"并在回溯中合并子问题的解\",{\"1\":{\"97\":1}}],[\"并在回溯中动态更新\",{\"1\":{\"89\":1}}],[\"并在搜索过程中将重叠子问题剪枝\",{\"1\":{\"94\":1}}],[\"并在选择过程中实时更新\",{\"1\":{\"85\":1}}],[\"并在剩余区间执行相同的二分操作\",{\"1\":{\"63\":1}}],[\"并将对应的套接字从fd\",{\"1\":{\"441\":1}}],[\"并将对应的套接字从fds数组当中清除\",{\"1\":{\"391\":1}}],[\"并将我们设置的提示语句进行打印输出\",{\"1\":{\"439\":3}}],[\"并将拷贝构造函数和赋值运算符重载函数设置为私有或删除\",{\"1\":{\"354\":3}}],[\"并将拷贝构造函数和赋值运算符重载设置为私有或删除\",{\"1\":{\"354\":1}}],[\"并将该接口设置为静态成员函数\",{\"1\":{\"354\":1}}],[\"并将该元素插入到正确的位置\",{\"1\":{\"40\":1}}],[\"并将其存储在一个字符数组中\",{\"1\":{\"309\":1}}],[\"并将其存储到变量\",{\"1\":{\"252\":1}}],[\"并将其翻译成汇编代码\",{\"1\":{\"271\":1}}],[\"并将分别将其存储到变量\",{\"1\":{\"252\":1}}],[\"并将新增顶点作为链表头节点\",{\"1\":{\"219\":1}}],[\"并将第\",{\"1\":{\"218\":1}}],[\"并将搜索到的目标元素与该\",{\"1\":{\"172\":1}}],[\"并将\",{\"1\":{\"161\":2}}],[\"并将短板向内移动一格\",{\"1\":{\"123\":1}}],[\"并将重叠子问题进行剪枝\",{\"1\":{\"104\":1}}],[\"并将重复元素剪枝\",{\"1\":{\"82\":1}}],[\"并基于它实现以下剪枝操作\",{\"1\":{\"81\":1}}],[\"并实现框架中的各个方法即可\",{\"1\":{\"77\":1}}],[\"并要求路径中不包含值为3的节点\",{\"1\":{\"76\":1}}],[\"并尝试其他可能的选择\",{\"1\":{\"75\":1}}],[\"并判断当前节点的值是否为7\",{\"1\":{\"74\":1}}],[\"并保持它们的原有顺序不变\",{\"1\":{\"70\":1}}],[\"并行优化在多核或多处理器的环境中尤其有效\",{\"1\":{\"62\":1}}],[\"并行计算优化\",{\"0\":{\"62\":1}}],[\"并且还需要一个数组来保存需要被监视写事件是否就绪的文件描述符\",{\"1\":{\"442\":1}}],[\"并且后续打印输出timeout的值都是4\",{\"1\":{\"439\":1}}],[\"并且每次打印输出timeout的值都是0\",{\"1\":{\"439\":1}}],[\"并且可以被修改\",{\"1\":{\"379\":1}}],[\"并且该接口必须设置为静态成员函数\",{\"1\":{\"354\":1}}],[\"并且只声明不实现\",{\"1\":{\"354\":1}}],[\"并且上一行对某个变量的修改对下一行会产生影响\",{\"1\":{\"296\":1}}],[\"并且仍然保持二叉搜索树的性质\",{\"1\":{\"201\":1}}],[\"并且这个质数最好足够大\",{\"1\":{\"177\":1}}],[\"并且由于哈希表容量\",{\"1\":{\"168\":1}}],[\"并且\",{\"1\":{\"158\":1}}],[\"并且有可能找到非常差的解\",{\"1\":{\"114\":1}}],[\"并且把内循环更改为倒序遍历即可\",{\"1\":{\"111\":1}}],[\"并且一个状态与其周围的状态存在递推关系\",{\"1\":{\"101\":1}}],[\"并且解是通过一系列决策产生的\",{\"1\":{\"101\":1}}],[\"并且将不满足列约束和对角线约束的方案都进行了剪枝\",{\"1\":{\"88\":1}}],[\"并且是稳定排序\",{\"1\":{\"54\":1}}],[\"并且无须特别处理正负零的歧义问题\",{\"1\":{\"17\":1}}],[\"最基本的互斥量\",{\"1\":{\"379\":1}}],[\"最简日期类相减运算\",{\"1\":{\"361\":1}}],[\"最简单的加锁方式就是在进行if判断之前加锁\",{\"1\":{\"354\":1}}],[\"最多记录1000人\",{\"1\":{\"342\":1}}],[\"最多不要超过3层\",{\"1\":{\"298\":1}}],[\"最多能够表示\",{\"1\":{\"18\":1}}],[\"最底层节点靠左填充\",{\"1\":{\"208\":1}}],[\"最差情况下所有键值对都存储到同一个桶中\",{\"1\":{\"175\":1}}],[\"最差时间复杂度\",{\"1\":{\"33\":1}}],[\"最小\",{\"1\":{\"117\":1,\"208\":1}}],[\"最小路径和\",{\"1\":{\"102\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1}}],[\"最小子问题的解是已知的\",{\"1\":{\"93\":1}}],[\"最优子结构\",{\"0\":{\"98\":1},\"1\":{\"97\":1,\"101\":1}}],[\"最直接地\",{\"1\":{\"82\":1}}],[\"最高位是第8位\",{\"1\":{\"56\":1}}],[\"最终就能够读取到一个完整的http报文\",{\"1\":{\"442\":1}}],[\"最终编译器进行了优化\",{\"1\":{\"361\":1}}],[\"最终由n\",{\"1\":{\"361\":1}}],[\"最终无法得到我们想要的结果\",{\"1\":{\"319\":1}}],[\"最终导致增删查改操作效率劣化\",{\"1\":{\"172\":1}}],[\"最终\",{\"1\":{\"99\":1}}],[\"最终得到原问题的解\",{\"1\":{\"97\":1}}],[\"最终按照桶的顺序将所有数据合并\",{\"1\":{\"49\":1}}],[\"最终i和j会分别指向首个大于\",{\"1\":{\"27\":1}}],[\"最大值和最小值不相等则让天数+1\",{\"1\":{\"361\":1}}],[\"最大值标记空位\",{\"1\":{\"190\":1}}],[\"最大对齐数的整数倍\",{\"1\":{\"361\":1}}],[\"最大对齐数\",{\"1\":{\"361\":1}}],[\"最大切分乘积\",{\"1\":{\"128\":1}}],[\"最大切分乘积问题\",{\"0\":{\"126\":1}}],[\"最大容量\",{\"1\":{\"124\":1}}],[\"最大容量问题\",{\"0\":{\"122\":1}}],[\"最大化背包内物品总价值\",{\"1\":{\"119\":1}}],[\"最大递归深度为n\",{\"1\":{\"82\":1,\"90\":1}}],[\"最大团问题是图论中的一个经典问题\",{\"1\":{\"79\":1}}],[\"最大团问题\",{\"1\":{\"79\":1}}],[\"最大位数为k\",{\"1\":{\"56\":1}}],[\"最大或索引\",{\"1\":{\"48\":1,\"212\":1}}],[\"最大元素位于堆顶\",{\"1\":{\"48\":1}}],[\"最大的元素会被移动到数组的最右端\",{\"1\":{\"37\":1}}],[\"最后赋值的属性\",{\"1\":{\"303\":1}}],[\"最后两位相同的\",{\"1\":{\"172\":1}}],[\"最后得到的霍夫曼树的带权路径长度\",{\"1\":{\"117\":1}}],[\"最后选择2\",{\"1\":{\"81\":1}}],[\"最后将小圆盘从\",{\"1\":{\"71\":1}}],[\"最后将各个桶的元素依次取出\",{\"1\":{\"63\":1}}],[\"最后将基准数交换至两个子数组的分界线\",{\"1\":{\"42\":1}}],[\"最后找出跨越两部分的最近点对\",{\"1\":{\"63\":1}}],[\"最后一个节点被称为\",{\"1\":{\"146\":1}}],[\"最后一个元素设置成\",{\"1\":{\"245\":1}}],[\"最后一个元素\",{\"1\":{\"48\":1}}],[\"最后一轮的未排序区间长度为2\",{\"1\":{\"36\":1}}],[\"最后处理合并\",{\"1\":{\"46\":1}}],[\"最后处理根节点\",{\"1\":{\"46\":1}}],[\"最佳时间复杂度可达到o\",{\"1\":{\"37\":1}}],[\"指一个派生类继承多个基类\",{\"1\":{\"373\":2}}],[\"指一个派生类只继承一个基类\",{\"1\":{\"373\":1}}],[\"指的是一个类只能创建一个对象\",{\"1\":{\"354\":1}}],[\"指令系统\",{\"0\":{\"485\":1,\"486\":1}}],[\"指令用于引入标准库头文件\",{\"1\":{\"320\":1}}],[\"指令结束是通过换行符来识别的\",{\"1\":{\"317\":1}}],[\"指令前面可以有空白字符\",{\"1\":{\"317\":1}}],[\"指明具体的类型\",{\"1\":{\"286\":1}}],[\"指定它将指向的数组\",{\"1\":{\"263\":1}}],[\"指定元素的类型\",{\"1\":{\"244\":1}}],[\"指定元素的类型和个数并同时进行初始化\",{\"1\":{\"244\":1}}],[\"指针范围\",{\"1\":{\"379\":1}}],[\"指针赋给其他类型指针\",{\"1\":{\"313\":1}}],[\"指针不包含指向的数据类型的信息\",{\"1\":{\"313\":1}}],[\"指针不能解引用\",{\"1\":{\"313\":1}}],[\"指针并解引用\",{\"1\":{\"313\":2}}],[\"指针转换为\",{\"1\":{\"313\":2}}],[\"指针转为\",{\"1\":{\"313\":2}}],[\"指针也可以转为任一类型的指针由于不知道\",{\"1\":{\"313\":1}}],[\"指针与其他所有类型指针之间是互相转换关系\",{\"1\":{\"313\":1}}],[\"指针与整数的加减运算\",{\"1\":{\"262\":1}}],[\"指针用\",{\"1\":{\"302\":1}}],[\"指针初始化如果没有确切的地址赋值\",{\"1\":{\"267\":1}}],[\"指针指向什么类型的值\",{\"1\":{\"313\":1}}],[\"指针指向已释放的空间\",{\"1\":{\"267\":1}}],[\"指针指向int类型\",{\"1\":{\"262\":1}}],[\"指针越界访问\",{\"1\":{\"267\":1}}],[\"指针变量必须有类型\",{\"1\":{\"313\":1}}],[\"指针变量在定义时如果未初始化\",{\"1\":{\"267\":1}}],[\"指针变量名\",{\"1\":{\"261\":1}}],[\"指针使用前未初始化\",{\"1\":{\"267\":1}}],[\"指针和函数\",{\"0\":{\"264\":1}}],[\"指针和数组\",{\"0\":{\"263\":1}}],[\"指针数组的每个元素指向不同的整数\",{\"1\":{\"263\":1}}],[\"指针数组名\",{\"1\":{\"263\":1}}],[\"指针数组指针数组\",{\"1\":{\"263\":1}}],[\"指针得到的是本身的大小数组名不能进行自增\",{\"1\":{\"263\":1}}],[\"指针之间可以进行比较运算\",{\"1\":{\"262\":1}}],[\"指针自减\",{\"1\":{\"262\":1}}],[\"指针自增\",{\"1\":{\"262\":2}}],[\"指针自增自减\",{\"1\":{\"262\":1}}],[\"指针加3\",{\"1\":{\"262\":1}}],[\"指针加减整数\",{\"1\":{\"262\":1}}],[\"指针移动多少\",{\"1\":{\"262\":1}}],[\"指针大小只与地址线有关\",{\"1\":{\"261\":1}}],[\"指针大小一般为\",{\"1\":{\"261\":1}}],[\"指针的形式传递\",{\"1\":{\"310\":1}}],[\"指针的描述\",{\"0\":{\"268\":1}}],[\"指针的比较运算\",{\"1\":{\"262\":1}}],[\"指针的运算\",{\"0\":{\"262\":1}}],[\"指针的大小\",{\"1\":{\"261\":1}}],[\"指针的定义\",{\"1\":{\"261\":1}}],[\"指针的理解\",{\"0\":{\"261\":1}}],[\"指针里面存储的是变量\",{\"1\":{\"261\":1}}],[\"指针\",{\"0\":{\"231\":1,\"260\":1},\"1\":{\"146\":2,\"148\":1,\"149\":1,\"153\":1,\"180\":1,\"181\":1,\"182\":2,\"189\":1,\"213\":1,\"262\":1,\"302\":1,\"313\":4,\"314\":1,\"373\":1}}],[\"指针i和j分列数组两端\",{\"1\":{\"123\":1}}],[\"指针i和j使用常数大小的额外空间稳定排序\",{\"1\":{\"37\":1,\"41\":1}}],[\"指针i和j使用常数大小的额外空间非稳定排序\",{\"1\":{\"36\":1}}],[\"指针i和j使用常数大小空间\",{\"1\":{\"20\":1}}],[\"指针i指向最左一个\",{\"1\":{\"27\":1}}],[\"指数阶属于爆炸式增长\",{\"1\":{\"93\":1}}],[\"指向的空间\",{\"1\":{\"314\":1}}],[\"指向的是已经释放的内存空间\",{\"1\":{\"267\":1}}],[\"指向新分配内存块的地址\",{\"1\":{\"314\":2}}],[\"指向新的字符串\",{\"1\":{\"263\":1}}],[\"指向指针的指针\",{\"0\":{\"265\":1}}],[\"指向队尾索引\",{\"1\":{\"161\":1,\"164\":1}}],[\"指向队尾\",{\"1\":{\"161\":1,\"164\":1}}],[\"指向队尾元素之后的下一个位置\",{\"1\":{\"161\":1}}],[\"指向队首元素\",{\"1\":{\"161\":1,\"164\":1}}],[\"指向队首元素的索引\",{\"1\":{\"161\":1}}],[\"指向前驱节点的指针\",{\"1\":{\"153\":1}}],[\"指向后继节点的指针\",{\"1\":{\"153\":1}}],[\"指向下一节点的指针\",{\"1\":{\"146\":1}}],[\"指向首个大于\",{\"1\":{\"27\":1}}],[\"指向最右一个\",{\"1\":{\"27\":1}}],[\"代替指针使用\",{\"1\":{\"348\":1}}],[\"代替链表\",{\"1\":{\"170\":1}}],[\"代价\",{\"1\":{\"103\":1,\"104\":1}}],[\"代表了一个具体的对象\",{\"1\":{\"302\":1}}],[\"代表一个顶点\",{\"1\":{\"216\":1}}],[\"代表无记录\",{\"1\":{\"94\":1}}],[\"代表无目标元素\",{\"1\":{\"64\":1}}],[\"代表空位\",{\"1\":{\"90\":1,\"190\":1}}],[\"代表皇后\",{\"1\":{\"90\":1}}],[\"代表它已被选择\",{\"1\":{\"81\":1}}],[\"代表\",{\"1\":{\"53\":1,\"54\":1,\"180\":1,\"240\":1}}],[\"代表搜索区间\",{\"1\":{\"20\":1}}],[\"代码中直接将读取的数据存储到了字符数组buffer当中\",{\"1\":{\"442\":1}}],[\"代码中读取数据时并没有按照某种规则进行读取\",{\"1\":{\"442\":1}}],[\"代码编写完毕后\",{\"1\":{\"403\":1}}],[\"代码短的用inline\",{\"1\":{\"361\":1}}],[\"代码经过预处理之后再送入编译器进行编译预处理器的主要任务包括宏替换\",{\"1\":{\"317\":1}}],[\"代码块通常具有花括号\",{\"1\":{\"288\":1}}],[\"代码分析等功能\",{\"1\":{\"270\":1}}],[\"代码管控工具\",{\"1\":{\"270\":1}}],[\"代码相对抽象\",{\"1\":{\"223\":1}}],[\"代码如下\",{\"1\":{\"212\":1,\"262\":1,\"287\":1,\"291\":1,\"304\":1}}],[\"代码如下所示\",{\"1\":{\"26\":1,\"48\":1,\"75\":1,\"76\":1,\"92\":1,\"94\":1,\"96\":1,\"105\":1,\"110\":1,\"201\":1,\"205\":1,\"206\":1,\"207\":1,\"211\":1,\"223\":1}}],[\"代码循环最多n轮\",{\"1\":{\"124\":1}}],[\"代码实现\",{\"0\":{\"90\":1,\"120\":1,\"124\":1,\"128\":1},\"1\":{\"81\":1,\"82\":1,\"85\":1,\"86\":1}}],[\"代码在此省略\",{\"1\":{\"27\":1}}],[\"直虚线代表向下递推\",{\"1\":{\"225\":1}}],[\"直接用20作为参数构造新对象a2\",{\"1\":{\"361\":1}}],[\"直接构造\",{\"1\":{\"361\":1}}],[\"直接引入即可\",{\"1\":{\"320\":1}}],[\"直接进行文本替换\",{\"1\":{\"318\":1}}],[\"直接使用变量名进行的访问\",{\"1\":{\"261\":1}}],[\"直接使用的常量\",{\"1\":{\"254\":1}}],[\"直接访问\",{\"1\":{\"261\":1}}],[\"直接定义并初始化\",{\"1\":{\"246\":1}}],[\"直接在邻接矩阵中修改指定的边即可\",{\"1\":{\"218\":1}}],[\"直接删除\",{\"1\":{\"207\":2}}],[\"直接提前返回\",{\"1\":{\"195\":1}}],[\"直接遍历数组\",{\"1\":{\"190\":1}}],[\"直接回到数组头部继续遍历\",{\"1\":{\"161\":1}}],[\"直接跳过\",{\"1\":{\"86\":1}}],[\"直接对排列结果进行去重\",{\"1\":{\"82\":1}}],[\"直接移至\",{\"1\":{\"72\":1}}],[\"直接移动至\",{\"1\":{\"72\":1}}],[\"直接返回\",{\"1\":{\"26\":1,\"194\":2,\"205\":1,\"206\":1}}],[\"直至所有顶点遍历完成\",{\"1\":{\"224\":1}}],[\"直至所有顶点访问完毕\",{\"1\":{\"222\":1}}],[\"直至所有桶中的元素数量大致相等\",{\"1\":{\"51\":1}}],[\"直至越过根节点或遇到无须交换的节点时结束\",{\"1\":{\"211\":1}}],[\"直至找到空桶\",{\"1\":{\"172\":1}}],[\"直至找到目标节点\",{\"1\":{\"150\":1}}],[\"直至找到目标元素或搜索区间为空为止\",{\"1\":{\"20\":1}}],[\"直至冲突消失为止\",{\"1\":{\"169\":1}}],[\"直至两板相遇\",{\"1\":{\"124\":1}}],[\"直至两指针相遇\",{\"1\":{\"123\":1}}],[\"直至i和j相遇时结束\",{\"1\":{\"123\":1}}],[\"直至凑出目标金额为止\",{\"1\":{\"113\":1}}],[\"直至问题被解决\",{\"1\":{\"113\":1}}],[\"直至到达右下角单元格\",{\"1\":{\"102\":1}}],[\"直至到达最小子问题dp\",{\"1\":{\"93\":1}}],[\"直至到达最小子问题时终止\",{\"1\":{\"58\":1}}],[\"直至最小子问题\",{\"1\":{\"97\":1}}],[\"直至最后一行结束\",{\"1\":{\"88\":1}}],[\"直至得到原问题的解\",{\"1\":{\"95\":1}}],[\"直至解已知的最小子问题\",{\"1\":{\"95\":1}}],[\"直至达到最小子问题f\",{\"1\":{\"72\":1}}],[\"直至达到最小子问题\",{\"1\":{\"66\":1}}],[\"直至子数组只剩下一个元素\",{\"1\":{\"63\":1}}],[\"直至子数组区间长度为\",{\"1\":{\"46\":1}}],[\"直至子数组长度为\",{\"1\":{\"43\":1}}],[\"直至结束\",{\"1\":{\"45\":1}}],[\"直到商为0为止\",{\"1\":{\"326\":2}}],[\"直到耗尽系统可用的内存资源free\",{\"1\":{\"314\":1}}],[\"直到条件不成立停止循环\",{\"1\":{\"298\":1}}],[\"直到遇到换行符为止函数原型\",{\"1\":{\"309\":1}}],[\"直到遇到break或者执行到switch结尾\",{\"1\":{\"297\":1}}],[\"直到遇到结束标记\",{\"1\":{\"245\":1}}],[\"直到走到尽头时返回\",{\"1\":{\"224\":1}}],[\"直到所有顶点被访问完毕后结束\",{\"1\":{\"223\":1}}],[\"直到所有位都排序完成后结束\",{\"1\":{\"56\":1}}],[\"直到越过叶节点或遇到无须交换的节点时结束\",{\"1\":{\"212\":1}}],[\"直到越过叶节点\",{\"1\":{\"194\":1}}],[\"直到找到目标元素时返回\",{\"1\":{\"174\":1}}],[\"直到找到空位后插入元素\",{\"1\":{\"174\":1}}],[\"直到找到对应元素\",{\"1\":{\"172\":1}}],[\"直到找到解或者尝试了所有可能的选择都无法找到解为止\",{\"1\":{\"74\":1}}],[\"直到基本情况时停止\",{\"1\":{\"136\":1}}],[\"直到任务完成递归\",{\"1\":{\"136\":1}}],[\"直到达到\",{\"1\":{\"136\":1}}],[\"直到这个条件不再满足\",{\"1\":{\"136\":1}}],[\"直到无剩余金额\",{\"1\":{\"113\":1}}],[\"直到\",{\"1\":{\"42\":1}}],[\"回车符\",{\"1\":{\"332\":1}}],[\"回车\",{\"1\":{\"293\":1}}],[\"回顾完全二叉树的定义\",{\"1\":{\"190\":1}}],[\"回忆哈希函数的计算步骤\",{\"1\":{\"175\":1}}],[\"回忆二分查找插入点的方法\",{\"1\":{\"26\":1}}],[\"回到尾部\",{\"1\":{\"164\":1}}],[\"回到头部继续遍历\",{\"1\":{\"172\":1}}],[\"回到头部\",{\"1\":{\"164\":1}}],[\"回退表示撤销一个选择\",{\"1\":{\"81\":1}}],[\"回退并不仅仅包括函数返回\",{\"1\":{\"75\":1}}],[\"回退\",{\"1\":{\"75\":4,\"76\":1,\"77\":3,\"81\":1,\"82\":1,\"85\":2,\"86\":1,\"90\":1,\"92\":1}}],[\"回溯到了开启此方法的位置\",{\"1\":{\"225\":1}}],[\"回溯中的侧重点不同\",{\"1\":{\"97\":1}}],[\"回溯不是最优解决方案\",{\"1\":{\"79\":1}}],[\"回溯\",{\"0\":{\"74\":1},\"1\":{\"92\":2}}],[\"回溯算法在尝试和回退中穷举所有可能的解\",{\"1\":{\"97\":1}}],[\"回溯算法可用于解决许多搜索问题\",{\"1\":{\"79\":1}}],[\"回溯算法经典例题\",{\"0\":{\"79\":1}}],[\"回溯算法仍然是某些搜索问题和约束满足问题的最佳解决方案\",{\"1\":{\"78\":1}}],[\"回溯算法通常并不显式地对问题进行拆解\",{\"1\":{\"93\":1}}],[\"回溯算法通常需要遍历状态空间的所有可能\",{\"1\":{\"78\":1}}],[\"回溯算法通常采用\",{\"1\":{\"74\":1}}],[\"回溯算法的运行效率可能难以接受\",{\"1\":{\"78\":1}}],[\"回溯算法本质上是一种深度优先搜索算法\",{\"1\":{\"78\":1}}],[\"回溯算法框架\",{\"1\":{\"77\":1}}],[\"回溯算法\",{\"0\":{\"11\":1},\"1\":{\"74\":1,\"77\":1,\"81\":1,\"82\":1,\"85\":2,\"86\":1,\"90\":1}}],[\"首位就是代表1\",{\"1\":{\"327\":1}}],[\"首位为符号位\",{\"1\":{\"327\":1}}],[\"首尾相接\",{\"1\":{\"153\":1}}],[\"首个元素的地址偏移量是0\",{\"1\":{\"140\":1}}],[\"首个小于\",{\"1\":{\"24\":1}}],[\"首元素内存地址\",{\"1\":{\"140\":1}}],[\"首列\",{\"1\":{\"105\":1,\"106\":1}}],[\"首行\",{\"1\":{\"105\":1,\"106\":1}}],[\"首先遍历该顶点的所有邻接顶点\",{\"1\":{\"222\":1}}],[\"首先初始化节点\",{\"1\":{\"182\":1}}],[\"首先通过哈希函数访问链表头节点\",{\"1\":{\"170\":1}}],[\"首先\",{\"1\":{\"38\":1,\"43\":1}}],[\"首先给出三者的定义\",{\"1\":{\"17\":1}}],[\"存放时间差\",{\"1\":{\"291\":1}}],[\"存放的地址\",{\"1\":{\"265\":2}}],[\"存在多条路径可以从左上角到达某一单元格\",{\"1\":{\"103\":1}}],[\"存在重复元素\",{\"1\":{\"24\":1}}],[\"存在重复元素情况\",{\"0\":{\"24\":1}}],[\"存储系统\",{\"0\":{\"483\":1}}],[\"存储器层次结构\",{\"0\":{\"482\":1}}],[\"存储类别说明符分为\",{\"1\":{\"334\":1}}],[\"存储类别说明符\",{\"0\":{\"334\":1}}],[\"存储类型关键字\",{\"1\":{\"259\":1}}],[\"存储长度是\",{\"1\":{\"332\":1}}],[\"存储大小\",{\"1\":{\"330\":1,\"331\":1}}],[\"存储的值\",{\"1\":{\"249\":1}}],[\"存储\",{\"1\":{\"69\":1}}],[\"存储结构\",{\"0\":{\"15\":1}}],[\"无论被监视的文件描述符上的事件是否就绪\",{\"1\":{\"439\":1}}],[\"无论是否加virtual\",{\"1\":{\"376\":1}}],[\"无论是文本文件还是二进制文件\",{\"1\":{\"310\":1}}],[\"无效参数等\",{\"1\":{\"382\":1}}],[\"无效的转换等\",{\"1\":{\"382\":1}}],[\"无序容器\",{\"1\":{\"379\":1}}],[\"无参构造\",{\"1\":{\"361\":1}}],[\"无参构造函数\",{\"1\":{\"361\":1}}],[\"无需排序\",{\"1\":{\"344\":1}}],[\"无\",{\"1\":{\"344\":14}}],[\"无符号char取值范围\",{\"1\":{\"332\":1}}],[\"无符号\",{\"1\":{\"330\":2,\"332\":1}}],[\"无符号long类型\",{\"1\":{\"330\":1}}],[\"无类型指针\",{\"0\":{\"313\":1}}],[\"无返回值\",{\"1\":{\"286\":1}}],[\"无返回值类型\",{\"1\":{\"286\":1}}],[\"无路可走再回头的遍历方式\",{\"1\":{\"224\":1}}],[\"无意义\",{\"1\":{\"142\":2}}],[\"无初始值\",{\"1\":{\"139\":1}}],[\"无后效性是动态规划能够有效解决问题的重要特性之一\",{\"1\":{\"99\":1}}],[\"无后效性\",{\"0\":{\"99\":1},\"1\":{\"97\":1}}],[\"无相等元素的情况\",{\"0\":{\"81\":1}}],[\"无须旋转\",{\"1\":{\"205\":1}}],[\"无须进行额外的排序操作\",{\"1\":{\"196\":1}}],[\"无须额外的结构开销\",{\"1\":{\"138\":1}}],[\"无须使用递归\",{\"1\":{\"95\":1}}],[\"无须排序\",{\"1\":{\"36\":1,\"38\":1}}],[\"无须借助额外的辅助数组\",{\"1\":{\"33\":1}}],[\"无重复元素\",{\"1\":{\"23\":1}}],[\"无重复元素的情况\",{\"0\":{\"23\":1,\"85\":1}}],[\"无法一次发送完毕\",{\"1\":{\"442\":1}}],[\"无法防止外部在静态区创建对象\",{\"1\":{\"354\":1}}],[\"无法防止外部调用拷贝构造函数创建对象\",{\"1\":{\"354\":1}}],[\"无法删除\",{\"1\":{\"344\":1}}],[\"无法获取\",{\"1\":{\"289\":1}}],[\"无法通过哈希值反推出关于输入数据的任何信息\",{\"1\":{\"176\":1}}],[\"无法用于排序对象\",{\"1\":{\"53\":1}}],[\"无法在多语言环境下正常工作\",{\"1\":{\"18\":1}}],[\"无法处理部分罕见字和繁体字\",{\"1\":{\"18\":1}}],[\"返回临时对象的函数\",{\"1\":{\"379\":1}}],[\"返回const迭代器\",{\"1\":{\"379\":2}}],[\"返回date类的引用\",{\"1\":{\"361\":1}}],[\"返回dp\",{\"1\":{\"99\":1}}],[\"返回局部对象的过程势必需要调用拷贝构造函数\",{\"1\":{\"354\":1}}],[\"返回返回一个空指针\",{\"1\":{\"314\":1}}],[\"返回文件指针相对于起始位置的偏移量\",{\"1\":{\"310\":1}}],[\"返回成功读取和分配的参数数目\",{\"1\":{\"310\":1}}],[\"返回成功写入的字符数\",{\"1\":{\"309\":1}}],[\"返回一个日期类型的对象\",{\"1\":{\"361\":1}}],[\"返回一个\",{\"1\":{\"314\":1}}],[\"返回一个void指针\",{\"1\":{\"314\":1}}],[\"返回一个空指针\",{\"1\":{\"310\":1,\"314\":2}}],[\"返回一个指向重新分配内存块的指针\",{\"1\":{\"314\":1}}],[\"返回一个指向\",{\"1\":{\"310\":1}}],[\"返回一个指向存储在\",{\"1\":{\"309\":1}}],[\"返回一个整数值\",{\"1\":{\"309\":2,\"310\":4}}],[\"返回一个不确定的值\",{\"1\":{\"286\":1}}],[\"返回错误码对应的描述字符串\",{\"1\":{\"292\":1}}],[\"返回类型与return的值类型不一致\",{\"1\":{\"286\":1}}],[\"返回类型可以写\",{\"1\":{\"286\":1}}],[\"返回的指针可能与原始指针相同\",{\"1\":{\"314\":1}}],[\"返回的值与输入的\",{\"1\":{\"310\":1}}],[\"返回的是负值同类型指针相减的结果是一个\",{\"1\":{\"262\":1}}],[\"返回的是正值\",{\"1\":{\"262\":1}}],[\"返回的插入点是i\",{\"1\":{\"27\":1}}],[\"返回它们之间的距离\",{\"1\":{\"262\":1}}],[\"返回堆顶元素\",{\"1\":{\"212\":1}}],[\"返回子树的根节点\",{\"1\":{\"206\":1,\"207\":1}}],[\"返回旋转后子树的根节点\",{\"1\":{\"201\":1,\"202\":1}}],[\"返回目标节点\",{\"1\":{\"193\":1}}],[\"返回桶索引\",{\"1\":{\"172\":1}}],[\"返回移动后的桶索引\",{\"1\":{\"172\":1}}],[\"返回对应的桶索引\",{\"1\":{\"172\":1}}],[\"返回对应的姓名\",{\"1\":{\"166\":1}}],[\"返回扩展后的新数组\",{\"1\":{\"145\":1}}],[\"返回最大容量\",{\"1\":{\"122\":1}}],[\"返回两种方案中价值更大的那一个\",{\"1\":{\"108\":1}}],[\"返回值用的别名\",{\"1\":{\"361\":1}}],[\"返回值说明\",{\"1\":{\"309\":4,\"310\":8,\"314\":4}}],[\"返回值有精度损失\",{\"1\":{\"286\":1}}],[\"返回值常常是一个计算的结果\",{\"1\":{\"286\":1}}],[\"返回值的类型要与函数名前面的返回类型对应\",{\"1\":{\"286\":1}}],[\"返回值是\",{\"1\":{\"262\":1}}],[\"返回值\",{\"1\":{\"108\":1,\"310\":6,\"344\":14}}],[\"返回从左上角到\",{\"1\":{\"103\":1}}],[\"返回之\",{\"1\":{\"93\":1,\"94\":1}}],[\"返回所有不重复的排列\",{\"1\":{\"82\":1}}],[\"返回所有可能的排列\",{\"1\":{\"81\":1}}],[\"返回根节点\",{\"1\":{\"69\":1}}],[\"返回二叉树的根节点\",{\"1\":{\"65\":1}}],[\"返回基准数的索引\",{\"1\":{\"42\":1,\"43\":1}}],[\"返回索引\",{\"1\":{\"26\":1,\"27\":1}}],[\"返回插入点\",{\"1\":{\"23\":2,\"24\":1}}],[\"返回\",{\"1\":{\"20\":1,\"21\":1,\"26\":1,\"27\":1,\"172\":2,\"292\":1}}],[\"返回其索引\",{\"1\":{\"20\":1,\"21\":1,\"64\":1}}],[\"此后每次select函数一调用就会检测到读事件就绪并成功返回\",{\"1\":{\"439\":1}}],[\"此外\",{\"1\":{\"391\":1,\"398\":1,\"441\":1,\"442\":1}}],[\"此处的a\",{\"1\":{\"325\":1}}],[\"此处无法使用\",{\"1\":{\"195\":1,\"207\":1}}],[\"此过程也属于线性查找\",{\"1\":{\"151\":1}}],[\"此类排序算法的时间复杂度无法超越o\",{\"1\":{\"49\":1}}],[\"此时服务器就不能进行数据的分析处理\",{\"1\":{\"442\":1}}],[\"此时服务端接收到客户端的信息后\",{\"1\":{\"404\":1,\"405\":1}}],[\"此时再根据http报头当中的content\",{\"1\":{\"442\":1}}],[\"此时select服务器就可以读取对应客户端发来的数据\",{\"1\":{\"441\":1}}],[\"此时select函数便会成功返回\",{\"1\":{\"439\":3}}],[\"此时通过telnet向服务器发送的数据就能够被服务器读到并且打印输出了\",{\"1\":{\"441\":1}}],[\"此时就可能造成粘包问题\",{\"1\":{\"442\":1}}],[\"此时就只能将刚刚获取上来的连接对应的套接字进行关闭\",{\"1\":{\"440\":1}}],[\"此时就无法得到正确的状态转移结果\",{\"1\":{\"111\":1}}],[\"此时如果select监视的文件描述符上有事件就绪\",{\"1\":{\"439\":1}}],[\"此时客户端就被操作系统强制杀掉了\",{\"1\":{\"403\":1}}],[\"此时客户端发来的数据也能够成功被epoll服务器收到并进行打印输出\",{\"1\":{\"398\":1}}],[\"此时客户端发来的数据也能够成功被poll服务器收到并进行打印输出\",{\"1\":{\"391\":1}}],[\"此时这两个进程之间是能够通信的\",{\"1\":{\"403\":1}}],[\"此时我们从客户端写入的信息被客户端写入到命名管道当中\",{\"1\":{\"403\":1}}],[\"此时epoll服务器对应的5号和6号文件描述符就关闭了\",{\"1\":{\"398\":1}}],[\"此时数据已经准备好了\",{\"1\":{\"379\":1}}],[\"此时派生类析构函数只要定义\",{\"1\":{\"376\":1}}],[\"此时称该派生类虚函数重写了基类虚函数\",{\"1\":{\"376\":1}}],[\"此时多个线程就会各自创建处一个对象\",{\"1\":{\"354\":1}}],[\"此时需要先创建这个单例对象然后再将单例对象返回\",{\"1\":{\"354\":1}}],[\"此时需要先对\",{\"1\":{\"203\":1}}],[\"此时也能达到防拷贝的目的\",{\"1\":{\"354\":1}}],[\"此时\",{\"1\":{\"267\":3}}],[\"此时p就为野指针\",{\"1\":{\"267\":1}}],[\"此时操作指针就是去访问一个不确定的地址\",{\"1\":{\"267\":1}}],[\"此时指针超出数组界限\",{\"1\":{\"262\":1}}],[\"此时指针会向前移动8个字节\",{\"1\":{\"262\":1}}],[\"此时指针会向后移动12个字节\",{\"1\":{\"262\":1}}],[\"此时邻接矩阵关于主对角线对称\",{\"1\":{\"216\":1}}],[\"此时可以将链表转换为avl树或红黑树\",{\"1\":{\"170\":1}}],[\"此时有\",{\"1\":{\"128\":1}}],[\"此时最小元素位于堆顶\",{\"1\":{\"47\":1}}],[\"此时递归层数达到n\",{\"1\":{\"43\":1}}],[\"此时返回\",{\"1\":{\"20\":1}}],[\"此方法简单粗暴且有效\",{\"1\":{\"169\":1}}],[\"此方法通过哈希查找将时间复杂度从o\",{\"1\":{\"30\":1}}],[\"此方法的时间复杂度为o\",{\"1\":{\"29\":1}}],[\"此情况说明\",{\"1\":{\"20\":2,\"21\":2}}],[\"+5\",{\"1\":{\"318\":1}}],[\"+4\",{\"1\":{\"318\":1}}],[\"+y\",{\"1\":{\"276\":1}}],[\"+x\",{\"1\":{\"276\":1}}],[\"+1\",{\"1\":{\"262\":1,\"327\":3}}],[\"+∞\",{\"1\":{\"103\":1,\"104\":1}}],[\"+dp\",{\"1\":{\"95\":1,\"99\":1}}],[\"+=10\",{\"1\":{\"379\":3}}],[\"+=\",{\"1\":{\"54\":1,\"56\":1,\"120\":2,\"143\":1,\"244\":1,\"246\":1,\"262\":1,\"264\":2,\"267\":2,\"279\":3,\"288\":3,\"291\":1,\"348\":1,\"361\":9}}],[\"++min\",{\"1\":{\"361\":1}}],[\"++n\",{\"1\":{\"361\":1}}],[\"++ret\",{\"1\":{\"361\":1}}],[\"++d1\",{\"1\":{\"361\":1}}],[\"++b\",{\"1\":{\"278\":1}}],[\"++\",{\"1\":{\"53\":1,\"54\":1,\"56\":1,\"73\":1,\"81\":1,\"82\":1,\"90\":1,\"92\":1,\"187\":3,\"190\":3,\"223\":3,\"225\":1,\"263\":1,\"283\":1,\"319\":1,\"361\":1}}],[\"++k\",{\"1\":{\"46\":1}}],[\"++j\",{\"1\":{\"29\":1,\"90\":1,\"344\":1,\"348\":1}}],[\"++it\",{\"1\":{\"379\":1}}],[\"++i1\",{\"1\":{\"276\":1}}],[\"++i\",{\"1\":{\"29\":1,\"75\":1,\"85\":1,\"90\":2,\"264\":1,\"344\":4,\"348\":1}}],[\"+\",{\"1\":{\"20\":2,\"21\":2,\"23\":2,\"24\":2,\"27\":5,\"29\":2,\"36\":1,\"38\":3,\"39\":3,\"41\":2,\"43\":1,\"46\":6,\"48\":2,\"53\":2,\"54\":1,\"64\":2,\"69\":4,\"81\":1,\"82\":1,\"85\":2,\"86\":1,\"90\":4,\"92\":2,\"93\":2,\"94\":3,\"95\":2,\"96\":1,\"98\":3,\"99\":3,\"103\":1,\"104\":1,\"105\":3,\"106\":3,\"108\":1,\"109\":1,\"110\":3,\"111\":2,\"142\":1,\"145\":2,\"161\":5,\"164\":6,\"167\":2,\"172\":3,\"177\":2,\"199\":3,\"209\":2,\"218\":3,\"219\":1,\"223\":2,\"263\":2,\"276\":1,\"279\":3,\"283\":1,\"286\":2,\"288\":4,\"294\":4,\"297\":1,\"314\":1,\"318\":3,\"319\":1,\"332\":2,\"337\":4,\"338\":4,\"348\":7,\"357\":1,\"361\":4,\"379\":2,\"404\":5,\"438\":1,\"439\":2}}],[\"循环变量初化只执行一次\",{\"1\":{\"298\":1}}],[\"循环变量初始化\",{\"1\":{\"298\":1}}],[\"循环变量变化\",{\"1\":{\"298\":1}}],[\"循环结束后循环变量的值\",{\"1\":{\"298\":2}}],[\"循环标记变量变化\",{\"1\":{\"298\":1}}],[\"循环体语句\",{\"1\":{\"298\":2}}],[\"循环条件表达式不能永远成立\",{\"1\":{\"298\":1}}],[\"循环条件表达式\",{\"1\":{\"298\":3}}],[\"循环控制语句\",{\"0\":{\"298\":1}}],[\"循环控制语句非主要控制语句\",{\"1\":{\"295\":1}}],[\"循环语句\",{\"1\":{\"298\":1}}],[\"循环语句中的标记变量i是块级变量\",{\"1\":{\"288\":1}}],[\"循环语句等\",{\"1\":{\"288\":2}}],[\"循环直至访问完所有顶点\",{\"1\":{\"223\":1}}],[\"循环步骤2\",{\"1\":{\"223\":1}}],[\"循环向上堆化\",{\"1\":{\"211\":1}}],[\"循环向下堆化\",{\"1\":{\"48\":1,\"212\":1}}],[\"循环查找\",{\"1\":{\"193\":1,\"194\":1,\"195\":1}}],[\"循环次数最多为二叉树的高度\",{\"1\":{\"193\":1}}],[\"循环比较节点值\",{\"1\":{\"193\":1}}],[\"循环贪心选择\",{\"1\":{\"120\":1,\"124\":1}}],[\"循环进行贪心选择\",{\"1\":{\"113\":1,\"120\":1}}],[\"循环n\",{\"1\":{\"48\":1}}],[\"循环执行第2步和第3步\",{\"1\":{\"123\":1}}],[\"循环执行第\",{\"1\":{\"48\":1}}],[\"循环执行步骤2\",{\"1\":{\"42\":1}}],[\"循环执行以下两步\",{\"1\":{\"20\":1}}],[\"循环遍历数组\",{\"1\":{\"30\":1}}],[\"循环\",{\"1\":{\"20\":1,\"21\":1,\"48\":1,\"83\":1,\"262\":1,\"298\":1}}],[\"即不可被中断的一个或一系列操作\",{\"1\":{\"379\":1}}],[\"即在构造函数中获取互斥锁\",{\"1\":{\"379\":1}}],[\"即b的类型为int\",{\"1\":{\"379\":1}}],[\"即使名字不同\",{\"1\":{\"376\":1}}],[\"即使它们重叠\",{\"1\":{\"294\":1}}],[\"即深拷贝\",{\"1\":{\"361\":1}}],[\"即8\",{\"1\":{\"361\":1}}],[\"即8个字节\",{\"1\":{\"261\":1}}],[\"即raii特性\",{\"1\":{\"351\":1}}],[\"即用第一位表示符号\",{\"1\":{\"327\":1}}],[\"即用宏体替换所有宏名\",{\"1\":{\"255\":1}}],[\"即max\",{\"1\":{\"319\":1}}],[\"即文件大小\",{\"1\":{\"310\":1}}],[\"即字符的ascii码值\",{\"1\":{\"310\":1}}],[\"即执行代码块1\",{\"1\":{\"297\":1}}],[\"即系统之前分配给这块空间的值\",{\"1\":{\"288\":1}}],[\"即所有的程序一定要包含一个主函数\",{\"1\":{\"287\":1}}],[\"即所经过的\",{\"1\":{\"199\":1}}],[\"即空类型\",{\"1\":{\"286\":1}}],[\"即函数不能嵌套声明\",{\"1\":{\"285\":1}}],[\"即true\",{\"1\":{\"277\":1}}],[\"即为实参\",{\"1\":{\"286\":1}}],[\"即为形参\",{\"1\":{\"286\":1}}],[\"即为越界访问\",{\"1\":{\"267\":1}}],[\"即为常量\",{\"1\":{\"253\":1}}],[\"即存放字符串的字符数组的首地址\",{\"1\":{\"263\":1}}],[\"即相隔多少个数据单位\",{\"1\":{\"262\":1}}],[\"即4个字节\",{\"1\":{\"261\":1}}],[\"即邻接顶点的顺序可以任意打乱\",{\"1\":{\"225\":1}}],[\"即a\",{\"1\":{\"214\":1}}],[\"即列表首元素\",{\"1\":{\"212\":1}}],[\"即同样满足条件1\",{\"1\":{\"192\":1}}],[\"即树退化为链表时\",{\"1\":{\"187\":1}}],[\"即满二叉树时\",{\"1\":{\"186\":1}}],[\"即节点引用\",{\"1\":{\"181\":1}}],[\"即某些位置比其他位置更容易被占用由于平方的增长\",{\"1\":{\"173\":1}}],[\"即1\",{\"1\":{\"173\":1}}],[\"即新来的人不断加入队列尾部\",{\"1\":{\"159\":1}}],[\"即前面介绍的普通链表\",{\"1\":{\"153\":1}}],[\"即两种基本的程序控制结构\",{\"1\":{\"136\":1}}],[\"即切分出1反而会导致乘积减少\",{\"1\":{\"127\":1}}],[\"即i为短板\",{\"1\":{\"123\":1}}],[\"即贪心地做出局部最优的决策\",{\"1\":{\"113\":1}}],[\"即o\",{\"1\":{\"110\":1}}],[\"即网格尺寸o\",{\"1\":{\"104\":1}}],[\"即dp\",{\"1\":{\"93\":1}}],[\"即数组diags1\",{\"1\":{\"90\":1}}],[\"即对角线上所有格子的row\",{\"1\":{\"89\":1}}],[\"即剪枝\",{\"1\":{\"81\":1}}],[\"即子图中的任意两个顶点之间都有边相连\",{\"1\":{\"79\":1}}],[\"即当哈希冲突比较严重时\",{\"1\":{\"169\":1}}],[\"即当有三个圆盘时\",{\"1\":{\"72\":1}}],[\"即当有两个圆盘时\",{\"1\":{\"71\":1}}],[\"即当只有一个圆盘时\",{\"1\":{\"71\":1}}],[\"即二叉树退化为链表时\",{\"1\":{\"69\":1}}],[\"即可得到左旋的实现代码\",{\"1\":{\"202\":1}}],[\"即可得到从小到大排序的序列\",{\"1\":{\"47\":1}}],[\"即可访问链表头节点\",{\"1\":{\"170\":1}}],[\"即可\",{\"1\":{\"53\":1,\"71\":1,\"99\":1,\"148\":1,\"149\":1,\"172\":1}}],[\"即可完成数组排序\",{\"1\":{\"48\":1}}],[\"即各轮外循环分别包含n\",{\"1\":{\"36\":1}}],[\"即未排序\",{\"1\":{\"36\":1}}],[\"即最佳时间复杂度\",{\"1\":{\"33\":1}}],[\"即便如此\",{\"1\":{\"24\":1,\"78\":1}}],[\"即左边界包含自身\",{\"1\":{\"21\":1}}],[\"即\",{\"1\":{\"20\":1,\"21\":1,\"54\":1,\"56\":1,\"246\":1,\"287\":1}}],[\"lu\",{\"1\":{\"330\":1}}],[\"ll\",{\"1\":{\"330\":2}}],[\"lld\",{\"1\":{\"291\":2,\"330\":3}}],[\"lf和\",{\"1\":{\"331\":1}}],[\"lf\",{\"1\":{\"297\":1,\"318\":1,\"331\":5,\"357\":1}}],[\"ld\",{\"1\":{\"292\":1,\"310\":1,\"330\":3}}],[\"lh\",{\"1\":{\"199\":3}}],[\"lable\",{\"1\":{\"404\":2}}],[\"label1是标签名\",{\"1\":{\"299\":1}}],[\"label1\",{\"1\":{\"299\":2}}],[\"label\",{\"1\":{\"299\":4}}],[\"lambda\",{\"1\":{\"379\":2}}],[\"lambdafunction\",{\"1\":{\"379\":2}}],[\"lambda函数的返回值\",{\"1\":{\"379\":1}}],[\"lambda表达式\",{\"1\":{\"379\":1}}],[\"lazy\",{\"1\":{\"172\":1}}],[\"last\",{\"1\":{\"164\":2}}],[\"lib\",{\"1\":{\"320\":1}}],[\"liu\",{\"1\":{\"302\":2}}],[\"link\",{\"1\":{\"390\":1,\"397\":1,\"440\":1}}],[\"linkedlistdeque\",{\"1\":{\"163\":17}}],[\"linkedlistqueue\",{\"1\":{\"160\":12}}],[\"linkedliststack\",{\"1\":{\"156\":10}}],[\"linked\",{\"1\":{\"146\":1}}],[\"linux\",{\"0\":{\"531\":1}}],[\"linux环境变量与地址空间\",{\"0\":{\"425\":1}}],[\"linux环境需要安装gcc\",{\"1\":{\"270\":1}}],[\"linux开发工具使用\",{\"0\":{\"421\":1}}],[\"linux权限管理\",{\"0\":{\"419\":1}}],[\"linux线程安全\",{\"0\":{\"417\":1}}],[\"linux多线程\",{\"0\":{\"415\":1}}],[\"linux任务管理与守护进程\",{\"0\":{\"413\":1}}],[\"linux进程控制\",{\"0\":{\"427\":1}}],[\"linux进程状态\",{\"0\":{\"423\":1}}],[\"linux进程信号\",{\"0\":{\"411\":1}}],[\"linux进程间通信之posix\",{\"0\":{\"409\":1}}],[\"linux进程间通信之system\",{\"0\":{\"407\":1}}],[\"linux进程间通信之管道\",{\"0\":{\"401\":1}}],[\"linux的高级io\",{\"0\":{\"431\":1}}],[\"linux的基础io\",{\"0\":{\"429\":1}}],[\"linux的动态库和静态库\",{\"0\":{\"399\":1}}],[\"linux的io多路转接之select\",{\"0\":{\"433\":1}}],[\"linux的io多路转接之epoll\",{\"0\":{\"392\":1}}],[\"linux的io多路转接之poll\",{\"0\":{\"385\":1}}],[\"linux常用命令\",{\"0\":{\"383\":1}}],[\"linux系统或macos系统中使用绝对路径引入自定义头文件\",{\"1\":{\"320\":1}}],[\"linux系统\",{\"1\":{\"320\":1}}],[\"line\",{\"1\":{\"309\":1,\"370\":3}}],[\"listen\",{\"1\":{\"388\":6,\"389\":2,\"390\":3,\"395\":6,\"396\":2,\"397\":3,\"436\":2,\"437\":6,\"438\":2,\"440\":3}}],[\"list为参数的构造函数\",{\"1\":{\"379\":3}}],[\"list使用\",{\"1\":{\"379\":1}}],[\"list>\",{\"1\":{\"379\":1}}],[\"list<int>\",{\"1\":{\"379\":2}}],[\"listnode\",{\"1\":{\"146\":8,\"147\":5,\"148\":3,\"149\":3,\"150\":2,\"151\":1,\"153\":8,\"156\":6,\"160\":5}}],[\"list\",{\"1\":{\"146\":1,\"217\":1,\"379\":2}}],[\"l++\",{\"1\":{\"50\":1}}],[\"l\",{\"1\":{\"48\":6,\"50\":4,\"68\":2,\"69\":4,\"212\":6,\"245\":6,\"330\":3,\"331\":2,\"379\":2}}],[\"legs\",{\"1\":{\"304\":1}}],[\"letter\",{\"1\":{\"293\":4}}],[\"levelorder\",{\"1\":{\"186\":1,\"190\":1}}],[\"level\",{\"1\":{\"181\":1,\"186\":1}}],[\"leaf\",{\"1\":{\"181\":1}}],[\"leftrotate\",{\"1\":{\"202\":1,\"205\":3}}],[\"left\",{\"1\":{\"42\":6,\"43\":10,\"46\":13,\"103\":3,\"104\":3,\"180\":3,\"190\":1,\"193\":1,\"198\":1,\"202\":2,\"209\":1,\"212\":1,\"379\":2}}],[\"length属性得知正文的长度\",{\"1\":{\"442\":1}}],[\"length\",{\"1\":{\"292\":2}}],[\"len\",{\"1\":{\"20\":2,\"21\":2,\"92\":5,\"167\":1,\"244\":2,\"245\":3,\"262\":3,\"288\":4,\"390\":2,\"397\":2,\"436\":2,\"440\":2}}],[\"log\",{\"1\":{\"388\":2,\"389\":1,\"390\":1,\"395\":2,\"396\":1,\"397\":1,\"437\":2,\"438\":1,\"440\":1}}],[\"logical\",{\"1\":{\"382\":1}}],[\"logic\",{\"1\":{\"382\":3}}],[\"logn\",{\"1\":{\"20\":1,\"46\":1,\"48\":1,\"64\":3,\"170\":1,\"193\":1,\"194\":1,\"195\":3,\"211\":3,\"212\":1,\"217\":1}}],[\"lock在这里离开作用域\",{\"1\":{\"379\":1}}],[\"lock2\",{\"1\":{\"379\":3}}],[\"lock<std\",{\"1\":{\"379\":2}}],[\"lock的使用\",{\"1\":{\"379\":1}}],[\"lock是一个更加灵活的互斥锁封装类\",{\"1\":{\"379\":1}}],[\"lock\",{\"1\":{\"351\":1,\"354\":3,\"379\":15}}],[\"local\",{\"1\":{\"320\":1,\"436\":8}}],[\"local和\",{\"1\":{\"259\":1}}],[\"lowercase\",{\"1\":{\"293\":3}}],[\"loadfactor\",{\"1\":{\"170\":2,\"172\":2}}],[\"loadthres\",{\"1\":{\"170\":1,\"172\":1}}],[\"load\",{\"1\":{\"168\":1,\"240\":1,\"379\":5}}],[\"longer\",{\"1\":{\"351\":1}}],[\"long类型\",{\"1\":{\"330\":1}}],[\"long等\",{\"1\":{\"297\":1}}],[\"long\",{\"1\":{\"16\":1,\"177\":6,\"259\":1,\"291\":3,\"310\":3,\"330\":34,\"331\":2,\"335\":19}}],[\"双检查就是在当前加锁和解锁的外面再进行一次if判断\",{\"1\":{\"354\":1}}],[\"双检查加锁\",{\"1\":{\"354\":1}}],[\"双检查\",{\"1\":{\"354\":2}}],[\"双引号\",{\"1\":{\"332\":1}}],[\"双精度\",{\"1\":{\"331\":1}}],[\"双向分支\",{\"1\":{\"297\":1}}],[\"双向\",{\"1\":{\"214\":1}}],[\"双向队列为空\",{\"1\":{\"164\":2}}],[\"双向队列已满\",{\"1\":{\"164\":2}}],[\"双向队列的顺序实现\",{\"0\":{\"164\":1}}],[\"双向队列的长度\",{\"1\":{\"163\":1}}],[\"双向队列的链式实现\",{\"0\":{\"163\":1}}],[\"双向队列需要实现另一个对称方向的操作\",{\"1\":{\"163\":1}}],[\"双向队列\",{\"0\":{\"162\":1},\"1\":{\"162\":1}}],[\"双向链表节点\",{\"1\":{\"163\":1}}],[\"双向链表节点结构体\",{\"1\":{\"153\":1}}],[\"双向链表更具灵活性\",{\"1\":{\"153\":1}}],[\"双向链表的节点定义同时包含指向后继节点\",{\"1\":{\"153\":1}}],[\"双向链表记录了两个方向的引用\",{\"1\":{\"153\":1}}],[\"双向链表\",{\"1\":{\"153\":1,\"163\":1}}],[\"双闭区间\",{\"1\":{\"20\":1,\"21\":2}}],[\"双指针\",{\"0\":{\"8\":1}}],[\"来引用右值\",{\"1\":{\"379\":1}}],[\"来引用左值\",{\"1\":{\"379\":1}}],[\"来获取类型类别\",{\"1\":{\"379\":1}}],[\"来显式指定访问基类的成员\",{\"1\":{\"373\":1}}],[\"来表示一个替换文本\",{\"1\":{\"318\":1}}],[\"来定义常量\",{\"1\":{\"255\":1}}],[\"来代替链表\",{\"1\":{\"219\":1}}],[\"来确定失衡节点属于哪种情况\",{\"1\":{\"205\":1}}],[\"来标记这个桶\",{\"1\":{\"172\":1}}],[\"来处理哈希冲突\",{\"1\":{\"171\":1}}],[\"来处理次对角线约束\",{\"1\":{\"89\":1}}],[\"来实现\",{\"1\":{\"161\":1,\"186\":1}}],[\"来实现它\",{\"1\":{\"64\":1}}],[\"来举例\",{\"1\":{\"102\":1}}],[\"来节省内存空间\",{\"1\":{\"96\":1}}],[\"来存储所有子问题的解\",{\"1\":{\"96\":1}}],[\"来存储子问题的解\",{\"1\":{\"95\":1}}],[\"来存储数组\",{\"1\":{\"69\":1}}],[\"来记录已被访问的顶点\",{\"1\":{\"225\":1}}],[\"来记录哪些节点已被访问\",{\"1\":{\"223\":1}}],[\"来记录子问题的解\",{\"1\":{\"109\":1}}],[\"来记录每个子问题的解\",{\"1\":{\"94\":1}}],[\"来记录路径\",{\"1\":{\"75\":1}}],[\"来满足该约束\",{\"1\":{\"86\":1}}],[\"来遍历解空间\",{\"1\":{\"74\":1}}],[\"来完成移动\",{\"1\":{\"71\":1}}],[\"来划分左子树和右子树呢\",{\"1\":{\"67\":1}}],[\"来求解问题f\",{\"1\":{\"64\":1}}],[\"来监测这种情况\",{\"1\":{\"39\":1}}],[\"来判断元素的相对顺序\",{\"1\":{\"33\":1}}],[\"来计算中点\",{\"1\":{\"20\":1}}],[\"来解析年代久远的\",{\"1\":{\"18\":1}}],[\"若派生类中有一个和基类完全相同的虚函数\",{\"1\":{\"376\":1}}],[\"若子类和父类中有同名成员\",{\"1\":{\"373\":1}}],[\"若子集和超过\",{\"1\":{\"85\":2,\"86\":1}}],[\"若无待删除节点\",{\"1\":{\"195\":1}}],[\"若无该\",{\"1\":{\"170\":1}}],[\"若树为空\",{\"1\":{\"194\":1,\"195\":1}}],[\"若树的高度为h\",{\"1\":{\"183\":1}}],[\"若待插入节点在树中已存在\",{\"1\":{\"194\":1}}],[\"若为空位\",{\"1\":{\"190\":1}}],[\"若为左上角单元格\",{\"1\":{\"103\":1,\"104\":1}}],[\"若索引越界\",{\"1\":{\"190\":1}}],[\"若某节点的索引为i\",{\"1\":{\"189\":1}}],[\"若哈希函数f1\",{\"1\":{\"174\":1}}],[\"若键值对不存在\",{\"1\":{\"172\":2}}],[\"若之前遇到了删除标记\",{\"1\":{\"172\":1}}],[\"若发现哈希冲突\",{\"1\":{\"172\":1}}],[\"若发现桶内已有元素\",{\"1\":{\"172\":1}}],[\"若遇到空位或已尝试所有哈希函数\",{\"1\":{\"174\":1}}],[\"若遇到\",{\"1\":{\"172\":1}}],[\"若遇到指定\",{\"1\":{\"170\":2}}],[\"若遇到值为3的节点\",{\"1\":{\"76\":1}}],[\"若未找到\",{\"1\":{\"170\":1}}],[\"若未找到可行方案\",{\"1\":{\"113\":1}}],[\"若找到键值对\",{\"1\":{\"172\":3}}],[\"若找到\",{\"1\":{\"170\":1}}],[\"若链表为空\",{\"1\":{\"163\":1}}],[\"若越过尾部\",{\"1\":{\"161\":1}}],[\"若匹配则输出对应索引\",{\"1\":{\"144\":1}}],[\"若此时将长板j向短板i靠近\",{\"1\":{\"123\":1}}],[\"若剩余容量不足\",{\"1\":{\"120\":1}}],[\"若剩余容量充足\",{\"1\":{\"120\":1}}],[\"若剩余背包容量不足\",{\"1\":{\"119\":1}}],[\"若超过背包容量\",{\"1\":{\"108\":1,\"109\":1,\"110\":1}}],[\"若已选完所有物品或背包无剩余容量\",{\"1\":{\"108\":1,\"109\":1}}],[\"若已有记录\",{\"1\":{\"104\":1,\"109\":1}}],[\"若当前物品重量超出背包剩余容量\",{\"1\":{\"108\":1}}],[\"若当前元素与其左边元素相等\",{\"1\":{\"86\":1}}],[\"若行列索引越界\",{\"1\":{\"103\":1,\"104\":1}}],[\"若第1\",{\"1\":{\"98\":1}}],[\"若第一轮选择5\",{\"1\":{\"85\":1}}],[\"若存在记录\",{\"1\":{\"94\":1}}],[\"若\",{\"1\":{\"73\":1,\"172\":1,\"193\":3}}],[\"若区间为空\",{\"1\":{\"64\":1}}],[\"若将价格区间平均划分为\",{\"1\":{\"51\":1}}],[\"若节点\",{\"1\":{\"48\":1,\"212\":1}}],[\"若是将方向反过来\",{\"1\":{\"406\":1}}],[\"若是想让服务端执行带选项的命令\",{\"1\":{\"405\":1}}],[\"若是我们只让客户端向管道写入数据\",{\"1\":{\"403\":1}}],[\"若是\",{\"1\":{\"29\":1,\"30\":1,\"74\":1}}],[\"若数组不包含目标元素\",{\"1\":{\"20\":1}}],[\"若采用上述方案\",{\"1\":{\"18\":1}}],[\"=4\",{\"1\":{\"357\":1}}],[\"=tmp\",{\"1\":{\"344\":1}}],[\"=psl\",{\"1\":{\"344\":2}}],[\"=null\",{\"1\":{\"344\":2}}],[\"=buf\",{\"1\":{\"344\":1}}],[\"=b的值\",{\"1\":{\"277\":2}}],[\"=0\",{\"1\":{\"314\":5}}],[\"=0表示两顶点之间无边\",{\"1\":{\"216\":1}}],[\"=初始地址值\",{\"1\":{\"261\":1}}],[\"=dp\",{\"1\":{\"95\":1}}],[\"=2\",{\"1\":{\"93\":1,\"379\":1}}],[\"=1表示顶点v\",{\"1\":{\"216\":1}}],[\"=1\",{\"1\":{\"93\":1}}],[\"==0\",{\"1\":{\"344\":1,\"370\":1}}],[\"==\",{\"1\":{\"24\":1,\"26\":1,\"27\":1,\"29\":1,\"30\":1,\"48\":1,\"73\":1,\"74\":2,\"75\":2,\"76\":3,\"77\":1,\"81\":1,\"82\":1,\"85\":2,\"86\":2,\"90\":1,\"92\":1,\"93\":2,\"94\":2,\"95\":2,\"96\":2,\"98\":4,\"99\":2,\"103\":2,\"104\":2,\"108\":2,\"109\":2,\"113\":1,\"128\":2,\"144\":1,\"150\":1,\"151\":1,\"156\":2,\"157\":3,\"160\":2,\"161\":2,\"163\":1,\"164\":5,\"170\":3,\"172\":6,\"187\":3,\"190\":4,\"194\":2,\"195\":6,\"199\":1,\"206\":1,\"207\":4,\"211\":1,\"212\":1,\"218\":3,\"219\":5,\"223\":2,\"225\":1,\"262\":2,\"263\":1,\"277\":1,\"294\":1,\"299\":2,\"310\":3,\"314\":2,\"321\":2,\"354\":4,\"357\":1,\"361\":30,\"382\":1,\"389\":1,\"390\":4,\"396\":1,\"397\":2,\"403\":1,\"404\":1,\"405\":2,\"406\":2,\"438\":1,\"440\":4}}],[\"=\",{\"1\":{\"20\":6,\"21\":6,\"23\":5,\"24\":6,\"26\":2,\"27\":3,\"29\":7,\"30\":14,\"33\":1,\"36\":7,\"38\":5,\"39\":7,\"41\":5,\"42\":5,\"43\":3,\"46\":12,\"48\":14,\"50\":16,\"53\":9,\"54\":10,\"56\":22,\"64\":2,\"69\":11,\"73\":3,\"74\":1,\"75\":3,\"76\":3,\"77\":9,\"81\":14,\"82\":16,\"85\":12,\"86\":5,\"90\":23,\"92\":8,\"93\":2,\"94\":8,\"95\":6,\"96\":6,\"98\":14,\"99\":12,\"103\":3,\"104\":5,\"105\":13,\"106\":9,\"108\":2,\"109\":4,\"110\":10,\"111\":6,\"113\":3,\"120\":9,\"124\":5,\"128\":2,\"139\":2,\"140\":2,\"141\":3,\"142\":2,\"143\":2,\"144\":1,\"145\":5,\"146\":3,\"147\":9,\"148\":3,\"149\":3,\"150\":2,\"151\":2,\"153\":4,\"156\":12,\"157\":5,\"160\":20,\"161\":11,\"163\":36,\"164\":13,\"167\":49,\"168\":2,\"170\":45,\"172\":50,\"175\":1,\"177\":15,\"180\":5,\"182\":13,\"186\":14,\"187\":3,\"190\":22,\"193\":7,\"194\":10,\"195\":19,\"198\":5,\"199\":6,\"201\":4,\"202\":4,\"205\":3,\"206\":4,\"207\":17,\"211\":3,\"212\":7,\"218\":25,\"219\":52,\"223\":17,\"225\":5,\"240\":1,\"244\":13,\"245\":8,\"246\":19,\"250\":6,\"251\":6,\"255\":5,\"262\":21,\"263\":19,\"264\":11,\"265\":7,\"266\":3,\"267\":5,\"276\":19,\"277\":3,\"278\":4,\"279\":6,\"280\":6,\"281\":4,\"282\":1,\"286\":3,\"287\":2,\"288\":18,\"289\":9,\"291\":9,\"292\":11,\"293\":7,\"294\":3,\"297\":6,\"298\":5,\"299\":2,\"301\":7,\"302\":5,\"303\":4,\"304\":11,\"309\":1,\"310\":48,\"313\":8,\"314\":12,\"318\":7,\"319\":4,\"321\":4,\"325\":4,\"330\":25,\"331\":8,\"332\":9,\"335\":4,\"337\":13,\"338\":7,\"344\":6,\"348\":39,\"351\":5,\"354\":22,\"357\":27,\"361\":102,\"364\":7,\"367\":3,\"373\":5,\"376\":4,\"379\":64,\"382\":5,\"388\":1,\"389\":6,\"390\":12,\"391\":3,\"395\":2,\"396\":3,\"397\":10,\"398\":3,\"403\":9,\"404\":23,\"405\":4,\"406\":7,\"436\":6,\"437\":1,\"438\":6,\"439\":5,\"440\":11}}],[\">initselectserver\",{\"1\":{\"439\":1}}],[\">initepollserver\",{\"1\":{\"398\":1}}],[\">initpollserver\",{\"1\":{\"391\":1}}],[\">get\",{\"1\":{\"382\":1}}],[\">gender\",{\"1\":{\"302\":1}}],[\">~myclass\",{\"1\":{\"364\":2}}],[\">display\",{\"1\":{\"376\":1}}],[\">draw\",{\"1\":{\"376\":2}}],[\">d1\",{\"1\":{\"361\":2}}],[\">data=null\",{\"1\":{\"344\":1}}],[\">data=tmp\",{\"1\":{\"344\":2}}],[\">data+i\",{\"1\":{\"344\":1}}],[\">data\",{\"1\":{\"157\":4,\"210\":1,\"211\":3,\"212\":5,\"344\":31}}],[\">运算符进行重载\",{\"1\":{\"351\":1}}],[\">0\",{\"1\":{\"344\":1}}],[\">成员名\",{\"1\":{\"302\":1}}],[\">访问成员\",{\"1\":{\"302\":1}}],[\">自定义函数\",{\"1\":{\"285\":1}}],[\">heads\",{\"1\":{\"219\":14}}],[\">height\",{\"1\":{\"180\":1,\"198\":1,\"199\":3}}],[\">vertex\",{\"1\":{\"219\":9,\"223\":3,\"225\":2}}],[\">vertices\",{\"1\":{\"218\":4,\"223\":2}}],[\">val\",{\"1\":{\"30\":3,\"69\":1,\"74\":1,\"75\":1,\"76\":2,\"77\":2,\"146\":1,\"151\":1,\"153\":1,\"156\":2,\"160\":2,\"163\":4,\"167\":7,\"170\":5,\"172\":14,\"180\":1,\"186\":1,\"187\":3,\"193\":2,\"194\":3,\"195\":5,\"198\":1,\"206\":2,\"207\":5}}],[\">age\",{\"1\":{\"302\":1}}],[\">adjmat\",{\"1\":{\"218\":12}}],[\">a两个方向的边是相互独立的\",{\"1\":{\"214\":1}}],[\">b\",{\"1\":{\"214\":1}}],[\">buckets\",{\"1\":{\"167\":18,\"170\":14,\"172\":26}}],[\">tree\",{\"1\":{\"190\":4}}],[\">tombstone\",{\"1\":{\"172\":13}}],[\">top\",{\"1\":{\"156\":11}}],[\">>\",{\"1\":{\"177\":1,\"280\":3,\"361\":4,\"370\":2,\"382\":2}}],[\">pair\",{\"1\":{\"170\":13}}],[\">prev\",{\"1\":{\"153\":1,\"163\":6}}],[\">extendratio\",{\"1\":{\"170\":2,\"172\":2}}],[\">loadthres\",{\"1\":{\"170\":2,\"172\":2}}],[\">len\",{\"1\":{\"167\":3}}],[\">left\",{\"1\":{\"69\":2,\"74\":1,\"75\":1,\"76\":1,\"77\":1,\"180\":1,\"182\":5,\"186\":2,\"187\":3,\"193\":1,\"194\":2,\"195\":8,\"198\":1,\"199\":2,\"201\":2,\"202\":2,\"205\":3,\"206\":2,\"207\":6}}],[\">capacity+=2\",{\"1\":{\"344\":1}}],[\">capacity+2\",{\"1\":{\"344\":1}}],[\">capacity=0\",{\"1\":{\"344\":2}}],[\">capacity\",{\"1\":{\"170\":11,\"172\":10,\"344\":1}}],[\">set\",{\"1\":{\"167\":3}}],[\">string\",{\"1\":{\"167\":1}}],[\">size==0\",{\"1\":{\"344\":2}}],[\">size==psl\",{\"1\":{\"344\":1}}],[\">size=0\",{\"1\":{\"344\":2}}],[\">size++\",{\"1\":{\"156\":1,\"157\":1,\"170\":1,\"172\":1,\"211\":1,\"218\":1,\"219\":1,\"223\":1,\"344\":2}}],[\">size\",{\"1\":{\"156\":4,\"157\":8,\"170\":4,\"172\":4,\"190\":2,\"211\":3,\"212\":2,\"218\":17,\"219\":9,\"223\":3,\"344\":13}}],[\">name\",{\"1\":{\"302\":1}}],[\">nums\",{\"1\":{\"161\":4,\"164\":6}}],[\">next\",{\"1\":{\"146\":1,\"147\":4,\"148\":3,\"149\":4,\"150\":1,\"151\":1,\"153\":1,\"156\":3,\"160\":4,\"163\":8,\"170\":10,\"219\":13,\"223\":1,\"225\":1}}],[\">quecapacity\",{\"1\":{\"161\":5,\"164\":3}}],[\">quesize++\",{\"1\":{\"160\":1,\"161\":1,\"163\":1,\"164\":2}}],[\">quesize\",{\"1\":{\"160\":6,\"161\":5,\"163\":7,\"164\":9}}],[\">run\",{\"1\":{\"391\":1,\"398\":1,\"439\":1}}],[\">root\",{\"1\":{\"193\":1,\"194\":3,\"195\":2,\"206\":2,\"207\":1}}],[\">rear\",{\"1\":{\"160\":4,\"163\":11,\"223\":4}}],[\">right\",{\"1\":{\"69\":2,\"74\":1,\"75\":1,\"76\":1,\"77\":1,\"180\":1,\"182\":2,\"186\":2,\"187\":3,\"193\":1,\"194\":2,\"195\":5,\"198\":1,\"199\":2,\"201\":2,\"202\":2,\"205\":3,\"206\":2,\"207\":8}}],[\">front\",{\"1\":{\"160\":13,\"161\":5,\"163\":16,\"164\":9,\"223\":4}}],[\">=\",{\"1\":{\"41\":1,\"42\":1,\"43\":2,\"46\":1,\"48\":1,\"54\":1,\"56\":2,\"111\":1,\"190\":1,\"205\":1,\"218\":5,\"262\":2,\"277\":1,\"278\":1,\"297\":3,\"310\":1,\"361\":4,\"367\":1,\"388\":1,\"395\":2,\"437\":1}}],[\">key\",{\"1\":{\"30\":1,\"167\":3,\"170\":6,\"172\":5}}],[\">\",{\"1\":{\"20\":3,\"21\":1,\"23\":1,\"24\":2,\"33\":1,\"37\":1,\"38\":2,\"39\":2,\"41\":1,\"48\":3,\"50\":3,\"53\":1,\"54\":1,\"56\":3,\"64\":2,\"77\":1,\"85\":1,\"86\":1,\"92\":1,\"108\":1,\"109\":1,\"110\":1,\"113\":3,\"127\":1,\"141\":1,\"147\":4,\"149\":2,\"167\":1,\"170\":2,\"172\":2,\"182\":1,\"187\":6,\"193\":2,\"196\":2,\"199\":1,\"200\":1,\"205\":1,\"206\":1,\"207\":1,\"212\":2,\"225\":6,\"262\":3,\"277\":1,\"278\":4,\"281\":2,\"283\":9,\"286\":2,\"290\":1,\"297\":1,\"302\":2,\"310\":1,\"319\":1,\"332\":4,\"338\":1,\"344\":12,\"345\":1,\"357\":4,\"361\":8,\"379\":6,\"382\":2,\"390\":1,\"397\":1,\"403\":2,\"404\":1,\"405\":1,\"406\":2,\"438\":1,\"440\":1}}],[\"joinable检查线程执行完毕function没有\",{\"1\":{\"379\":1}}],[\"joinable\",{\"1\":{\"379\":8}}],[\"join\",{\"1\":{\"379\":15}}],[\"j<psl\",{\"1\":{\"344\":1}}],[\"j=0\",{\"1\":{\"344\":1}}],[\"just\",{\"1\":{\"321\":3}}],[\"jimbo\",{\"1\":{\"344\":2,\"345\":2,\"348\":2,\"351\":2,\"354\":2,\"357\":2,\"361\":2,\"364\":2,\"367\":2,\"370\":2,\"373\":2,\"376\":2,\"379\":2,\"382\":2}}],[\"jim\",{\"1\":{\"302\":2}}],[\"jack\",{\"1\":{\"278\":2,\"361\":1}}],[\"java\",{\"1\":{\"146\":1}}],[\"j为长版\",{\"1\":{\"123\":1}}],[\"j+1\",{\"1\":{\"102\":1}}],[\"j++\",{\"1\":{\"36\":1,\"38\":1,\"39\":1,\"46\":2,\"50\":3,\"53\":1,\"105\":2,\"106\":2,\"218\":3,\"219\":1,\"246\":2,\"291\":1,\"298\":1}}],[\"j\",{\"1\":{\"20\":9,\"21\":8,\"23\":5,\"24\":6,\"27\":6,\"29\":4,\"36\":4,\"38\":8,\"39\":8,\"41\":8,\"42\":12,\"43\":7,\"46\":4,\"50\":11,\"53\":2,\"56\":4,\"64\":7,\"90\":3,\"102\":5,\"103\":9,\"104\":11,\"105\":11,\"106\":11,\"111\":2,\"122\":1,\"123\":4,\"124\":8,\"216\":3,\"218\":25,\"219\":4,\"245\":1,\"246\":6,\"257\":1,\"291\":3,\"298\":3,\"348\":3}}],[\"说明一下\",{\"1\":{\"440\":1}}],[\"说明目标节点在\",{\"1\":{\"193\":2}}],[\"说明目标元素不在哈希表中\",{\"1\":{\"172\":1}}],[\"说明哈希表中不存在该元素\",{\"1\":{\"174\":1}}],[\"说明该搜索分支重复\",{\"1\":{\"86\":1}}],[\"说明数组已经完成排序\",{\"1\":{\"39\":1}}],[\"说明排序算法在某些数据下性能可能劣化\",{\"1\":{\"33\":1}}],[\"说明找到目标节点\",{\"1\":{\"193\":1}}],[\"说明找到\",{\"1\":{\"20\":1}}],[\"说明\",{\"1\":{\"20\":2,\"297\":1,\"310\":2,\"314\":1,\"319\":2,\"332\":1,\"357\":1,\"361\":1,\"376\":3,\"379\":2}}],[\"时跳出循环\",{\"1\":{\"194\":1}}],[\"时应该继续遍历\",{\"1\":{\"172\":1}}],[\"时返回\",{\"1\":{\"93\":1}}],[\"时间锁\",{\"1\":{\"379\":1}}],[\"时间空间复杂度\",{\"1\":{\"223\":1,\"225\":1}}],[\"时间空间复杂度为o\",{\"1\":{\"43\":1,\"187\":1}}],[\"时间下访问数组中的任意元素\",{\"1\":{\"150\":1}}],[\"时间内获取对应的值value\",{\"1\":{\"166\":1}}],[\"时间内随机访问数组中任何一个元素\",{\"1\":{\"140\":1}}],[\"时间内访问任何元素\",{\"1\":{\"138\":1}}],[\"时间效率\",{\"1\":{\"135\":1,\"158\":1}}],[\"时间和内存空间下完成\",{\"1\":{\"131\":1}}],[\"时间\",{\"1\":{\"43\":1,\"48\":1,\"56\":2,\"61\":4,\"69\":1,\"78\":1,\"82\":1,\"90\":2,\"186\":1,\"193\":1,\"194\":1,\"195\":3,\"196\":1,\"218\":5,\"219\":4,\"223\":3,\"225\":3}}],[\"时间复杂度\",{\"1\":{\"223\":1,\"225\":1}}],[\"时间复杂度退化至o\",{\"1\":{\"175\":1,\"184\":1}}],[\"时间复杂度均为o\",{\"1\":{\"161\":1,\"216\":1}}],[\"时间复杂度都为\",{\"1\":{\"157\":1}}],[\"时间复杂度高\",{\"1\":{\"142\":1}}],[\"时间复杂度取决于编程语言的幂运算的实现方法\",{\"1\":{\"128\":1}}],[\"时间复杂度取决于子问题数量\",{\"1\":{\"109\":1}}],[\"时间复杂度和空间复杂度都由数组\",{\"1\":{\"110\":1}}],[\"时间复杂度优化至o\",{\"1\":{\"94\":1}}],[\"时间复杂度可以达到指数阶或阶乘阶\",{\"1\":{\"78\":1}}],[\"时间复杂度可达到o\",{\"1\":{\"64\":1}}],[\"时间复杂度可达o\",{\"1\":{\"33\":1}}],[\"时间复杂度趋向o\",{\"1\":{\"56\":1}}],[\"时间复杂度中的常数项变小\",{\"1\":{\"33\":1}}],[\"时间复杂度为o\",{\"1\":{\"20\":1,\"36\":1,\"37\":1,\"41\":1,\"43\":1,\"46\":1,\"48\":1,\"56\":1,\"64\":2,\"93\":1,\"148\":1,\"150\":1,\"186\":1,\"187\":1}}],[\"时终止划分\",{\"1\":{\"45\":1}}],[\"时终止递归\",{\"1\":{\"43\":1,\"46\":1}}],[\"时终止\",{\"1\":{\"43\":1,\"46\":1,\"66\":1}}],[\"时为空\",{\"1\":{\"20\":1,\"21\":1}}],[\"时\",{\"1\":{\"20\":3,\"27\":1,\"81\":1,\"85\":3,\"86\":1,\"94\":2,\"111\":1,\"128\":4,\"191\":1,\"194\":1,\"195\":1,\"201\":1,\"202\":1,\"211\":1,\"297\":1}}],[\"<num\",{\"1\":{\"440\":1}}],[\"<cstdlib>\",{\"1\":{\"436\":1}}],[\"<cstring>\",{\"1\":{\"436\":1}}],[\"<ctype\",{\"1\":{\"293\":1}}],[\"<arpa\",{\"1\":{\"436\":1}}],[\"<assert\",{\"1\":{\"361\":1}}],[\"<fcntl\",{\"1\":{\"403\":1,\"406\":1}}],[\"<unistd\",{\"1\":{\"403\":1,\"406\":1,\"436\":1}}],[\"<sys\",{\"1\":{\"395\":1,\"396\":1,\"397\":1,\"403\":2,\"406\":2,\"436\":2,\"437\":1,\"438\":1,\"440\":1}}],[\"<stdbool\",{\"1\":{\"333\":1}}],[\"<stdint\",{\"1\":{\"330\":2}}],[\"<stdio\",{\"1\":{\"244\":4,\"245\":3,\"246\":1,\"250\":1,\"251\":1,\"252\":2,\"255\":2,\"262\":4,\"263\":3,\"264\":2,\"265\":1,\"266\":2,\"267\":1,\"271\":1,\"276\":4,\"277\":1,\"278\":1,\"279\":1,\"280\":3,\"281\":1,\"286\":4,\"287\":2,\"288\":6,\"289\":3,\"290\":1,\"291\":4,\"292\":1,\"293\":1,\"294\":1,\"297\":5,\"298\":4,\"299\":3,\"302\":2,\"309\":3,\"310\":9,\"313\":1,\"314\":4,\"317\":5,\"318\":5,\"319\":4,\"325\":2,\"330\":2,\"331\":1,\"332\":1,\"335\":1,\"337\":2,\"338\":1,\"403\":1,\"406\":1}}],[\"<std\",{\"1\":{\"317\":1}}],[\"<stdlib\",{\"1\":{\"310\":1,\"314\":5}}],[\"<string>\",{\"1\":{\"391\":1,\"398\":1,\"439\":1}}],[\"<string\",{\"1\":{\"292\":1,\"294\":1,\"403\":1,\"406\":1}}],[\"<poll\",{\"1\":{\"388\":1,\"389\":1,\"390\":1}}],[\"<iostream>\",{\"1\":{\"361\":1,\"382\":1,\"436\":1}}],[\"<头文件名\",{\"1\":{\"320\":1}}],[\"<malloc\",{\"1\":{\"314\":1}}],[\"<math\",{\"1\":{\"291\":1}}],[\"<time\",{\"1\":{\"291\":2}}],[\"<<std\",{\"1\":{\"367\":5,\"370\":2,\"379\":2,\"389\":1,\"396\":1,\"438\":2}}],[\"<<this\",{\"1\":{\"361\":3}}],[\"<<endl\",{\"1\":{\"361\":2}}],[\"<<\",{\"1\":{\"177\":1,\"280\":3,\"348\":62,\"351\":17,\"357\":6,\"361\":80,\"364\":6,\"367\":28,\"370\":19,\"373\":18,\"376\":22,\"379\":117,\"382\":23,\"389\":4,\"390\":18,\"391\":4,\"395\":2,\"396\":4,\"397\":15,\"398\":4,\"436\":6,\"438\":2,\"439\":18,\"440\":18}}],[\"<=\",{\"1\":{\"20\":1,\"23\":1,\"24\":1,\"42\":1,\"43\":1,\"46\":5,\"94\":1,\"95\":1,\"96\":1,\"98\":2,\"99\":3,\"110\":4,\"111\":2,\"120\":1,\"128\":2,\"205\":1,\"211\":1,\"218\":1,\"262\":1,\"277\":1,\"278\":1,\"291\":1,\"319\":2,\"361\":5}}],[\"<\",{\"1\":{\"20\":2,\"21\":2,\"23\":1,\"24\":1,\"29\":2,\"30\":1,\"33\":1,\"36\":3,\"38\":1,\"39\":1,\"41\":1,\"42\":3,\"43\":3,\"46\":1,\"48\":2,\"50\":8,\"53\":4,\"54\":3,\"56\":4,\"64\":1,\"69\":2,\"75\":1,\"76\":1,\"77\":3,\"81\":3,\"82\":3,\"85\":5,\"86\":3,\"90\":4,\"92\":1,\"103\":2,\"104\":2,\"105\":6,\"106\":3,\"120\":2,\"123\":2,\"124\":2,\"127\":1,\"142\":1,\"143\":1,\"144\":1,\"145\":2,\"150\":1,\"160\":1,\"163\":2,\"167\":8,\"170\":5,\"172\":3,\"177\":4,\"186\":1,\"190\":2,\"192\":2,\"193\":2,\"194\":4,\"195\":5,\"196\":2,\"205\":1,\"206\":1,\"207\":1,\"211\":1,\"212\":2,\"218\":13,\"219\":8,\"223\":1,\"225\":1,\"244\":1,\"245\":1,\"246\":4,\"262\":3,\"263\":2,\"264\":1,\"277\":1,\"278\":1,\"287\":1,\"288\":3,\"291\":1,\"297\":4,\"298\":5,\"299\":2,\"314\":4,\"344\":2,\"348\":2,\"361\":9,\"367\":2,\"389\":2,\"390\":3,\"395\":1,\"396\":1,\"397\":2,\"403\":5,\"404\":2,\"405\":2,\"406\":5,\"436\":3,\"438\":2,\"440\":2}}],[\"mkfifo\",{\"1\":{\"403\":4,\"404\":2,\"405\":2,\"406\":2}}],[\"mtx\",{\"1\":{\"354\":10}}],[\"msize\",{\"1\":{\"314\":4}}],[\"msg3\",{\"1\":{\"310\":3}}],[\"msg2\",{\"1\":{\"310\":3}}],[\"msg1\",{\"1\":{\"310\":3}}],[\"msg02\",{\"1\":{\"289\":4}}],[\"msg01\",{\"1\":{\"289\":4}}],[\"msg=hello\",{\"1\":{\"288\":3}}],[\"msg=\",{\"1\":{\"288\":2}}],[\"msg\",{\"1\":{\"288\":5,\"403\":13,\"404\":8,\"405\":8,\"406\":9}}],[\"multiplyfunction\",{\"1\":{\"379\":2}}],[\"multiply\",{\"1\":{\"379\":6}}],[\"mulhash\",{\"1\":{\"177\":1}}],[\"mutex>\",{\"1\":{\"379\":4}}],[\"mutex的种类\",{\"1\":{\"379\":1}}],[\"mutex\",{\"1\":{\"354\":4,\"379\":9}}],[\"mushroom\",{\"1\":{\"304\":1}}],[\"myfifo\",{\"1\":{\"403\":1,\"406\":1}}],[\"myfish\",{\"1\":{\"373\":3}}],[\"myexception\",{\"1\":{\"382\":4}}],[\"mythread2\",{\"1\":{\"379\":4}}],[\"mythread1\",{\"1\":{\"379\":4}}],[\"mythread\",{\"1\":{\"379\":13}}],[\"myvector\",{\"1\":{\"379\":7}}],[\"myvariablename\",{\"1\":{\"258\":1}}],[\"myset\",{\"1\":{\"379\":1}}],[\"mylist\",{\"1\":{\"379\":1}}],[\"mydog\",{\"1\":{\"373\":3,\"376\":2}}],[\"mydervivedclass\",{\"1\":{\"357\":3}}],[\"myderivedclass\",{\"1\":{\"357\":3}}],[\"myarray\",{\"1\":{\"367\":3}}],[\"mycat\",{\"1\":{\"373\":3}}],[\"mycontainer<double\",{\"1\":{\"367\":1}}],[\"mycontainer<int\",{\"1\":{\"367\":4}}],[\"mycontainer<int>\",{\"1\":{\"367\":2}}],[\"mycontainer\",{\"1\":{\"367\":4}}],[\"myclass\",{\"1\":{\"357\":6,\"364\":8,\"379\":4}}],[\"myobjects++\",{\"1\":{\"364\":1}}],[\"myobjects\",{\"1\":{\"364\":5}}],[\"mybaseclass\",{\"1\":{\"357\":6}}],[\"myheader\",{\"1\":{\"321\":3}}],[\"myheader05\",{\"1\":{\"320\":1}}],[\"myheader04\",{\"1\":{\"320\":1}}],[\"myheader03\",{\"1\":{\"320\":1}}],[\"myheader02\",{\"1\":{\"320\":1}}],[\"myheader01\",{\"1\":{\"320\":3}}],[\"mymutex\",{\"1\":{\"379\":3}}],[\"mymap\",{\"1\":{\"379\":5}}],[\"mymax\",{\"1\":{\"108\":1,\"109\":1,\"110\":1,\"111\":1,\"124\":1}}],[\"mymin\",{\"1\":{\"98\":2,\"103\":2,\"104\":2,\"105\":1,\"106\":1,\"124\":1}}],[\"md5\",{\"1\":{\"178\":1}}],[\"modified\",{\"1\":{\"379\":16}}],[\"modifyvalue\",{\"1\":{\"379\":4}}],[\"modify\",{\"1\":{\"344\":1,\"345\":1}}],[\"mode\",{\"1\":{\"310\":2}}],[\"modulus\",{\"1\":{\"177\":8}}],[\"month=month\",{\"1\":{\"361\":1}}],[\"month=0\",{\"1\":{\"361\":1}}],[\"month++\",{\"1\":{\"361\":2}}],[\"monthdayarray\",{\"1\":{\"361\":2}}],[\"month\",{\"1\":{\"361\":91}}],[\"mon\",{\"1\":{\"301\":3}}],[\"monday\",{\"1\":{\"301\":1}}],[\"money=101\",{\"1\":{\"288\":2}}],[\"money=1\",{\"1\":{\"288\":1}}],[\"money=\",{\"1\":{\"288\":2}}],[\"money\",{\"1\":{\"288\":4}}],[\"mouse\",{\"1\":{\"257\":1}}],[\"move将左值转换为右值引用\",{\"1\":{\"379\":1}}],[\"move将左值转为右值引用\",{\"1\":{\"379\":1}}],[\"move\",{\"1\":{\"73\":3,\"379\":3}}],[\"mn\",{\"1\":{\"104\":1}}],[\"m+2\",{\"1\":{\"103\":1}}],[\"m+1\",{\"1\":{\"20\":2,\"21\":1,\"23\":1,\"24\":1,\"64\":1}}],[\"minus\",{\"1\":{\"286\":4}}],[\"minpathsumdpcomp\",{\"1\":{\"106\":1}}],[\"minpathsumdp\",{\"1\":{\"105\":1}}],[\"minpathsumdfsmem\",{\"1\":{\"104\":3}}],[\"minpathsumdfs\",{\"1\":{\"103\":3}}],[\"mincostclimbingstairsdpcomp\",{\"1\":{\"98\":1}}],[\"mincostclimbingstairsdp\",{\"1\":{\"98\":1}}],[\"min\",{\"1\":{\"56\":1,\"208\":1,\"361\":3}}],[\"mid+1\",{\"1\":{\"46\":1}}],[\"mid\",{\"1\":{\"46\":12}}],[\"message\",{\"1\":{\"292\":1}}],[\"memset\",{\"1\":{\"294\":5,\"390\":1,\"397\":1,\"436\":1,\"440\":1}}],[\"memmove\",{\"1\":{\"294\":5}}],[\"memcmp\",{\"1\":{\"294\":6}}],[\"memcols\",{\"1\":{\"109\":4}}],[\"memcpy\",{\"1\":{\"54\":1,\"190\":1,\"294\":5}}],[\"mem\",{\"1\":{\"94\":14,\"95\":1,\"104\":8,\"109\":10}}],[\"mergesort\",{\"1\":{\"46\":3}}],[\"merge\",{\"1\":{\"45\":1,\"46\":2}}],[\"mammal\",{\"1\":{\"373\":2}}],[\"manmal\",{\"1\":{\"373\":3}}],[\"make\",{\"1\":{\"351\":2}}],[\"makechoice\",{\"1\":{\"77\":3}}],[\"mavis\",{\"1\":{\"321\":1}}],[\"macos系统\",{\"1\":{\"320\":1}}],[\"mate60\",{\"1\":{\"297\":1}}],[\"matrix\",{\"1\":{\"216\":1}}],[\"map<int\",{\"1\":{\"379\":1}}],[\"map<std\",{\"1\":{\"379\":1}}],[\"map使用\",{\"1\":{\"379\":1}}],[\"map>\",{\"1\":{\"379\":1}}],[\"map\",{\"1\":{\"246\":6,\"379\":5}}],[\"mapset\",{\"1\":{\"167\":4}}],[\"main\",{\"0\":{\"345\":1},\"1\":{\"244\":4,\"245\":3,\"246\":1,\"250\":1,\"251\":1,\"252\":1,\"255\":2,\"262\":4,\"263\":3,\"264\":2,\"265\":1,\"266\":1,\"267\":1,\"276\":4,\"277\":1,\"278\":1,\"279\":1,\"280\":3,\"281\":1,\"286\":4,\"287\":4,\"288\":6,\"289\":2,\"290\":1,\"291\":4,\"292\":1,\"293\":1,\"294\":1,\"297\":5,\"298\":4,\"299\":3,\"302\":2,\"309\":3,\"310\":9,\"313\":1,\"314\":4,\"317\":1,\"318\":5,\"319\":4,\"320\":1,\"325\":2,\"330\":2,\"331\":1,\"332\":1,\"335\":1,\"337\":2,\"338\":1,\"345\":3,\"348\":7,\"351\":2,\"354\":1,\"357\":7,\"361\":13,\"364\":3,\"367\":7,\"370\":5,\"373\":4,\"376\":5,\"379\":45,\"382\":4,\"391\":1,\"398\":1,\"403\":3,\"404\":1,\"405\":1,\"406\":2,\"439\":1}}],[\"maxfd\",{\"1\":{\"438\":4,\"439\":2}}],[\"max=\",{\"1\":{\"319\":1}}],[\"maxlen\",{\"1\":{\"292\":1}}],[\"maxclassesperstudent\",{\"1\":{\"258\":1}}],[\"maxcapacity\",{\"1\":{\"124\":1}}],[\"maxheap\",{\"1\":{\"209\":6,\"210\":3,\"211\":14,\"212\":20}}],[\"maxproductcutting\",{\"1\":{\"128\":1}}],[\"max\",{\"1\":{\"56\":4,\"69\":1,\"81\":1,\"82\":2,\"90\":11,\"103\":5,\"104\":7,\"105\":2,\"106\":2,\"156\":1,\"157\":3,\"186\":2,\"190\":10,\"208\":1,\"211\":1,\"212\":10,\"218\":6,\"219\":3,\"223\":3,\"257\":2,\"258\":2,\"286\":4,\"319\":7,\"344\":12,\"361\":3,\"396\":3,\"397\":1}}],[\"ma\",{\"1\":{\"48\":10}}],[\"malloc函数malloc\",{\"1\":{\"314\":1}}],[\"malloc\",{\"1\":{\"29\":1,\"30\":2,\"46\":1,\"54\":1,\"56\":2,\"69\":2,\"81\":4,\"82\":4,\"90\":3,\"92\":1,\"94\":1,\"95\":1,\"99\":1,\"105\":1,\"110\":1,\"120\":1,\"145\":1,\"146\":1,\"153\":1,\"156\":2,\"157\":2,\"160\":2,\"161\":2,\"163\":3,\"164\":2,\"167\":7,\"170\":5,\"172\":7,\"180\":1,\"186\":2,\"190\":6,\"198\":1,\"218\":1,\"219\":3,\"223\":1,\"314\":5,\"344\":1,\"361\":3}}],[\"m\",{\"1\":{\"20\":13,\"21\":8,\"23\":9,\"24\":11,\"53\":6,\"54\":6,\"64\":8,\"68\":1,\"69\":5,\"105\":5,\"106\":5,\"219\":1,\"245\":1,\"286\":4,\"302\":3,\"303\":4,\"318\":4,\"321\":8,\"361\":15}}],[\"ipc\",{\"0\":{\"407\":1}}],[\"ip\",{\"1\":{\"390\":2,\"397\":2,\"440\":2}}],[\"ipad\",{\"1\":{\"297\":1}}],[\"it\",{\"1\":{\"379\":3}}],[\"iteration\",{\"1\":{\"136\":1}}],[\"items\",{\"1\":{\"120\":9}}],[\"itemcount\",{\"1\":{\"120\":5}}],[\"item\",{\"1\":{\"120\":9}}],[\"i<psl\",{\"1\":{\"344\":3}}],[\"i=0\",{\"1\":{\"344\":3}}],[\"ios\",{\"1\":{\"370\":9}}],[\"io\",{\"1\":{\"317\":1}}],[\"i1++\",{\"1\":{\"276\":1}}],[\"i1\",{\"1\":{\"276\":3}}],[\"id\",{\"1\":{\"302\":12,\"379\":7}}],[\"ide\",{\"1\":{\"270\":3}}],[\"idx\",{\"1\":{\"50\":6}}],[\"i仍为短板\",{\"1\":{\"123\":1}}],[\"i肯定变小\",{\"1\":{\"123\":1}}],[\"implement\",{\"1\":{\"344\":1,\"345\":1}}],[\"imaginary\",{\"1\":{\"259\":1}}],[\"im\",{\"1\":{\"85\":1}}],[\"i2\",{\"1\":{\"85\":1,\"276\":5}}],[\"ii\",{\"1\":{\"82\":2,\"86\":2}}],[\"istream\",{\"1\":{\"361\":4}}],[\"isleapyear\",{\"1\":{\"361\":2}}],[\"islower\",{\"1\":{\"293\":4}}],[\"isok\",{\"1\":{\"318\":3}}],[\"ispass\",{\"1\":{\"318\":3}}],[\"isset\",{\"1\":{\"440\":2}}],[\"isspace\",{\"1\":{\"293\":4}}],[\"issolution\",{\"1\":{\"77\":3}}],[\"isdigit\",{\"1\":{\"293\":4}}],[\"isalpha\",{\"1\":{\"293\":4}}],[\"isupper\",{\"1\":{\"293\":4}}],[\"isvisited\",{\"1\":{\"223\":2,\"225\":2}}],[\"isvalid\",{\"1\":{\"77\":3}}],[\"is\",{\"1\":{\"211\":1,\"212\":1,\"252\":1,\"264\":2,\"265\":16,\"292\":1,\"293\":10,\"310\":1,\"351\":1,\"370\":4,\"373\":8,\"379\":18,\"390\":1,\"440\":1}}],[\"isfront\",{\"1\":{\"163\":4}}],[\"isempty\",{\"1\":{\"156\":1,\"157\":1,\"212\":1,\"223\":2}}],[\"ifstream\",{\"1\":{\"370\":2}}],[\"ifndef发现这个宏没有被定义过\",{\"1\":{\"321\":1}}],[\"ifndef常用于防止重复加载\",{\"1\":{\"321\":1}}],[\"ifndef分别指定了两种情况各自需要编译的代码\",{\"1\":{\"321\":1}}],[\"ifndef\",{\"1\":{\"321\":5,\"348\":1}}],[\"ifdef和\",{\"1\":{\"321\":1}}],[\"ifdef指令\",{\"1\":{\"321\":1}}],[\"ifdef可以与\",{\"1\":{\"321\":1}}],[\"ifdef检查宏extra\",{\"1\":{\"321\":1}}],[\"ifdef\",{\"1\":{\"321\":10,\"348\":1}}],[\"if后面的判断条件\",{\"1\":{\"321\":1}}],[\"if后面的0\",{\"1\":{\"321\":1}}],[\"if①\",{\"1\":{\"321\":1}}],[\"if的比较\",{\"1\":{\"297\":1}}],[\"if\",{\"1\":{\"20\":2,\"21\":2,\"23\":2,\"24\":2,\"26\":1,\"27\":1,\"29\":1,\"30\":2,\"36\":1,\"38\":1,\"39\":2,\"43\":1,\"46\":2,\"48\":3,\"50\":1,\"53\":1,\"54\":1,\"56\":1,\"64\":3,\"69\":1,\"73\":1,\"74\":2,\"75\":2,\"76\":2,\"77\":4,\"81\":2,\"82\":2,\"85\":4,\"86\":3,\"90\":2,\"92\":2,\"93\":1,\"94\":2,\"95\":1,\"96\":1,\"98\":2,\"99\":1,\"103\":2,\"104\":3,\"108\":2,\"109\":3,\"110\":1,\"111\":1,\"120\":1,\"124\":1,\"128\":3,\"144\":1,\"149\":1,\"150\":1,\"151\":1,\"156\":1,\"157\":2,\"160\":1,\"161\":1,\"163\":6,\"164\":2,\"167\":7,\"170\":5,\"172\":11,\"186\":2,\"187\":3,\"190\":6,\"193\":2,\"194\":4,\"195\":6,\"199\":3,\"205\":4,\"206\":3,\"207\":6,\"211\":2,\"212\":4,\"218\":4,\"219\":7,\"223\":2,\"225\":2,\"259\":1,\"263\":1,\"278\":5,\"288\":1,\"290\":1,\"292\":1,\"293\":5,\"294\":1,\"297\":16,\"299\":2,\"310\":16,\"314\":3,\"318\":3,\"321\":16,\"344\":12,\"351\":1,\"354\":6,\"357\":2,\"361\":15,\"367\":2,\"370\":3,\"379\":3,\"382\":2,\"388\":1,\"389\":1,\"390\":8,\"391\":1,\"395\":3,\"396\":2,\"397\":5,\"398\":1,\"403\":8,\"404\":4,\"405\":5,\"406\":9,\"436\":3,\"437\":1,\"438\":2,\"439\":1,\"440\":8}}],[\"i+1\",{\"1\":{\"102\":1,\"344\":4}}],[\"i++\",{\"1\":{\"30\":1,\"36\":1,\"41\":1,\"42\":1,\"43\":1,\"46\":2,\"50\":5,\"53\":3,\"54\":3,\"56\":4,\"69\":1,\"76\":1,\"77\":3,\"81\":3,\"82\":3,\"85\":3,\"86\":2,\"92\":1,\"94\":1,\"95\":1,\"96\":1,\"98\":2,\"99\":3,\"105\":4,\"106\":1,\"110\":3,\"111\":1,\"120\":2,\"124\":1,\"142\":1,\"143\":1,\"144\":1,\"145\":2,\"150\":1,\"160\":1,\"163\":2,\"167\":8,\"170\":5,\"172\":3,\"177\":4,\"190\":1,\"218\":6,\"219\":6,\"223\":1,\"225\":1,\"244\":1,\"245\":1,\"246\":2,\"262\":1,\"263\":2,\"287\":1,\"288\":3,\"291\":1,\"298\":3,\"299\":2,\"314\":3,\"319\":6,\"344\":1,\"389\":2,\"390\":2,\"397\":1,\"438\":2,\"440\":2}}],[\"i+\",{\"1\":{\"20\":1}}],[\"i+j\",{\"1\":{\"20\":1}}],[\"i\",{\"0\":{\"508\":1},\"1\":{\"20\":10,\"21\":9,\"23\":8,\"24\":9,\"26\":6,\"27\":3,\"29\":5,\"30\":9,\"36\":8,\"38\":6,\"39\":6,\"41\":6,\"42\":13,\"43\":8,\"46\":4,\"48\":21,\"50\":16,\"53\":9,\"54\":15,\"56\":21,\"64\":7,\"69\":9,\"73\":10,\"75\":4,\"76\":4,\"77\":12,\"81\":19,\"82\":13,\"85\":23,\"86\":13,\"90\":9,\"92\":3,\"93\":9,\"94\":23,\"95\":9,\"96\":5,\"98\":10,\"99\":13,\"102\":6,\"103\":9,\"104\":11,\"105\":17,\"106\":4,\"107\":4,\"108\":11,\"109\":15,\"110\":18,\"111\":9,\"113\":7,\"118\":6,\"120\":12,\"122\":1,\"123\":3,\"124\":6,\"141\":5,\"142\":4,\"143\":3,\"144\":4,\"145\":7,\"150\":2,\"160\":4,\"163\":6,\"164\":4,\"167\":36,\"170\":15,\"172\":9,\"177\":12,\"190\":16,\"209\":7,\"211\":7,\"212\":10,\"216\":3,\"218\":36,\"219\":25,\"223\":3,\"225\":3,\"244\":4,\"245\":5,\"246\":6,\"262\":7,\"263\":9,\"264\":2,\"276\":10,\"287\":3,\"288\":11,\"291\":2,\"298\":13,\"299\":8,\"309\":3,\"314\":11,\"319\":6,\"321\":8,\"344\":16,\"348\":3,\"370\":1,\"379\":1,\"389\":10,\"390\":16,\"397\":5,\"438\":9,\"440\":15}}],[\"inaddr\",{\"1\":{\"436\":1}}],[\"initselectserver\",{\"1\":{\"437\":1}}],[\"initepollserver\",{\"1\":{\"395\":1}}],[\"initpollserver\",{\"1\":{\"388\":1}}],[\"inet\",{\"1\":{\"390\":1,\"397\":1,\"436\":3,\"440\":1}}],[\"infile\",{\"1\":{\"370\":5}}],[\"information\",{\"1\":{\"18\":1}}],[\"inside\",{\"1\":{\"379\":2}}],[\"inst\",{\"1\":{\"354\":6}}],[\"inserthelper\",{\"1\":{\"206\":4}}],[\"insertionsort\",{\"1\":{\"41\":1}}],[\"insertion\",{\"1\":{\"40\":1}}],[\"insert\",{\"1\":{\"30\":2,\"141\":1,\"148\":1,\"194\":1,\"206\":1}}],[\"inc\",{\"1\":{\"320\":1}}],[\"includes\",{\"1\":{\"320\":1}}],[\"include<condition\",{\"1\":{\"379\":1}}],[\"include<thread>\",{\"1\":{\"379\":11}}],[\"include<time\",{\"1\":{\"291\":1}}],[\"include<utility>\",{\"1\":{\"379\":1}}],[\"include<unordered\",{\"1\":{\"379\":2}}],[\"include<unistd\",{\"1\":{\"344\":1}}],[\"include<functional>\",{\"1\":{\"379\":2}}],[\"include<forward\",{\"1\":{\"379\":1}}],[\"include<fstream>\",{\"1\":{\"370\":4}}],[\"include<atomic>\",{\"1\":{\"379\":1}}],[\"include<array>\",{\"1\":{\"379\":1}}],[\"include<assert\",{\"1\":{\"344\":1}}],[\"include<list>\",{\"1\":{\"379\":1}}],[\"include<vector>\",{\"1\":{\"379\":5}}],[\"include<mutex>\",{\"1\":{\"354\":2,\"379\":2}}],[\"include<memory>\",{\"1\":{\"351\":2}}],[\"include<map>\",{\"1\":{\"379\":1}}],[\"include<malloc\",{\"1\":{\"314\":1}}],[\"include<math\",{\"1\":{\"291\":1}}],[\"include<iostream>\",{\"1\":{\"348\":8,\"351\":1,\"354\":9,\"357\":5,\"361\":4,\"364\":2,\"367\":6,\"370\":4,\"373\":5,\"376\":4,\"379\":28,\"382\":2}}],[\"include<errno\",{\"1\":{\"344\":1}}],[\"include<stddef\",{\"1\":{\"348\":1}}],[\"include<stdlib\",{\"1\":{\"344\":1}}],[\"include<stdio\",{\"1\":{\"291\":1,\"344\":1,\"357\":1}}],[\"include<string>\",{\"1\":{\"364\":1,\"379\":3}}],[\"include<string\",{\"1\":{\"344\":1}}],[\"include<\",{\"1\":{\"285\":1}}],[\"include\",{\"1\":{\"244\":4,\"245\":3,\"246\":1,\"250\":1,\"251\":1,\"252\":1,\"255\":2,\"262\":4,\"263\":3,\"264\":2,\"265\":1,\"266\":1,\"267\":1,\"276\":4,\"277\":1,\"278\":1,\"279\":1,\"280\":3,\"281\":1,\"285\":1,\"286\":4,\"287\":2,\"288\":6,\"289\":3,\"290\":1,\"291\":7,\"292\":2,\"293\":2,\"294\":2,\"297\":5,\"298\":4,\"299\":3,\"302\":2,\"309\":3,\"310\":10,\"313\":1,\"314\":9,\"317\":6,\"318\":5,\"319\":4,\"320\":12,\"321\":3,\"325\":2,\"330\":3,\"331\":1,\"332\":1,\"335\":1,\"337\":2,\"338\":1,\"345\":1,\"361\":3,\"382\":1,\"388\":2,\"389\":2,\"390\":2,\"391\":2,\"395\":2,\"396\":2,\"397\":2,\"398\":2,\"403\":9,\"404\":1,\"405\":1,\"406\":8,\"436\":7,\"437\":2,\"438\":2,\"439\":2,\"440\":2}}],[\"inline不支持声明和定义分别放到\",{\"1\":{\"361\":1}}],[\"inline\",{\"1\":{\"259\":1}}],[\"input=0\",{\"1\":{\"345\":1}}],[\"inputstring\",{\"1\":{\"291\":2}}],[\"input\",{\"1\":{\"252\":2,\"308\":1,\"309\":1,\"310\":8,\"319\":2,\"345\":3}}],[\"in\",{\"1\":{\"190\":2,\"214\":1,\"292\":2,\"310\":1,\"370\":3,\"379\":6,\"390\":1,\"397\":1,\"436\":1,\"440\":1}}],[\"index>=\",{\"1\":{\"367\":1}}],[\"index++\",{\"1\":{\"151\":1,\"167\":3,\"186\":1,\"190\":1}}],[\"index\",{\"1\":{\"138\":1,\"141\":6,\"142\":4,\"150\":3,\"151\":2,\"167\":17,\"170\":9,\"172\":28,\"175\":1,\"186\":3,\"190\":17,\"218\":9,\"367\":9}}],[\"inordersize\",{\"1\":{\"69\":4}}],[\"inordermap\",{\"1\":{\"69\":8}}],[\"inorder\",{\"1\":{\"65\":1,\"66\":1,\"67\":5,\"68\":4,\"69\":6,\"187\":3,\"190\":1}}],[\"int>\",{\"1\":{\"379\":1}}],[\"intcontainer\",{\"1\":{\"367\":4}}],[\"int隐式转换为float\",{\"1\":{\"357\":1}}],[\"int64\",{\"1\":{\"330\":1}}],[\"int16\",{\"1\":{\"330\":1}}],[\"int8\",{\"1\":{\"330\":1}}],[\"intarraypointer\",{\"1\":{\"304\":3}}],[\"intptr\",{\"1\":{\"304\":2,\"313\":3}}],[\"intptr是int\",{\"1\":{\"304\":1}}],[\"integer\",{\"1\":{\"304\":2}}],[\"interchange\",{\"1\":{\"18\":1}}],[\"int32\",{\"1\":{\"56\":1,\"330\":3}}],[\"int\",{\"1\":{\"16\":1,\"20\":6,\"21\":6,\"23\":6,\"24\":6,\"26\":5,\"27\":6,\"29\":9,\"30\":15,\"36\":6,\"38\":5,\"39\":5,\"41\":4,\"42\":9,\"43\":9,\"46\":13,\"48\":12,\"50\":10,\"53\":10,\"54\":13,\"56\":23,\"64\":11,\"69\":15,\"73\":18,\"75\":1,\"76\":1,\"77\":5,\"81\":22,\"82\":22,\"85\":20,\"86\":10,\"90\":11,\"92\":17,\"93\":5,\"94\":11,\"95\":7,\"96\":5,\"98\":15,\"99\":9,\"103\":9,\"104\":10,\"105\":14,\"106\":10,\"108\":7,\"109\":9,\"110\":14,\"111\":11,\"113\":6,\"120\":8,\"124\":7,\"128\":4,\"139\":2,\"140\":5,\"141\":5,\"142\":4,\"143\":4,\"144\":5,\"145\":9,\"146\":2,\"150\":2,\"151\":3,\"153\":2,\"156\":7,\"157\":9,\"160\":9,\"161\":14,\"163\":17,\"164\":21,\"167\":16,\"170\":17,\"172\":19,\"177\":16,\"180\":3,\"186\":7,\"187\":3,\"190\":49,\"193\":1,\"194\":1,\"195\":2,\"198\":3,\"199\":4,\"205\":1,\"206\":2,\"207\":3,\"209\":6,\"210\":1,\"211\":3,\"212\":7,\"218\":19,\"219\":8,\"223\":7,\"225\":5,\"240\":1,\"244\":16,\"245\":5,\"246\":14,\"250\":4,\"251\":4,\"252\":3,\"255\":2,\"259\":1,\"261\":2,\"262\":18,\"263\":17,\"264\":13,\"265\":12,\"266\":3,\"267\":8,\"276\":15,\"277\":3,\"278\":3,\"279\":2,\"280\":9,\"281\":5,\"282\":1,\"286\":25,\"287\":10,\"288\":23,\"289\":11,\"290\":2,\"291\":10,\"292\":8,\"293\":15,\"294\":3,\"297\":9,\"298\":10,\"299\":5,\"302\":17,\"303\":1,\"304\":15,\"305\":1,\"309\":9,\"310\":29,\"313\":7,\"314\":23,\"317\":1,\"318\":11,\"319\":10,\"325\":6,\"330\":13,\"331\":1,\"332\":1,\"333\":1,\"335\":6,\"337\":10,\"338\":9,\"344\":15,\"345\":2,\"348\":64,\"351\":3,\"357\":20,\"361\":135,\"364\":12,\"367\":16,\"370\":5,\"373\":7,\"376\":4,\"379\":92,\"382\":8,\"388\":3,\"389\":8,\"390\":10,\"391\":3,\"395\":4,\"396\":5,\"397\":10,\"398\":3,\"403\":6,\"404\":6,\"405\":2,\"406\":6,\"436\":7,\"437\":3,\"438\":9,\"439\":3,\"440\":11}}],[\"中断和异常\",{\"0\":{\"496\":1}}],[\"中央处理器\",{\"0\":{\"487\":1,\"488\":1}}],[\"中定义了一些新的类型别名\",{\"1\":{\"330\":1}}],[\"中定义的数据\",{\"1\":{\"289\":1}}],[\"中定义的静态全局变量会报错\",{\"1\":{\"289\":1}}],[\"中定义的全局变量\",{\"1\":{\"289\":2}}],[\"中定义的变量\",{\"1\":{\"288\":1}}],[\"中引入以上自定义的头文件\",{\"1\":{\"320\":1}}],[\"中声明的变量称为形式参数\",{\"1\":{\"286\":1}}],[\"中任意节点的左子树和右子树的高度之差的绝对值不超过\",{\"1\":{\"183\":1}}],[\"中间插入节点\",{\"1\":{\"182\":1}}],[\"中分别被记为\",{\"1\":{\"146\":1}}],[\"中随机抽取一个数字\",{\"1\":{\"140\":1}}],[\"中获取结果\",{\"1\":{\"94\":1}}],[\"中哪些元素已被选择过\",{\"1\":{\"83\":1}}],[\"中重复出现\",{\"1\":{\"83\":1}}],[\"中弹出\",{\"1\":{\"75\":1}}],[\"中保存的就是所有的解\",{\"1\":{\"75\":1}}],[\"中序和后序遍历都属于深度优先遍历\",{\"1\":{\"187\":1}}],[\"中序和后序遍历都属于深度优先搜索\",{\"1\":{\"74\":1}}],[\"中序\",{\"0\":{\"187\":1},\"1\":{\"225\":1}}],[\"中序遍历有序\",{\"0\":{\"196\":1}}],[\"中序遍历序列\",{\"1\":{\"195\":1}}],[\"中序遍历的下一个节点\",{\"1\":{\"195\":1}}],[\"中序遍历和后序遍历\",{\"1\":{\"187\":1}}],[\"中序遍历和后序遍历等\",{\"1\":{\"185\":1}}],[\"中序遍历\",{\"1\":{\"67\":1,\"187\":1,\"190\":3}}],[\"中剩余的一个圆盘从\",{\"1\":{\"72\":1}}],[\"中元素到索引的映射\",{\"1\":{\"69\":1}}],[\"中最后一次出现的索引\",{\"1\":{\"54\":1}}],[\"中各数字的出现次数\",{\"1\":{\"53\":1}}],[\"中值最大的节点\",{\"1\":{\"48\":1,\"212\":1}}],[\"中的字符串的指针参数说明\",{\"1\":{\"309\":1}}],[\"中的使用的常量\",{\"1\":{\"286\":1}}],[\"中的顶点数量最多为|v|\",{\"1\":{\"223\":1}}],[\"中的下一个节点\",{\"1\":{\"195\":1}}],[\"中的所有元素都应该是唯一的\",{\"1\":{\"81\":1}}],[\"中的索引记为m\",{\"1\":{\"68\":1}}],[\"中的索引记为i\",{\"1\":{\"68\":1}}],[\"中的索引区间记为\",{\"1\":{\"68\":1}}],[\"中的索引区间\",{\"1\":{\"68\":2}}],[\"中的索引\",{\"1\":{\"67\":1,\"68\":1}}],[\"中的\",{\"1\":{\"50\":1,\"214\":1}}],[\"中的元素复制回原数组\",{\"1\":{\"46\":1}}],[\"中的正确位置\",{\"1\":{\"41\":1}}],[\"中的最大元素交换至该区间的最右端\",{\"1\":{\"38\":1,\"39\":1}}],[\"中的最小元素\",{\"1\":{\"36\":2}}],[\"中没有执行任何交换操作\",{\"1\":{\"39\":1}}],[\"中遇到相等元素不交换\",{\"1\":{\"37\":1}}],[\"中\",{\"1\":{\"20\":4,\"21\":2,\"23\":2,\"24\":3,\"62\":1,\"75\":1,\"252\":3}}],[\"中括号表示闭区间\",{\"1\":{\"20\":1}}],[\"中国国家标准总局于\",{\"1\":{\"18\":1}}],[\"ntohs\",{\"1\":{\"390\":1,\"397\":1,\"440\":1}}],[\"ntoa\",{\"1\":{\"390\":1,\"397\":1,\"440\":1}}],[\"n>\",{\"1\":{\"367\":3}}],[\"n和\",{\"1\":{\"361\":1}}],[\"n和date\",{\"1\":{\"361\":1}}],[\"n不及格的成绩有\",{\"1\":{\"314\":1}}],[\"nyou\",{\"1\":{\"309\":1}}],[\"n次\",{\"1\":{\"298\":1}}],[\"n你的年龄不大\",{\"1\":{\"297\":1}}],[\"n你年龄大于18\",{\"1\":{\"297\":1}}],[\"n=n\",{\"1\":{\"361\":1}}],[\"n=11\",{\"1\":{\"289\":1}}],[\"n=10\",{\"1\":{\"289\":3}}],[\"n=\",{\"1\":{\"289\":2}}],[\"n=3a+b\",{\"1\":{\"128\":1}}],[\"nvar`s\",{\"1\":{\"265\":1}}],[\"nxn大小的邻接矩阵\",{\"1\":{\"218\":1}}],[\"nxn大小的棋盘共有n^2个格子\",{\"1\":{\"87\":1}}],[\"n5\",{\"1\":{\"182\":2}}],[\"n4\",{\"1\":{\"147\":2,\"182\":2,\"337\":2}}],[\"n3\",{\"1\":{\"147\":3,\"182\":2,\"337\":2}}],[\"n2\",{\"1\":{\"147\":3,\"182\":7,\"337\":3}}],[\"n1\",{\"1\":{\"147\":3,\"148\":3,\"149\":4,\"182\":6,\"281\":1,\"337\":2}}],[\"n0\",{\"1\":{\"147\":3,\"148\":5,\"149\":6}}],[\"new与delete用法\",{\"1\":{\"364\":1}}],[\"new函数和operator\",{\"1\":{\"354\":1}}],[\"newqueue\",{\"1\":{\"223\":2}}],[\"newgraphadjlist\",{\"1\":{\"219\":1}}],[\"newgraphadjmat\",{\"1\":{\"218\":1}}],[\"newtreenode\",{\"1\":{\"180\":1,\"182\":6,\"194\":2,\"198\":1,\"206\":1}}],[\"newhashmapopenaddressing\",{\"1\":{\"172\":1}}],[\"newhashmapchaining\",{\"1\":{\"170\":1}}],[\"newnode\",{\"1\":{\"170\":4}}],[\"newpair\",{\"1\":{\"170\":4}}],[\"new\",{\"1\":{\"163\":5,\"351\":2,\"354\":6,\"357\":4,\"364\":11,\"376\":4,\"379\":2,\"382\":1,\"390\":1,\"391\":1,\"397\":1,\"398\":1,\"439\":1,\"440\":1}}],[\"newdoublylistnode\",{\"1\":{\"163\":2}}],[\"newarraybinarytree\",{\"1\":{\"190\":1}}],[\"newarrayhashmap\",{\"1\":{\"167\":1}}],[\"newarraydeque\",{\"1\":{\"164\":1}}],[\"newarrayqueue\",{\"1\":{\"161\":1}}],[\"newarraystack\",{\"1\":{\"157\":1}}],[\"newlinkedlistdeque\",{\"1\":{\"163\":1}}],[\"newlinkedlistqueue\",{\"1\":{\"160\":1}}],[\"newlinkedliststack\",{\"1\":{\"156\":1}}],[\"newlistnode\",{\"1\":{\"146\":1,\"147\":5,\"153\":1,\"160\":1}}],[\"next\",{\"1\":{\"146\":1,\"147\":1,\"153\":1,\"163\":1,\"170\":1,\"219\":3}}],[\"nextchoices\",{\"1\":{\"77\":2}}],[\"noexcept\",{\"1\":{\"382\":2}}],[\"nonconstptr\",{\"1\":{\"357\":1}}],[\"none\",{\"1\":{\"146\":1,\"153\":1,\"172\":3,\"174\":1,\"181\":1,\"190\":7,\"191\":1,\"194\":3}}],[\"notify\",{\"1\":{\"379\":5}}],[\"notify系列成员函数\",{\"1\":{\"379\":1}}],[\"not\",{\"1\":{\"292\":1,\"293\":5,\"294\":1,\"321\":2,\"379\":1,\"524\":1}}],[\"noreturn\",{\"1\":{\"259\":1}}],[\"node\",{\"1\":{\"146\":6,\"153\":6,\"156\":4,\"160\":11,\"163\":17,\"170\":21,\"180\":10,\"181\":2,\"186\":7,\"194\":3,\"198\":7,\"199\":12,\"201\":8,\"202\":7,\"203\":1,\"204\":1,\"205\":14,\"206\":13,\"207\":24,\"219\":8,\"223\":7,\"225\":6}}],[\"no\",{\"1\":{\"108\":2,\"109\":2,\"351\":1}}],[\"nm\",{\"1\":{\"105\":2}}],[\"nqueens\",{\"1\":{\"90\":1}}],[\"n维方阵中row\",{\"1\":{\"90\":1}}],[\"nppptr`s\",{\"1\":{\"265\":1}}],[\"npptr`s\",{\"1\":{\"265\":1}}],[\"nptr`s\",{\"1\":{\"265\":1}}],[\"np\",{\"1\":{\"79\":1}}],[\"n皇后问题\",{\"0\":{\"87\":1}}],[\"n皇后\",{\"1\":{\"79\":1}}],[\"n+3\",{\"1\":{\"318\":3}}],[\"n++=12\",{\"1\":{\"289\":1}}],[\"n++=11\",{\"1\":{\"289\":3}}],[\"n++=\",{\"1\":{\"289\":2}}],[\"n++\",{\"1\":{\"289\":2,\"348\":1}}],[\"n+m\",{\"1\":{\"219\":2}}],[\"n+1\",{\"1\":{\"90\":1,\"186\":1}}],[\"n+d\",{\"1\":{\"56\":3}}],[\"n+2\",{\"1\":{\"36\":1}}],[\"nk\",{\"1\":{\"56\":1}}],[\"n^n\",{\"1\":{\"81\":1}}],[\"n^\",{\"1\":{\"41\":1,\"82\":2}}],[\"n^2\",{\"1\":{\"29\":1,\"30\":1,\"36\":1,\"37\":1,\"39\":1,\"41\":1,\"43\":1,\"44\":1,\"61\":1,\"90\":3,\"111\":1,\"216\":1,\"218\":2}}],[\"nlogn\",{\"1\":{\"33\":1,\"43\":2,\"44\":1,\"46\":2,\"48\":1,\"49\":1}}],[\"name1\",{\"1\":{\"361\":3}}],[\"namespace\",{\"1\":{\"348\":13,\"361\":4,\"364\":2}}],[\"name存储要查找的联系人名\",{\"1\":{\"344\":1}}],[\"name=张三\",{\"1\":{\"302\":3}}],[\"name=\",{\"1\":{\"302\":3}}],[\"name容易混淆\",{\"1\":{\"258\":1}}],[\"name\",{\"1\":{\"33\":1,\"258\":2,\"291\":2,\"302\":15,\"304\":1,\"310\":2,\"344\":10,\"348\":4,\"361\":6,\"373\":1,\"379\":2,\"403\":6,\"404\":2,\"405\":2,\"406\":4}}],[\"numerator\",{\"1\":{\"382\":5}}],[\"numelements是要分配的元素的数量\",{\"1\":{\"314\":1}}],[\"numelements\",{\"1\":{\"314\":1}}],[\"num=0\",{\"1\":{\"348\":1}}],[\"num4\",{\"1\":{\"348\":1}}],[\"num是要读取的最大字符数\",{\"1\":{\"310\":1}}],[\"num02\",{\"1\":{\"289\":3}}],[\"num01\",{\"1\":{\"289\":3}}],[\"num3值为\",{\"1\":{\"348\":2}}],[\"num3=44\",{\"1\":{\"338\":1}}],[\"num3=\",{\"1\":{\"338\":1}}],[\"num31\",{\"1\":{\"252\":1}}],[\"num3\",{\"1\":{\"252\":3,\"263\":2,\"325\":2,\"338\":2,\"348\":2}}],[\"num2值为\",{\"1\":{\"348\":2}}],[\"num2=y\",{\"1\":{\"348\":1}}],[\"num2=6\",{\"1\":{\"338\":1}}],[\"num2=\",{\"1\":{\"338\":1}}],[\"num2\",{\"1\":{\"252\":4,\"263\":2,\"325\":2,\"338\":2,\"348\":17,\"370\":5,\"379\":1,\"404\":7}}],[\"num1+num2\",{\"1\":{\"370\":1}}],[\"num1值为\",{\"1\":{\"348\":2}}],[\"num1=5\",{\"1\":{\"338\":1}}],[\"num1=31\",{\"1\":{\"325\":1}}],[\"num1=210\",{\"1\":{\"325\":1}}],[\"num1=2\",{\"1\":{\"325\":1}}],[\"num1=\",{\"1\":{\"325\":3,\"338\":1}}],[\"num1\",{\"1\":{\"252\":4,\"263\":2,\"292\":3,\"302\":1,\"325\":2,\"338\":2,\"348\":15,\"370\":2,\"404\":7}}],[\"numbers\",{\"1\":{\"252\":1,\"257\":1,\"319\":1,\"370\":2}}],[\"number\",{\"1\":{\"252\":3,\"309\":1,\"319\":1}}],[\"numres\",{\"1\":{\"77\":3}}],[\"numchoices\",{\"1\":{\"77\":3}}],[\"num++\",{\"1\":{\"53\":1,\"298\":1}}],[\"num\",{\"1\":{\"50\":1,\"53\":10,\"54\":10,\"56\":3,\"141\":4,\"156\":2,\"157\":2,\"160\":4,\"161\":5,\"163\":8,\"164\":10,\"193\":8,\"194\":9,\"195\":3,\"240\":1,\"252\":4,\"257\":1,\"261\":5,\"264\":9,\"266\":2,\"282\":1,\"287\":2,\"294\":4,\"298\":5,\"304\":3,\"310\":6,\"313\":2,\"348\":2,\"379\":2,\"389\":10,\"390\":6,\"396\":7,\"397\":3,\"438\":7,\"439\":2,\"440\":5}}],[\"nums2存的应该是临时\",{\"1\":{\"348\":1}}],[\"numssize\",{\"1\":{\"29\":3,\"30\":2,\"64\":2,\"81\":5,\"82\":5,\"85\":5,\"86\":3}}],[\"numsize\",{\"1\":{\"23\":2,\"24\":2,\"26\":3,\"27\":2}}],[\"nums\",{\"1\":{\"20\":7,\"21\":3,\"23\":3,\"24\":5,\"26\":3,\"27\":3,\"29\":3,\"30\":5,\"36\":8,\"38\":7,\"39\":7,\"41\":7,\"42\":13,\"43\":12,\"46\":14,\"48\":16,\"50\":6,\"53\":10,\"54\":8,\"56\":12,\"64\":7,\"81\":2,\"82\":2,\"85\":7,\"86\":5,\"139\":1,\"140\":2,\"141\":4,\"142\":3,\"143\":2,\"144\":2,\"145\":2,\"147\":3,\"161\":1,\"164\":1,\"244\":14,\"262\":11,\"263\":12,\"288\":11}}],[\"null和0的值一样就会引发问题\",{\"1\":{\"348\":1}}],[\"null可能被定义为字面常量0\",{\"1\":{\"348\":1}}],[\"null底层是一个宏\",{\"1\":{\"348\":1}}],[\"nullptr关键字\",{\"1\":{\"379\":1}}],[\"nullptr\",{\"1\":{\"146\":1,\"195\":1,\"354\":10,\"379\":2,\"397\":1,\"438\":3,\"439\":4}}],[\"null\",{\"1\":{\"29\":1,\"30\":4,\"69\":3,\"74\":1,\"75\":1,\"76\":1,\"77\":1,\"146\":2,\"150\":2,\"153\":2,\"156\":1,\"160\":4,\"163\":9,\"167\":8,\"170\":3,\"172\":8,\"180\":2,\"186\":2,\"187\":3,\"193\":1,\"194\":3,\"195\":8,\"198\":2,\"199\":2,\"206\":1,\"207\":8,\"219\":16,\"223\":1,\"225\":1,\"266\":2,\"267\":2,\"292\":4,\"310\":13,\"314\":5,\"348\":3,\"361\":1,\"404\":1,\"405\":2}}],[\"n\",{\"1\":{\"20\":2,\"21\":2,\"23\":1,\"24\":1,\"30\":2,\"33\":1,\"36\":9,\"37\":3,\"39\":1,\"41\":4,\"43\":2,\"46\":1,\"48\":10,\"50\":1,\"51\":1,\"56\":1,\"61\":3,\"64\":4,\"69\":4,\"72\":3,\"73\":2,\"81\":1,\"82\":5,\"90\":24,\"92\":8,\"93\":4,\"94\":5,\"95\":7,\"96\":6,\"98\":13,\"99\":11,\"105\":7,\"106\":2,\"109\":1,\"110\":7,\"111\":3,\"120\":2,\"124\":1,\"127\":2,\"128\":7,\"142\":1,\"145\":1,\"148\":1,\"150\":1,\"156\":3,\"157\":2,\"158\":1,\"161\":2,\"164\":2,\"167\":1,\"170\":2,\"172\":3,\"175\":1,\"184\":1,\"186\":4,\"187\":4,\"196\":1,\"217\":1,\"218\":15,\"223\":1,\"225\":1,\"244\":10,\"245\":10,\"246\":1,\"251\":3,\"252\":1,\"262\":21,\"263\":20,\"264\":4,\"265\":18,\"266\":2,\"267\":1,\"276\":17,\"277\":6,\"278\":6,\"280\":9,\"281\":3,\"286\":15,\"287\":3,\"288\":30,\"289\":21,\"290\":7,\"291\":11,\"292\":14,\"293\":13,\"294\":5,\"298\":4,\"299\":7,\"302\":14,\"309\":2,\"310\":29,\"313\":2,\"314\":10,\"318\":11,\"319\":5,\"321\":10,\"325\":7,\"330\":5,\"331\":5,\"332\":5,\"335\":17,\"337\":4,\"338\":3,\"344\":27,\"345\":2,\"348\":2,\"357\":2,\"361\":7,\"367\":1,\"379\":6,\"403\":3,\"404\":4,\"405\":3,\"406\":4}}],[\"分离新线程\",{\"1\":{\"379\":1}}],[\"分开声明和定义类的方法\",{\"1\":{\"361\":1}}],[\"分类\",{\"1\":{\"351\":1}}],[\"分号会成为\",{\"1\":{\"317\":1}}],[\"分号会成为常量值的一部分\",{\"1\":{\"255\":1}}],[\"分配堆上的内存有一些系统开销\",{\"1\":{\"315\":1}}],[\"分配的内存块一旦释放\",{\"1\":{\"314\":1}}],[\"分配内存块\",{\"1\":{\"364\":1}}],[\"分配内存\",{\"1\":{\"314\":1}}],[\"分配完毕后\",{\"1\":{\"51\":1}}],[\"分隔内容赋值给不同的变量\",{\"1\":{\"310\":1}}],[\"分没有任何奖励\",{\"1\":{\"297\":1}}],[\"分解字符串为子字符串\",{\"1\":{\"292\":1}}],[\"分解为子问题\",{\"1\":{\"64\":1}}],[\"分解为一个小问题\",{\"1\":{\"64\":1}}],[\"分支控制语句\",{\"0\":{\"297\":1}}],[\"分支控制\",{\"1\":{\"295\":1}}],[\"分支语句体具有块级作用域\",{\"1\":{\"288\":1}}],[\"分支语句\",{\"1\":{\"288\":2}}],[\"分支与循环语句\",{\"0\":{\"227\":1}}],[\"分布越均匀\",{\"1\":{\"176\":1}}],[\"分数背包\",{\"1\":{\"120\":1}}],[\"分数背包问题和\",{\"1\":{\"118\":1}}],[\"分数背包问题\",{\"0\":{\"118\":1},\"1\":{\"117\":1}}],[\"分\",{\"1\":{\"58\":2,\"195\":1}}],[\"分治算法递归地将原问题划分为多个相互独立的子问题\",{\"1\":{\"97\":1}}],[\"分治能够提升搜索效率\",{\"1\":{\"64\":1}}],[\"分治搜索策略\",{\"0\":{\"64\":1}}],[\"分治是一种\",{\"1\":{\"63\":1}}],[\"分治在算法和数据结构的设计中应用得非常广泛\",{\"1\":{\"63\":1}}],[\"分治可以用来解决许多经典算法问题\",{\"1\":{\"63\":1}}],[\"分治的常见应用\",{\"0\":{\"63\":1}}],[\"分治不仅可以降低算法的时间复杂度\",{\"1\":{\"62\":1}}],[\"分治不仅可以有效地解决算法问题\",{\"1\":{\"60\":1}}],[\"分治生成的子问题是相互独立的\",{\"1\":{\"62\":1}}],[\"分治通常基于递归实现\",{\"1\":{\"58\":1}}],[\"分治基本概念\",{\"0\":{\"58\":1}}],[\"分治\",{\"0\":{\"57\":1},\"1\":{\"58\":1,\"69\":1,\"184\":1}}],[\"分别是m\",{\"1\":{\"303\":1}}],[\"分别命名为file01\",{\"1\":{\"289\":1}}],[\"分别需要采用右旋\",{\"1\":{\"205\":1}}],[\"分别用于获取和更新节点的高度\",{\"1\":{\"199\":1}}],[\"分别对应的是标准输入\",{\"1\":{\"398\":1}}],[\"分别对应十进制的\",{\"1\":{\"325\":1}}],[\"分别对应前序\",{\"1\":{\"225\":1}}],[\"分别对应前序遍历\",{\"1\":{\"187\":1}}],[\"分别对应跳1步和跳2步\",{\"1\":{\"99\":1}}],[\"分别指向左子节点\",{\"1\":{\"180\":1}}],[\"分别指向数组首元素\",{\"1\":{\"20\":1,\"21\":1}}],[\"分别指向数组首元素和尾元素\",{\"1\":{\"20\":1}}],[\"分别视为\",{\"1\":{\"160\":1}}],[\"分别寻找第一个比基准数大\",{\"1\":{\"42\":1}}],[\"分析和处理\",{\"1\":{\"32\":1}}],[\"分为以下三种情况\",{\"1\":{\"20\":1}}],[\"分为以下两种情况\",{\"1\":{\"18\":1}}],[\"每隔5秒timeout一次\",{\"1\":{\"439\":1}}],[\"每隔0秒timeout一次\",{\"1\":{\"439\":1}}],[\"每单位就移动多少个字节\",{\"1\":{\"262\":1}}],[\"每种哈希算法的最后一步都是对大质数1000000007取模\",{\"1\":{\"177\":1}}],[\"每种硬币可以重复选取\",{\"1\":{\"113\":1}}],[\"每当遇到哈希冲突时\",{\"1\":{\"169\":1}}],[\"每当到达楼梯顶部时就将方案数量加1\",{\"1\":{\"92\":1}}],[\"每一行\",{\"1\":{\"216\":1}}],[\"每一条路径代表一个决策序列\",{\"1\":{\"101\":1}}],[\"每一阶楼梯上都贴有一个非负整数\",{\"1\":{\"98\":1}}],[\"每一层的选择都是从左到右被逐个尝试的\",{\"1\":{\"85\":1}}],[\"每列和每个3x3子网格中的数字不重复\",{\"1\":{\"79\":1}}],[\"每次读之前将msg清空\",{\"1\":{\"403\":2,\"404\":1,\"405\":1,\"406\":1}}],[\"每次调用函数\",{\"1\":{\"319\":1}}],[\"每次先判断后执行循环体语句循环标记变量变化每次循环都执行\",{\"1\":{\"298\":1}}],[\"每次累积之前都会对哈希值进行旋转操作\",{\"1\":{\"177\":1}}],[\"每次选择出现频率最低的两个节点合并\",{\"1\":{\"117\":1}}],[\"每次只能向下或者向右移动一步\",{\"1\":{\"102\":1}}],[\"每次只能移动一个圆盘\",{\"1\":{\"70\":1,\"79\":1}}],[\"每次插入操作分别需要循环n\",{\"1\":{\"41\":1}}],[\"每个成员分别占有其自己的内存单元共用体变量所占的内存长度等于最长的成员的长度\",{\"1\":{\"303\":1}}],[\"每个函数的返回类型和参数类型\",{\"1\":{\"287\":1}}],[\"每个语句以\",{\"1\":{\"272\":1}}],[\"每个占4个字节\",{\"1\":{\"262\":1}}],[\"每个内存单元通常占用1个字节\",{\"1\":{\"261\":1}}],[\"每个学生都有\",{\"1\":{\"166\":1}}],[\"每个节点都有两个引用\",{\"1\":{\"180\":1}}],[\"每个节点都包含两项数据\",{\"1\":{\"146\":1}}],[\"每个节点包含值\",{\"1\":{\"180\":1}}],[\"每个节点代表一个子问题\",{\"1\":{\"73\":1}}],[\"每个任务在一段时间内进行\",{\"1\":{\"117\":1}}],[\"每个物品只能选择一次\",{\"1\":{\"107\":1,\"118\":1}}],[\"每个物品有一定的价值和重量\",{\"1\":{\"79\":1}}],[\"每个状态都是由正上方或左上方的格子转移过来的\",{\"1\":{\"111\":1}}],[\"每个状态都有向下和向右两种选择\",{\"1\":{\"103\":1}}],[\"每个状态都对应一个子问题以及相应的局部最优解\",{\"1\":{\"95\":1}}],[\"每个时刻的棋盘就是状态\",{\"1\":{\"87\":1}}],[\"每个元素字节长度相等\",{\"1\":{\"244\":1}}],[\"每个元素只可被选择一次\",{\"1\":{\"86\":1}}],[\"每个元素只允许被选择一次\",{\"1\":{\"81\":1}}],[\"每个元素可以被选取多次\",{\"1\":{\"85\":1}}],[\"每个调用的\",{\"1\":{\"83\":1}}],[\"每个叶节点都对应一个排列\",{\"1\":{\"81\":1}}],[\"每个递归函数内的前序遍历\",{\"1\":{\"69\":1}}],[\"每个子数组都可以独立地进行排序\",{\"1\":{\"59\":1}}],[\"每个桶都是一个列表\",{\"1\":{\"170\":1}}],[\"每个桶仅能存储一个键值对\",{\"1\":{\"170\":1}}],[\"每个桶可存储一个键值对\",{\"1\":{\"167\":1}}],[\"每个桶最多可以分配\",{\"1\":{\"50\":1}}],[\"每个桶对应一个数据范围\",{\"1\":{\"49\":1}}],[\"每个字符都使用\",{\"1\":{\"18\":1}}],[\"每层合并的总操作数量为n\",{\"1\":{\"46\":1}}],[\"每层中的循环数为n\",{\"1\":{\"43\":1}}],[\"每层中的总循环数为n\",{\"1\":{\"43\":1}}],[\"每轮乘以一个常数\",{\"1\":{\"177\":1}}],[\"每轮判断元素值是否匹配\",{\"1\":{\"144\":1}}],[\"每轮向内收缩短板对应的指针\",{\"1\":{\"123\":1}}],[\"每轮贪心地选择单位价值最高的物品\",{\"1\":{\"119\":1}}],[\"每轮选择上1阶或2阶\",{\"1\":{\"92\":1}}],[\"每轮选择\",{\"1\":{\"83\":1}}],[\"每轮只处理一个子问题\",{\"1\":{\"64\":1}}],[\"每轮将\",{\"1\":{\"53\":1}}],[\"每轮哨兵划分操作都将长度为n的数组划分为长度为0和n\",{\"1\":{\"43\":1}}],[\"每轮从未排序区间选择最小的元素\",{\"1\":{\"36\":1}}],[\"每轮执行图如下所示\",{\"1\":{\"30\":1}}],[\"每轮缩小一半搜索范围\",{\"1\":{\"20\":1}}],[\"二义性\",{\"1\":{\"373\":1}}],[\"二进制可读\",{\"1\":{\"344\":1}}],[\"二进制可写\",{\"1\":{\"344\":1}}],[\"二进制01000001\",{\"1\":{\"332\":1}}],[\"二进制00100000\",{\"1\":{\"332\":1}}],[\"二进制转成十六进制\",{\"1\":{\"326\":1}}],[\"二进制转换成十进制\",{\"1\":{\"326\":1}}],[\"二进制与十六进制的转换\",{\"1\":{\"326\":1}}],[\"二进制与十进制的转换\",{\"1\":{\"326\":1}}],[\"二进制与数据类型\",{\"0\":{\"323\":1}}],[\"二进制\",{\"0\":{\"324\":1},\"1\":{\"325\":3}}],[\"二进制文本的读取判断结束\",{\"1\":{\"310\":1}}],[\"二进制读写文件\",{\"1\":{\"310\":1}}],[\"二目运算符\",{\"1\":{\"275\":1}}],[\"二级指针指向\",{\"1\":{\"265\":1}}],[\"二级指针\",{\"1\":{\"265\":2}}],[\"二者值是相同的\",{\"1\":{\"263\":1}}],[\"二维数组中元素排列的顺序是按行存放的\",{\"1\":{\"246\":1}}],[\"二维数组的内存分析\",{\"1\":{\"246\":1}}],[\"二维数组的访问和遍历\",{\"1\":{\"246\":1}}],[\"二位数组的定义方法一\",{\"1\":{\"246\":1}}],[\"二叉搜索树的效率\",{\"0\":{\"197\":1}}],[\"二叉搜索树的中序遍历序列是升序的\",{\"1\":{\"196\":1}}],[\"二叉搜索树的\",{\"1\":{\"195\":1}}],[\"二叉搜索树的查找操作与二分查找算法的工作原理一致\",{\"1\":{\"193\":1}}],[\"二叉搜索树不允许存在重复节点\",{\"1\":{\"194\":1}}],[\"二叉搜索树\",{\"0\":{\"192\":1},\"1\":{\"192\":1,\"200\":1}}],[\"二叉树中首个失衡节点是\",{\"1\":{\"201\":1}}],[\"二叉树常见的遍历方式包括层序遍历\",{\"1\":{\"185\":1}}],[\"二叉树常见术语\",{\"0\":{\"181\":1}}],[\"二叉树退化为\",{\"1\":{\"184\":1}}],[\"二叉树基本操作\",{\"0\":{\"182\":1}}],[\"二叉树的中序遍历遵循\",{\"1\":{\"196\":1}}],[\"二叉树的存储单元为节点\",{\"1\":{\"188\":1}}],[\"二叉树的数组表示主要有以下优点\",{\"1\":{\"191\":1}}],[\"二叉树的数组表示\",{\"0\":{\"188\":1},\"1\":{\"190\":1}}],[\"二叉树的遍历\",{\"0\":{\"185\":1,\"455\":1,\"456\":1}}],[\"二叉树的叶节点数量\",{\"1\":{\"184\":1}}],[\"二叉树的退化\",{\"0\":{\"184\":1}}],[\"二叉树的高度\",{\"1\":{\"181\":1}}],[\"二叉树的常用术语如下所示\",{\"1\":{\"181\":1}}],[\"二叉树的基本单元是节点\",{\"1\":{\"180\":1}}],[\"二叉树的基本概念\",{\"0\":{\"180\":1}}],[\"二叉树节点结构体\",{\"1\":{\"180\":1}}],[\"二叉树\",{\"0\":{\"10\":1},\"1\":{\"74\":1,\"180\":1,\"209\":1}}],[\"二分查找是基于递推\",{\"1\":{\"64\":1}}],[\"二分查找是将有序数组从中点索引处分为两部分\",{\"1\":{\"63\":1}}],[\"二分查找旨在查找一个特定元素\",{\"1\":{\"64\":1}}],[\"二分查找递归地将原问题\",{\"1\":{\"64\":1}}],[\"二分查找的分治策略如下所示\",{\"1\":{\"64\":1}}],[\"二分查找的每一步都将问题\",{\"1\":{\"64\":1}}],[\"二分查找的区间表示方法\",{\"0\":{\"21\":1}}],[\"二分查找最右一个\",{\"1\":{\"27\":1}}],[\"二分查找最左一个\",{\"1\":{\"26\":1}}],[\"二分查找边界\",{\"0\":{\"25\":1}}],[\"二分查找不仅可用于搜索目标元素\",{\"1\":{\"22\":1}}],[\"二分查找插入点\",{\"0\":{\"22\":1},\"1\":{\"23\":1,\"24\":1}}],[\"二分查找流程如下\",{\"1\":{\"20\":1}}],[\"二分查找\",{\"0\":{\"20\":1},\"1\":{\"20\":2,\"21\":1,\"63\":1,\"64\":2}}],[\"搜索时间也会增加\",{\"1\":{\"172\":1}}],[\"搜索代码包含以下要素\",{\"1\":{\"108\":1}}],[\"搜索所有可能的解\",{\"1\":{\"93\":1}}],[\"搜索过程会产生大量的重复子集\",{\"1\":{\"85\":1}}],[\"搜索问题\",{\"1\":{\"79\":1}}],[\"搜索并记录所有值为8的节点\",{\"1\":{\"74\":1}}],[\"搜索算法分为两大类\",{\"1\":{\"64\":1}}],[\"搜索完成后i指向最左一个\",{\"1\":{\"26\":1}}],[\"搜索区间最终会缩小为空\",{\"1\":{\"20\":1}}],[\"搜索\",{\"0\":{\"19\":1},\"1\":{\"93\":2,\"172\":4}}],[\"因而更为复杂\",{\"1\":{\"213\":1}}],[\"因而搜索效率往往优于以上时间复杂度\",{\"1\":{\"90\":1}}],[\"因为响应数据可能很庞大\",{\"1\":{\"442\":1}}],[\"因为本次数据读取可能并没有读取到一个完整的报文\",{\"1\":{\"442\":1}}],[\"因为调用write函数时实际也分为\",{\"1\":{\"442\":1}}],[\"因为此时服务器已经没有能力处理这个连接了\",{\"1\":{\"440\":1}}],[\"因为此时新连接当中的数据可能并没有就绪\",{\"1\":{\"440\":1}}],[\"因为timeout和readfds\",{\"1\":{\"439\":1}}],[\"因为当前程序并没有对就绪事件进行处理\",{\"1\":{\"439\":2}}],[\"因为编写epoll服务器在调用epoll\",{\"1\":{\"398\":1}}],[\"因为我们编写的poll服务器在调用poll函数时\",{\"1\":{\"391\":1}}],[\"因为右值被引用后会导致右值被存储到特定位置\",{\"1\":{\"379\":1}}],[\"因为构造函数使用了explicit关键字\",{\"1\":{\"379\":1}}],[\"因为构造函数被标记为explicit\",{\"1\":{\"357\":1}}],[\"因为这里是使用管道在本地进行的文件拷贝\",{\"1\":{\"406\":1}}],[\"因为这样让代码可读性变差了\",{\"1\":{\"379\":1}}],[\"因为这是一个读操作\",{\"1\":{\"354\":1}}],[\"因为继承后基类的虚函数被继承下来\",{\"1\":{\"376\":1}}],[\"因为重载需要在同一作用域下\",{\"1\":{\"373\":1}}],[\"因为采用私有继承\",{\"1\":{\"373\":1}}],[\"因为采用的保护继承\",{\"1\":{\"373\":1}}],[\"因为早期class是唯一的关键字\",{\"1\":{\"367\":1}}],[\"因为a=1\",{\"1\":{\"361\":1}}],[\"因为对象赋值不能让成员初始化\",{\"1\":{\"361\":1}}],[\"因为上面的成员是私有的\",{\"1\":{\"361\":1}}],[\"因为myclass构造函数接受一个int类型的参数\",{\"1\":{\"357\":1}}],[\"因为const\",{\"1\":{\"357\":1}}],[\"因为createobj函数\",{\"1\":{\"354\":1}}],[\"因为多个线程可能同时调用getinstance函数\",{\"1\":{\"354\":1}}],[\"因为外部调用该接口就是为了获取对象的\",{\"1\":{\"354\":1}}],[\"因为f和y没有使用指针和引用\",{\"1\":{\"348\":1}}],[\"因为底层实现是y先赋值给一个临时变量\",{\"1\":{\"348\":1}}],[\"因为类型不同\",{\"1\":{\"348\":1}}],[\"因为0为常量\",{\"1\":{\"348\":1}}],[\"因为x为常量\",{\"1\":{\"348\":1}}],[\"因为常变量只能读\",{\"1\":{\"348\":1}}],[\"因为初始化的时候我们就设定了capacity的大小\",{\"1\":{\"344\":1}}],[\"因为机器数带有符号位\",{\"1\":{\"327\":1}}],[\"因为\",{\"1\":{\"313\":1,\"361\":1}}],[\"因为所有属性都保存在同一个内存地址\",{\"1\":{\"303\":1}}],[\"因为每个内存单元都有地址\",{\"1\":{\"261\":1}}],[\"因为是无向图\",{\"1\":{\"219\":1}}],[\"因为质数不与其他数字存在公约数\",{\"1\":{\"177\":1}}],[\"因为线性探测可能需要跳过多个\",{\"1\":{\"172\":1}}],[\"因为其实际引用的就是线程栈中的拷贝\",{\"1\":{\"379\":1}}],[\"因为其之下可能还存在键值对\",{\"1\":{\"172\":1}}],[\"因为其逻辑更加清晰\",{\"1\":{\"24\":1}}],[\"因为需要线性遍历链表来查找对应元素\",{\"1\":{\"170\":1}}],[\"因为哈希表扩容需要进行大量的数据搬运与哈希值计算\",{\"1\":{\"169\":1}}],[\"因为从1开始计数会更自然\",{\"1\":{\"140\":1}}],[\"因为只有这样\",{\"1\":{\"135\":1}}],[\"因为1\",{\"1\":{\"127\":1}}],[\"因为虽然宽度一定变小\",{\"1\":{\"123\":1}}],[\"因为它们的pid和ppid都不相同\",{\"1\":{\"403\":1}}],[\"因为它往往比回溯\",{\"1\":{\"114\":1}}],[\"因为它仅需\",{\"1\":{\"18\":2}}],[\"因为数组是线性数据结构\",{\"1\":{\"144\":1}}],[\"因为数组\",{\"1\":{\"106\":1}}],[\"因为子集\",{\"1\":{\"85\":1}}],[\"因为该选择产生的子集\",{\"1\":{\"85\":1}}],[\"因为该方法引入了小数\",{\"1\":{\"27\":1}}],[\"因为生成重复排列的搜索分支没有必要\",{\"1\":{\"82\":1}}],[\"因为已知f\",{\"1\":{\"72\":1}}],[\"因为系统可以同时处理多个子问题\",{\"1\":{\"62\":1}}],[\"因为实际数据往往不是均匀分布的\",{\"1\":{\"51\":1}}],[\"因为有序数据通常能够被更高效地查找\",{\"1\":{\"32\":1}}],[\"因此如果要使用timeout参数\",{\"1\":{\"439\":1}}],[\"因此如果undefined是一个没有定义过的宏\",{\"1\":{\"321\":1}}],[\"因此就会不断打印\",{\"1\":{\"439\":1}}],[\"因此每次select函数的返回值都是0\",{\"1\":{\"439\":1}}],[\"因此会看到屏幕不断打印输出提示语句\",{\"1\":{\"439\":2}}],[\"因此select函数调用后会进行阻塞等待\",{\"1\":{\"439\":1}}],[\"因此运行服务器后如果没有客户端发来连接请求\",{\"1\":{\"391\":1,\"398\":1}}],[\"因此c++11中引入了原子操作\",{\"1\":{\"379\":1}}],[\"因此虚函数调用时\",{\"1\":{\"376\":1}}],[\"因此太大的单例对象不适合使用这种方式\",{\"1\":{\"354\":1}}],[\"因此饿汉模式下单例对象的创建是线程安全的\",{\"1\":{\"354\":1}}],[\"因此将带符号的机器数的真正表示的值称为机器数的真值\",{\"1\":{\"327\":1}}],[\"因此实参必须要指明数据类型在宏定义中\",{\"1\":{\"319\":1}}],[\"因此实际上删除的是原来的堆顶元素\",{\"1\":{\"212\":1}}],[\"因此实际的路径数量会少一些\",{\"1\":{\"103\":1}}],[\"因此传数组的本质就是传地址\",{\"1\":{\"264\":1}}],[\"因此使用o\",{\"1\":{\"225\":1}}],[\"因此其时间效率不如邻接矩阵\",{\"1\":{\"217\":1}}],[\"因此其遍历方式是通过指针逐个访问节点\",{\"1\":{\"185\":1}}],[\"因此它更加节省空间\",{\"1\":{\"217\":1}}],[\"因此它的索引为0是合理的\",{\"1\":{\"140\":1}}],[\"因此增删查改操作的效率很高\",{\"1\":{\"216\":1}}],[\"因此邻接矩阵主对角线元素没有意义\",{\"1\":{\"216\":1}}],[\"因此是一种平衡二叉搜索树\",{\"1\":{\"198\":1}}],[\"因此这个节点可以是右子树的最小节点或左子树的最大节点\",{\"1\":{\"195\":1}}],[\"因此不必指明数据类型\",{\"1\":{\"319\":1}}],[\"因此不适合存储数据量过大的树\",{\"1\":{\"191\":1}}],[\"因此不需要将子问题的解进行合并\",{\"1\":{\"64\":1}}],[\"因此所有边都会被访问2次\",{\"1\":{\"223\":1}}],[\"因此所有\",{\"1\":{\"190\":1}}],[\"因此要求节点值不能为\",{\"1\":{\"190\":1}}],[\"因此加法哈希和异或哈希无法区分内容相同但顺序不同的字符串\",{\"1\":{\"178\":1}}],[\"因此理论上哈希冲突是不可避免的\",{\"1\":{\"169\":1}}],[\"因此链表节点占用的空间相对较大综上\",{\"1\":{\"158\":1}}],[\"因此平均效率更高\",{\"1\":{\"158\":1}}],[\"因此效率相对较低\",{\"1\":{\"158\":1}}],[\"因此效率较高\",{\"1\":{\"158\":1}}],[\"因此一般不会用到\",{\"1\":{\"158\":1}}],[\"因此一般建议采用\",{\"1\":{\"21\":1}}],[\"因此在每次调用select函数之前\",{\"1\":{\"442\":1}}],[\"因此在获取完连接后直接将该连接对应的文件描述符添加到fd\",{\"1\":{\"440\":1}}],[\"因此在第一次select检测到读事件就绪后\",{\"1\":{\"439\":1}}],[\"因此在下一次传参时该右值会被识别成左值\",{\"1\":{\"379\":1}}],[\"因此在调用getinstance函数获取单例对象时\",{\"1\":{\"354\":1}}],[\"因此在该空桶之下的元素都无法再被访问到\",{\"1\":{\"172\":1}}],[\"因此在相同数据量下\",{\"1\":{\"146\":1}}],[\"因此在大多数编程语言中\",{\"1\":{\"145\":1}}],[\"因此在插入元素后\",{\"1\":{\"142\":1}}],[\"因此在数据结构与算法的设计中\",{\"1\":{\"15\":1}}],[\"因此高度只可能不变\",{\"1\":{\"123\":1}}],[\"因此本题的状态为两个隔板的索引\",{\"1\":{\"122\":1}}],[\"因此较大概率是一个动态规划问题\",{\"1\":{\"107\":1}}],[\"因此该问题满足决策树模型\",{\"1\":{\"107\":1}}],[\"因此物品i对应重量wgt\",{\"1\":{\"107\":1}}],[\"因此时间复杂度为0\",{\"1\":{\"124\":1}}],[\"因此时间复杂度为o\",{\"1\":{\"41\":1,\"73\":1,\"82\":1,\"105\":1,\"108\":1,\"120\":1}}],[\"因此时间复杂度取决于状态总数\",{\"1\":{\"104\":1}}],[\"因此首行i=0和首列j=0\",{\"1\":{\"102\":1}}],[\"因此被舍弃\",{\"1\":{\"99\":1}}],[\"因此被视为负面属性\",{\"1\":{\"33\":1}}],[\"因此空间复杂度从o\",{\"1\":{\"96\":1}}],[\"因此空间复杂度为o\",{\"1\":{\"30\":1,\"82\":1,\"105\":1,\"120\":1,\"124\":1,\"128\":1}}],[\"因此只需使用循环迭代实现\",{\"1\":{\"95\":1}}],[\"因此直接跳过当前元素\",{\"1\":{\"86\":1}}],[\"因此相等元素都是相邻的\",{\"1\":{\"86\":1}}],[\"因此相当于所有数字已经排序好了\",{\"1\":{\"53\":1}}],[\"因此越靠右的分支被剪掉的越多\",{\"1\":{\"85\":1}}],[\"因此无须借助\",{\"1\":{\"85\":1}}],[\"因此也应将第二轮的1^\",{\"1\":{\"82\":1}}],[\"因此也称\",{\"1\":{\"15\":2}}],[\"因此应该把1^\",{\"1\":{\"82\":1}}],[\"因此我们也可以采用类似的方法来优化效率\",{\"1\":{\"217\":1}}],[\"因此我们将采用数组来存储堆\",{\"1\":{\"209\":1}}],[\"因此我们需要为节点类添加\",{\"1\":{\"198\":1}}],[\"因此我们需要给\",{\"1\":{\"48\":1}}],[\"因此我们无法仅凭该序列来推测\",{\"1\":{\"190\":1}}],[\"因此我们无须使用一个数组\",{\"1\":{\"96\":1}}],[\"因此我们可以很容易地从哈希值反推出可用的\",{\"1\":{\"176\":1}}],[\"因此我们可以使用动态数组\",{\"1\":{\"157\":1}}],[\"因此我们可以使用两个数组滚动前进\",{\"1\":{\"111\":1}}],[\"因此我们可以只用一个单行数组来实现dp表\",{\"1\":{\"106\":1}}],[\"因此我们使用循环来遍历矩阵\",{\"1\":{\"102\":1}}],[\"因此我们通常会放宽条件\",{\"1\":{\"101\":1}}],[\"因此我们仍然可以通过扩展状态定义\",{\"1\":{\"99\":1}}],[\"因此我们容易得到一个推论\",{\"1\":{\"88\":1}}],[\"因此我们必须对所有可能的选择进行遍历\",{\"1\":{\"78\":1}}],[\"因此总体空间复杂度为o\",{\"1\":{\"69\":1}}],[\"因此总体时间复杂度为o\",{\"1\":{\"46\":1,\"69\":1}}],[\"因此通常可以并行解决\",{\"1\":{\"62\":1}}],[\"因此通过指针i和指针j缩小区间的操作也是对称的\",{\"1\":{\"21\":1}}],[\"因此需要同时更新两个方向的边\",{\"1\":{\"218\":1}}],[\"因此需要修复从插入节点到根节点的路径上的各个节点\",{\"1\":{\"211\":1}}],[\"因此需要将记录解之后的\",{\"1\":{\"77\":1}}],[\"因此需要将其减1\",{\"1\":{\"27\":1}}],[\"因此需要借助\",{\"1\":{\"71\":1}}],[\"因此需要长度为\",{\"1\":{\"56\":1}}],[\"因此访问元素的效率较高\",{\"1\":{\"44\":1}}],[\"因此得名冒泡排序\",{\"1\":{\"37\":1}}],[\"因此数组排序完成\",{\"1\":{\"36\":1,\"38\":1}}],[\"因此返回j即可\",{\"1\":{\"27\":1}}],[\"因此返回索引m\",{\"1\":{\"20\":1}}],[\"因此查找插入点本质上是在查找最左一个\",{\"1\":{\"26\":1}}],[\"因此两者可以合并\",{\"1\":{\"24\":1}}],[\"因此i+j可能超出int类型的取值范围\",{\"1\":{\"20\":1}}],[\"因此执行\",{\"1\":{\"193\":2}}],[\"因此执行j=m\",{\"1\":{\"20\":1}}],[\"因此执行i=m+1\",{\"1\":{\"20\":1}}],[\"因此循环次数为logn空间复杂度为o\",{\"1\":{\"20\":1}}],[\"因此\",{\"1\":{\"18\":1,\"27\":1,\"34\":1,\"39\":1,\"42\":1,\"81\":1,\"90\":2,\"102\":1,\"136\":1,\"158\":1,\"167\":1,\"168\":2,\"194\":1,\"195\":1,\"206\":1,\"221\":1,\"379\":1}}],[\"更加方便使用\",{\"1\":{\"379\":1}}],[\"更加充分地利用计算资源\",{\"1\":{\"62\":1}}],[\"更多的格式占位符后续会进行讲解\",{\"1\":{\"251\":1}}],[\"更近的桶\",{\"1\":{\"172\":1}}],[\"更快的原因类似\",{\"1\":{\"44\":1}}],[\"更占用空间\",{\"1\":{\"18\":1}}],[\"更新最大文件描述符\",{\"1\":{\"438\":1}}],[\"更新最大容量\",{\"1\":{\"124\":1}}],[\"更新节点高度\",{\"1\":{\"199\":1,\"201\":1,\"202\":1,\"206\":1,\"207\":1}}],[\"更新数组长度的值\",{\"1\":{\"186\":1}}],[\"更新尾节点\",{\"1\":{\"163\":1}}],[\"更新队列长度\",{\"1\":{\"163\":2}}],[\"更新头节点\",{\"1\":{\"163\":2}}],[\"更新栈大小\",{\"1\":{\"156\":1}}],[\"更新栈顶\",{\"1\":{\"156\":1}}],[\"更新新加节点数据域\",{\"1\":{\"156\":1}}],[\"更新新加节点指针域\",{\"1\":{\"156\":1}}],[\"更新等\",{\"1\":{\"132\":1}}],[\"更新元素和\",{\"1\":{\"85\":1}}],[\"更新状态\",{\"1\":{\"77\":3,\"81\":1,\"82\":1,\"92\":1}}],[\"更新\",{\"1\":{\"15\":1,\"85\":1,\"86\":1}}],[\"比较有意思的是\",{\"1\":{\"405\":1}}],[\"比较两个内存块的前几个字节是否相等\",{\"1\":{\"294\":1}}],[\"比较两个字符串\",{\"1\":{\"292\":1}}],[\"比较内存内容\",{\"1\":{\"294\":1}}],[\"比较字符串\",{\"1\":{\"292\":1}}],[\"比较\",{\"1\":{\"263\":1}}],[\"比较的是各自指向的内存地址的大小\",{\"1\":{\"262\":1}}],[\"比较节省空间\",{\"1\":{\"191\":1}}],[\"比较板i和板j的高度\",{\"1\":{\"123\":1}}],[\"比较子集\",{\"1\":{\"85\":1}}],[\"比较浪费空间\",{\"1\":{\"47\":1}}],[\"比\",{\"1\":{\"18\":1,\"44\":1}}],[\"比如http协议规定在读取底层数据时读取到空行就表明读完了一个http报头\",{\"1\":{\"442\":1}}],[\"比如我们这里将timeout的值设置为5秒\",{\"1\":{\"439\":1}}],[\"比如我们从客户端输入命令到管道当中\",{\"1\":{\"405\":1}}],[\"比如下面使用char类型时\",{\"1\":{\"367\":1}}],[\"比如空格\",{\"1\":{\"332\":1}}],[\"比如空格或制表符\",{\"1\":{\"317\":1}}],[\"比如显示器\",{\"1\":{\"309\":1}}],[\"比如大家经常使用的word文档\",{\"1\":{\"308\":1}}],[\"比如一个\",{\"1\":{\"262\":1}}],[\"比如当链表较长时\",{\"1\":{\"217\":1}}],[\"比如以上代码中的链表可记作链表\",{\"1\":{\"147\":1}}],[\"比如数组\",{\"1\":{\"147\":1}}],[\"比如都依赖最优子结构性质\",{\"1\":{\"113\":1}}],[\"比如在下图所示的\",{\"1\":{\"62\":1}}],[\"比如搜索目标元素的插入位置\",{\"1\":{\"22\":1}}],[\"比如汉字有近十万个\",{\"1\":{\"18\":1}}],[\"比如\",{\"1\":{\"15\":1,\"85\":1,\"166\":1,\"168\":2,\"169\":1,\"240\":1,\"257\":1,\"258\":1,\"261\":1,\"286\":1,\"303\":1,\"305\":1,\"310\":1,\"331\":1,\"354\":2,\"364\":1,\"379\":3}}],[\"或400年一润\",{\"1\":{\"361\":1}}],[\"或if\",{\"1\":{\"361\":1}}],[\"或显式\",{\"1\":{\"338\":1}}],[\"或根目录\",{\"1\":{\"320\":1}}],[\"或calloc\",{\"1\":{\"314\":2}}],[\"或者干脆重载成成员函数\",{\"1\":{\"361\":1}}],[\"或者无类型指针\",{\"1\":{\"348\":1}}],[\"或者null\",{\"1\":{\"310\":1}}],[\"或者说是一个指针链\",{\"1\":{\"265\":1}}],[\"或者说对合数取模的弊端是什么\",{\"1\":{\"177\":1}}],[\"或其他文件流\",{\"1\":{\"310\":1}}],[\"或枚举类型case后面的值必须是常量\",{\"1\":{\"297\":1}}],[\"或是用来作为判断函数执行状态的标记\",{\"1\":{\"286\":1}}],[\"或列下标\",{\"1\":{\"246\":1}}],[\"或不指定数组长度\",{\"1\":{\"245\":1}}],[\"或变小\",{\"1\":{\"123\":1}}],[\"或最多\",{\"1\":{\"101\":1}}],[\"或\",{\"1\":{\"18\":1,\"96\":1,\"102\":1,\"161\":1,\"211\":1,\"262\":1,\"291\":2,\"330\":4,\"331\":2,\"335\":1}}],[\"之前输出信息\",{\"1\":{\"379\":1}}],[\"之前的写法\",{\"1\":{\"304\":1}}],[\"之间存在边\",{\"1\":{\"216\":1}}],[\"之间插入一个新节点\",{\"1\":{\"148\":1}}],[\"之间的大小关系\",{\"1\":{\"193\":1}}],[\"之间的映射\",{\"1\":{\"166\":1}}],[\"之间的所有元素向右移动一位\",{\"1\":{\"40\":1}}],[\"之间的派生关系\",{\"1\":{\"14\":1,\"180\":1}}],[\"之后每次select函数一调用就会检测到读事件就绪并成功返回\",{\"1\":{\"439\":1}}],[\"之后需要做的就是将file\",{\"1\":{\"406\":1}}],[\"之后需要做的就是将从管道当中读取到的数据写入到file\",{\"1\":{\"406\":1}}],[\"之后我们就能在客户端看到这个已经被创建的命名管道文件\",{\"1\":{\"403\":1}}],[\"之后的首个节点\",{\"1\":{\"149\":1}}],[\"之后的所有元素向前移动一位\",{\"1\":{\"142\":1}}],[\"之后插入节点\",{\"1\":{\"148\":1}}],[\"之后再把元素赋值给该索引\",{\"1\":{\"141\":1}}],[\"之后\",{\"1\":{\"85\":1,\"95\":1}}],[\"之后继续尝试其他选择\",{\"1\":{\"81\":1}}],[\"之所以称之为回溯算法\",{\"1\":{\"75\":1}}],[\"之中\",{\"1\":{\"74\":1}}],[\"之外\",{\"1\":{\"18\":1}}],[\"从file\",{\"1\":{\"406\":1}}],[\"从客户端的标准输入流读取信息\",{\"1\":{\"403\":1}}],[\"从命名管道当中读取信息\",{\"1\":{\"403\":1,\"404\":1,\"405\":1,\"406\":1}}],[\"从文件末尾位置开始计算偏移量\",{\"1\":{\"310\":1}}],[\"从文件当前位置开始计算偏移量\",{\"1\":{\"310\":1}}],[\"从文件起始位置开始计算偏移量\",{\"1\":{\"310\":1}}],[\"从输入文件中读取数据\",{\"1\":{\"310\":1}}],[\"从头写入\",{\"1\":{\"310\":4}}],[\"从0到6\",{\"1\":{\"301\":1}}],[\"从0开始\",{\"1\":{\"301\":1}}],[\"从0开始的连续数字数组的长度\",{\"1\":{\"243\":1}}],[\"从字符串中提取数据\",{\"1\":{\"291\":1}}],[\"从函数传回到调用点的值\",{\"1\":{\"286\":1}}],[\"从使用的角度\",{\"1\":{\"285\":1}}],[\"从标准输入读取3个整数\",{\"1\":{\"252\":1}}],[\"从标准输入读取整数\",{\"1\":{\"252\":1}}],[\"从某个节点出发\",{\"1\":{\"222\":1}}],[\"从某个顶点出发\",{\"1\":{\"214\":2}}],[\"从该节点到根节点的路径上可能会出现一系列失衡节点\",{\"1\":{\"206\":1}}],[\"从二叉树的根节点\",{\"1\":{\"193\":1}}],[\"从物理结构的角度来看\",{\"1\":{\"185\":1}}],[\"从距离该节点最远的叶节点到该节点所经过的边的数量\",{\"1\":{\"181\":1}}],[\"从中删除键值对\",{\"1\":{\"170\":1}}],[\"从最低位开始\",{\"1\":{\"326\":2}}],[\"从最基础的步骤开始\",{\"1\":{\"136\":1}}],[\"从最小子问题的解开始\",{\"1\":{\"95\":1}}],[\"从高到低进行排序\",{\"1\":{\"120\":1}}],[\"从左上角顶点出发\",{\"1\":{\"222\":1,\"224\":1}}],[\"从左上角走到右下角总共需要m+n\",{\"1\":{\"103\":1}}],[\"从左向右找首个大于基准数的元素\",{\"1\":{\"42\":1,\"43\":1}}],[\"从起始点\",{\"1\":{\"102\":1}}],[\"从较小子问题逐步求解较大子问题\",{\"1\":{\"95\":1,\"98\":1,\"99\":1}}],[\"从底至顶堆化\",{\"1\":{\"211\":2,\"212\":1}}],[\"从底至顶修复堆中的各个节点\",{\"1\":{\"211\":1}}],[\"从底至顶执行堆化\",{\"1\":{\"211\":1}}],[\"从底至顶看\",{\"1\":{\"201\":1}}],[\"从底至顶\",{\"1\":{\"95\":1}}],[\"从底至顶地将子问题的解进行合并\",{\"1\":{\"58\":1}}],[\"从底至顶地将左子数组和右子数组合并为一个有序数组\",{\"1\":{\"46\":1}}],[\"从地面出发\",{\"1\":{\"92\":1}}],[\"从第\",{\"1\":{\"92\":1}}],[\"从第一行开始\",{\"1\":{\"88\":1}}],[\"从第二个字节开始\",{\"1\":{\"18\":1}}],[\"从根节点出发\",{\"1\":{\"194\":1}}],[\"从根节点到该节点所经过的边的数量\",{\"1\":{\"181\":1}}],[\"从根节点到最远叶节点所经过的边的数量\",{\"1\":{\"181\":1}}],[\"从根节点到叶节点的路径上的各个节点构成一个排列\",{\"1\":{\"83\":1}}],[\"从根节点开始\",{\"1\":{\"81\":1,\"212\":1}}],[\"从回溯代码的角度看\",{\"1\":{\"81\":1}}],[\"从回溯算法的角度看\",{\"1\":{\"81\":1,\"87\":1}}],[\"从一个点出发\",{\"1\":{\"79\":1}}],[\"从\",{\"1\":{\"72\":2,\"73\":1,\"85\":1,\"86\":2}}],[\"从本质上看\",{\"1\":{\"72\":1,\"82\":1,\"88\":1,\"103\":1,\"168\":1}}],[\"从另一根柱子顶部放入\",{\"1\":{\"70\":1}}],[\"从分治的角度切入\",{\"1\":{\"66\":1}}],[\"从已知解的最小子问题开始\",{\"1\":{\"58\":1}}],[\"从节点\",{\"1\":{\"48\":1,\"211\":1,\"212\":1}}],[\"从堆中提取最大元素\",{\"1\":{\"48\":1}}],[\"从堆中提取最大元素的时间复杂度为o\",{\"1\":{\"48\":1}}],[\"从堆顶元素开始\",{\"1\":{\"48\":1}}],[\"从顶点\",{\"1\":{\"214\":1}}],[\"从顶部到底部逐层遍历二叉树\",{\"1\":{\"186\":1}}],[\"从顶至底执行堆化\",{\"1\":{\"212\":1}}],[\"从顶至底递增\",{\"1\":{\"181\":1}}],[\"从顶至底递归地将数组从中点切分为两个子数组\",{\"1\":{\"46\":1}}],[\"从顶至底\",{\"1\":{\"95\":1}}],[\"从顶至底进行堆化\",{\"1\":{\"48\":1}}],[\"从顶至底堆化\",{\"1\":{\"48\":1,\"212\":3}}],[\"从顶到底执行堆化操作\",{\"1\":{\"48\":1}}],[\"从长度为\",{\"1\":{\"46\":1}}],[\"从名称上就能看出\",{\"1\":{\"44\":1}}],[\"从右向左找首个小于基准数的元素\",{\"1\":{\"42\":1,\"43\":1}}],[\"从数组最左端开始向右遍历\",{\"1\":{\"37\":1}}],[\"从而显式的指示编译器不生产该函数的默认版本\",{\"1\":{\"379\":1}}],[\"从而显式的指示编译器生成该函数的默认版本\",{\"1\":{\"379\":1}}],[\"从而显著减少总体的运行时间\",{\"1\":{\"62\":1}}],[\"从而解决数据冗余\",{\"1\":{\"373\":1}}],[\"从而导致野指针问题崩溃\",{\"1\":{\"361\":1}}],[\"从而导致资源释放时\",{\"1\":{\"361\":1}}],[\"从而衍生出了不同版本的智能指针\",{\"1\":{\"351\":1}}],[\"从而加载内部的代码\",{\"1\":{\"321\":1}}],[\"从而输出defined\",{\"1\":{\"321\":1}}],[\"从而输出重复子集\",{\"1\":{\"86\":1}}],[\"从而便于引用\",{\"1\":{\"304\":1}}],[\"从而使用o\",{\"1\":{\"218\":1}}],[\"从而得出一个重要性质\",{\"1\":{\"196\":1}}],[\"从而得到相应的结果\",{\"1\":{\"404\":1}}],[\"从而得到如下图所示的有权图\",{\"1\":{\"214\":1}}],[\"从而得到一个有序数组\",{\"1\":{\"63\":1}}],[\"从而得到最终的排序结果\",{\"1\":{\"55\":1}}],[\"从而完成节点插入操作\",{\"1\":{\"194\":1}}],[\"从而完成整个数组的排序\",{\"1\":{\"43\":1}}],[\"从而避免哈希冲突总而言之\",{\"1\":{\"177\":1}}],[\"从而避免重复计算该子问题\",{\"1\":{\"94\":1}}],[\"从而破解密码\",{\"1\":{\"176\":1}}],[\"从而优化查询效率\",{\"1\":{\"172\":1}}],[\"从而优先搜索最有可能产生有效解的路径\",{\"1\":{\"78\":1}}],[\"从而进一步促使该位置的聚堆生长\",{\"1\":{\"172\":1}}],[\"从而将时间复杂度降至o\",{\"1\":{\"217\":1}}],[\"从而将时间效率从o\",{\"1\":{\"217\":1}}],[\"从而将查询操作的时间复杂度优化至o\",{\"1\":{\"170\":1}}],[\"从而将商品平均分配到各个桶中\",{\"1\":{\"51\":1}}],[\"从而简化代码\",{\"1\":{\"170\":1}}],[\"从而获取\",{\"1\":{\"167\":1}}],[\"从而获取该\",{\"1\":{\"167\":1}}],[\"从而获得j\",{\"1\":{\"27\":1}}],[\"从而提高代码的可读性和可维护性如果我们定义一个变量\",{\"1\":{\"301\":1}}],[\"从而提高了代码的可读性\",{\"1\":{\"285\":1}}],[\"从而提高了搜索效率\",{\"1\":{\"76\":1}}],[\"从而提高效率\",{\"1\":{\"158\":1}}],[\"从而无法安全地扩展数组容量\",{\"1\":{\"145\":1}}],[\"从而直接访问该元素\",{\"1\":{\"140\":1}}],[\"从而借助高速缓存来提升后续操作的执行速度\",{\"1\":{\"138\":1}}],[\"从而大幅提升时间效率\",{\"1\":{\"92\":1}}],[\"从而节省时间和空间\",{\"1\":{\"78\":1}}],[\"从而节省内存\",{\"1\":{\"33\":1}}],[\"从而划分左右子树\",{\"1\":{\"69\":1}}],[\"从而可将\",{\"1\":{\"67\":1}}],[\"从而构建出原问题的解\",{\"1\":{\"58\":1}}],[\"从而缺乏这一特性\",{\"1\":{\"44\":1}}],[\"从而排序整个数组\",{\"1\":{\"33\":1}}],[\"从而具备一定的\",{\"1\":{\"15\":1}}],[\"从兼容性的角度看\",{\"1\":{\"18\":1}}],[\"从存储空间占用的角度看\",{\"1\":{\"18\":1}}],[\"第3个字符\",{\"1\":{\"245\":2}}],[\"第四个元素的值\",{\"1\":{\"244\":2}}],[\"第四章\",{\"0\":{\"137\":1,\"323\":1,\"365\":1,\"423\":1,\"451\":1,\"485\":1,\"505\":1,\"516\":1}}],[\"第九章\",{\"0\":{\"213\":1,\"260\":1,\"380\":1,\"433\":1}}],[\"第八章\",{\"0\":{\"208\":1,\"284\":1,\"377\":1,\"431\":1,\"471\":1}}],[\"第七章\",{\"0\":{\"179\":1,\"242\":1,\"374\":1,\"429\":1,\"467\":1,\"491\":1,\"522\":1}}],[\"第六章\",{\"0\":{\"165\":1,\"295\":1,\"371\":1,\"427\":1,\"460\":1,\"489\":1,\"520\":1}}],[\"第五章\",{\"0\":{\"154\":1,\"274\":1,\"368\":1,\"425\":1,\"453\":1,\"487\":1,\"507\":1,\"518\":1}}],[\"第三种\",{\"1\":{\"301\":1}}],[\"第三个元素的值\",{\"1\":{\"244\":2}}],[\"第三章\",{\"0\":{\"134\":1,\"247\":1,\"362\":1,\"421\":1,\"448\":1,\"482\":1,\"503\":1,\"514\":1}}],[\"第三轮选择\",{\"1\":{\"81\":1}}],[\"第二次调用f\",{\"1\":{\"361\":1}}],[\"第二种\",{\"1\":{\"301\":1}}],[\"第二个操作数可以是任何形式的表达式赋值运算符的副作用针对第一个操作数\",{\"1\":{\"279\":1}}],[\"第二个指针指向包含实际值的位置\",{\"1\":{\"265\":1}}],[\"第二个元素的值\",{\"1\":{\"244\":2}}],[\"第二维\",{\"1\":{\"246\":1}}],[\"第二步是构建节点之间的引用关系\",{\"1\":{\"147\":1}}],[\"第二章\",{\"0\":{\"130\":1,\"269\":1,\"359\":1,\"419\":1,\"445\":1,\"480\":1,\"497\":1,\"512\":1}}],[\"第二轮的两个4也会产生重复子集\",{\"1\":{\"86\":1}}],[\"第二轮选择中的1和1^\",{\"1\":{\"82\":1}}],[\"第二轮选择\",{\"1\":{\"81\":1}}],[\"第i个链表对应顶点i\",{\"1\":{\"217\":1}}],[\"第i个物品的重量为wgt\",{\"1\":{\"107\":1,\"118\":1}}],[\"第i种硬币的面值为coins\",{\"1\":{\"113\":1}}],[\"第1阶和第2阶楼梯\",{\"1\":{\"95\":1}}],[\"第一次调用f\",{\"1\":{\"361\":1}}],[\"第一次大修订\",{\"1\":{\"241\":1}}],[\"第一种\",{\"1\":{\"301\":1}}],[\"第一维\",{\"1\":{\"246\":1}}],[\"第一维的数组长度可以不给出\",{\"1\":{\"246\":1}}],[\"第一个参数是要提取数据的字符串\",{\"1\":{\"291\":1}}],[\"第一个参数是要写入的字符串\",{\"1\":{\"291\":1}}],[\"第一个指针包含了第二个指针的地址\",{\"1\":{\"265\":1}}],[\"第一个内存单元的地址即是变量\",{\"1\":{\"261\":1}}],[\"第一个iso标准\",{\"1\":{\"241\":1}}],[\"第一个元素的值\",{\"1\":{\"244\":6}}],[\"第一个元素\",{\"1\":{\"48\":1}}],[\"第一代\",{\"1\":{\"240\":1}}],[\"第一步是初始化各个节点对象\",{\"1\":{\"147\":1}}],[\"第一轮共有三个选择\",{\"1\":{\"86\":1}}],[\"第一轮的未排序区间长度为n\",{\"1\":{\"36\":1}}],[\"第一章\",{\"0\":{\"13\":1,\"238\":1,\"346\":1,\"383\":1,\"443\":1,\"477\":1,\"493\":1,\"509\":1}}],[\"第\",{\"1\":{\"33\":1,\"56\":2}}],[\"第十九章\",{\"0\":{\"417\":1}}],[\"第十八章\",{\"0\":{\"415\":1}}],[\"第十七章\",{\"0\":{\"413\":1}}],[\"第十六章\",{\"0\":{\"411\":1}}],[\"第十五章\",{\"0\":{\"112\":1,\"409\":1}}],[\"第十四章\",{\"0\":{\"91\":1,\"407\":1}}],[\"第十三章\",{\"0\":{\"74\":1,\"307\":1,\"358\":1,\"401\":1}}],[\"第十二章\",{\"0\":{\"57\":1,\"311\":1,\"355\":1,\"399\":1}}],[\"第十一章\",{\"0\":{\"31\":1,\"300\":1,\"352\":1,\"392\":1}}],[\"第十章\",{\"0\":{\"19\":1,\"316\":1,\"349\":1,\"385\":1}}],[\"第n+1位设置为0\",{\"1\":{\"18\":1}}],[\"将有效位置的文件描述符添加到readfds当中\",{\"1\":{\"438\":1}}],[\"将fd\",{\"1\":{\"438\":1}}],[\"将客户端想象成\",{\"1\":{\"406\":1}}],[\"将读取到的数据写入到命名管道当中\",{\"1\":{\"406\":1}}],[\"将读取到的信息写入到file\",{\"1\":{\"406\":1}}],[\"将读取的字符串显示在屏幕上\",{\"1\":{\"310\":1}}],[\"将信息写入命名管道\",{\"1\":{\"403\":1}}],[\"将文件默认掩码设置为0\",{\"1\":{\"403\":2,\"404\":1,\"405\":1,\"406\":1}}],[\"将文件描述符从epoll模型中删除\",{\"1\":{\"397\":2}}],[\"将文件指针重新定位到文件开头\",{\"1\":{\"310\":1}}],[\"将获取到的套接字添加到fd\",{\"1\":{\"440\":1}}],[\"将获取到的套接字添加到fds数组中\",{\"1\":{\"390\":1}}],[\"将获取到的套接字添加到epoll模型中\",{\"1\":{\"397\":1}}],[\"将监听套接字添加到fd\",{\"1\":{\"438\":1}}],[\"将监听套接字添加到epoll模型中\",{\"1\":{\"396\":1}}],[\"将监听套接字添加到数组中\",{\"1\":{\"389\":1}}],[\"将timeout的值设置成了\",{\"1\":{\"391\":1}}],[\"将lambda表达式作为线程函数\",{\"1\":{\"379\":2}}],[\"将实参的地址传入线程函数\",{\"1\":{\"379\":2}}],[\"将两个线程对象关联线程的状态进行交换\",{\"1\":{\"379\":1}}],[\"将两个圆盘从\",{\"1\":{\"72\":2}}],[\"将第一个参数和第三个参数分别绑定为std\",{\"1\":{\"379\":1}}],[\"将第二大元素交换至正确位置\",{\"1\":{\"38\":1}}],[\"将指针置为空\",{\"1\":{\"361\":1}}],[\"将int指针转换为char指针\",{\"1\":{\"357\":1}}],[\"将拷贝构造函数设置为私有\",{\"1\":{\"354\":1}}],[\"将构造函数设置为私有\",{\"1\":{\"354\":12}}],[\"将十六进制数每1位\",{\"1\":{\"326\":1}}],[\"将二进制数每四位一组\",{\"1\":{\"326\":1}}],[\"将每个位上的数提取出来\",{\"1\":{\"326\":2}}],[\"将每个字符的\",{\"1\":{\"177\":1}}],[\"将每个字节的高2位都设置为10\",{\"1\":{\"18\":1}}],[\"将地址赋给指针p\",{\"1\":{\"314\":1}}],[\"将不同类型的值组合在一起\",{\"1\":{\"302\":1}}],[\"将内存块的前几个字节设置为指定的值\",{\"1\":{\"294\":1}}],[\"将内存块中的数据移动到另一个内存块中\",{\"1\":{\"294\":1}}],[\"将源内存中的数据复制到目标内存中\",{\"1\":{\"294\":1}}],[\"将字符显示在屏幕上\",{\"1\":{\"310\":1}}],[\"将字符转换为大写\",{\"1\":{\"293\":1}}],[\"将字符转换为小写\",{\"1\":{\"293\":1}}],[\"将字符串转换为整数\",{\"1\":{\"292\":1}}],[\"将时间值转为字符串\",{\"1\":{\"291\":1}}],[\"将初始化为空字符\",{\"1\":{\"288\":1}}],[\"将程序按照功能拆分成若干模块单元\",{\"1\":{\"285\":1}}],[\"将变量\",{\"1\":{\"250\":1,\"251\":1}}],[\"将遍历起始顶点\",{\"1\":{\"223\":1}}],[\"将邻接矩阵的元素从1和0替换为权重\",{\"1\":{\"216\":1}}],[\"将边看作连接各个节点的引用\",{\"1\":{\"213\":1}}],[\"将堆底从列表中删除\",{\"1\":{\"212\":1}}],[\"将堆顶元素\",{\"1\":{\"48\":1}}],[\"将底层最靠右的节点称为\",{\"1\":{\"208\":1}}],[\"将待删除节点替换为其子节点即可\",{\"1\":{\"195\":1}}],[\"将输入数据的每个元素通过异或操作累积到一个哈希值中\",{\"1\":{\"177\":1}}],[\"将输入元素赋值给\",{\"1\":{\"161\":1}}],[\"将各个字符的\",{\"1\":{\"177\":1}}],[\"将各元素填入\",{\"1\":{\"56\":1}}],[\"将各元素填入结果数组\",{\"1\":{\"54\":1}}],[\"将各元素填入原数组\",{\"1\":{\"53\":1}}],[\"将得到的总和作为哈希值\",{\"1\":{\"177\":1}}],[\"将元素插入其中\",{\"1\":{\"172\":1}}],[\"将所有大于i的索引全部减1\",{\"1\":{\"219\":1}}],[\"将所有的\",{\"1\":{\"202\":1}}],[\"将所有发生冲突的键值对都存储在同一链表中\",{\"1\":{\"170\":1}}],[\"将所有小于基准数的元素移到其左侧\",{\"1\":{\"42\":1}}],[\"将单个元素转换为链表\",{\"1\":{\"170\":1}}],[\"将哈希值对桶数量\",{\"1\":{\"167\":1}}],[\"将把元素加入队尾的操作称为\",{\"1\":{\"159\":1}}],[\"将把元素添加到栈顶的操作叫作\",{\"1\":{\"155\":1}}],[\"将头节点作为栈顶\",{\"1\":{\"156\":1}}],[\"将原数组中的所有元素复制到新数组\",{\"1\":{\"145\":1}}],[\"将原问题分解为更小的子问题\",{\"1\":{\"136\":1}}],[\"将原问题f\",{\"1\":{\"72\":1}}],[\"将一个函数的某些参数绑定为固定的值\",{\"1\":{\"379\":1}}],[\"将一个循环放在另一个循环体内\",{\"1\":{\"298\":1}}],[\"将一个字符串附加到另一个字符串\",{\"1\":{\"292\":2}}],[\"将一个完整的功能封装成函数\",{\"1\":{\"285\":1}}],[\"将一对\",{\"1\":{\"128\":1}}],[\"将一维压缩至零维\",{\"1\":{\"98\":1}}],[\"将物品按照单位价值从高到低进行排序\",{\"1\":{\"119\":1}}],[\"将空间复杂度从o\",{\"1\":{\"111\":1}}],[\"将递推公式dp\",{\"1\":{\"95\":1}}],[\"将最大的子节点与根节点交换\",{\"1\":{\"212\":1}}],[\"将最后一个节点称为尾节点\",{\"1\":{\"153\":1}}],[\"将最小子问题对应的状态\",{\"1\":{\"95\":1}}],[\"将最高位设置为0\",{\"1\":{\"18\":1}}],[\"将爬楼梯想象为一个多轮选择的过程\",{\"1\":{\"92\":1}}],[\"将皇后放置在该格子\",{\"1\":{\"90\":1}}],[\"将已有皇后的列进行剪枝\",{\"1\":{\"89\":1}}],[\"将圆盘放入\",{\"1\":{\"73\":1}}],[\"将剩余1个圆盘从\",{\"1\":{\"72\":1}}],[\"将n\",{\"1\":{\"72\":2}}],[\"将n个元素分配到k个桶中\",{\"1\":{\"50\":1}}],[\"将当前树在\",{\"1\":{\"68\":1}}],[\"将当前树的根节点在\",{\"1\":{\"68\":2}}],[\"将当前元素填入索引\",{\"1\":{\"56\":1}}],[\"将子问题的解合并为原问题的解\",{\"1\":{\"60\":1}}],[\"将大问题分解为多个子问题\",{\"1\":{\"60\":1}}],[\"将k增加1\",{\"1\":{\"56\":1}}],[\"将数据格式化为字符串\",{\"1\":{\"291\":1}}],[\"将数据粗略地分到\",{\"1\":{\"51\":1}}],[\"将数据平均分配到各个桶中\",{\"1\":{\"49\":1}}],[\"将数组中的所有位置设置为无效\",{\"1\":{\"438\":1}}],[\"将数组\",{\"1\":{\"95\":1}}],[\"将数组从中点处分为两个子数组\",{\"1\":{\"61\":1}}],[\"将数组元素分配到各个桶中\",{\"1\":{\"50\":1}}],[\"将数组的最大元素交换至正确位置\",{\"1\":{\"38\":1}}],[\"将临时数组\",{\"1\":{\"46\":1}}],[\"将左子数组和右子数组的剩余元素复制到临时数组中\",{\"1\":{\"46\":1}}],[\"将长数组的排序问题转换为短数组的排序问题\",{\"1\":{\"45\":1}}],[\"将基准数交换至两子数组的分界线\",{\"1\":{\"42\":1,\"43\":1}}],[\"将\",{\"1\":{\"41\":3,\"54\":2,\"56\":2,\"72\":2,\"73\":4,\"141\":1,\"161\":1,\"163\":2,\"164\":2,\"201\":2,\"202\":2,\"219\":1}}],[\"将该文件描述符从fd\",{\"1\":{\"440\":2}}],[\"将该文件描述符从fds数组中清除\",{\"1\":{\"390\":2}}],[\"将该线程与创建线程进行分离\",{\"1\":{\"379\":1}}],[\"将该数不断除以16\",{\"1\":{\"326\":1}}],[\"将该数不断除以2\",{\"1\":{\"326\":1}}],[\"将该顶点之后的顶点向前移动\",{\"1\":{\"219\":1}}],[\"将该节点记为\",{\"1\":{\"201\":1}}],[\"将该节点置于\",{\"1\":{\"194\":1}}],[\"将该格子恢复为空位\",{\"1\":{\"90\":1}}],[\"将该元素与其左侧已排序区间的元素逐一比较大小\",{\"1\":{\"40\":1}}],[\"将该最小元素与未排序区间的首个元素交换\",{\"1\":{\"36\":1}}],[\"将未排序区间\",{\"1\":{\"38\":1,\"39\":1}}],[\"将其折行\",{\"1\":{\"317\":1}}],[\"将其切分为至少两个正整数的和\",{\"1\":{\"126\":1}}],[\"将其划分为更小的子树\",{\"1\":{\"66\":1}}],[\"将其插入到正确位置后\",{\"1\":{\"41\":3}}],[\"将其与索引1处的元素交换\",{\"1\":{\"36\":1}}],[\"将其与索引0处的元素交换\",{\"1\":{\"36\":1}}],[\"将其放到已排序区间的末尾\",{\"1\":{\"36\":1}}],[\"将键值对从原哈希表搬运至新哈希表\",{\"1\":{\"170\":1,\"172\":1}}],[\"将键值对作为链表节点\",{\"1\":{\"170\":1}}],[\"将键值对\",{\"1\":{\"30\":1}}],[\"将查找最右一个\",{\"1\":{\"27\":1}}],[\"将首个字节的高位n都设置为1\",{\"1\":{\"18\":1}}],[\"将世界范围内的所有语言和符号都收录其中\",{\"1\":{\"18\":1}}],[\"拉丁字母和希腊字母需要\",{\"1\":{\"18\":1}}],[\"到9223372036854775807\",{\"1\":{\"330\":2}}],[\"到90分\",{\"1\":{\"297\":1}}],[\"到数据源\",{\"1\":{\"308\":1}}],[\"到程序\",{\"1\":{\"308\":1}}],[\"到80分\",{\"1\":{\"297\":1}}],[\"到顶点v\",{\"1\":{\"216\":1}}],[\"到顶点\",{\"1\":{\"214\":2}}],[\"到\",{\"1\":{\"18\":1,\"214\":1,\"325\":1,\"330\":8,\"331\":2}}],[\"已退出\",{\"1\":{\"345\":1}}],[\"已经实现了原子操作的一系列方法\",{\"1\":{\"379\":1}}],[\"已经不再属于该链表了\",{\"1\":{\"149\":1}}],[\"已经包含\",{\"1\":{\"18\":1}}],[\"已知\",{\"1\":{\"93\":1,\"94\":1}}],[\"已排序元素数量加1\",{\"1\":{\"48\":1}}],[\"已排序区间为\",{\"1\":{\"41\":1}}],[\"已成为国际上使用最广泛的\",{\"1\":{\"18\":1}}],[\"umask\",{\"1\":{\"403\":2,\"404\":1,\"405\":1,\"406\":1}}],[\"usage\",{\"1\":{\"391\":3,\"398\":3,\"439\":3}}],[\"using\",{\"1\":{\"348\":8,\"361\":7,\"364\":2}}],[\"usr\",{\"1\":{\"320\":1}}],[\"uint64\",{\"1\":{\"330\":1}}],[\"uint32\",{\"1\":{\"330\":1,\"396\":1,\"397\":1}}],[\"uint16\",{\"1\":{\"330\":1}}],[\"uint8\",{\"1\":{\"330\":1}}],[\"ull\",{\"1\":{\"330\":1}}],[\"ul\",{\"1\":{\"330\":1}}],[\"u\",{\"1\":{\"330\":3,\"337\":1,\"361\":9}}],[\"uppercase\",{\"1\":{\"293\":3}}],[\"updateheight\",{\"1\":{\"199\":1,\"201\":2,\"202\":2,\"206\":1,\"207\":1}}],[\"up\",{\"1\":{\"103\":3,\"104\":3,\"292\":1}}],[\"unsetpollfds\",{\"1\":{\"390\":3}}],[\"unsign\",{\"1\":{\"304\":1}}],[\"unsigned\",{\"1\":{\"177\":4,\"259\":1,\"304\":1,\"330\":11,\"332\":2,\"335\":2,\"337\":1}}],[\"until\",{\"1\":{\"379\":1}}],[\"unordered\",{\"1\":{\"379\":8}}],[\"unable\",{\"1\":{\"370\":2}}],[\"unlock\",{\"1\":{\"354\":3,\"379\":3}}],[\"uniqueptr\",{\"1\":{\"351\":4}}],[\"unique\",{\"1\":{\"351\":7,\"379\":5}}],[\"union命令定义了一个包含三个属性的数据类型\",{\"1\":{\"304\":1}}],[\"union命令定义了一个包含三个属性的数据类型data\",{\"1\":{\"303\":1}}],[\"union等命令定义的复杂数据结构创建别名\",{\"1\":{\"304\":1}}],[\"union\",{\"1\":{\"259\":1,\"303\":10,\"304\":1}}],[\"unicode码点\",{\"1\":{\"18\":1}}],[\"unicode\",{\"1\":{\"18\":10}}],[\"unicode字符集\",{\"1\":{\"18\":1}}],[\"undefined为真\",{\"1\":{\"321\":1}}],[\"undefined为伪\",{\"1\":{\"321\":1}}],[\"undef\",{\"1\":{\"318\":1}}],[\"undef命令\",{\"1\":{\"318\":1}}],[\"undeclared\",{\"1\":{\"288\":8}}],[\"undirected\",{\"1\":{\"214\":1}}],[\"undochoice\",{\"1\":{\"77\":3}}],[\"utc时间\",{\"1\":{\"291\":1}}],[\"uthash\",{\"1\":{\"30\":1}}],[\"ut\",{\"1\":{\"30\":1}}],[\"utf\",{\"1\":{\"18\":16}}],[\"英文文本占用空间的大小将会是\",{\"1\":{\"18\":1}}],[\"系统调用\",{\"0\":{\"495\":1}}],[\"系统中使用绝对路径引入自定义头文件\",{\"1\":{\"320\":1}}],[\"系统全局变量和函数原型写在自定义的头文件中\",{\"1\":{\"320\":1}}],[\"系统内部使用了一些下划线开头的标识符\",{\"1\":{\"258\":1}}],[\"系统占用o\",{\"1\":{\"187\":1}}],[\"系统通常不会直接存储用户的明文密码\",{\"1\":{\"176\":1}}],[\"系统通过内存地址来访问目标位置的数据\",{\"1\":{\"15\":1}}],[\"系统会按照最长的成员为它分配内存\",{\"1\":{\"303\":1}}],[\"系统会自动初始化为零\",{\"1\":{\"289\":1}}],[\"系统会自动计算\",{\"1\":{\"244\":1}}],[\"系统会根据共同游戏时间来计算玩家之间的\",{\"1\":{\"214\":1}}],[\"系统会对输入的密码计算哈希值\",{\"1\":{\"176\":1}}],[\"系统会将哈希表扩容至原先的2倍\",{\"1\":{\"168\":1}}],[\"系统会为列表分配\",{\"1\":{\"158\":1}}],[\"系统可将整个子数组加载到缓存\",{\"1\":{\"44\":1}}],[\"系统如何确认它是一个\",{\"1\":{\"18\":1}}],[\"系统如何解析字符\",{\"1\":{\"18\":1}}],[\"有事件发生\",{\"1\":{\"389\":1,\"396\":1,\"438\":1,\"439\":2}}],[\"有效数字7位\",{\"1\":{\"357\":1}}],[\"有效小数位数\",{\"1\":{\"331\":1}}],[\"有也可以\",{\"1\":{\"344\":1}}],[\"有符号整数自动转为无符号整数\",{\"1\":{\"337\":1}}],[\"有符号char取值范围\",{\"1\":{\"332\":1}}],[\"有符号\",{\"1\":{\"332\":1}}],[\"有些编译器的扩展允许将预处理指令写在函数里\",{\"1\":{\"317\":1}}],[\"有些编译器会触发警告\",{\"1\":{\"313\":1}}],[\"有些生僻的字符占用\",{\"1\":{\"18\":1}}],[\"有一个结构体的名字是\",{\"1\":{\"304\":1}}],[\"有时源码文件可能会重复加载某个库\",{\"1\":{\"321\":1}}],[\"有时候向系统请求内存的时候\",{\"1\":{\"313\":1}}],[\"有时是浮点数\",{\"1\":{\"303\":1}}],[\"有时是字符\",{\"1\":{\"303\":1}}],[\"有时需要一种数据结构\",{\"1\":{\"303\":1}}],[\"有明确的返回值\",{\"1\":{\"286\":1}}],[\"有助于降低复杂度增强可维护性\",{\"1\":{\"285\":1}}],[\"有助于数据分布得更加均匀\",{\"1\":{\"173\":1}}],[\"有浮点数执行浮点数除法\",{\"1\":{\"276\":1}}],[\"有两种方式\",{\"1\":{\"261\":1}}],[\"有两方面原因\",{\"1\":{\"85\":1}}],[\"有左子节点\",{\"1\":{\"202\":1}}],[\"有右子节点\",{\"1\":{\"201\":1}}],[\"有3x3\",{\"1\":{\"127\":1}}],[\"有后效性\",{\"1\":{\"99\":1}}],[\"有关\",{\"1\":{\"96\":1}}],[\"有可能被交换至与其相等的元素的右边\",{\"1\":{\"36\":1}}],[\"有了这个函数\",{\"1\":{\"205\":1}}],[\"有了这些地址\",{\"1\":{\"15\":1}}],[\"有了字符集之后\",{\"1\":{\"18\":1}}],[\"字面常量\",{\"1\":{\"379\":1}}],[\"字面常量或表达式计算结果\",{\"1\":{\"379\":1}}],[\"字面常量后缀字面量是源代码中一个固定值的表示法\",{\"1\":{\"330\":1}}],[\"字面量可以省略括号\",{\"1\":{\"335\":1}}],[\"字面量的存储大小\",{\"1\":{\"335\":1}}],[\"字面量后缀\",{\"1\":{\"331\":1}}],[\"字面量常量\",{\"1\":{\"254\":1}}],[\"字母\",{\"1\":{\"325\":1}}],[\"字母b对应十进制的11\",{\"1\":{\"325\":1}}],[\"字母a对应十进制的10\",{\"1\":{\"325\":1}}],[\"字节表示\",{\"1\":{\"18\":2}}],[\"字节来表示一个字符\",{\"1\":{\"18\":2}}],[\"字节的字符\",{\"1\":{\"18\":3}}],[\"字节的字符还是两个\",{\"1\":{\"18\":1}}],[\"字节的编码\",{\"1\":{\"18\":1}}],[\"字节unicode\",{\"1\":{\"18\":1}}],[\"字节甚至\",{\"1\":{\"18\":1}}],[\"字节\",{\"1\":{\"18\":10,\"330\":9,\"331\":2}}],[\"字符型数据在计算中存储和读取的过程\",{\"1\":{\"332\":1}}],[\"字符函数的例子\",{\"1\":{\"293\":1}}],[\"字符指针是可变的\",{\"1\":{\"263\":1}}],[\"字符指针字符指针变量\",{\"1\":{\"263\":1}}],[\"字符常量\",{\"1\":{\"254\":1}}],[\"字符数组名和字符指针表示字符串的区别\",{\"1\":{\"263\":1}}],[\"字符数组的访问和遍历字符数组\",{\"1\":{\"245\":1}}],[\"字符数组的定义方法一\",{\"1\":{\"245\":1}}],[\"字符数组的介绍用来存放字符的数组称为字符数组\",{\"1\":{\"245\":1}}],[\"字符数组\",{\"0\":{\"245\":1},\"1\":{\"263\":2,\"288\":4,\"291\":1,\"309\":1}}],[\"字符与字符串\",{\"0\":{\"232\":1}}],[\"字符或字符串等\",{\"1\":{\"32\":1}}],[\"字符占比较高的文本\",{\"1\":{\"18\":1}}],[\"字符和常用的非英文字符\",{\"1\":{\"18\":1}}],[\"字符在\",{\"1\":{\"18\":1}}],[\"字符只需\",{\"1\":{\"18\":1}}],[\"字符使用一个字节表示\",{\"1\":{\"18\":1}}],[\"字符集中占据了前\",{\"1\":{\"18\":1}}],[\"字符集中\",{\"1\":{\"18\":1}}],[\"字符集与编码标准百花齐放\",{\"1\":{\"18\":1}}],[\"字符集是在\",{\"1\":{\"18\":1}}],[\"字符集\",{\"1\":{\"18\":4}}],[\"字符\",{\"1\":{\"18\":1,\"32\":1,\"325\":1}}],[\"字符编码\",{\"0\":{\"18\":1}}],[\"字符类型本质\",{\"1\":{\"332\":1}}],[\"字符类型\",{\"0\":{\"332\":1},\"1\":{\"16\":1,\"332\":1}}],[\"字符串内的形参通常要用括号括起来以避免出错\",{\"1\":{\"319\":1}}],[\"字符串函数的例子\",{\"1\":{\"292\":1}}],[\"字符串转整数\",{\"1\":{\"292\":1}}],[\"字符串结尾\",{\"1\":{\"245\":1}}],[\"字符串的输入输出格式占位符是\",{\"1\":{\"245\":1}}],[\"字符串\",{\"0\":{\"7\":1,\"245\":1},\"1\":{\"245\":1,\"309\":1,\"379\":1}}],[\"常值具有常性const\",{\"1\":{\"348\":1}}],[\"常引用时\",{\"1\":{\"348\":1}}],[\"常引用权限问题\",{\"1\":{\"348\":1}}],[\"常把用typedef声明的类型名的第1个字母用大写表示\",{\"1\":{\"304\":1}}],[\"常量转换\",{\"1\":{\"357\":1}}],[\"常量与运算符也可以组成复杂一些的表达式\",{\"1\":{\"275\":1}}],[\"常量值n\",{\"1\":{\"297\":1}}],[\"常量值2\",{\"1\":{\"297\":1}}],[\"常量值1\",{\"1\":{\"297\":1}}],[\"常量值\",{\"1\":{\"255\":1}}],[\"常量的定义方法主要有\",{\"1\":{\"255\":1}}],[\"常量的定义\",{\"0\":{\"255\":1}}],[\"常量的分类\",{\"0\":{\"254\":1}}],[\"常量\",{\"0\":{\"253\":1},\"1\":{\"338\":1,\"379\":1}}],[\"常见进制介绍\",{\"1\":{\"325\":1}}],[\"常见二叉树类型\",{\"0\":{\"183\":1}}],[\"常见哈希算法\",{\"0\":{\"178\":1}}],[\"常见链表类型\",{\"0\":{\"153\":1}}],[\"常见的链表类型包括三种\",{\"1\":{\"153\":1}}],[\"常见的效率优化方法有两种\",{\"1\":{\"78\":1}}],[\"常见的区间表示还有\",{\"1\":{\"21\":1}}],[\"常见的编码方式还包括以下两种\",{\"1\":{\"18\":1}}],[\"常见的数据结构包括数组\",{\"1\":{\"13\":1}}],[\"常用typeid\",{\"1\":{\"379\":1}}],[\"常用\",{\"1\":{\"361\":1}}],[\"常用内存操作函数汇总\",{\"1\":{\"294\":1}}],[\"常用内存操作函数\",{\"0\":{\"294\":1}}],[\"常用字符函数汇总\",{\"1\":{\"293\":1}}],[\"常用字符函数\",{\"0\":{\"293\":1}}],[\"常用字符串函数汇总\",{\"1\":{\"292\":1}}],[\"常用字符串函数\",{\"0\":{\"292\":1}}],[\"常用系统函数\",{\"0\":{\"291\":1}}],[\"常用解法有遗传算法和蚁群算法等\",{\"1\":{\"79\":1}}],[\"常用的中文字符需要\",{\"1\":{\"18\":1}}],[\"常用的字符占用\",{\"1\":{\"18\":1}}],[\"月\",{\"1\":{\"18\":1,\"361\":2}}],[\"年龄\",{\"1\":{\"302\":6,\"342\":1,\"344\":1,\"361\":2,\"373\":1}}],[\"年\",{\"1\":{\"18\":1,\"361\":2}}],[\"年发布以来\",{\"1\":{\"18\":1}}],[\"年发布了\",{\"1\":{\"18\":1}}],[\"截至\",{\"1\":{\"18\":1}}],[\"提示语句\",{\"1\":{\"439\":1}}],[\"提示客户端输入\",{\"1\":{\"403\":1}}],[\"提示程序存在潜在的隐患\",{\"1\":{\"338\":1}}],[\"提高了灵活性和代码的可读性\",{\"1\":{\"376\":1}}],[\"提高了运算效率\",{\"1\":{\"17\":1}}],[\"提高效率\",{\"1\":{\"348\":1}}],[\"提高代码的结构化和复用性代码模块化\",{\"1\":{\"285\":1}}],[\"提升安全和可靠性\",{\"1\":{\"241\":1}}],[\"提升哈希算法的稳健性\",{\"1\":{\"177\":1}}],[\"提升代码的通用性\",{\"1\":{\"77\":1}}],[\"提供了一个what\",{\"1\":{\"382\":2}}],[\"提供了更高的灵活性\",{\"1\":{\"162\":1}}],[\"提供了更丰富的逻辑信息\",{\"1\":{\"132\":1}}],[\"提供额外成员函数\",{\"1\":{\"379\":1}}],[\"提供emplace系列方法\",{\"1\":{\"379\":2}}],[\"提供cbegin和cend方法\",{\"1\":{\"379\":2}}],[\"提供initializer\",{\"1\":{\"379\":2}}],[\"提供函数获取内容\",{\"1\":{\"361\":1}}],[\"提供一个全局访问点获取单例对象\",{\"1\":{\"354\":8}}],[\"提供一个指向单例对象的static指针\",{\"1\":{\"354\":6}}],[\"提供一个获取对象的接口\",{\"1\":{\"354\":2}}],[\"提供一种通用的字符集来处理和显示各种语言文字\",{\"1\":{\"18\":1}}],[\"提供简洁的数据表示和逻辑信息\",{\"1\":{\"132\":1}}],[\"不可移动\",{\"1\":{\"379\":1}}],[\"不可拷贝\",{\"1\":{\"379\":1}}],[\"不可见指的是继承下来用不了的意思\",{\"1\":{\"373\":1}}],[\"不表示\",{\"1\":{\"379\":1}}],[\"不代表右值引用\",{\"1\":{\"379\":1}}],[\"不具有内存位置的表达式\",{\"1\":{\"379\":1}}],[\"不使用explicit\",{\"1\":{\"379\":1}}],[\"不安全\",{\"1\":{\"373\":1}}],[\"不写自动生成\",{\"1\":{\"361\":1}}],[\"不写构造函数\",{\"1\":{\"361\":1}}],[\"不拷贝构造\",{\"1\":{\"361\":2}}],[\"不在类中\",{\"1\":{\"361\":1}}],[\"不开空间是声明\",{\"1\":{\"361\":1}}],[\"不够彻底\",{\"1\":{\"354\":1}}],[\"不减少引用计数的方式\",{\"1\":{\"351\":1}}],[\"不就是野指针了吗\",{\"1\":{\"348\":1}}],[\"不就可以解决跨语言环境和乱码问题了吗\",{\"1\":{\"18\":1}}],[\"不初始化也行\",{\"1\":{\"345\":1}}],[\"不分先后\",{\"1\":{\"330\":1}}],[\"不推荐写法\",{\"1\":{\"317\":1}}],[\"不推荐一行声明多个变量\",{\"1\":{\"250\":1}}],[\"不管是在标准头文件中还是以后的编程实践中\",{\"1\":{\"304\":1}}],[\"不给出结构体的名字\",{\"1\":{\"302\":1}}],[\"不能直接调用write函数\",{\"1\":{\"442\":1}}],[\"不能立即调用read函数读取该连接当中的数据\",{\"1\":{\"440\":1}}],[\"不能实例化\",{\"1\":{\"376\":2}}],[\"不能被继承\",{\"1\":{\"354\":2}}],[\"不能被拷贝\",{\"1\":{\"354\":2}}],[\"不能写\",{\"1\":{\"348\":1}}],[\"不能放大\",{\"1\":{\"348\":1}}],[\"不能通过变量名或者数组名来引用这些数据\",{\"1\":{\"312\":1}}],[\"不能使用feof函数的返回值直接判断文本是否结束\",{\"1\":{\"310\":1}}],[\"不能是其他值\",{\"1\":{\"301\":1}}],[\"不能对字符数组名重新赋值\",{\"1\":{\"263\":1}}],[\"不建议省略\",{\"1\":{\"287\":1}}],[\"不论前面还是后面\",{\"1\":{\"276\":1}}],[\"不正确\",{\"1\":{\"267\":1}}],[\"不要用基类指针赋值派生类指针\",{\"1\":{\"373\":1}}],[\"不要用分号结尾\",{\"1\":{\"255\":1}}],[\"不要把一个表达式写得过于复杂\",{\"1\":{\"283\":1}}],[\"不要过多的依赖运算的优先级来控制表达式的执行顺序\",{\"1\":{\"283\":1}}],[\"不要出现仅靠大小写区分不同的标识符\",{\"1\":{\"258\":1}}],[\"不同类型浮点数进行运算\",{\"1\":{\"337\":1}}],[\"不同类型整数进行运算\",{\"1\":{\"337\":1}}],[\"不同类型的浮点数运算\",{\"1\":{\"337\":1}}],[\"不同类型的数据进行混合运算\",{\"1\":{\"337\":1}}],[\"不同类型的数据在内存中占据不同大小的空间\",{\"1\":{\"329\":1}}],[\"不同类型的变量占用不同大小的空间\",{\"1\":{\"261\":1}}],[\"不同的场合表示不同的数据类型\",{\"1\":{\"303\":1}}],[\"不同编译器和平台会有所不同\",{\"1\":{\"257\":1}}],[\"不同点在于\",{\"1\":{\"118\":1}}],[\"不进行类型检查\",{\"1\":{\"255\":1}}],[\"不是二维的\",{\"1\":{\"246\":1}}],[\"不会调用拷贝构造\",{\"1\":{\"361\":1}}],[\"不会改变原值\",{\"1\":{\"348\":1}}],[\"不会改变它们的顺序\",{\"1\":{\"41\":1}}],[\"不会造成精度损失\",{\"1\":{\"337\":1}}],[\"不会在函数调用结束就销毁\",{\"1\":{\"334\":1}}],[\"不会执行\",{\"1\":{\"321\":1}}],[\"不会执行代码块\",{\"1\":{\"297\":1}}],[\"不会对表达式进行计算\",{\"1\":{\"319\":1}}],[\"不会为形式参数分配内存\",{\"1\":{\"319\":1}}],[\"不会自动添加\",{\"1\":{\"245\":1}}],[\"不指定元素个数\",{\"1\":{\"244\":1}}],[\"不应该添加这么多节点\",{\"1\":{\"211\":1}}],[\"不需要对原子类型进行加锁解锁操作\",{\"1\":{\"379\":1}}],[\"不需要的代码就放在\",{\"1\":{\"321\":1}}],[\"不需要定义或声明\",{\"1\":{\"254\":1}}],[\"不需要存储指针\",{\"1\":{\"191\":1}}],[\"不需要设计特殊的硬件电路来处理减法\",{\"1\":{\"17\":1}}],[\"不难发现\",{\"1\":{\"178\":1}}],[\"不存在联系人\",{\"1\":{\"344\":1}}],[\"不存在\",{\"1\":{\"172\":1}}],[\"不存在上述数组扩容时效率降低的问题\",{\"1\":{\"158\":1}}],[\"不引入额外的数据结构\",{\"1\":{\"171\":1}}],[\"不过注意的是tr1并不是标准版\",{\"1\":{\"351\":1}}],[\"不过\",{\"1\":{\"158\":1,\"304\":1}}],[\"不做处理\",{\"1\":{\"128\":2}}],[\"不选和选物品\",{\"1\":{\"110\":1,\"111\":1}}],[\"不允许越过第\",{\"1\":{\"92\":1}}],[\"不允许该格子所在列\",{\"1\":{\"90\":1}}],[\"不允许重复选择相等元素\",{\"1\":{\"82\":1}}],[\"不允许重复选择元素\",{\"1\":{\"81\":1,\"82\":1}}],[\"不满足该条件的选择序列都会造成重复\",{\"1\":{\"85\":1}}],[\"不再继续搜索\",{\"1\":{\"76\":1,\"77\":1}}],[\"不再赘述\",{\"1\":{\"63\":1}}],[\"不一定要每轮将数据划分为\",{\"1\":{\"51\":1}}],[\"不断循环该步骤\",{\"1\":{\"113\":1}}],[\"不断缩小问题范围\",{\"1\":{\"113\":1}}],[\"不断执行出堆操作\",{\"1\":{\"47\":1}}],[\"不断扩充新的语言与字符\",{\"1\":{\"18\":1}}],[\"不相等\",{\"1\":{\"26\":1,\"263\":1}}],[\"则这个函数称为存虚函数\",{\"1\":{\"376\":1}}],[\"则被重写为dervied类的析构函数\",{\"1\":{\"376\":1}}],[\"则被视为正面属性\",{\"1\":{\"33\":1}}],[\"则先执行\",{\"1\":{\"361\":1}}],[\"则\",{\"1\":{\"361\":1}}],[\"则类大小为最大对齐数4的倍数\",{\"1\":{\"361\":1}}],[\"则交换\",{\"1\":{\"344\":1}}],[\"则执行指定的操作\",{\"1\":{\"321\":1}}],[\"则执行\",{\"1\":{\"321\":1}}],[\"则执行else\",{\"1\":{\"297\":1}}],[\"则忽略内部的语句\",{\"1\":{\"321\":1}}],[\"则内层循环体实际上需要执行m\",{\"1\":{\"298\":1}}],[\"则输出\",{\"1\":{\"297\":1}}],[\"则提示\",{\"1\":{\"297\":1}}],[\"则提前返回\",{\"1\":{\"76\":1}}],[\"则函数会返回一个不确定的值\",{\"1\":{\"286\":1}}],[\"则把它分成几步来完成\",{\"1\":{\"283\":1}}],[\"则它称为指针变量\",{\"1\":{\"261\":1}}],[\"则它们一定处在同一条主对角线上\",{\"1\":{\"89\":1}}],[\"则会自动在后面加\",{\"1\":{\"245\":1}}],[\"则会陷入漫长的等待之中\",{\"1\":{\"93\":1}}],[\"则各种操作的实现方式如下图所示\",{\"1\":{\"218\":1}}],[\"则树的高度为o\",{\"1\":{\"211\":1}}],[\"则删除操作流程如下图所示\",{\"1\":{\"195\":1}}],[\"则初始化根节点\",{\"1\":{\"194\":1}}],[\"则该节点的左子节点索引为2i+1\",{\"1\":{\"189\":1}}],[\"则该选择序列需要满足i1\",{\"1\":{\"85\":1}}],[\"则每个节点都对应唯一的数组索引\",{\"1\":{\"189\":1}}],[\"则节点总数为2^\",{\"1\":{\"183\":1}}],[\"则其左子节点和右子节点分别是\",{\"1\":{\"180\":1}}],[\"则尝试f2\",{\"1\":{\"174\":1}}],[\"则用删除标记覆盖它\",{\"1\":{\"172\":1}}],[\"则添加该键值对\",{\"1\":{\"172\":1}}],[\"则覆盖\",{\"1\":{\"172\":1}}],[\"则使用引用做返回值\",{\"1\":{\"348\":1}}],[\"则使用相同步长向后进行线性遍历\",{\"1\":{\"172\":1}}],[\"则使用当前物品的一部分填满背包\",{\"1\":{\"119\":1}}],[\"则更新对应\",{\"1\":{\"170\":2}}],[\"则必然有多个整数映射至同一桶索引\",{\"1\":{\"169\":1}}],[\"则令\",{\"1\":{\"163\":1}}],[\"则令头\",{\"1\":{\"160\":1}}],[\"则得到一个环形链表\",{\"1\":{\"153\":1}}],[\"则只需改变两个节点引用\",{\"1\":{\"148\":1}}],[\"则只能选择不放入背包\",{\"1\":{\"108\":2,\"109\":1}}],[\"则需遍历整个邻接表\",{\"1\":{\"219\":1}}],[\"则需重新建立一个更大的数组\",{\"1\":{\"145\":1}}],[\"则需要执行下图所示的\",{\"1\":{\"202\":1}}],[\"则需要把索引i之后的元素都往前移动一位\",{\"1\":{\"142\":1}}],[\"则需要将该元素之后的所有元素都向后移动一位\",{\"1\":{\"141\":1}}],[\"则需要在第二轮剪掉元素\",{\"1\":{\"81\":1}}],[\"则容量一定变小\",{\"1\":{\"123\":1}}],[\"则将它们交换\",{\"1\":{\"211\":1}}],[\"则将中序遍历的下个节点删除\",{\"1\":{\"207\":1}}],[\"则将键值对移动至该索引处\",{\"1\":{\"172\":1}}],[\"则将键值对添加至链表头部\",{\"1\":{\"170\":1}}],[\"则将该节点添加到尾节点后\",{\"1\":{\"160\":1}}],[\"则将该节点的值加入结果列表\",{\"1\":{\"74\":1}}],[\"则将当前物品的一部分装进背包\",{\"1\":{\"120\":1}}],[\"则将当前物品整个装进背包\",{\"1\":{\"120\":1}}],[\"则背包增加的价值为w\",{\"1\":{\"118\":1}}],[\"则不会自动添加\",{\"1\":{\"245\":1}}],[\"则不会发生覆盖问题\",{\"1\":{\"111\":1}}],[\"则不执行插入\",{\"1\":{\"194\":1}}],[\"则不选物品\",{\"1\":{\"110\":1}}],[\"则终止搜索\",{\"1\":{\"103\":1,\"104\":1}}],[\"则向下或向右走一步后\",{\"1\":{\"102\":1}}],[\"则从冲突位置向后线性遍历\",{\"1\":{\"172\":1}}],[\"则从地面爬到第3阶的最小代价为2\",{\"1\":{\"98\":1}}],[\"则从第一行到最后一行分别有n\",{\"1\":{\"90\":1}}],[\"则说明它已经被选择过\",{\"1\":{\"86\":1}}],[\"则现有代码的输出结果为\",{\"1\":{\"86\":1}}],[\"则第二轮应该跳过3和4\",{\"1\":{\"85\":1}}],[\"则第二轮应该跳过3\",{\"1\":{\"85\":1}}],[\"则跳过该选择\",{\"1\":{\"85\":1}}],[\"则n个元素共有n\",{\"1\":{\"82\":1}}],[\"则获得排列\",{\"1\":{\"81\":1}}],[\"则复制\",{\"1\":{\"75\":1}}],[\"则表示\",{\"1\":{\"75\":1}}],[\"则直接返回\",{\"1\":{\"104\":1,\"109\":1,\"195\":1}}],[\"则直接返回之\",{\"1\":{\"94\":1}}],[\"则直接返回这两个元素的索引\",{\"1\":{\"30\":1}}],[\"则直接跳过\",{\"1\":{\"86\":1}}],[\"则直接结束循环\",{\"1\":{\"85\":1}}],[\"则直接将其移到\",{\"1\":{\"73\":1}}],[\"则返回非负整数\",{\"1\":{\"310\":2}}],[\"则返回添加点的索引\",{\"1\":{\"172\":1}}],[\"则返回空字符串\",{\"1\":{\"170\":1,\"172\":1}}],[\"则返回对应\",{\"1\":{\"170\":1,\"172\":1}}],[\"则返回到数组头部\",{\"1\":{\"161\":1}}],[\"则返回价值\",{\"1\":{\"108\":1,\"109\":1}}],[\"则返回\",{\"1\":{\"64\":1,\"103\":1,\"104\":1,\"113\":2,\"174\":1,\"190\":2}}],[\"则返回它们的索引\",{\"1\":{\"29\":1}}],[\"则可根据下图所示的方法实现各种操作\",{\"1\":{\"219\":1}}],[\"则可表示有权图\",{\"1\":{\"216\":1}}],[\"则可以采用下图所示的哈希表来实现\",{\"1\":{\"166\":1}}],[\"则可以在\",{\"1\":{\"166\":1}}],[\"则可以根据数据概率分布设置每个桶的价格分界线\",{\"1\":{\"51\":1}}],[\"则可所有桶的排序任务分散到各个计算单元\",{\"1\":{\"62\":1}}],[\"则划分需要o\",{\"1\":{\"61\":1}}],[\"则对某一位执行计数排序使用o\",{\"1\":{\"56\":1}}],[\"则无须继续堆化\",{\"1\":{\"48\":1,\"212\":1}}],[\"则无法被其他程序同时使用了\",{\"1\":{\"15\":1}}],[\"则普通二分查找只能返回其中一个\",{\"1\":{\"24\":1}}],[\"则在信息传递时就会出现乱码那个时代的研究人员就在想\",{\"1\":{\"18\":1}}],[\"光日常使用的就有几千个\",{\"1\":{\"18\":1}}],[\"以验证timeout是一个输入输出型参数\",{\"1\":{\"439\":1}}],[\"以写的方式打开这个已经存在的命名管道文件\",{\"1\":{\"406\":1}}],[\"以写的方式打开命名管道文件\",{\"1\":{\"403\":1,\"406\":1}}],[\"以写方式打开\",{\"1\":{\"370\":1}}],[\"以读的方式打开file\",{\"1\":{\"406\":1}}],[\"以读的方式打开命名管道文件\",{\"1\":{\"403\":2,\"405\":1,\"406\":1}}],[\"以读方式打开\",{\"1\":{\"370\":1}}],[\"以追加方式写入文件\",{\"1\":{\"370\":1}}],[\"以提高代码的可移植性\",{\"1\":{\"330\":1}}],[\"以提升查询效率\",{\"1\":{\"63\":1}}],[\"以机器数10000001为例\",{\"1\":{\"327\":1}}],[\"以0x或0x开头表示\",{\"1\":{\"325\":1}}],[\"以0b或0b开头表示\",{\"1\":{\"325\":1}}],[\"以保持项目的组织结构清晰\",{\"1\":{\"320\":1}}],[\"以字节为单位\",{\"1\":{\"310\":1,\"314\":3}}],[\"以后使用string声明变量时\",{\"1\":{\"304\":1}}],[\"以后的每一次仍然先经过判断注意\",{\"1\":{\"298\":1}}],[\"以能够看懂其他开发者的代码中可能出现的\",{\"1\":{\"299\":1}}],[\"以控制变量和函数的作用范围和生存周期\",{\"1\":{\"289\":1}}],[\"以外定义的变量\",{\"1\":{\"288\":1}}],[\"以它的补码形式进行运算\",{\"1\":{\"280\":1}}],[\"以前的程序中都是采用这种方式间接访问\",{\"1\":{\"261\":1}}],[\"以为矩阵的形式初始化\",{\"1\":{\"246\":1}}],[\"以树的遍历为例\",{\"1\":{\"225\":1}}],[\"以避免重复访问顶点\",{\"1\":{\"225\":1}}],[\"以顶点\",{\"1\":{\"223\":1}}],[\"以填补空缺\",{\"1\":{\"219\":1}}],[\"以尽可能消除周期性模式\",{\"1\":{\"177\":1}}],[\"以确保哈希值在合适的范围内\",{\"1\":{\"177\":1}}],[\"以查找目标键值对\",{\"1\":{\"170\":1}}],[\"以表示键值对\",{\"1\":{\"167\":1}}],[\"以节省计算机内存\",{\"1\":{\"132\":1}}],[\"以便提高访问速度\",{\"1\":{\"334\":1}}],[\"以便表示超过9的值\",{\"1\":{\"325\":1}}],[\"以便在当前源文件中使用其中定义的函数\",{\"1\":{\"320\":1}}],[\"以便与变量名区分开来替换文本\",{\"1\":{\"318\":1}}],[\"以便与系统提供的标准类型标识符相区别\",{\"1\":{\"304\":1}}],[\"以便将内存返回给操作系统\",{\"1\":{\"314\":1}}],[\"以便将物品按照单位价值进行排序\",{\"1\":{\"120\":1}}],[\"以便访问键盘和屏幕\",{\"1\":{\"309\":1}}],[\"以便读取或修改它们\",{\"1\":{\"244\":1}}],[\"以便获取指定顶点的所有邻接顶点\",{\"1\":{\"223\":1,\"225\":1}}],[\"以便算法高效运行\",{\"1\":{\"132\":1}}],[\"以便之后使用\",{\"1\":{\"94\":1}}],[\"以期获得全局最优解\",{\"1\":{\"113\":1}}],[\"以爬楼梯问题为例\",{\"1\":{\"99\":1}}],[\"以dp\",{\"1\":{\"93\":1}}],[\"以达到更高的时间效率\",{\"1\":{\"79\":1}}],[\"以下三个文件会在程序执行时自动打开\",{\"1\":{\"309\":1}}],[\"以下3种用法等价\",{\"1\":{\"302\":1}}],[\"以下是邻接表的代码实现\",{\"1\":{\"219\":1}}],[\"以下是基于邻接矩阵表示图的实现代码\",{\"1\":{\"218\":1}}],[\"以下使用无向图进行举例\",{\"1\":{\"215\":1}}],[\"以下示例展示了一个包含\",{\"1\":{\"213\":1}}],[\"以下实现包含哈希表扩容方法\",{\"1\":{\"170\":1}}],[\"以下代码会报错\",{\"1\":{\"361\":1}}],[\"以下代码为c++11补丁\",{\"1\":{\"361\":1}}],[\"以下代码实现了一棵基于数组表示的二叉树\",{\"1\":{\"190\":1}}],[\"以下代码实现了一个包含懒删除的开放寻址\",{\"1\":{\"172\":1}}],[\"以下代码实现了一个简单哈希表\",{\"1\":{\"167\":1}}],[\"以下代码给出了链式地址哈希表的简单实现\",{\"1\":{\"170\":1}}],[\"以下列举了一些典型的贪心算法问题\",{\"1\":{\"117\":1}}],[\"以下框架代码中\",{\"1\":{\"77\":1}}],[\"以下两点值得注意\",{\"1\":{\"27\":1}}],[\"以恢复本次尝试之前的状态\",{\"1\":{\"75\":1}}],[\"以上介绍的简单哈希算法都比较\",{\"1\":{\"178\":1}}],[\"以上图数据为例\",{\"1\":{\"67\":1}}],[\"以上方法虽然可行\",{\"1\":{\"47\":1}}],[\"以及简化代码\",{\"1\":{\"219\":1}}],[\"以及之后的所有元素向后移动一位\",{\"1\":{\"141\":1}}],[\"以及操作数据的方法\",{\"1\":{\"133\":1}}],[\"以及它们之间的空间可以组成一个容器\",{\"1\":{\"122\":1}}],[\"以及每种剪枝操作是如何工作的\",{\"1\":{\"86\":1}}],[\"以及子树在\",{\"1\":{\"68\":1}}],[\"以及能够以相同方式递归地进行划分\",{\"1\":{\"59\":1}}],[\"以及一些控制字符\",{\"1\":{\"18\":1}}],[\"以学号数据为例\",{\"1\":{\"56\":1}}],[\"以根节点为起点\",{\"1\":{\"48\":1}}],[\"以\",{\"1\":{\"42\":1,\"43\":1,\"61\":1,\"201\":1,\"202\":1}}],[\"以此类推如果所有的表达式都不成立\",{\"1\":{\"297\":1}}],[\"以此类推\",{\"1\":{\"36\":1,\"38\":1,\"41\":1,\"174\":1,\"222\":1,\"224\":1}}],[\"以空间换时间\",{\"0\":{\"30\":1}}],[\"以时间换空间\",{\"0\":{\"29\":1}}],[\"以适应不同语言的需求\",{\"1\":{\"18\":1}}],[\"后置\",{\"1\":{\"361\":2}}],[\"后续通过std\",{\"1\":{\"379\":1}}],[\"后续调用getinstance函数获取已经创建好的单例对象时\",{\"1\":{\"354\":1}}],[\"后续所有多线程要访问这个单例对象\",{\"1\":{\"354\":1}}],[\"后续单词的首字母大写\",{\"1\":{\"258\":1}}],[\"后面代码中出现bool会替换成int\",{\"1\":{\"318\":1}}],[\"后面代码中出现了\",{\"1\":{\"318\":1}}],[\"后面写入的属性会覆盖前面的属性\",{\"1\":{\"303\":1}}],[\"后面如果引用了没有定义的标签\",{\"1\":{\"299\":1}}],[\"后面参数与\",{\"1\":{\"291\":2}}],[\"后面自动添加\",{\"1\":{\"245\":3}}],[\"后使用\",{\"1\":{\"250\":1,\"287\":1}}],[\"后两位相同时\",{\"1\":{\"168\":1}}],[\"后继节点\",{\"1\":{\"163\":1,\"219\":1}}],[\"后边元素更大\",{\"1\":{\"85\":1}}],[\"后序遍历\",{\"0\":{\"187\":1},\"1\":{\"46\":1,\"187\":1,\"190\":3,\"225\":1}}],[\"后来人们发现\",{\"1\":{\"18\":1}}],[\"后\",{\"1\":{\"18\":1,\"38\":1,\"81\":1,\"136\":1}}],[\"后代\",{\"1\":{\"14\":1,\"180\":1}}],[\"个数\",{\"1\":{\"348\":1}}],[\"个字节由于数组的元素在内存中连续存储的\",{\"1\":{\"262\":1}}],[\"个字节\",{\"1\":{\"262\":1,\"332\":1}}],[\"个字符\",{\"1\":{\"18\":1}}],[\"个字符定义不同\",{\"1\":{\"18\":1}}],[\"个字符统一为\",{\"1\":{\"18\":1}}],[\"个内存位置在64位系统中\",{\"1\":{\"261\":1}}],[\"个顶点\",{\"1\":{\"218\":1}}],[\"个顶点和\",{\"1\":{\"213\":1}}],[\"个圆盘借助\",{\"1\":{\"73\":3}}],[\"个\",{\"1\":{\"51\":1,\"244\":1,\"259\":4}}],[\"个桶中\",{\"1\":{\"51\":2}}],[\"个桶\",{\"1\":{\"50\":1,\"51\":2}}],[\"个元素的整型数组\",{\"1\":{\"264\":1}}],[\"个元素的数组\",{\"1\":{\"244\":1}}],[\"个元素\",{\"1\":{\"50\":2,\"218\":1}}],[\"个元素已排序\",{\"1\":{\"41\":2}}],[\"个元素已完成排序\",{\"1\":{\"41\":1}}],[\"个元素作为\",{\"1\":{\"41\":2}}],[\"个码点\",{\"1\":{\"18\":1}}],[\"个汉字\",{\"1\":{\"18\":2}}],[\"个不同的字符在世界范围内\",{\"1\":{\"18\":1}}],[\"个不同的字符\",{\"1\":{\"18\":1}}],[\"这行会报错\",{\"1\":{\"379\":1}}],[\"这多个基类由继承一个基类\",{\"1\":{\"373\":1}}],[\"这时这个右值可以被取地址\",{\"1\":{\"379\":1}}],[\"这时便对单例对象进行了释放\",{\"1\":{\"354\":1}}],[\"这时我们可以只保留必要的状态\",{\"1\":{\"96\":1}}],[\"这人名字有8位\",{\"1\":{\"344\":1}}],[\"这和函数有些类似对带参数的宏\",{\"1\":{\"319\":1}}],[\"这两个函数我们在前面的案例中已经大量使用\",{\"1\":{\"309\":1}}],[\"这两种方案的较大值\",{\"1\":{\"110\":1,\"111\":1}}],[\"这次放过你了\",{\"1\":{\"297\":1}}],[\"这一行\",{\"1\":{\"287\":1}}],[\"这就是函数的返回值\",{\"1\":{\"286\":1}}],[\"这使得code\",{\"1\":{\"270\":1}}],[\"这使得遍历树比遍历链表更加复杂\",{\"1\":{\"185\":1}}],[\"这允许寻址2^64个内存位置\",{\"1\":{\"261\":1}}],[\"这允许寻址2^32\",{\"1\":{\"261\":1}}],[\"这里的实现非常简单\",{\"1\":{\"405\":1}}],[\"这里的int传的值大小无关\",{\"1\":{\"361\":1}}],[\"这里我们无需更改客户端的代码\",{\"1\":{\"404\":1}}],[\"这里我们以客户端向服务端派发计算任务为例\",{\"1\":{\"404\":1}}],[\"这里我们以二维数组为例进行演示\",{\"1\":{\"246\":1}}],[\"这里再次持有互斥锁\",{\"1\":{\"379\":1}}],[\"这里可以执行一些不需要互斥锁的操作\",{\"1\":{\"379\":1}}],[\"这里进行一些线程安全的操作\",{\"1\":{\"379\":2}}],[\"这里需要注意的是\",{\"1\":{\"361\":1}}],[\"这里编译不通过\",{\"1\":{\"361\":1}}],[\"这里其实可以用我们后面学习的友元解决\",{\"1\":{\"361\":1}}],[\"这里会发现运算符重载成全局的就需要成员变量是共有的\",{\"1\":{\"361\":1}}],[\"这里d2调用的默认拷贝构造完成拷贝\",{\"1\":{\"361\":1}}],[\"这里用的别名\",{\"1\":{\"361\":1}}],[\"这里用的是别名\",{\"1\":{\"361\":1}}],[\"这里接收失败\",{\"1\":{\"344\":1}}],[\"这里一定要用字符数组并且给大小\",{\"1\":{\"344\":1}}],[\"这里不用检查扩容函数\",{\"1\":{\"344\":1}}],[\"这里不能使用到pi了\",{\"1\":{\"318\":1}}],[\"这里有分号会报错\",{\"1\":{\"317\":1}}],[\"这里定义的是一个指针变量\",{\"1\":{\"261\":1}}],[\"这里\",{\"1\":{\"251\":1,\"344\":1}}],[\"这里采用编程语言的内置排序函数\",{\"1\":{\"50\":1}}],[\"这将使得后续使用堆化进行修复变得困难\",{\"1\":{\"212\":1}}],[\"这可能会加剧哈希冲突\",{\"1\":{\"178\":1}}],[\"这进一步增加了扩容过程的计算开销\",{\"1\":{\"168\":1}}],[\"这显然是不对的\",{\"1\":{\"168\":1}}],[\"这会导致出队操作效率较低\",{\"1\":{\"161\":1}}],[\"这似乎有些反直觉\",{\"1\":{\"140\":1}}],[\"这些成员\",{\"1\":{\"361\":1}}],[\"这些成员不需要考虑\",{\"1\":{\"361\":1}}],[\"这些全局的数据在程序的整个生命周期内都存在\",{\"1\":{\"288\":1}}],[\"这些变量的内存会被自动释放函数每调用一次就创建一次局部数据\",{\"1\":{\"288\":1}}],[\"这些局部数据的内存分配和释放是自动管理的\",{\"1\":{\"288\":1}}],[\"这些编号被称为内存地址\",{\"1\":{\"261\":1}}],[\"这些连续位置发生哈希冲突的可能性越大\",{\"1\":{\"172\":1}}],[\"这些子问题和原问题具有相同的形式\",{\"1\":{\"136\":1}}],[\"这些字符集一般只定义了特定语言的字符\",{\"1\":{\"18\":1}}],[\"这些字符集的前\",{\"1\":{\"18\":1}}],[\"这道题还有更高效率的解法\",{\"1\":{\"123\":1}}],[\"这道题可以使用分治来求解\",{\"1\":{\"67\":1}}],[\"这引入了新的问题\",{\"1\":{\"86\":1}}],[\"这类问题的目标是在一个组合空间中找到满足某些条件的最优解\",{\"1\":{\"79\":1}}],[\"这类问题的目标是找到满足所有约束条件的解\",{\"1\":{\"79\":1}}],[\"这类问题的目标是找到满足特定条件的解决方案\",{\"1\":{\"79\":1}}],[\"这类算法需要跳跃式访问元素\",{\"1\":{\"44\":1}}],[\"这说明子问题是独立的\",{\"1\":{\"72\":1}}],[\"这是不严谨的\",{\"1\":{\"442\":1}}],[\"这是一种不好的代码风格\",{\"1\":{\"250\":1}}],[\"这是一个有趣的问题先抛出结论\",{\"1\":{\"177\":1}}],[\"这是一个o\",{\"1\":{\"145\":1}}],[\"这是一个巨大的飞跃\",{\"1\":{\"94\":1}}],[\"这是通过哈希函数\",{\"1\":{\"167\":1}}],[\"这是通过比较中间元素和目标元素来实现的\",{\"1\":{\"64\":1}}],[\"这是因为每次删除操作都会产生一个删除标记\",{\"1\":{\"172\":1}}],[\"这是因为删除元素会在数组内产生一个空桶\",{\"1\":{\"172\":1}}],[\"这是因为在移动长板j后\",{\"1\":{\"123\":1}}],[\"这是因为数组已排序\",{\"1\":{\"85\":1}}],[\"这是因为搜索过程是区分选择顺序的\",{\"1\":{\"85\":1}}],[\"这是典型的分治策略应用\",{\"1\":{\"63\":1}}],[\"这个作用域被称为派生类的作用域\",{\"1\":{\"373\":1}}],[\"这个获取是不需要加锁的\",{\"1\":{\"354\":1}}],[\"这个类仍可被继承\",{\"1\":{\"354\":1}}],[\"这个bug我改了几个小时\",{\"1\":{\"344\":1}}],[\"这个现象称为穿透\",{\"1\":{\"297\":1}}],[\"这个函数调用了几次拷贝构造函数\",{\"1\":{\"361\":1}}],[\"这个函数容易被错误使用文本文件读取判断结束\",{\"1\":{\"310\":1}}],[\"这个函数在同一个时间内只会输出一个单一的字符函数原型\",{\"1\":{\"309\":1}}],[\"这个函数在同一个时间内只会读取一个单一的字符函数原型\",{\"1\":{\"309\":1}}],[\"这个函数\",{\"1\":{\"271\":1}}],[\"这个数量相当大\",{\"1\":{\"261\":1}}],[\"这个操作被称为堆化\",{\"1\":{\"211\":1}}],[\"这个公式计算出的\",{\"1\":{\"161\":1}}],[\"这个过程不是线程安全的\",{\"1\":{\"354\":1}}],[\"这个过程一直持续到数组为空或找到目标元素为止\",{\"1\":{\"64\":1}}],[\"这个过程就像气泡从底部升到顶部一样\",{\"1\":{\"37\":1}}],[\"这个问题可以从操作数量和并行计算两方面来讨论\",{\"1\":{\"60\":1}}],[\"这几步的效率为什么比直接解决原问题的效率更高\",{\"1\":{\"60\":1}}],[\"这样调用partiallybound\",{\"1\":{\"379\":1}}],[\"这样一来\",{\"1\":{\"354\":1}}],[\"这样不会造成精度损失\",{\"1\":{\"337\":1}}],[\"这样不容易看出来\",{\"1\":{\"304\":1}}],[\"这样更加安全\",{\"1\":{\"313\":1}}],[\"这样更不容易出错\",{\"1\":{\"21\":1}}],[\"这样的函数就是递归函数\",{\"1\":{\"290\":1}}],[\"这样的数组就称为多维数组\",{\"1\":{\"246\":1}}],[\"这样可读性太差\",{\"1\":{\"283\":1}}],[\"这样可以进一步提升算法效率\",{\"1\":{\"82\":1}}],[\"这样做的最大好处是节省空间\",{\"1\":{\"303\":1}}],[\"这样做的原因是\",{\"1\":{\"219\":1}}],[\"这样做的好处是当每次查询或添加元素时\",{\"1\":{\"172\":1}}],[\"这样在遍历至\",{\"1\":{\"194\":1}}],[\"这样在插入数据时\",{\"1\":{\"142\":1}}],[\"这样处理后\",{\"1\":{\"190\":1}}],[\"这样才能确保哈希表是可靠的\",{\"1\":{\"176\":1}}],[\"这样就避免了后续无意义的加锁解锁操作\",{\"1\":{\"354\":1}}],[\"这样就无须自行处理数组扩容问题\",{\"1\":{\"157\":1}}],[\"这样就可以合理地设定价格区间\",{\"1\":{\"51\":1}}],[\"这样既能去除重复子集\",{\"1\":{\"86\":1}}],[\"这样三个圆盘就被顺利地从\",{\"1\":{\"72\":1}}],[\"这种版本的懒汉主要有如下两个缺点\",{\"1\":{\"354\":1}}],[\"这种写法更加简练\",{\"1\":{\"304\":1}}],[\"这种结构就需要有时是整数\",{\"1\":{\"303\":1}}],[\"这种类型称为结构体\",{\"1\":{\"302\":1}}],[\"这种情况叫隐藏\",{\"1\":{\"373\":1}}],[\"这种情况称为内存泄漏\",{\"1\":{\"314\":1}}],[\"这种情况\",{\"1\":{\"255\":1}}],[\"这种情况可能导致以下两种结果\",{\"1\":{\"26\":1}}],[\"这种多层次的结构允许我们以表格或矩阵的方式组织数据\",{\"1\":{\"246\":1}}],[\"这种\",{\"1\":{\"225\":1}}],[\"这种亲密度网络就可以用有权图来表示\",{\"1\":{\"214\":1}}],[\"这种周期性规律可以通过\",{\"1\":{\"161\":1}}],[\"这种节点插入方法被称为\",{\"1\":{\"156\":1}}],[\"这种计算方式未考虑临近网格边界的情况\",{\"1\":{\"103\":1}}],[\"这种问题可以使用树形结构来描述\",{\"1\":{\"101\":1}}],[\"这种空间优化技巧被称为\",{\"1\":{\"96\":1}}],[\"这种方法的优点在于能够找到所有可能的解决方案\",{\"1\":{\"78\":1}}],[\"这种方法本质上是创建一棵递归树\",{\"1\":{\"51\":1}}],[\"这与\",{\"1\":{\"44\":1,\"223\":1}}],[\"这意味着在二叉搜索树中进行中序遍历时\",{\"1\":{\"196\":1}}],[\"这意味着在某轮选择中\",{\"1\":{\"86\":1}}],[\"这意味着使用数组表示完全二叉树时\",{\"1\":{\"190\":1}}],[\"这意味着存在多种二叉树结构都符合该层序遍历序列\",{\"1\":{\"190\":1}}],[\"这意味着即使哈希表中有空桶\",{\"1\":{\"173\":1}}],[\"这意味着计算数组元素的内存地址非常容易\",{\"1\":{\"140\":1}}],[\"这意味着切分出的3比切分出2更优\",{\"1\":{\"127\":1}}],[\"这意味着我们无须关心如何处理相等的情况\",{\"1\":{\"27\":1}}],[\"这意味着我们可以使用\",{\"1\":{\"18\":1}}],[\"这意味着\",{\"1\":{\"18\":1,\"149\":1,\"175\":1}}],[\"这大大简化了硬件设计\",{\"1\":{\"17\":1}}],[\"陆续出现了一批适用于不同地区的\",{\"1\":{\"18\":1}}],[\"8366743500\",{\"1\":{\"337\":1}}],[\"8bit\",{\"1\":{\"330\":1}}],[\"8的立方方根\",{\"1\":{\"291\":1}}],[\"8的立方根\",{\"1\":{\"291\":1}}],[\"89\",{\"1\":{\"286\":1,\"291\":1}}],[\"800\",{\"1\":{\"314\":1}}],[\"8000\",{\"1\":{\"314\":1}}],[\"800000\",{\"1\":{\"288\":1}}],[\"80\",{\"1\":{\"278\":1,\"297\":1,\"303\":2}}],[\"8字节\",{\"1\":{\"261\":1,\"330\":1}}],[\"8编码\",{\"1\":{\"18\":1}}],[\"8\",{\"0\":{\"49\":1,\"50\":1,\"51\":1,\"87\":1,\"88\":1,\"89\":1,\"90\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"234\":1,\"267\":1,\"282\":1,\"292\":1},\"1\":{\"18\":11,\"190\":1,\"244\":2,\"246\":2,\"262\":1,\"263\":1,\"277\":1,\"286\":1,\"291\":1,\"299\":1,\"303\":1,\"330\":5,\"331\":2,\"335\":10,\"348\":1,\"361\":3,\"364\":1,\"379\":3}}],[\"8比特\",{\"1\":{\"16\":1}}],[\"的这个过程交给select函数\",{\"1\":{\"442\":1}}],[\"的线程将会被阻塞\",{\"1\":{\"379\":1}}],[\"的直接访问\",{\"1\":{\"373\":1}}],[\"的常量\",{\"1\":{\"348\":1}}],[\"的宽度\",{\"1\":{\"330\":1}}],[\"的十六进制整数\",{\"1\":{\"325\":2}}],[\"的空间\",{\"1\":{\"314\":1}}],[\"的指针\",{\"1\":{\"309\":1,\"310\":1}}],[\"的参数\",{\"1\":{\"309\":1}}],[\"的传输路径\",{\"1\":{\"308\":2}}],[\"的一种\",{\"1\":{\"308\":1}}],[\"的一条路径\",{\"1\":{\"214\":1}}],[\"的别名\",{\"1\":{\"304\":1,\"335\":1}}],[\"的定义形式相似\",{\"1\":{\"303\":1}}],[\"的概念\",{\"1\":{\"302\":1}}],[\"的名称可以自行设置\",{\"1\":{\"299\":1}}],[\"的语句处\",{\"1\":{\"299\":1}}],[\"的代码块\",{\"1\":{\"297\":1}}],[\"的使用\",{\"1\":{\"291\":2,\"379\":4}}],[\"的可见性和访问范围\",{\"1\":{\"288\":1}}],[\"的源文件\",{\"1\":{\"287\":1}}],[\"的默认返回值为0\",{\"1\":{\"287\":1}}],[\"的类型是\",{\"1\":{\"263\":2}}],[\"的类是\",{\"1\":{\"263\":1}}],[\"的放置位置\",{\"1\":{\"261\":1}}],[\"的地址\",{\"1\":{\"261\":2}}],[\"的缩写\",{\"1\":{\"251\":1}}],[\"的标准含义是格式化输出文本\",{\"1\":{\"251\":1}}],[\"的访问和遍历\",{\"1\":{\"245\":1}}],[\"的方式进行\",{\"1\":{\"308\":1}}],[\"的方式对这些数据进行统一管理\",{\"1\":{\"243\":1}}],[\"的方法\",{\"1\":{\"95\":2,\"164\":1}}],[\"的算法范式通常基于递归来实现\",{\"1\":{\"225\":1}}],[\"的算法思想\",{\"1\":{\"63\":1}}],[\"的思想异曲同工\",{\"1\":{\"223\":1}}],[\"的关系\",{\"1\":{\"221\":1}}],[\"的边\",{\"1\":{\"219\":1}}],[\"的列\",{\"1\":{\"218\":1}}],[\"的行\",{\"1\":{\"218\":1}}],[\"的顶点\",{\"1\":{\"218\":1}}],[\"的邻接顶点为顶点\",{\"1\":{\"214\":1}}],[\"的自由度更高\",{\"1\":{\"213\":1}}],[\"的父节点\",{\"1\":{\"211\":1}}],[\"的值的一部分\",{\"1\":{\"317\":1}}],[\"的值赋值给\",{\"1\":{\"250\":1,\"251\":1}}],[\"的值\",{\"1\":{\"250\":1,\"251\":1}}],[\"的值是最大\",{\"1\":{\"208\":1}}],[\"的值覆盖待删除节点的值\",{\"1\":{\"195\":1}}],[\"的平衡因子\",{\"1\":{\"205\":1}}],[\"的右子节点\",{\"1\":{\"202\":1}}],[\"的右子树中\",{\"1\":{\"193\":2,\"194\":1,\"195\":1}}],[\"的左子节点\",{\"1\":{\"201\":1}}],[\"的左子树中\",{\"1\":{\"193\":2,\"194\":1,\"195\":1}}],[\"的遍历顺序\",{\"1\":{\"196\":1}}],[\"的遍历方式\",{\"1\":{\"187\":1}}],[\"的下一个节点\",{\"1\":{\"195\":1}}],[\"的位置\",{\"1\":{\"194\":1}}],[\"的性质仍然满足\",{\"1\":{\"195\":1}}],[\"的性质\",{\"1\":{\"194\":1,\"195\":1,\"200\":1,\"223\":1}}],[\"的规则\",{\"1\":{\"186\":2}}],[\"的逐层遍历方式\",{\"1\":{\"186\":1}}],[\"的优势\",{\"1\":{\"184\":1}}],[\"的分治逻辑\",{\"1\":{\"180\":1}}],[\"的分支\",{\"1\":{\"81\":2}}],[\"的输出都相同\",{\"1\":{\"176\":1}}],[\"的哈希表数据结构\",{\"1\":{\"176\":1}}],[\"的设计上\",{\"1\":{\"175\":1}}],[\"的步数\",{\"1\":{\"173\":1}}],[\"的增加\",{\"1\":{\"172\":1}}],[\"的两个学生时\",{\"1\":{\"168\":1}}],[\"的情况\",{\"1\":{\"168\":1}}],[\"的情况下\",{\"1\":{\"80\":1}}],[\"的查询功能\",{\"1\":{\"166\":1}}],[\"的引用\",{\"1\":{\"153\":1}}],[\"的首个节点\",{\"1\":{\"151\":1}}],[\"的节点称为\",{\"1\":{\"200\":1}}],[\"的节点\",{\"1\":{\"150\":1,\"151\":1}}],[\"的操作方向与\",{\"1\":{\"212\":1}}],[\"的操作\",{\"1\":{\"145\":1}}],[\"的操作相同\",{\"1\":{\"24\":1}}],[\"的数量\",{\"1\":{\"199\":1}}],[\"的数量和分布位置\",{\"1\":{\"190\":1}}],[\"的数量减\",{\"1\":{\"56\":1}}],[\"的数据结构与算法\",{\"1\":{\"135\":1}}],[\"的个数\",{\"1\":{\"128\":1}}],[\"的物品\",{\"1\":{\"117\":1}}],[\"的最大价值\",{\"1\":{\"108\":1,\"109\":1}}],[\"的最小路径代价\",{\"1\":{\"103\":2,\"104\":1}}],[\"的最小路径和\",{\"1\":{\"102\":1}}],[\"的尺寸变大而急剧增多\",{\"1\":{\"103\":1}}],[\"的长度都为2n\",{\"1\":{\"90\":1}}],[\"的状态\",{\"1\":{\"89\":1}}],[\"的异同非常耗时\",{\"1\":{\"85\":1}}],[\"的棋盘上放置n个皇后\",{\"1\":{\"79\":1}}],[\"的主体框架提炼出来\",{\"1\":{\"77\":1}}],[\"的策略\",{\"1\":{\"75\":1}}],[\"的解是已知的\",{\"1\":{\"72\":1}}],[\"的解\",{\"1\":{\"72\":1}}],[\"的栈帧空间\",{\"1\":{\"69\":1}}],[\"的过程中建立的\",{\"1\":{\"69\":2}}],[\"的含义是\",{\"1\":{\"68\":1}}],[\"的划分结果如下图所示\",{\"1\":{\"69\":1}}],[\"的划分结果\",{\"1\":{\"67\":1}}],[\"的搜索算法通常是基于分治策略实现的\",{\"1\":{\"64\":1}}],[\"的桶数组\",{\"1\":{\"56\":1}}],[\"的第一维i直接删除\",{\"1\":{\"111\":1}}],[\"的第\",{\"1\":{\"56\":1}}],[\"的核心思想与计数排序一致\",{\"1\":{\"55\":1}}],[\"的前缀和\",{\"1\":{\"54\":1}}],[\"的各个索引天然有序\",{\"1\":{\"53\":1}}],[\"的出现次数\",{\"1\":{\"53\":2,\"54\":1,\"56\":1}}],[\"的对应区间\",{\"1\":{\"46\":1}}],[\"的对应区间为\",{\"1\":{\"46\":1}}],[\"的待合并区间为\",{\"1\":{\"46\":1}}],[\"的子数组开始合并\",{\"1\":{\"46\":1}}],[\"的时间复杂度下运行\",{\"1\":{\"44\":1}}],[\"的工作原理非常简单\",{\"1\":{\"36\":1}}],[\"的相对位置改变\",{\"1\":{\"33\":1}}],[\"的元素\",{\"1\":{\"27\":2,\"42\":1}}],[\"的元素在区间\",{\"1\":{\"24\":1}}],[\"的插入点\",{\"1\":{\"26\":1}}],[\"的索引\",{\"1\":{\"24\":1,\"26\":1,\"54\":1,\"172\":1}}],[\"的写法\",{\"1\":{\"21\":1}}],[\"的大小关系循环向下搜索\",{\"1\":{\"194\":1}}],[\"的大小关系\",{\"1\":{\"20\":1,\"196\":1}}],[\"的通用性最佳\",{\"1\":{\"18\":1}}],[\"的编码规则并不复杂\",{\"1\":{\"18\":1}}],[\"的编码方案中\",{\"1\":{\"18\":1}}],[\"的中文名称为\",{\"1\":{\"18\":1}}],[\"的基础上扩展得到的\",{\"1\":{\"18\":1}}],[\"的\",{\"1\":{\"18\":1,\"142\":1,\"208\":1,\"214\":1,\"223\":1}}],[\"的形式存储在计算机中的\",{\"1\":{\"17\":1}}],[\"ev\",{\"1\":{\"396\":4,\"397\":4}}],[\"event\",{\"1\":{\"396\":4,\"397\":4}}],[\"events\",{\"1\":{\"389\":2,\"390\":2,\"396\":1,\"397\":3}}],[\"epfd\",{\"1\":{\"395\":5,\"396\":3,\"397\":3}}],[\"epoll服务器调用的epoll\",{\"1\":{\"398\":1}}],[\"epoll服务器测试\",{\"0\":{\"398\":1}}],[\"epoll服务器代码\",{\"0\":{\"394\":1}}],[\"epollin\",{\"1\":{\"396\":1,\"397\":3}}],[\"epoll模型\",{\"1\":{\"395\":1,\"396\":1,\"397\":1}}],[\"epollserver\",{\"1\":{\"395\":2,\"396\":1,\"397\":1,\"398\":2}}],[\"epollserver类\",{\"0\":{\"395\":1}}],[\"epoll\",{\"1\":{\"395\":3,\"396\":7,\"397\":7,\"398\":1}}],[\"echo\",{\"1\":{\"390\":1,\"397\":1,\"440\":1}}],[\"eating\",{\"1\":{\"373\":2}}],[\"eat\",{\"1\":{\"373\":4}}],[\"eascii\",{\"1\":{\"18\":3}}],[\"ee\",{\"1\":{\"348\":4}}],[\"element\",{\"1\":{\"367\":3,\"379\":3}}],[\"elif的位置必须在\",{\"1\":{\"321\":1}}],[\"elif指定了第二重判断\",{\"1\":{\"321\":1}}],[\"elif命令\",{\"1\":{\"321\":1}}],[\"elif\",{\"1\":{\"321\":3}}],[\"else的部分\",{\"1\":{\"321\":1}}],[\"else的部分没有定义过的宏\",{\"1\":{\"321\":1}}],[\"else之前\",{\"1\":{\"321\":1}}],[\"else指令配合使用\",{\"1\":{\"321\":1}}],[\"else指令\",{\"1\":{\"321\":1}}],[\"else\",{\"1\":{\"20\":2,\"21\":2,\"23\":2,\"24\":2,\"30\":1,\"46\":1,\"64\":2,\"110\":1,\"120\":1,\"124\":1,\"160\":1,\"163\":3,\"170\":1,\"172\":2,\"193\":2,\"194\":2,\"195\":3,\"199\":1,\"205\":2,\"206\":2,\"207\":4,\"259\":1,\"263\":1,\"278\":1,\"292\":1,\"293\":5,\"294\":1,\"297\":12,\"310\":13,\"321\":8,\"344\":5,\"348\":1,\"351\":1,\"357\":1,\"361\":3,\"367\":2,\"370\":2,\"379\":1,\"390\":3,\"396\":2,\"397\":3,\"403\":2,\"404\":2,\"405\":2,\"406\":4,\"440\":3}}],[\"emplace\",{\"1\":{\"379\":4}}],[\"empty\",{\"1\":{\"160\":1,\"161\":1,\"163\":3,\"164\":3,\"212\":1}}],[\"embedded\",{\"1\":{\"320\":1}}],[\"eof参数说明\",{\"1\":{\"310\":5}}],[\"eof\",{\"1\":{\"309\":1,\"310\":9}}],[\"equal\",{\"1\":{\"294\":2}}],[\"errno\",{\"1\":{\"344\":3}}],[\"errnum\",{\"1\":{\"292\":1}}],[\"error通常用于表示运行时错误\",{\"1\":{\"382\":1}}],[\"errorcode\",{\"1\":{\"382\":2}}],[\"error异常\",{\"1\":{\"382\":1}}],[\"error\",{\"1\":{\"292\":2,\"310\":5,\"370\":2,\"382\":16,\"389\":1,\"390\":2,\"395\":1,\"396\":1,\"397\":2,\"403\":1,\"404\":1,\"405\":1,\"406\":2,\"436\":3,\"438\":1,\"439\":2,\"440\":2}}],[\"edge\",{\"1\":{\"181\":1,\"213\":1}}],[\"enter\",{\"1\":{\"309\":2,\"370\":2,\"382\":4,\"403\":1}}],[\"entered\",{\"1\":{\"309\":3}}],[\"entries\",{\"1\":{\"167\":9}}],[\"ensure\",{\"1\":{\"292\":1}}],[\"endl\",{\"1\":{\"348\":22,\"351\":6,\"357\":3,\"361\":26,\"364\":2,\"367\":13,\"370\":9,\"373\":8,\"376\":12,\"379\":42,\"382\":7,\"389\":3,\"390\":6,\"391\":1,\"395\":1,\"396\":3,\"397\":5,\"398\":1,\"436\":3,\"438\":3,\"439\":7,\"440\":6}}],[\"endif里面加载\",{\"1\":{\"321\":1}}],[\"endif正好相反\",{\"1\":{\"321\":1}}],[\"endif指令跟\",{\"1\":{\"321\":1}}],[\"endif指令用于判断某个宏是否定义过\",{\"1\":{\"321\":1}}],[\"endif指令用于预处理器的条件判断\",{\"1\":{\"321\":1}}],[\"endif可以用来实现条件加载\",{\"1\":{\"321\":1}}],[\"endif检查这个宏是否定义过\",{\"1\":{\"321\":1}}],[\"endif之间还可以加入\",{\"1\":{\"321\":1}}],[\"endif\",{\"1\":{\"321\":13,\"348\":2}}],[\"endseek\",{\"1\":{\"310\":1}}],[\"end\",{\"1\":{\"291\":3,\"310\":2,\"406\":1,\"438\":2}}],[\"ended\",{\"1\":{\"162\":1}}],[\"enumeration\",{\"1\":{\"301\":1}}],[\"enum\",{\"1\":{\"259\":1,\"301\":8,\"344\":1}}],[\"enqueue\",{\"1\":{\"223\":3}}],[\"enlarge\",{\"1\":{\"145\":3}}],[\"execlp\",{\"1\":{\"405\":1}}],[\"exe文件得到程序的运行结果说明\",{\"1\":{\"271\":1}}],[\"exception通常在异常处理中使用\",{\"1\":{\"382\":1}}],[\"exception用于充当未被捕获的异常的一个基类\",{\"1\":{\"382\":1}}],[\"exception\",{\"1\":{\"382\":12}}],[\"exception是所有异常类的基类\",{\"1\":{\"382\":1}}],[\"excel文件\",{\"1\":{\"308\":1}}],[\"excel\",{\"1\":{\"15\":1}}],[\"extra\",{\"1\":{\"321\":10}}],[\"extern\",{\"1\":{\"259\":1,\"289\":8,\"334\":2}}],[\"extendratio\",{\"1\":{\"170\":1,\"172\":1}}],[\"extend\",{\"1\":{\"145\":1,\"170\":2,\"172\":2}}],[\"exit\",{\"1\":{\"310\":2,\"344\":1,\"345\":1,\"391\":1,\"395\":1,\"398\":1,\"405\":1,\"436\":3,\"439\":1}}],[\"example\",{\"1\":{\"310\":2,\"370\":6}}],[\"explicit关键字\",{\"1\":{\"361\":1,\"379\":1}}],[\"explicit的使用\",{\"1\":{\"357\":1}}],[\"explicit\",{\"1\":{\"357\":2,\"379\":1}}],[\"expression\",{\"1\":{\"357\":1}}],[\"exprn\",{\"1\":{\"282\":1}}],[\"expr2\",{\"1\":{\"282\":1}}],[\"expr1\",{\"1\":{\"282\":1}}],[\"exp\",{\"1\":{\"56\":14}}],[\"e\",{\"1\":{\"33\":2,\"245\":2,\"325\":1,\"331\":7,\"332\":2,\"348\":4,\"379\":1,\"382\":11}}],[\"诞生了一种能够表示更多语言的\",{\"1\":{\"18\":1}}],[\"一瞬间这两个进程就相继运行结束了\",{\"1\":{\"406\":1}}],[\"一共4+3=7次\",{\"1\":{\"361\":1}}],[\"一共规定了128个字符的编码\",{\"1\":{\"332\":1}}],[\"一定要关闭文件\",{\"1\":{\"310\":1}}],[\"一定出现在层序遍历序列的末尾\",{\"1\":{\"190\":1}}],[\"一次性为\",{\"1\":{\"304\":1}}],[\"一样\",{\"1\":{\"304\":1}}],[\"一致\",{\"1\":{\"291\":2}}],[\"一元运算符\",{\"1\":{\"283\":1}}],[\"一目运算符\",{\"1\":{\"275\":1}}],[\"一系列的操作\",{\"1\":{\"267\":1}}],[\"一级指针指向\",{\"1\":{\"265\":1}}],[\"一级指针\",{\"1\":{\"265\":2}}],[\"一行定义一个指针\",{\"1\":{\"261\":1}}],[\"一般都用public\",{\"1\":{\"373\":1}}],[\"一般写0或1\",{\"1\":{\"361\":1}}],[\"一般不允许写在这里\",{\"1\":{\"317\":1}}],[\"一般不留空格\",{\"1\":{\"317\":1}}],[\"一般是基本数据类型\",{\"1\":{\"302\":1}}],[\"一般用\",{\"1\":{\"285\":2}}],[\"一般用小括号来保证优先级\",{\"1\":{\"283\":1}}],[\"一般格式\",{\"1\":{\"261\":1}}],[\"一般限制在63个字符内\",{\"1\":{\"257\":1}}],[\"一般情况下\",{\"1\":{\"114\":1}}],[\"一对多\",{\"1\":{\"221\":1}}],[\"一圈\",{\"1\":{\"187\":1}}],[\"一圈一圈向外扩展\",{\"1\":{\"186\":1}}],[\"一分为二\",{\"1\":{\"180\":1}}],[\"一部分研究人员努力提升哈希算法的性能\",{\"1\":{\"178\":1}}],[\"一列或一条斜线上的棋子\",{\"1\":{\"87\":1}}],[\"一种直接的思路是对结果列表进行去重\",{\"1\":{\"85\":1}}],[\"一种直接的解决方案是将所有字符存储为等长的编码\",{\"1\":{\"18\":1}}],[\"一旦得到了左子树和右子树\",{\"1\":{\"66\":1}}],[\"一旦出现就立即返回\",{\"1\":{\"39\":1}}],[\"一方面\",{\"1\":{\"18\":1,\"63\":1}}],[\"一些标点符号\",{\"1\":{\"18\":1}}],[\"一个存在的对象去初始化另一个要创建的对象\",{\"1\":{\"361\":1}}],[\"一个表达式中\",{\"1\":{\"361\":1}}],[\"一个符号\",{\"1\":{\"332\":1}}],[\"一个字母\",{\"1\":{\"332\":1}}],[\"一个字节的低\",{\"1\":{\"18\":1}}],[\"一个整数字面量默认是int类型\",{\"1\":{\"330\":1}}],[\"一个数在计算机的存储形式是二进制数\",{\"1\":{\"327\":1}}],[\"一个头文件也可以被多个源文件导入标准库头文件\",{\"1\":{\"320\":1}}],[\"一个函数在函数体内又调用了本身\",{\"1\":{\"290\":1}}],[\"一个函数并不从属于另一个函数\",{\"1\":{\"285\":1}}],[\"一个源文件可以导入多个头文件\",{\"1\":{\"320\":1}}],[\"一个源文件可以由若干个函数构成\",{\"1\":{\"285\":1}}],[\"一个源文件是一个编译单位\",{\"1\":{\"285\":1}}],[\"一个变量或一个常量就是一个表达式\",{\"1\":{\"275\":1}}],[\"一个指针包含一个变量的地址\",{\"1\":{\"265\":1}}],[\"一个用于访问行\",{\"1\":{\"246\":1}}],[\"一个顶点拥有的边数\",{\"1\":{\"214\":1}}],[\"一个子数组的元素比基准值小\",{\"1\":{\"63\":1}}],[\"一个问题是否适合使用分治解决\",{\"1\":{\"59\":1}}],[\"一个大而全的字符集\",{\"1\":{\"18\":1}}],[\"一个二进制位即为\",{\"1\":{\"16\":1}}],[\"934\",{\"1\":{\"338\":1}}],[\"98\",{\"1\":{\"332\":1}}],[\"982300e+02\",{\"1\":{\"331\":2}}],[\"9823e2f\",{\"1\":{\"331\":1}}],[\"9823e2\",{\"1\":{\"331\":1}}],[\"967\",{\"1\":{\"330\":2}}],[\"9及a\",{\"1\":{\"325\":1}}],[\"95\",{\"1\":{\"297\":1}}],[\"9223372036854775808\",{\"1\":{\"330\":2}}],[\"92\",{\"1\":{\"297\":1}}],[\"90\",{\"1\":{\"286\":1,\"297\":2,\"303\":1,\"335\":1}}],[\"90的结果\",{\"1\":{\"286\":2}}],[\"99\",{\"1\":{\"278\":3,\"281\":1}}],[\"9\",{\"0\":{\"52\":1,\"53\":1,\"54\":1,\"235\":1,\"268\":1,\"283\":1,\"293\":1},\"1\":{\"18\":2,\"67\":4,\"173\":1,\"190\":1,\"244\":2,\"246\":2,\"293\":1,\"299\":1,\"325\":2,\"331\":1,\"332\":1,\"338\":1,\"348\":1,\"361\":1,\"364\":1,\"379\":2}}],[\"~epollserver\",{\"1\":{\"395\":1}}],[\"~pollserver\",{\"1\":{\"388\":1}}],[\"~circle\",{\"1\":{\"376\":1}}],[\"~cgarbo\",{\"1\":{\"354\":1}}],[\"~derived\",{\"1\":{\"376\":1}}],[\"~dp\",{\"1\":{\"111\":1}}],[\"~myclass\",{\"1\":{\"364\":1}}],[\"~selectserver\",{\"1\":{\"437\":1}}],[\"~seqlist\",{\"1\":{\"361\":1}}],[\"~shape\",{\"1\":{\"376\":2}}],[\"~string\",{\"1\":{\"361\":2}}],[\"~255\",{\"1\":{\"332\":1}}],[\"~18\",{\"1\":{\"331\":1}}],[\"~base\",{\"1\":{\"376\":1}}],[\"~b\",{\"1\":{\"280\":1}}],[\"~b=11\",{\"1\":{\"280\":1}}],[\"~b=\",{\"1\":{\"280\":1}}],[\"~a\",{\"1\":{\"280\":1}}],[\"~a=\",{\"1\":{\"280\":2}}],[\"~\",{\"1\":{\"18\":1,\"330\":2,\"331\":1,\"332\":2}}],[\"0666\",{\"1\":{\"403\":2,\"404\":1,\"405\":1,\"406\":2}}],[\"01\",{\"1\":{\"331\":2}}],[\"01clang\",{\"1\":{\"320\":1}}],[\"0的补码\",{\"1\":{\"327\":1}}],[\"0的原码\",{\"1\":{\"327\":1}}],[\"0的反码\",{\"1\":{\"327\":2}}],[\"0表示正数\",{\"1\":{\"327\":1}}],[\"0x64\",{\"1\":{\"325\":2}}],[\"0x开头\",{\"1\":{\"325\":4}}],[\"0x\",{\"1\":{\"325\":2}}],[\"0x1f\",{\"1\":{\"325\":1}}],[\"0b10\",{\"1\":{\"325\":1}}],[\"0里面\",{\"1\":{\"321\":1}}],[\"0这种写法常用来当作注释使用\",{\"1\":{\"321\":1}}],[\"0前的元素个数\",{\"1\":{\"292\":1}}],[\"0f\",{\"1\":{\"291\":1,\"331\":2}}],[\"02\",{\"1\":{\"291\":1}}],[\"000\",{\"1\":{\"327\":1}}],[\"0001\",{\"1\":{\"327\":9}}],[\"000000e+12\",{\"1\":{\"331\":2}}],[\"00000053575ff838\",{\"1\":{\"314\":1}}],[\"000000\",{\"1\":{\"276\":2,\"288\":2,\"337\":1}}],[\"000000f47adff860\",{\"1\":{\"264\":1}}],[\"000000f47adff85c\",{\"1\":{\"264\":1}}],[\"000000f47adff858\",{\"1\":{\"264\":1}}],[\"000000f47adff854\",{\"1\":{\"264\":1}}],[\"000000f47adff850\",{\"1\":{\"264\":1}}],[\"0000009c22fff890\",{\"1\":{\"263\":1}}],[\"0000009c22fff894\",{\"1\":{\"263\":1}}],[\"0000009c22fff898\",{\"1\":{\"263\":1}}],[\"0000000cffbffdd0\",{\"1\":{\"265\":1}}],[\"0000000cffbffdd8\",{\"1\":{\"265\":2}}],[\"0000000cffbffde0\",{\"1\":{\"265\":2}}],[\"0000000cffbffdec\",{\"1\":{\"265\":2}}],[\"0000000cdb5ffe5c\",{\"1\":{\"263\":1}}],[\"0000000cdb5ffe64\",{\"1\":{\"263\":1}}],[\"0000000cdb5ffe60\",{\"1\":{\"263\":2}}],[\"0000000e1efffe0a\",{\"1\":{\"262\":2}}],[\"0000000e1efffe08\",{\"1\":{\"262\":2}}],[\"0000000e1efffe06\",{\"1\":{\"262\":2}}],[\"0000000e1efffe04\",{\"1\":{\"262\":2}}],[\"0000000e1efffe02\",{\"1\":{\"262\":2}}],[\"000000010000\",{\"1\":{\"240\":1}}],[\"0000\",{\"1\":{\"240\":2,\"327\":6}}],[\"00\",{\"1\":{\"291\":2,\"331\":1}}],[\"0为假\",{\"1\":{\"278\":1}}],[\"0z\",{\"1\":{\"277\":1}}],[\"0~9\",{\"1\":{\"56\":2}}],[\"0\",{\"0\":{\"107\":1},\"1\":{\"18\":1,\"20\":3,\"21\":3,\"23\":2,\"24\":2,\"27\":2,\"29\":3,\"30\":3,\"36\":3,\"38\":4,\"39\":4,\"41\":3,\"46\":3,\"48\":5,\"50\":14,\"53\":6,\"54\":5,\"56\":4,\"64\":2,\"69\":4,\"73\":1,\"75\":1,\"76\":1,\"77\":4,\"79\":2,\"81\":5,\"82\":5,\"85\":8,\"86\":4,\"90\":8,\"92\":6,\"94\":1,\"98\":1,\"99\":4,\"102\":2,\"103\":6,\"104\":6,\"105\":12,\"106\":7,\"107\":3,\"108\":5,\"109\":5,\"110\":3,\"111\":1,\"113\":4,\"118\":1,\"120\":5,\"124\":3,\"128\":1,\"139\":6,\"140\":1,\"143\":2,\"144\":1,\"145\":2,\"147\":1,\"150\":1,\"151\":1,\"156\":3,\"157\":3,\"160\":3,\"161\":3,\"163\":4,\"164\":4,\"167\":17,\"170\":8,\"172\":9,\"177\":8,\"180\":1,\"181\":1,\"182\":1,\"186\":3,\"190\":12,\"195\":3,\"198\":1,\"199\":3,\"205\":2,\"207\":1,\"210\":1,\"211\":1,\"212\":2,\"218\":16,\"219\":7,\"223\":4,\"225\":2,\"244\":13,\"245\":17,\"246\":16,\"250\":1,\"251\":1,\"252\":1,\"255\":2,\"262\":19,\"263\":9,\"264\":4,\"265\":1,\"266\":1,\"267\":1,\"276\":5,\"277\":4,\"278\":1,\"279\":1,\"280\":3,\"281\":1,\"286\":4,\"287\":4,\"288\":27,\"289\":2,\"290\":1,\"291\":8,\"292\":3,\"293\":1,\"294\":2,\"297\":8,\"298\":20,\"299\":7,\"302\":2,\"309\":3,\"310\":16,\"313\":1,\"314\":8,\"317\":1,\"318\":7,\"319\":4,\"321\":2,\"325\":6,\"330\":8,\"331\":4,\"332\":2,\"333\":1,\"335\":1,\"337\":2,\"338\":4,\"342\":1,\"344\":9,\"345\":2,\"348\":23,\"351\":2,\"357\":6,\"361\":23,\"364\":2,\"367\":8,\"370\":4,\"373\":2,\"376\":5,\"379\":31,\"382\":5,\"388\":1,\"389\":5,\"390\":9,\"391\":2,\"395\":3,\"396\":2,\"397\":7,\"398\":2,\"403\":21,\"404\":14,\"405\":12,\"406\":14,\"436\":5,\"437\":1,\"438\":4,\"439\":7,\"440\":7}}],[\"码累积到一个哈希值中\",{\"1\":{\"177\":1}}],[\"码累积到哈希值中\",{\"1\":{\"177\":1}}],[\"码进行相加\",{\"1\":{\"177\":1}}],[\"码顺序或自定义规则\",{\"1\":{\"32\":1}}],[\"码文本\",{\"1\":{\"18\":1}}],[\"码已经向我们证明\",{\"1\":{\"18\":1}}],[\"码点相等\",{\"1\":{\"18\":1}}],[\"码点同时出现在一个文本中时\",{\"1\":{\"18\":1}}],[\"码点\",{\"1\":{\"18\":2}}],[\"码仍然无法满足许多语言的字符数量要求\",{\"1\":{\"18\":1}}],[\"码\",{\"1\":{\"18\":2}}],[\"码仅能够表示英文\",{\"1\":{\"18\":1}}],[\"码包括英文字母的大小写\",{\"1\":{\"18\":1}}],[\"码是最早出现的字符集\",{\"1\":{\"18\":1}}],[\"位无符号整数\",{\"1\":{\"330\":4}}],[\"位有符号整数\",{\"1\":{\"330\":4}}],[\"位数\",{\"1\":{\"326\":2}}],[\"位运算符\",{\"0\":{\"280\":1}}],[\"位操作符关注的是二进制c语言中\",{\"1\":{\"278\":1}}],[\"位于标准库的stdio\",{\"1\":{\"310\":4}}],[\"位于头文件\",{\"1\":{\"252\":1}}],[\"位于二叉树顶层的节点\",{\"1\":{\"181\":1}}],[\"位段数\",{\"1\":{\"305\":1}}],[\"位段是一种以位为单位定义结构体或联合体成员变量所占的空间位段结构\",{\"1\":{\"305\":1}}],[\"位段概念\",{\"1\":{\"305\":1}}],[\"位段\",{\"0\":{\"233\":1,\"305\":1}}],[\"位执行计数排序\",{\"1\":{\"56\":1}}],[\"位排序\",{\"1\":{\"56\":1}}],[\"位设置为\",{\"1\":{\"18\":1}}],[\"位基础上扩展到\",{\"1\":{\"18\":1}}],[\"位\",{\"1\":{\"18\":2,\"56\":2,\"330\":1}}],[\"位二进制数\",{\"1\":{\"18\":1}}],[\"7>\",{\"1\":{\"367\":1}}],[\"7次\",{\"1\":{\"361\":1}}],[\"7e+308\",{\"1\":{\"331\":1}}],[\"767\",{\"1\":{\"330\":2}}],[\"768\",{\"1\":{\"330\":2}}],[\"7列\",{\"1\":{\"298\":1}}],[\"73\",{\"1\":{\"286\":1}}],[\"70\",{\"1\":{\"244\":1,\"278\":1}}],[\"75\",{\"1\":{\"170\":1}}],[\"75时\",{\"1\":{\"168\":1,\"170\":1}}],[\"7\",{\"0\":{\"47\":1,\"48\":1,\"70\":1,\"71\":1,\"72\":1,\"73\":1,\"84\":1,\"85\":1,\"86\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"145\":1,\"233\":1,\"266\":1,\"281\":1,\"291\":1},\"1\":{\"18\":4,\"67\":4,\"74\":1,\"75\":1,\"76\":1,\"77\":1,\"190\":1,\"213\":1,\"244\":4,\"246\":2,\"277\":1,\"279\":2,\"294\":1,\"299\":1,\"310\":1,\"331\":1,\"348\":3,\"357\":1,\"361\":1,\"364\":1,\"367\":2,\"379\":5}}],[\"它需要手动锁定和释放互斥锁\",{\"1\":{\"379\":1}}],[\"它允许在已分配的内存块中构造对象\",{\"1\":{\"364\":1}}],[\"它允许程序控制流程在代码中跳转到带有标签\",{\"1\":{\"299\":1}}],[\"它用来判断\",{\"1\":{\"321\":1}}],[\"它用于指向字符或字符串\",{\"1\":{\"263\":1}}],[\"它从文件系统的盘符\",{\"1\":{\"320\":1}}],[\"它没有机会参与编译\",{\"1\":{\"319\":1}}],[\"它可以是字面量\",{\"1\":{\"318\":1}}],[\"它可以指向任何类型的数据\",{\"1\":{\"313\":1}}],[\"它只有内存块的地址信息\",{\"1\":{\"313\":1}}],[\"它返回\",{\"1\":{\"310\":1}}],[\"它返回一个空指针\",{\"1\":{\"310\":1}}],[\"它返回指向\",{\"1\":{\"310\":1}}],[\"它返回所读取字符的ascii码值\",{\"1\":{\"310\":1}}],[\"它返回特殊值\",{\"1\":{\"310\":3}}],[\"它返回特殊值eof\",{\"1\":{\"310\":1}}],[\"它接受一个字符串作为参数\",{\"1\":{\"309\":1}}],[\"它既可以保存一张图片\",{\"1\":{\"308\":1}}],[\"它占4个字节\",{\"1\":{\"303\":1}}],[\"它由3个成员组成\",{\"1\":{\"303\":1}}],[\"它内部可以包含各种属性\",{\"1\":{\"303\":1}}],[\"它提供了一种方便的方式来处理结构体数据\",{\"1\":{\"302\":1}}],[\"它通常是一个整数类型\",{\"1\":{\"291\":1}}],[\"它通过建立键\",{\"1\":{\"166\":1}}],[\"它通过遍历数据结构实现\",{\"1\":{\"64\":1}}],[\"它通过设置一些具有大小顺序的桶\",{\"1\":{\"49\":1}}],[\"它决定了在程序的哪些部分可以引用或访问该标识符作用域可以分为全局作用域\",{\"1\":{\"288\":1}}],[\"它具有智能编辑器\",{\"1\":{\"270\":1}}],[\"它具有以下特性\",{\"1\":{\"131\":1}}],[\"它支持c\",{\"1\":{\"270\":1}}],[\"它包括了整个软件生命周期中所需要的大部分工具\",{\"1\":{\"270\":1}}],[\"它包括以下两个维度\",{\"1\":{\"135\":1}}],[\"它指向一个数组\",{\"1\":{\"263\":1}}],[\"它能够在不影响二叉树的中序遍历序列的前提下\",{\"1\":{\"200\":1}}],[\"它体现了一种\",{\"1\":{\"186\":1,\"187\":1}}],[\"它不直接从哈希表中移除元素\",{\"1\":{\"172\":1}}],[\"它不受其他子问题的影响\",{\"1\":{\"64\":1}}],[\"它相比数组更加耗费内存空间\",{\"1\":{\"170\":1}}],[\"它主要包含两个阶段\",{\"1\":{\"136\":1}}],[\"它与复杂度分析息息相关\",{\"1\":{\"136\":1}}],[\"它是一种轻量级但功能强大的集成开发环境\",{\"1\":{\"270\":1}}],[\"它是一种解决给定源顶点到其余各顶点的最短路径问题的贪心算法\",{\"1\":{\"117\":1}}],[\"它是一种可变长度的编码\",{\"1\":{\"18\":1}}],[\"它更适合用动态规划解决\",{\"1\":{\"114\":1}}],[\"它会返回\",{\"1\":{\"309\":1}}],[\"它会自动指向数组的首元素\",{\"1\":{\"263\":1}}],[\"它会发展出状态i+1和状态i+2\",{\"1\":{\"99\":1}}],[\"它会撤销上一步的选择\",{\"1\":{\"75\":1}}],[\"它起到了与记忆化搜索中数组\",{\"1\":{\"95\":1}}],[\"它和标准回溯代码都属于深度优先搜索\",{\"1\":{\"93\":1}}],[\"它将一个问题分解为一系列更小的子问题\",{\"1\":{\"92\":1}}],[\"它将大矩阵乘法分解为多个小矩阵的乘法和加法\",{\"1\":{\"63\":1}}],[\"它将大整数乘法分解为几个较小的整数的乘法和加法\",{\"1\":{\"63\":1}}],[\"它避免了同一行出现多个皇后的所有搜索分支\",{\"1\":{\"88\":1}}],[\"它记录的是在本轮遍历\",{\"1\":{\"83\":1}}],[\"它记录的是当前状态中包含哪些元素\",{\"1\":{\"83\":1}}],[\"它尝试所有可能的解决方案直到找到满足条件的解\",{\"1\":{\"78\":1}}],[\"它的信息如下\",{\"1\":{\"344\":1}}],[\"它的绝对值对应的二进制数\",{\"1\":{\"327\":1}}],[\"它的反码+1\",{\"1\":{\"327\":1}}],[\"它的原码符号位不变\",{\"1\":{\"327\":1}}],[\"它的未来发展只与当前状态有关\",{\"1\":{\"99\":1}}],[\"它的定义是在给定一个集合\",{\"1\":{\"80\":1}}],[\"它的核心思想是从一个初始状态出发\",{\"1\":{\"74\":1}}],[\"它的作用是将柱\",{\"1\":{\"73\":1}}],[\"它的工作原理与手动整理一副牌的过程非常相似\",{\"1\":{\"40\":1}}],[\"它利用特有的数据组织形式或先验信息\",{\"1\":{\"64\":1}}],[\"它利用数据的有序性\",{\"1\":{\"20\":1}}],[\"它们都是输入输出型参数\",{\"1\":{\"439\":1}}],[\"它们在程序启动时被分配\",{\"1\":{\"288\":1}}],[\"它们将自动初始化为零值对于全局数组\",{\"1\":{\"288\":1}}],[\"它们展示了三种遍历优先级\",{\"1\":{\"225\":1}}],[\"它们分别解决的两种失衡情况也是对称的\",{\"1\":{\"202\":1}}],[\"它们可以在定义的时候初始化也可以定义后赋值修改\",{\"1\":{\"361\":1}}],[\"它们可以将任意长度的输入数据映射到恒定长度的哈希值\",{\"1\":{\"178\":1}}],[\"它们可以从\",{\"1\":{\"13\":1}}],[\"它们只能保证哈希表可以在发生冲突时正常工作\",{\"1\":{\"175\":1}}],[\"它们被依次存储在该桶以及之下的桶中\",{\"1\":{\"172\":1}}],[\"它们之间没有空间再存放任何数据\",{\"1\":{\"141\":1}}],[\"它们之间没有交集\",{\"1\":{\"66\":1}}],[\"它们之间存在一些相似之处\",{\"1\":{\"113\":1}}],[\"它们对状态i的未来没有影响\",{\"1\":{\"99\":1}}],[\"它们不仅包含重叠子问题\",{\"1\":{\"97\":1}}],[\"它们从上到下按照从小到大的顺序排列\",{\"1\":{\"70\":1}}],[\"它们的头文件是\",{\"1\":{\"351\":1}}],[\"它们的生命周期受限于其定义的函数或块级作用域\",{\"1\":{\"288\":1}}],[\"它们的初始值是机器垃圾值\",{\"1\":{\"288\":1}}],[\"它们的元素将自动初始化为零值\",{\"1\":{\"288\":1}}],[\"它们的内存地址无须连续\",{\"1\":{\"146\":1}}],[\"它们的查找\",{\"1\":{\"63\":1}}],[\"它们的时间复杂度可以达到线性阶\",{\"1\":{\"49\":1}}],[\"它们通过比较元素间的大小来实现排序\",{\"1\":{\"49\":1}}],[\"它致力于将全球范围内的字符纳入统一的字符集之中\",{\"1\":{\"18\":1}}],[\"它共收录了\",{\"1\":{\"18\":1}}],[\"它在分配内存块时会自动将内存中的每个字节都设置为零\",{\"1\":{\"314\":1}}],[\"它在c语言中仅作为字符串的结束标志\",{\"1\":{\"245\":1}}],[\"它在单位重量下的价值为val\",{\"1\":{\"118\":1}}],[\"它在\",{\"1\":{\"18\":1,\"146\":1}}],[\"它使用\",{\"1\":{\"18\":1}}],[\"美国标准信息交换代码\",{\"1\":{\"18\":1}}],[\"fflush\",{\"1\":{\"403\":1}}],[\"fdin\",{\"1\":{\"406\":4}}],[\"fdout\",{\"1\":{\"406\":4}}],[\"fd命令\",{\"1\":{\"398\":1}}],[\"fds数组已满\",{\"1\":{\"389\":1,\"390\":1}}],[\"fds\",{\"1\":{\"389\":13,\"390\":19}}],[\"fd\",{\"1\":{\"389\":10,\"390\":15,\"396\":1,\"397\":9,\"403\":11,\"404\":4,\"405\":4,\"406\":8,\"438\":19,\"439\":2,\"440\":26}}],[\"fetch\",{\"1\":{\"379\":3}}],[\"feof\",{\"1\":{\"310\":1}}],[\"f的值为\",{\"1\":{\"348\":2}}],[\"f1\",{\"1\":{\"337\":3,\"361\":1}}],[\"f含义不同\",{\"1\":{\"331\":1}}],[\"f意思相同\",{\"1\":{\"331\":1}}],[\"f不区分大小写\",{\"1\":{\"325\":1}}],[\"ftell\",{\"1\":{\"310\":3}}],[\"fstream常用读写文件\",{\"1\":{\"370\":1}}],[\"fstream\",{\"1\":{\"370\":5}}],[\"fseek\",{\"1\":{\"310\":3}}],[\"fscanf\",{\"1\":{\"310\":2}}],[\"fwrite\",{\"1\":{\"310\":3,\"344\":1}}],[\"fgets判断返回值是否为null\",{\"1\":{\"310\":1}}],[\"fgets\",{\"1\":{\"310\":3}}],[\"fgetc判断是否为eof\",{\"1\":{\"310\":1}}],[\"fgetc\",{\"1\":{\"310\":4}}],[\"fputs\",{\"1\":{\"310\":12}}],[\"fputc\",{\"1\":{\"310\":9}}],[\"fprintf\",{\"1\":{\"218\":4,\"310\":10}}],[\"fclose\",{\"1\":{\"310\":12,\"344\":2}}],[\"fn02\",{\"1\":{\"289\":3}}],[\"fn01\",{\"1\":{\"289\":5}}],[\"fn\",{\"1\":{\"289\":6,\"291\":5}}],[\"fnext\",{\"1\":{\"163\":4}}],[\"foo\",{\"1\":{\"320\":2,\"321\":6,\"357\":2,\"361\":2}}],[\"foot\",{\"1\":{\"257\":1}}],[\"football\",{\"1\":{\"257\":2}}],[\"fopen\",{\"1\":{\"310\":15,\"344\":1}}],[\"found\",{\"1\":{\"292\":2,\"524\":1}}],[\"fork\",{\"1\":{\"405\":1}}],[\"forward<t>\",{\"1\":{\"379\":1}}],[\"forward<t>将参数以原始的左值或右值引用进行转发\",{\"1\":{\"379\":1}}],[\"forward\",{\"1\":{\"379\":4}}],[\"format是一个格式化字符串\",{\"1\":{\"310\":2}}],[\"format\",{\"1\":{\"310\":2}}],[\"formattedtext\",{\"1\":{\"310\":2}}],[\"formatted\",{\"1\":{\"251\":1}}],[\"for循环\",{\"1\":{\"298\":1}}],[\"for\",{\"1\":{\"18\":1,\"29\":2,\"30\":1,\"36\":2,\"38\":2,\"39\":2,\"41\":1,\"46\":1,\"48\":2,\"50\":6,\"53\":4,\"54\":4,\"56\":6,\"69\":1,\"75\":1,\"76\":1,\"77\":3,\"81\":3,\"82\":3,\"83\":1,\"85\":4,\"86\":2,\"90\":4,\"92\":1,\"94\":1,\"95\":1,\"96\":1,\"98\":2,\"99\":3,\"105\":6,\"106\":3,\"110\":4,\"111\":2,\"120\":2,\"136\":1,\"141\":1,\"142\":1,\"143\":1,\"144\":1,\"145\":2,\"150\":1,\"160\":1,\"163\":2,\"167\":8,\"170\":5,\"172\":3,\"177\":4,\"190\":1,\"218\":9,\"219\":7,\"223\":1,\"225\":1,\"244\":1,\"245\":1,\"246\":4,\"259\":1,\"262\":2,\"263\":2,\"264\":1,\"287\":1,\"288\":3,\"291\":2,\"292\":1,\"298\":5,\"299\":2,\"314\":3,\"344\":6,\"348\":6,\"370\":2,\"379\":10,\"389\":3,\"390\":2,\"396\":1,\"397\":1,\"438\":4,\"440\":2}}],[\"fun04\",{\"1\":{\"286\":2}}],[\"fun03\",{\"1\":{\"286\":2}}],[\"fun02\",{\"1\":{\"286\":2}}],[\"fun01\",{\"1\":{\"286\":4}}],[\"funciton\",{\"1\":{\"373\":1}}],[\"func3调用2次拷贝构造\",{\"1\":{\"361\":1}}],[\"func3\",{\"1\":{\"361\":1}}],[\"func2调用3次拷贝构造\",{\"1\":{\"361\":1}}],[\"func2\",{\"1\":{\"348\":2,\"361\":2}}],[\"func1调用4次拷贝构造\",{\"1\":{\"361\":1}}],[\"func1\",{\"1\":{\"348\":2,\"361\":1}}],[\"func\",{\"1\":{\"264\":4,\"286\":12,\"288\":8,\"318\":1,\"348\":6,\"361\":1,\"379\":2}}],[\"function包装函数对象\",{\"1\":{\"379\":1}}],[\"function包装普通函数\",{\"1\":{\"379\":1}}],[\"function<int\",{\"1\":{\"379\":3}}],[\"function<std\",{\"1\":{\"367\":1}}],[\"function<char>\",{\"1\":{\"367\":1}}],[\"functions\",{\"1\":{\"344\":1}}],[\"function\",{\"1\":{\"167\":1,\"282\":1,\"289\":2,\"345\":1,\"367\":3,\"373\":2,\"379\":15}}],[\"full\",{\"1\":{\"211\":1,\"390\":1,\"440\":1}}],[\"f3\",{\"1\":{\"174\":1}}],[\"f2\",{\"1\":{\"174\":1,\"361\":1}}],[\"firestfunction\",{\"1\":{\"379\":3}}],[\"first\",{\"1\":{\"186\":2,\"187\":2,\"379\":2}}],[\"firsttombstone\",{\"1\":{\"172\":8}}],[\"fish\",{\"1\":{\"373\":6}}],[\"fixedarray<5>\",{\"1\":{\"367\":1}}],[\"fixedarray\",{\"1\":{\"367\":1}}],[\"finished\",{\"1\":{\"379\":14}}],[\"final\",{\"1\":{\"354\":1}}],[\"findnode\",{\"1\":{\"219\":7,\"223\":1,\"225\":1}}],[\"findbucket\",{\"1\":{\"172\":4}}],[\"find\",{\"1\":{\"30\":4,\"144\":1,\"151\":1}}],[\"filename是一个以字符串形式指定的文件名\",{\"1\":{\"310\":1}}],[\"filename\",{\"1\":{\"310\":1,\"344\":1,\"345\":1,\"348\":1,\"351\":1,\"354\":1,\"357\":1,\"361\":1,\"364\":1,\"367\":1,\"370\":1,\"373\":1,\"376\":1,\"379\":1,\"382\":1}}],[\"file\",{\"1\":{\"310\":93,\"344\":2,\"370\":5,\"403\":6,\"404\":2,\"405\":2,\"406\":7}}],[\"file01\",{\"1\":{\"289\":3}}],[\"file02\",{\"1\":{\"289\":4}}],[\"fiveints\",{\"1\":{\"304\":3}}],[\"family\",{\"1\":{\"436\":1}}],[\"failure\",{\"1\":{\"310\":2}}],[\"fabs\",{\"1\":{\"291\":2}}],[\"factor\",{\"1\":{\"168\":1,\"199\":1,\"321\":2,\"379\":3}}],[\"false代表0\",{\"1\":{\"333\":1}}],[\"false\",{\"1\":{\"39\":1,\"81\":2,\"82\":3,\"90\":4,\"163\":2,\"262\":1,\"277\":1,\"318\":3,\"333\":1,\"361\":1,\"379\":5,\"389\":1,\"390\":1,\"440\":1}}],[\"from\",{\"1\":{\"370\":2}}],[\"front++\",{\"1\":{\"186\":1}}],[\"front\",{\"1\":{\"160\":1,\"161\":7,\"163\":3,\"164\":2,\"186\":3,\"223\":1}}],[\"fread\",{\"1\":{\"310\":3,\"344\":1}}],[\"free函数\",{\"1\":{\"314\":1}}],[\"free\",{\"1\":{\"46\":1,\"50\":2,\"53\":1,\"54\":1,\"69\":1,\"81\":2,\"82\":2,\"92\":1,\"94\":1,\"95\":1,\"98\":1,\"99\":2,\"105\":1,\"106\":1,\"110\":1,\"111\":1,\"120\":1,\"149\":1,\"156\":3,\"157\":2,\"160\":4,\"161\":2,\"163\":4,\"164\":2,\"167\":6,\"170\":9,\"172\":11,\"186\":1,\"190\":2,\"195\":1,\"218\":1,\"219\":8,\"223\":1,\"314\":7,\"344\":1,\"361\":2}}],[\"friend\",{\"1\":{\"361\":2}}],[\"fri\",{\"1\":{\"301\":3}}],[\"friday\",{\"1\":{\"301\":1}}],[\"fractionalknapsack\",{\"1\":{\"120\":1}}],[\"f\",{\"1\":{\"64\":4,\"72\":2,\"73\":4,\"264\":1,\"276\":2,\"286\":1,\"288\":5,\"289\":1,\"291\":14,\"293\":1,\"302\":2,\"313\":1,\"318\":4,\"325\":2,\"331\":8,\"337\":3,\"348\":3,\"361\":5,\"379\":2}}],[\"floor\",{\"1\":{\"291\":2}}],[\"float类型会转换成double来处理\",{\"1\":{\"331\":1}}],[\"float\",{\"1\":{\"16\":1,\"50\":7,\"120\":3,\"259\":1,\"261\":2,\"286\":1,\"291\":1,\"303\":4,\"304\":2,\"310\":1,\"331\":6,\"335\":4,\"337\":1,\"348\":1,\"357\":2,\"379\":2}}],[\"flag确定相差的天数\",{\"1\":{\"361\":1}}],[\"flag\",{\"1\":{\"37\":1,\"39\":4,\"361\":3,\"404\":8}}],[\"svr\",{\"1\":{\"391\":3,\"398\":3,\"439\":3}}],[\"ssize\",{\"1\":{\"390\":1,\"397\":1,\"403\":2,\"404\":1,\"405\":1,\"406\":2,\"440\":1}}],[\"sscanf\",{\"1\":{\"291\":4}}],[\"s2\",{\"1\":{\"361\":4}}],[\"sleep\",{\"1\":{\"344\":1,\"379\":1}}],[\"s1和s2的\",{\"1\":{\"361\":1}}],[\"s1\",{\"1\":{\"337\":3,\"361\":5}}],[\"square\",{\"1\":{\"376\":7}}],[\"sq=\",{\"1\":{\"319\":1}}],[\"sq\",{\"1\":{\"319\":11}}],[\"sqrt\",{\"1\":{\"291\":1}}],[\"specializecontainer\",{\"1\":{\"367\":2}}],[\"speed\",{\"1\":{\"304\":1}}],[\"space\",{\"1\":{\"332\":1}}],[\"spring\",{\"1\":{\"301\":1}}],[\"sprintf\",{\"1\":{\"291\":5}}],[\"saturday\",{\"1\":{\"301\":1}}],[\"sat\",{\"1\":{\"291\":1,\"301\":3}}],[\"score3=89\",{\"1\":{\"291\":1}}],[\"score3=\",{\"1\":{\"291\":1}}],[\"score3\",{\"1\":{\"291\":3}}],[\"score2=65\",{\"1\":{\"291\":1}}],[\"score2=\",{\"1\":{\"291\":1}}],[\"score2\",{\"1\":{\"291\":3}}],[\"score1=44\",{\"1\":{\"291\":1}}],[\"score1=\",{\"1\":{\"291\":1}}],[\"score1\",{\"1\":{\"291\":3}}],[\"score\",{\"1\":{\"278\":4,\"291\":2,\"297\":6}}],[\"scanf和printf函数\",{\"1\":{\"309\":1}}],[\"scanf也可以通过不同格式占位符为不同类型的变量获取值\",{\"1\":{\"252\":1}}],[\"scanf中\",{\"1\":{\"252\":1}}],[\"scanf\",{\"1\":{\"252\":2,\"291\":2,\"297\":6,\"298\":2,\"309\":2,\"314\":1,\"318\":1,\"319\":2,\"344\":12,\"345\":1}}],[\"scanf主要用于从标准输入\",{\"1\":{\"252\":1}}],[\"switch和if\",{\"1\":{\"297\":1}}],[\"switch后面表达式的值必须是一个整型\",{\"1\":{\"297\":1}}],[\"switch\",{\"1\":{\"259\":1,\"297\":6,\"345\":1,\"389\":1,\"404\":2,\"438\":2,\"439\":2}}],[\"swap赋予一个线程函数\",{\"1\":{\"379\":1}}],[\"swap\",{\"1\":{\"42\":3,\"43\":2,\"50\":1,\"211\":1,\"212\":2,\"348\":1,\"379\":2}}],[\"successfully\",{\"1\":{\"310\":1,\"370\":2}}],[\"sunday\",{\"1\":{\"301\":1}}],[\"sun\",{\"1\":{\"257\":1,\"301\":3}}],[\"sum是左值\",{\"1\":{\"379\":1}}],[\"sum=216\",{\"1\":{\"318\":1}}],[\"sum=\",{\"1\":{\"318\":2}}],[\"summer\",{\"1\":{\"301\":1}}],[\"sum\",{\"1\":{\"246\":3,\"257\":1,\"258\":1,\"264\":3,\"286\":2,\"291\":4,\"318\":5,\"370\":2,\"379\":2}}],[\"subtree\",{\"1\":{\"180\":2}}],[\"subsetsumii\",{\"1\":{\"86\":1}}],[\"subsetsumi\",{\"1\":{\"85\":1}}],[\"subsetsuminaive\",{\"1\":{\"85\":1}}],[\"showinfo方法声明放\",{\"1\":{\"361\":1}}],[\"showinfo\",{\"1\":{\"361\":1}}],[\"short\",{\"1\":{\"16\":1,\"259\":1,\"262\":2,\"297\":1,\"303\":3,\"304\":1,\"330\":11,\"335\":4,\"337\":2}}],[\"shenzhen\",{\"1\":{\"302\":2}}],[\"shape\",{\"1\":{\"376\":16}}],[\"shared<int>\",{\"1\":{\"351\":2}}],[\"sharedptr1\",{\"1\":{\"351\":2}}],[\"sharedptr\",{\"1\":{\"351\":5}}],[\"shared\",{\"1\":{\"351\":12}}],[\"shangguigu\",{\"1\":{\"310\":3}}],[\"shanghai\",{\"1\":{\"302\":2}}],[\"sha\",{\"1\":{\"178\":3}}],[\"s\",{\"1\":{\"156\":27,\"167\":1,\"170\":1,\"172\":1,\"245\":7,\"257\":1,\"287\":1,\"288\":3,\"289\":2,\"291\":3,\"292\":6,\"294\":3,\"302\":12,\"309\":3,\"310\":8,\"318\":2,\"344\":13,\"361\":3,\"373\":4,\"403\":8,\"404\":5,\"405\":5,\"406\":8,\"436\":1}}],[\"sol\",{\"1\":{\"436\":1}}],[\"solvehanota\",{\"1\":{\"73\":1}}],[\"socklen\",{\"1\":{\"390\":1,\"397\":1,\"436\":1,\"440\":1}}],[\"sockaddr\",{\"1\":{\"390\":2,\"397\":2,\"436\":2,\"440\":2}}],[\"sock\",{\"1\":{\"388\":6,\"389\":2,\"390\":8,\"395\":6,\"396\":5,\"397\":11,\"436\":9,\"437\":6,\"438\":2,\"440\":8}}],[\"socketlisten\",{\"1\":{\"388\":1,\"395\":1,\"436\":1,\"437\":1}}],[\"socketbind\",{\"1\":{\"388\":1,\"395\":1,\"436\":1,\"437\":1}}],[\"socketcreate\",{\"1\":{\"388\":1,\"395\":1,\"436\":1,\"437\":1}}],[\"socket\",{\"1\":{\"388\":4,\"389\":1,\"390\":1,\"395\":4,\"396\":1,\"397\":1,\"436\":5,\"437\":4,\"438\":1,\"440\":1}}],[\"source\",{\"1\":{\"379\":2}}],[\"songjiang\",{\"1\":{\"302\":2}}],[\"so\",{\"1\":{\"113\":1,\"436\":1}}],[\"sortbyvaluedensity\",{\"1\":{\"120\":1}}],[\"sort\",{\"1\":{\"36\":1,\"37\":1,\"40\":1,\"42\":1,\"45\":1,\"47\":1,\"49\":1,\"52\":1,\"55\":1,\"344\":1,\"345\":1}}],[\"sorting\",{\"1\":{\"32\":1}}],[\"srch\",{\"1\":{\"292\":1}}],[\"srcsize\",{\"1\":{\"73\":9}}],[\"src\",{\"1\":{\"73\":15,\"294\":6}}],[\"sigpipe\",{\"1\":{\"403\":1}}],[\"signed\",{\"1\":{\"259\":1,\"330\":12,\"332\":2}}],[\"sin\",{\"1\":{\"390\":2,\"397\":2,\"436\":3,\"440\":2}}],[\"singleptr\",{\"1\":{\"354\":17}}],[\"singleton\",{\"1\":{\"354\":43}}],[\"siftup\",{\"1\":{\"211\":2}}],[\"siftdown\",{\"1\":{\"48\":3,\"212\":2}}],[\"sift\",{\"1\":{\"48\":3}}],[\"size>\",{\"1\":{\"367\":1}}],[\"size代表最后一位元素\",{\"1\":{\"344\":1}}],[\"size是新的内存块的大小\",{\"1\":{\"314\":1}}],[\"size是要分配的内存块的大小\",{\"1\":{\"314\":1}}],[\"size是每个对象的字节大小\",{\"1\":{\"310\":1}}],[\"size\",{\"1\":{\"38\":2,\"39\":2,\"41\":2,\"50\":8,\"53\":3,\"54\":6,\"56\":9,\"69\":4,\"81\":1,\"82\":2,\"90\":11,\"103\":2,\"104\":4,\"105\":2,\"106\":2,\"113\":2,\"120\":1,\"140\":3,\"141\":2,\"142\":2,\"143\":2,\"144\":2,\"145\":5,\"156\":3,\"157\":4,\"160\":3,\"161\":7,\"163\":4,\"164\":1,\"170\":1,\"172\":1,\"186\":5,\"187\":12,\"190\":8,\"211\":1,\"212\":3,\"218\":7,\"219\":4,\"223\":6,\"225\":2,\"257\":1,\"264\":4,\"292\":4,\"294\":4,\"310\":16,\"314\":12,\"335\":1,\"344\":1,\"354\":4,\"361\":5,\"367\":3,\"390\":4,\"395\":2,\"396\":1,\"397\":5,\"440\":4}}],[\"sizeof返回一个size\",{\"1\":{\"335\":1}}],[\"sizeofelement是每个元素的大小\",{\"1\":{\"314\":1}}],[\"sizeofelement\",{\"1\":{\"314\":1}}],[\"sizeof是一个操作符\",{\"1\":{\"292\":1}}],[\"sizeof和strlen的区别\",{\"1\":{\"292\":1}}],[\"sizeof\",{\"1\":{\"29\":1,\"30\":2,\"46\":1,\"50\":3,\"53\":1,\"54\":3,\"56\":2,\"69\":2,\"81\":4,\"82\":4,\"85\":1,\"86\":1,\"90\":3,\"92\":3,\"94\":1,\"95\":1,\"98\":1,\"99\":2,\"105\":2,\"106\":1,\"110\":2,\"111\":1,\"120\":2,\"145\":1,\"146\":1,\"153\":1,\"156\":2,\"157\":2,\"160\":2,\"161\":2,\"163\":3,\"164\":2,\"167\":5,\"170\":5,\"172\":7,\"180\":1,\"186\":3,\"190\":7,\"198\":1,\"218\":1,\"219\":3,\"223\":1,\"244\":4,\"245\":2,\"246\":4,\"259\":1,\"263\":4,\"288\":4,\"292\":1,\"310\":1,\"314\":6,\"335\":15,\"344\":4,\"348\":4,\"361\":10,\"364\":1,\"390\":3,\"397\":3,\"403\":2,\"404\":1,\"405\":1,\"406\":2,\"436\":3,\"440\":3}}],[\"sec\",{\"1\":{\"439\":2}}],[\"seconds\",{\"1\":{\"379\":1}}],[\"secondfunction\",{\"1\":{\"379\":3}}],[\"second\",{\"1\":{\"379\":2}}],[\"server\",{\"1\":{\"390\":1,\"391\":1,\"398\":1,\"403\":2,\"404\":1,\"406\":1,\"439\":1,\"440\":1}}],[\"seqlist\",{\"1\":{\"361\":2}}],[\"sex\",{\"1\":{\"344\":7,\"361\":1,\"373\":1}}],[\"seek\",{\"1\":{\"310\":6}}],[\"season\",{\"1\":{\"301\":1}}],[\"search\",{\"1\":{\"20\":1,\"186\":1,\"187\":1,\"192\":1,\"193\":1,\"198\":1,\"344\":1,\"345\":1}}],[\"sentence\",{\"1\":{\"292\":3}}],[\"separate\",{\"1\":{\"170\":1}}],[\"setfdarray\",{\"1\":{\"440\":2}}],[\"setsockopt\",{\"1\":{\"436\":1}}],[\"setpollfds\",{\"1\":{\"389\":2,\"390\":2}}],[\"set<int>\",{\"1\":{\"379\":1}}],[\"set使用\",{\"1\":{\"379\":1}}],[\"set>\",{\"1\":{\"379\":1}}],[\"setdate\",{\"1\":{\"361\":3}}],[\"set\",{\"1\":{\"167\":16,\"310\":2,\"361\":2,\"367\":2,\"379\":2,\"438\":2,\"440\":1}}],[\"select在某次轮询检测时就会检测到监听套接字的读事件就绪\",{\"1\":{\"439\":1}}],[\"select检测后都会立即返回\",{\"1\":{\"439\":1}}],[\"select函数就会立马检测到监听套接字的读事件就绪\",{\"1\":{\"439\":1}}],[\"selectserver\",{\"1\":{\"437\":2,\"438\":1,\"439\":2,\"440\":1}}],[\"select\",{\"1\":{\"437\":1,\"438\":3,\"439\":5,\"440\":2}}],[\"select服务器如果要向客户端发送数据\",{\"1\":{\"442\":1}}],[\"select服务器存在的问题\",{\"0\":{\"442\":1}}],[\"select服务器测试\",{\"0\":{\"441\":1}}],[\"select服务器事件处理\",{\"0\":{\"440\":1}}],[\"select服务器的运行\",{\"0\":{\"438\":1}}],[\"select服务器的selectserver类\",{\"0\":{\"437\":1}}],[\"select服务器的socket类\",{\"0\":{\"436\":1}}],[\"select服务器代码\",{\"0\":{\"435\":1}}],[\"selected\",{\"1\":{\"81\":12,\"82\":10,\"83\":2,\"85\":1}}],[\"selectionsort\",{\"1\":{\"36\":1}}],[\"selection\",{\"1\":{\"36\":1}}],[\"store将值设置给原子变量\",{\"1\":{\"379\":1}}],[\"store\",{\"1\":{\"379\":2}}],[\"stod\",{\"1\":{\"379\":1}}],[\"stof\",{\"1\":{\"379\":1}}],[\"stoull\",{\"1\":{\"379\":1}}],[\"stoul\",{\"1\":{\"379\":1}}],[\"stold\",{\"1\":{\"379\":1}}],[\"stol\",{\"1\":{\"379\":1}}],[\"stoi使用\",{\"1\":{\"379\":1}}],[\"stoi\",{\"1\":{\"379\":2}}],[\"stl字符串转换函数\",{\"1\":{\"379\":1}}],[\"stl变化\",{\"1\":{\"379\":1}}],[\"stl容器\",{\"1\":{\"379\":1}}],[\"stuid\",{\"1\":{\"373\":1}}],[\"stu\",{\"1\":{\"302\":3,\"373\":2}}],[\"stu2\",{\"1\":{\"302\":10}}],[\"stu1和\",{\"1\":{\"302\":1}}],[\"stu1\",{\"1\":{\"302\":9,\"304\":2}}],[\"studying\",{\"1\":{\"310\":1}}],[\"studio\",{\"1\":{\"270\":3}}],[\"studentinfo\",{\"1\":{\"361\":4}}],[\"student起了一个别名\",{\"1\":{\"304\":1}}],[\"student\",{\"1\":{\"258\":1,\"302\":11,\"304\":4,\"361\":2,\"373\":4}}],[\"student23\",{\"1\":{\"257\":1}}],[\"stdout\",{\"1\":{\"403\":1}}],[\"std\",{\"1\":{\"348\":12,\"351\":20,\"354\":4,\"357\":6,\"361\":7,\"364\":6,\"367\":21,\"370\":36,\"373\":18,\"376\":24,\"379\":157,\"382\":48,\"389\":5,\"390\":13,\"391\":3,\"395\":2,\"396\":5,\"397\":11,\"398\":3,\"436\":6,\"438\":4,\"439\":15,\"440\":13}}],[\"stdbool\",{\"1\":{\"320\":1}}],[\"stdin\",{\"1\":{\"310\":1}}],[\"stdio\",{\"1\":{\"142\":1,\"149\":1,\"195\":1,\"207\":1,\"309\":1,\"310\":3,\"320\":1}}],[\"stderr\",{\"1\":{\"218\":4}}],[\"stables\",{\"1\":{\"321\":2}}],[\"stat\",{\"1\":{\"403\":1,\"406\":1}}],[\"static只会初始化一次\",{\"1\":{\"348\":1}}],[\"static声明的变量只会初始化一次\",{\"1\":{\"334\":1}}],[\"static关键字可以声明静态变量和静态函数\",{\"1\":{\"289\":1}}],[\"static关键字\",{\"0\":{\"289\":1}}],[\"static\",{\"1\":{\"241\":1,\"259\":2,\"289\":16,\"334\":2,\"348\":1,\"354\":15,\"357\":3,\"361\":2,\"382\":1,\"391\":1,\"398\":1,\"436\":3,\"439\":1}}],[\"statesize++\",{\"1\":{\"85\":2,\"86\":1}}],[\"statesize\",{\"1\":{\"81\":4,\"82\":4,\"85\":7,\"86\":4}}],[\"state\",{\"1\":{\"77\":12,\"81\":10,\"82\":7,\"83\":1,\"85\":4,\"86\":2,\"87\":1,\"90\":11,\"92\":6}}],[\"stack\",{\"1\":{\"155\":1,\"157\":23,\"288\":1}}],[\"startvet\",{\"1\":{\"223\":4,\"225\":2}}],[\"start\",{\"1\":{\"85\":6,\"86\":7,\"291\":3,\"299\":2}}],[\"standard\",{\"1\":{\"18\":1}}],[\"str被释放两次\",{\"1\":{\"361\":1}}],[\"str指向同一块空间\",{\"1\":{\"361\":1}}],[\"str的地址是一样的\",{\"1\":{\"361\":1}}],[\"str是一个指向字符数组的指针\",{\"1\":{\"310\":1}}],[\"str是要写入的字符串\",{\"1\":{\"310\":1}}],[\"stream是指向file对象的指针\",{\"1\":{\"310\":1}}],[\"stream是指向输出流的指针\",{\"1\":{\"310\":1}}],[\"stream是读取来源的输入流\",{\"1\":{\"310\":1}}],[\"stream是一个文件流\",{\"1\":{\"310\":1}}],[\"stream是一个指向\",{\"1\":{\"310\":5}}],[\"stream\",{\"1\":{\"308\":2,\"310\":12,\"436\":1}}],[\"strerror\",{\"1\":{\"292\":4,\"344\":3}}],[\"string使用\",{\"1\":{\"379\":1}}],[\"string转内置类型\",{\"1\":{\"379\":1}}],[\"string>>\",{\"1\":{\"379\":1}}],[\"string>\",{\"1\":{\"367\":1,\"379\":1}}],[\"string\",{\"1\":{\"292\":2,\"304\":3,\"309\":1,\"320\":1,\"361\":6,\"364\":4,\"367\":1,\"370\":1,\"373\":2,\"379\":6,\"390\":1,\"391\":1,\"397\":1,\"398\":1,\"439\":1,\"440\":1}}],[\"strtok\",{\"1\":{\"292\":5,\"404\":2}}],[\"strstr\",{\"1\":{\"292\":4}}],[\"strncat\",{\"1\":{\"292\":5}}],[\"strncpy\",{\"1\":{\"292\":5}}],[\"strnlen\",{\"1\":{\"292\":4}}],[\"str=\",{\"1\":{\"263\":1}}],[\"str\",{\"1\":{\"263\":2,\"292\":3,\"309\":11,\"310\":3,\"361\":11,\"379\":3}}],[\"str3=jacktom\",{\"1\":{\"245\":1}}],[\"str3=\",{\"1\":{\"245\":1}}],[\"str3\",{\"1\":{\"245\":2,\"292\":8}}],[\"str2=i\",{\"1\":{\"245\":1}}],[\"str2=tom\",{\"1\":{\"245\":1}}],[\"str2=\",{\"1\":{\"245\":2}}],[\"str2\",{\"1\":{\"245\":4,\"292\":12,\"304\":1,\"379\":2}}],[\"str1=i\",{\"1\":{\"245\":1}}],[\"str1=hello\",{\"1\":{\"245\":1}}],[\"str1=\",{\"1\":{\"245\":2}}],[\"str1\",{\"1\":{\"245\":4,\"292\":23,\"304\":1}}],[\"strcat\",{\"1\":{\"292\":5}}],[\"strcmp\",{\"1\":{\"190\":3,\"292\":4,\"344\":2}}],[\"strcpy\",{\"1\":{\"90\":1,\"167\":2,\"170\":2,\"172\":2,\"292\":5,\"361\":4}}],[\"strlen\",{\"1\":{\"167\":2,\"172\":4,\"177\":4,\"292\":4,\"294\":3,\"361\":2,\"403\":1}}],[\"strassen\",{\"1\":{\"63\":1}}],[\"struct升级为类\",{\"1\":{\"361\":1}}],[\"structure\",{\"1\":{\"132\":1,\"302\":1}}],[\"struct\",{\"1\":{\"30\":1,\"120\":1,\"146\":2,\"153\":3,\"156\":1,\"157\":1,\"160\":1,\"161\":1,\"163\":4,\"164\":1,\"167\":2,\"170\":3,\"172\":1,\"180\":3,\"190\":1,\"198\":3,\"218\":1,\"219\":3,\"223\":1,\"259\":1,\"302\":17,\"304\":5,\"344\":2,\"361\":1,\"379\":1,\"389\":3,\"390\":5,\"396\":2,\"397\":4,\"436\":2,\"439\":2,\"440\":2}}],[\"af\",{\"1\":{\"436\":2}}],[\"after\",{\"1\":{\"292\":4,\"294\":3}}],[\"accept\",{\"1\":{\"390\":2,\"397\":2,\"440\":2}}],[\"accessbasemember\",{\"1\":{\"373\":2}}],[\"access\",{\"1\":{\"150\":1}}],[\"app\",{\"1\":{\"370\":2}}],[\"a不是b的友元\",{\"1\":{\"361\":1}}],[\"a的类型为int\",{\"1\":{\"357\":1}}],[\"a的值为\",{\"1\":{\"348\":2}}],[\"aa\",{\"1\":{\"348\":3,\"361\":3}}],[\"a是97\",{\"1\":{\"332\":1}}],[\"a是65\",{\"1\":{\"332\":1}}],[\"a4=1\",{\"1\":{\"331\":1}}],[\"a4=198\",{\"1\":{\"331\":1}}],[\"a4=\",{\"1\":{\"331\":2}}],[\"a4\",{\"1\":{\"331\":3}}],[\"a3=20\",{\"1\":{\"330\":2}}],[\"a3=\",{\"1\":{\"330\":1,\"331\":4}}],[\"a3\",{\"1\":{\"330\":3,\"331\":3,\"332\":2,\"361\":4}}],[\"a2的初始化\",{\"1\":{\"361\":1}}],[\"a2的列表初始化\",{\"1\":{\"361\":1}}],[\"a2先声明\",{\"1\":{\"361\":1}}],[\"a2为随机值\",{\"1\":{\"361\":1}}],[\"a2初始化完\",{\"1\":{\"361\":2}}],[\"a2=1\",{\"1\":{\"331\":1}}],[\"a2=0\",{\"1\":{\"331\":1}}],[\"a2=\",{\"1\":{\"330\":3,\"331\":2}}],[\"a2\",{\"1\":{\"330\":2,\"331\":3,\"332\":2,\"337\":2,\"361\":8}}],[\"a1声明\",{\"1\":{\"361\":1}}],[\"a1还没初始化则\",{\"1\":{\"361\":1}}],[\"a1初始化\",{\"1\":{\"361\":2}}],[\"a1=3\",{\"1\":{\"331\":2}}],[\"a1=10\",{\"1\":{\"330\":2}}],[\"a1=\",{\"1\":{\"330\":1,\"331\":2}}],[\"a1\",{\"1\":{\"330\":6,\"331\":3,\"332\":2,\"337\":2,\"361\":10}}],[\"author\",{\"1\":{\"344\":1,\"345\":1,\"348\":1,\"351\":1,\"354\":1,\"357\":1,\"361\":1,\"364\":1,\"367\":1,\"370\":1,\"373\":1,\"376\":1,\"379\":1,\"382\":1}}],[\"autumn\",{\"1\":{\"301\":1}}],[\"autoptr\",{\"1\":{\"351\":4}}],[\"auto不能声明数组\",{\"1\":{\"348\":1}}],[\"auto\",{\"1\":{\"259\":1,\"334\":2,\"348\":12,\"351\":8,\"379\":10}}],[\"at\",{\"1\":{\"292\":1,\"367\":2}}],[\"atoi\",{\"1\":{\"292\":4,\"391\":1,\"398\":1,\"404\":2,\"439\":1}}],[\"atomicflag2\",{\"1\":{\"379\":5}}],[\"atomicflag\",{\"1\":{\"379\":5}}],[\"atomicinteger2\",{\"1\":{\"379\":5}}],[\"atomicinteger\",{\"1\":{\"379\":5}}],[\"atomic类模板是c++标准库提供的\",{\"1\":{\"379\":1}}],[\"atomic<char>\",{\"1\":{\"379\":1}}],[\"atomic<int>\",{\"1\":{\"379\":2}}],[\"atomic<bool>\",{\"1\":{\"379\":2}}],[\"atomic\",{\"1\":{\"259\":1,\"379\":5}}],[\"a+b+c\",{\"1\":{\"379\":1}}],[\"a+b+nums\",{\"1\":{\"288\":1}}],[\"a+b\",{\"1\":{\"367\":1,\"379\":1}}],[\"a+1\",{\"1\":{\"319\":2}}],[\"a++\",{\"1\":{\"281\":1}}],[\"a^b=\",{\"1\":{\"280\":3}}],[\"a|b=\",{\"1\":{\"280\":3}}],[\"a<<2=68\",{\"1\":{\"280\":2}}],[\"a<<2=\",{\"1\":{\"280\":1}}],[\"a<=b的值\",{\"1\":{\"277\":2}}],[\"a<b的值\",{\"1\":{\"277\":2}}],[\"a>b\",{\"1\":{\"319\":1}}],[\"a>b的值\",{\"1\":{\"277\":2}}],[\"a>>3=2\",{\"1\":{\"280\":2}}],[\"a>>3=\",{\"1\":{\"280\":1}}],[\"a>=b的值\",{\"1\":{\"277\":2}}],[\"available\",{\"1\":{\"351\":1}}],[\"average\",{\"1\":{\"264\":2}}],[\"avg\",{\"1\":{\"264\":6}}],[\"avltree\",{\"1\":{\"206\":1,\"207\":1}}],[\"avl树删除节点\",{\"0\":{\"207\":1}}],[\"avl树插入节点\",{\"0\":{\"206\":1}}],[\"avl树的旋转\",{\"0\":{\"200\":1}}],[\"avl树的常见术语\",{\"0\":{\"199\":1}}],[\"avl树\",{\"0\":{\"198\":1}}],[\"avl\",{\"1\":{\"63\":1,\"64\":1,\"198\":3,\"200\":1,\"206\":2,\"217\":1}}],[\"alloc\",{\"1\":{\"382\":2}}],[\"all\",{\"1\":{\"344\":1,\"345\":1,\"348\":1,\"351\":1,\"354\":1,\"357\":1,\"361\":1,\"364\":1,\"367\":1,\"370\":1,\"373\":1,\"376\":1,\"379\":3,\"382\":1}}],[\"alice\",{\"1\":{\"310\":1}}],[\"alignof\",{\"1\":{\"259\":1}}],[\"alignas\",{\"1\":{\"259\":1}}],[\"alphabet\",{\"1\":{\"293\":2}}],[\"algorithm\",{\"1\":{\"32\":1,\"74\":1,\"113\":1,\"131\":1}}],[\"ab\",{\"1\":{\"257\":1}}],[\"abt\",{\"1\":{\"190\":34}}],[\"are\",{\"1\":{\"294\":2}}],[\"area\",{\"1\":{\"255\":6,\"376\":1}}],[\"arg\",{\"1\":{\"367\":2,\"379\":8}}],[\"argv\",{\"1\":{\"287\":5,\"391\":3,\"398\":3,\"439\":3}}],[\"argc\",{\"1\":{\"287\":5,\"391\":2,\"398\":2,\"439\":2}}],[\"arg3\",{\"1\":{\"282\":1}}],[\"arg2\",{\"1\":{\"282\":1}}],[\"arg1\",{\"1\":{\"282\":1}}],[\"arr++\",{\"1\":{\"264\":1}}],[\"arr+1=000000f6d35ff9c4\",{\"1\":{\"263\":1}}],[\"arr+1=\",{\"1\":{\"263\":1}}],[\"arr存放的地址\",{\"1\":{\"264\":6}}],[\"arr=000000f6d35ff9c0\",{\"1\":{\"263\":1}}],[\"arr=\",{\"1\":{\"263\":1}}],[\"arr表示整个数组的地址\",{\"1\":{\"263\":1}}],[\"arrlen\",{\"1\":{\"244\":2}}],[\"arrbytelen\",{\"1\":{\"244\":2}}],[\"arr3\",{\"1\":{\"244\":1}}],[\"arr2\",{\"1\":{\"244\":1,\"379\":2}}],[\"arr1\",{\"1\":{\"244\":5}}],[\"arrsize\",{\"1\":{\"190\":4}}],[\"arr\",{\"1\":{\"139\":1,\"160\":4,\"163\":4,\"186\":6,\"187\":3,\"190\":2,\"244\":4,\"263\":7,\"264\":4,\"267\":2,\"288\":10,\"304\":2,\"344\":7,\"379\":3}}],[\"array中清除\",{\"1\":{\"440\":2}}],[\"array当中\",{\"1\":{\"440\":1}}],[\"array数组中全部的位置都已经被占用了\",{\"1\":{\"440\":1}}],[\"array数组中的第0个位置\",{\"1\":{\"438\":1}}],[\"array数组\",{\"1\":{\"440\":1}}],[\"array数组当中清除\",{\"1\":{\"441\":1}}],[\"array数组当中\",{\"1\":{\"440\":1}}],[\"array数组当中就行了\",{\"1\":{\"440\":1}}],[\"array数组当中的文件描述符添加到readfds当中\",{\"1\":{\"438\":1}}],[\"array数组已满\",{\"1\":{\"440\":1}}],[\"array<int\",{\"1\":{\"379\":1}}],[\"array使用\",{\"1\":{\"379\":1}}],[\"array2\",{\"1\":{\"379\":1}}],[\"arraybinarytree\",{\"1\":{\"190\":13}}],[\"arrayhashmap\",{\"1\":{\"167\":11}}],[\"arraydeque\",{\"1\":{\"164\":16}}],[\"arrayqueue\",{\"1\":{\"161\":12}}],[\"arraystack\",{\"1\":{\"157\":10}}],[\"array\",{\"1\":{\"138\":1,\"243\":1,\"263\":2,\"367\":3,\"379\":2,\"438\":10,\"439\":2,\"440\":14}}],[\"a=310\",{\"1\":{\"288\":2}}],[\"a=0\",{\"1\":{\"288\":2,\"289\":3}}],[\"a=0x0012ff40\",{\"1\":{\"267\":1}}],[\"a=16\",{\"1\":{\"288\":1,\"289\":1}}],[\"a=10\",{\"1\":{\"281\":1}}],[\"a=100\",{\"1\":{\"251\":1,\"288\":2}}],[\"a=11\",{\"1\":{\"279\":1}}],[\"a==b的值\",{\"1\":{\"277\":2}}],[\"a=\",{\"1\":{\"251\":1,\"279\":1,\"281\":1,\"288\":4,\"289\":2}}],[\"any\",{\"1\":{\"436\":1}}],[\"animal1\",{\"1\":{\"373\":3}}],[\"animal\",{\"1\":{\"373\":11,\"376\":6}}],[\"anothersharedptr\",{\"1\":{\"351\":2}}],[\"anothershareptr\",{\"1\":{\"351\":2}}],[\"an\",{\"1\":{\"293\":4,\"376\":1}}],[\"ansi\",{\"1\":{\"241\":1}}],[\"and\",{\"1\":{\"58\":1,\"292\":1,\"294\":2,\"309\":1}}],[\"adjlistnode\",{\"1\":{\"219\":24,\"223\":1,\"225\":1}}],[\"adjmat\",{\"1\":{\"218\":2}}],[\"adjacency\",{\"1\":{\"214\":1,\"216\":1,\"217\":1}}],[\"addevent\",{\"1\":{\"396\":2,\"397\":2}}],[\"addedgehelper\",{\"1\":{\"219\":3}}],[\"addedge\",{\"1\":{\"218\":1,\"219\":1}}],[\"addr\",{\"1\":{\"390\":1,\"397\":1,\"436\":2,\"440\":1}}],[\"address\",{\"1\":{\"265\":6,\"302\":12,\"344\":6,\"345\":1,\"364\":1}}],[\"addressing\",{\"1\":{\"171\":1}}],[\"addfunction\",{\"1\":{\"379\":2}}],[\"add函数时一个模板\",{\"1\":{\"367\":1}}],[\"add重载函数\",{\"1\":{\"348\":1}}],[\"adddress\",{\"1\":{\"265\":2}}],[\"addvertex\",{\"1\":{\"218\":1,\"219\":1}}],[\"addhash\",{\"1\":{\"177\":1}}],[\"add\",{\"1\":{\"30\":1,\"240\":1,\"257\":1,\"288\":13,\"344\":3,\"345\":1,\"348\":8,\"367\":3,\"379\":11,\"396\":1,\"397\":1}}],[\"am\",{\"1\":{\"245\":4}}],[\"amt\",{\"1\":{\"113\":5}}],[\"american\",{\"1\":{\"18\":1}}],[\"assert等功能\",{\"1\":{\"241\":1}}],[\"assert\",{\"1\":{\"160\":1,\"161\":1,\"163\":2,\"164\":2,\"219\":4,\"259\":1,\"344\":10,\"361\":2}}],[\"asize\",{\"1\":{\"73\":3}}],[\"ascii码是一种用于表示文本字符的字符编码标准\",{\"1\":{\"332\":1}}],[\"ascii码介绍\",{\"1\":{\"332\":1}}],[\"ascii\",{\"1\":{\"18\":14,\"32\":1,\"177\":3}}],[\"ascii字符集\",{\"1\":{\"18\":1}}],[\"a\",{\"1\":{\"33\":3,\"70\":2,\"71\":3,\"72\":9,\"73\":3,\"96\":3,\"98\":3,\"128\":5,\"168\":1,\"214\":2,\"240\":1,\"245\":1,\"246\":10,\"250\":6,\"251\":7,\"252\":1,\"257\":1,\"263\":2,\"267\":2,\"276\":3,\"277\":9,\"278\":3,\"279\":5,\"280\":11,\"281\":4,\"286\":6,\"288\":20,\"289\":5,\"292\":1,\"293\":7,\"297\":2,\"303\":8,\"304\":6,\"305\":1,\"309\":4,\"310\":6,\"319\":9,\"332\":1,\"335\":7,\"348\":18,\"357\":6,\"361\":26,\"367\":5,\"376\":12,\"379\":12,\"390\":1,\"397\":1,\"440\":1}}],[\"age1\",{\"1\":{\"361\":3}}],[\"age=20\",{\"1\":{\"302\":3}}],[\"age=\",{\"1\":{\"302\":3}}],[\"age\",{\"1\":{\"33\":1,\"291\":2,\"297\":6,\"302\":15,\"344\":5,\"361\":3,\"373\":1}}],[\"也就意味着timeout的时间是被耗尽了的\",{\"1\":{\"439\":1}}],[\"也就说明了双方进程之间的通信依旧是在内存当中进行的\",{\"1\":{\"403\":1}}],[\"也就没有意义了\",{\"1\":{\"403\":1}}],[\"也就证明了\",{\"1\":{\"403\":1}}],[\"也就是引用有具体内存位置的对象\",{\"1\":{\"379\":1}}],[\"也就是\",{\"1\":{\"379\":2}}],[\"也就是getinstance函数第一次被调用的时创建单例对象\",{\"1\":{\"354\":1}}],[\"也就是先判断不合适的一般来说都不用switch\",{\"1\":{\"297\":1}}],[\"也就是占用4个内存单元\",{\"1\":{\"261\":1}}],[\"也就是列表的首个元素\",{\"1\":{\"210\":1}}],[\"也就是o\",{\"1\":{\"109\":1}}],[\"也就是说\",{\"1\":{\"18\":1,\"62\":1,\"88\":1,\"89\":1,\"114\":1,\"135\":1,\"150\":1,\"285\":1}}],[\"也会关闭对应的连接\",{\"1\":{\"391\":1,\"398\":1,\"441\":1}}],[\"也会产生重复分支\",{\"1\":{\"82\":1}}],[\"也支持在指定实际内加锁\",{\"1\":{\"379\":1}}],[\"也可能不同\",{\"1\":{\"314\":1}}],[\"也可以是函数指针\",{\"1\":{\"379\":1}}],[\"也可以是数组\",{\"1\":{\"302\":1}}],[\"也可以在声明类变量的时候实例化\",{\"1\":{\"367\":1}}],[\"也可以在声明变量的同时进行赋值\",{\"1\":{\"250\":1}}],[\"也可以保持视频\",{\"1\":{\"308\":1}}],[\"也可以使用小驼峰命名法\",{\"1\":{\"258\":1}}],[\"也可以使用链表实现\",{\"1\":{\"15\":1}}],[\"也可以称为字符串\",{\"1\":{\"245\":1}}],[\"也可以直接遍历获取数组中的每个元素\",{\"1\":{\"143\":1}}],[\"也可以根据数据特点采用某种概率模型进行近似\",{\"1\":{\"51\":1}}],[\"也是通过基类指针调用\",{\"1\":{\"376\":1}}],[\"也是一组数据的集合\",{\"1\":{\"302\":1}}],[\"也是错误的\",{\"1\":{\"267\":1}}],[\"也是平衡二叉树\",{\"1\":{\"198\":1}}],[\"也不能用=delete方式将拷贝构造函数删除\",{\"1\":{\"354\":1}}],[\"也不会占用内存函数是一段可以重复使用的代码\",{\"1\":{\"319\":1}}],[\"也不应该再次使用\",{\"1\":{\"314\":1}}],[\"也不用包括函数体\",{\"1\":{\"287\":1}}],[\"也不是控制字符\",{\"1\":{\"245\":1}}],[\"也不例外\",{\"1\":{\"18\":1}}],[\"也叫适配器\",{\"1\":{\"379\":1}}],[\"也叫接口类\",{\"1\":{\"376\":1}}],[\"也叫重定向\",{\"1\":{\"373\":1}}],[\"也叫作宏定义\",{\"1\":{\"255\":1}}],[\"也叫格式声明符\",{\"1\":{\"251\":1}}],[\"也叫ansi\",{\"1\":{\"241\":1}}],[\"也叫完美二叉树\",{\"1\":{\"183\":1}}],[\"也能使树重新变为\",{\"1\":{\"200\":1}}],[\"也能避免重复选择元素\",{\"1\":{\"86\":1}}],[\"也称为标准函数\",{\"1\":{\"285\":1}}],[\"也称为解引用运算符或间接引用运算符\",{\"1\":{\"261\":1}}],[\"也称为下标\",{\"1\":{\"243\":1}}],[\"也称深度优先搜索\",{\"1\":{\"187\":1}}],[\"也称广度优先搜索\",{\"1\":{\"186\":1}}],[\"也常作为哈希表扩容的触发条件\",{\"1\":{\"168\":1}}],[\"也存在一些\",{\"1\":{\"101\":1}}],[\"也通过统计个数来实现排序\",{\"1\":{\"55\":1}}],[\"5号和6号文件描述符对应的分别是正在访问服务器的两个客户端\",{\"1\":{\"398\":1}}],[\"5>\",{\"1\":{\"367\":2,\"379\":1}}],[\"5s\",{\"1\":{\"344\":4}}],[\"5d\",{\"1\":{\"344\":2}}],[\"58667435\",{\"1\":{\"337\":1}}],[\"56\",{\"1\":{\"332\":2,\"357\":1}}],[\"566370\",{\"1\":{\"318\":1}}],[\"535\",{\"1\":{\"330\":2}}],[\"531441\",{\"1\":{\"291\":1}}],[\"55\",{\"1\":{\"304\":2}}],[\"5=20个字节\",{\"1\":{\"263\":1}}],[\"52\",{\"1\":{\"255\":2,\"379\":4}}],[\"512\",{\"1\":{\"331\":3}}],[\"51截断小数\",{\"1\":{\"291\":4}}],[\"51四舍五入\",{\"1\":{\"291\":4}}],[\"51向下取整\",{\"1\":{\"291\":4}}],[\"51\",{\"1\":{\"244\":2,\"291\":6}}],[\"50分\",{\"1\":{\"291\":1}}],[\"500000\",{\"1\":{\"276\":2,\"357\":1}}],[\"50000\",{\"1\":{\"246\":1}}],[\"5000\",{\"1\":{\"246\":1}}],[\"500\",{\"1\":{\"246\":1}}],[\"50\",{\"1\":{\"244\":4,\"246\":1,\"262\":6,\"263\":3,\"264\":1,\"291\":1,\"344\":1,\"379\":2}}],[\"5\",{\"0\":{\"18\":1,\"28\":1,\"29\":1,\"30\":1,\"42\":1,\"43\":1,\"44\":1,\"64\":1,\"79\":1,\"105\":1,\"117\":1,\"143\":1,\"151\":1,\"197\":1,\"198\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":2,\"206\":1,\"207\":1,\"220\":1,\"231\":1,\"265\":1,\"279\":1,\"289\":1,\"305\":1,\"321\":1,\"334\":1,\"339\":1,\"406\":1,\"440\":1,\"458\":1,\"465\":1,\"476\":1,\"502\":1},\"1\":{\"27\":2,\"33\":1,\"54\":1,\"85\":14,\"86\":4,\"139\":3,\"147\":2,\"180\":2,\"182\":1,\"213\":1,\"214\":2,\"218\":1,\"219\":1,\"244\":5,\"246\":3,\"257\":1,\"258\":1,\"261\":1,\"262\":1,\"263\":8,\"264\":3,\"271\":1,\"276\":2,\"278\":1,\"286\":2,\"288\":4,\"291\":2,\"292\":2,\"293\":1,\"297\":4,\"298\":4,\"299\":1,\"301\":1,\"302\":1,\"303\":3,\"304\":7,\"310\":1,\"314\":6,\"317\":1,\"318\":2,\"319\":2,\"331\":3,\"337\":1,\"338\":2,\"342\":1,\"344\":3,\"348\":9,\"354\":2,\"357\":6,\"361\":10,\"364\":2,\"367\":3,\"373\":1,\"379\":18,\"388\":1,\"389\":1,\"390\":1,\"395\":2,\"396\":1,\"397\":1,\"437\":1,\"438\":1,\"439\":1,\"440\":1}}],[\"正常的事件处理\",{\"1\":{\"389\":1,\"396\":1,\"438\":1,\"439\":2}}],[\"正常数字表示\",{\"1\":{\"325\":1}}],[\"正确\",{\"1\":{\"348\":2,\"357\":2,\"379\":1}}],[\"正确性证明\",{\"0\":{\"121\":1,\"125\":1,\"129\":1}}],[\"正号和负号\",{\"1\":{\"276\":1}}],[\"正向自适应\",{\"1\":{\"34\":1}}],[\"正数的补码\",{\"1\":{\"327\":1}}],[\"正数的补码与其原码相同\",{\"1\":{\"17\":1}}],[\"正数的反码\",{\"1\":{\"327\":1}}],[\"正数的反码与其原码相同\",{\"1\":{\"17\":1}}],[\"正数的原码\",{\"1\":{\"327\":2}}],[\"正在处理的数据主要存储在内存中\",{\"1\":{\"15\":1}}],[\"其属性可能会退化为左值\",{\"1\":{\"379\":1}}],[\"其既能接收左值又能接收右值\",{\"1\":{\"379\":1}}],[\"其实就是\",{\"1\":{\"348\":1}}],[\"其它位取反\",{\"1\":{\"327\":1}}],[\"其它信息都不需要\",{\"1\":{\"287\":1}}],[\"其真正表示的值\",{\"1\":{\"327\":1}}],[\"其所占用的内存空间会被释放\",{\"1\":{\"267\":1}}],[\"其值至少是1\",{\"1\":{\"287\":1}}],[\"其值是随机的\",{\"1\":{\"267\":1}}],[\"其值不能改变的量\",{\"1\":{\"253\":1}}],[\"其在内存中会占用4个字节\",{\"1\":{\"261\":1}}],[\"其长度就是确定的\",{\"1\":{\"243\":1}}],[\"其子节点的值\",{\"1\":{\"208\":2}}],[\"其左子节点的索引为2i+1\",{\"1\":{\"209\":1}}],[\"其左子节点记为\",{\"1\":{\"201\":1}}],[\"其左边和右边分别为划分前和划分后的操作总数\",{\"1\":{\"61\":1}}],[\"其两个指针均指向\",{\"1\":{\"181\":1}}],[\"其他类似\",{\"1\":{\"379\":1}}],[\"其他类型指针赋给\",{\"1\":{\"313\":1}}],[\"其他相同\",{\"1\":{\"361\":1}}],[\"其他版本的懒汉模式实现方式\",{\"1\":{\"354\":1}}],[\"其他文件不可访问\",{\"1\":{\"289\":1}}],[\"其他文件中可以定义与其同名的变量\",{\"1\":{\"289\":1}}],[\"其他文件中\",{\"1\":{\"289\":1}}],[\"其他关键字\",{\"1\":{\"259\":1}}],[\"其他层的节点都被填满\",{\"1\":{\"208\":1}}],[\"其他所有节点都包含子节点和非空子树\",{\"1\":{\"180\":1}}],[\"其他的一些生僻字符需要\",{\"1\":{\"18\":1}}],[\"其操作方法与普通哈希表有所不同\",{\"1\":{\"172\":1}}],[\"其将相同类型的元素存储在连续的内存空间中\",{\"1\":{\"138\":1}}],[\"其满足索引i\",{\"1\":{\"123\":1}}],[\"其基本思想是在问题的每个决策阶段\",{\"1\":{\"113\":1}}],[\"其具有很多变种\",{\"1\":{\"107\":1}}],[\"其遍历了整个网格\",{\"1\":{\"105\":1}}],[\"其数量会随着网格\",{\"1\":{\"103\":1}}],[\"其尺寸与输入网格grid相同\",{\"1\":{\"102\":1}}],[\"其定义为哈希表的元素数量除以桶数量\",{\"1\":{\"168\":1}}],[\"其定义为\",{\"1\":{\"99\":1}}],[\"其递归树的深度为n\",{\"1\":{\"93\":1}}],[\"其作用是保证相等元素只被选择一次\",{\"1\":{\"83\":1}}],[\"其作用是避免某个元素在\",{\"1\":{\"83\":1}}],[\"其各种操作\",{\"1\":{\"63\":1}}],[\"其处理一个长度为n的数组需要o\",{\"1\":{\"61\":1}}],[\"其底层逻辑是什么\",{\"1\":{\"60\":1}}],[\"其元素是范围\",{\"1\":{\"50\":1}}],[\"其目标是\",{\"1\":{\"42\":1}}],[\"其包含边界值本身\",{\"1\":{\"20\":1}}],[\"其余各位取反\",{\"1\":{\"327\":1}}],[\"其余位表示数值\",{\"1\":{\"327\":1}}],[\"其余位表示数字的值\",{\"1\":{\"17\":1}}],[\"其余所有节点的度都为2\",{\"1\":{\"183\":1}}],[\"其余所有位用于填充字符的\",{\"1\":{\"18\":1}}],[\"其余列\",{\"1\":{\"106\":1}}],[\"其余行\",{\"1\":{\"106\":1}}],[\"其余行和列\",{\"1\":{\"105\":1}}],[\"其余\",{\"1\":{\"18\":1}}],[\"其收录了\",{\"1\":{\"18\":1}}],[\"其全称为\",{\"1\":{\"18\":1}}],[\"其中服务端需要做的就是\",{\"1\":{\"406\":1}}],[\"其中文件描述符0\",{\"1\":{\"398\":1}}],[\"其中std\",{\"1\":{\"379\":1}}],[\"其中signed\",{\"1\":{\"332\":1}}],[\"其中派生类可以访问基类的成员\",{\"1\":{\"373\":1}}],[\"其中unique\",{\"1\":{\"351\":1}}],[\"其中存储了该顶点的所有邻接顶点\",{\"1\":{\"217\":1}}],[\"其中查找待删除节点需要o\",{\"1\":{\"195\":1}}],[\"其中n为结点数量空间复杂度为o\",{\"1\":{\"186\":1}}],[\"其中n为数组长度\",{\"1\":{\"142\":1}}],[\"其中n为物品数量\",{\"1\":{\"120\":1}}],[\"其中高度由较短的隔板决定\",{\"1\":{\"122\":1}}],[\"其中的每个元素都是指针\",{\"1\":{\"263\":1}}],[\"其中的每个元素都是一个节点对象\",{\"1\":{\"146\":1}}],[\"其中的每个元素代表一个垂直隔板的高度\",{\"1\":{\"122\":1}}],[\"其中的元素都是\",{\"1\":{\"53\":1}}],[\"其中包含一些重叠子问题\",{\"1\":{\"103\":1}}],[\"其中每一个节点代表一个决策\",{\"1\":{\"101\":1}}],[\"其中每个维度都对应于不同的行\",{\"1\":{\"246\":1}}],[\"其中每个单元格都可以存储一定大小的数据\",{\"1\":{\"15\":1}}],[\"其中每个黑色方块都包含一块内存空间\",{\"1\":{\"15\":1}}],[\"其中连续三次跳1阶的方案不满足约束条件\",{\"1\":{\"99\":1}}],[\"其中cost\",{\"1\":{\"98\":1}}],[\"其中两个都为4\",{\"1\":{\"86\":1}}],[\"其中不包含重复元素\",{\"1\":{\"81\":1}}],[\"其中\",{\"1\":{\"53\":1,\"56\":1,\"81\":1,\"90\":1,\"93\":1,\"109\":1,\"167\":1,\"287\":1,\"298\":1}}],[\"其中0表示正数\",{\"1\":{\"17\":1}}],[\"反正后也要初始化\",{\"1\":{\"345\":1}}],[\"反斜杠\",{\"1\":{\"332\":1}}],[\"反之m\",{\"1\":{\"216\":1}}],[\"反映了自然界中常见的细胞分裂现象\",{\"1\":{\"183\":1}}],[\"反映了复杂的网络关系\",{\"1\":{\"14\":1}}],[\"反向思考\",{\"1\":{\"123\":1}}],[\"反码的基础上加1\",{\"1\":{\"327\":1}}],[\"反码的概念总结\",{\"1\":{\"327\":1}}],[\"反码相同\",{\"1\":{\"327\":1}}],[\"反码通常是用来由原码求补码或者由补码求原码的过渡码\",{\"1\":{\"327\":1}}],[\"反码\",{\"0\":{\"327\":1},\"1\":{\"17\":1,\"327\":6}}],[\"反码首先需要指出\",{\"1\":{\"17\":1}}],[\"补码都是0\",{\"1\":{\"327\":1}}],[\"补码都一样\",{\"1\":{\"327\":1}}],[\"补码\",{\"0\":{\"327\":1},\"1\":{\"17\":3,\"327\":4}}],[\"由系统和编译器决定\",{\"1\":{\"335\":1}}],[\"由预处理器\",{\"1\":{\"319\":1}}],[\"由上面方式二中共用体变量a为例\",{\"1\":{\"303\":1}}],[\"由柯尼汉和里奇合写的\",{\"1\":{\"241\":1}}],[\"由近及远\",{\"1\":{\"223\":1}}],[\"由顶点\",{\"1\":{\"213\":1}}],[\"由此可知\",{\"1\":{\"211\":1}}],[\"由此便可推出本题的贪心策略\",{\"1\":{\"123\":1}}],[\"由此便可推理出下图所示的贪心策略\",{\"1\":{\"119\":1}}],[\"由于当前服务器调用select函数时直接将timeout设置为了nullptr\",{\"1\":{\"439\":1}}],[\"由于协变存在\",{\"1\":{\"376\":1}}],[\"由于b类中初始化列表初始化了\",{\"1\":{\"361\":1}}],[\"由于main函数之前是不存在多线程的\",{\"1\":{\"354\":1}}],[\"由于下标从0开始\",{\"1\":{\"344\":1}}],[\"由于未在声明部分定义其为变量或者数组\",{\"1\":{\"312\":1}}],[\"由于成员x的长度最长\",{\"1\":{\"303\":1}}],[\"由于程序总是先运行main\",{\"1\":{\"287\":1}}],[\"由于是不同类型的指针进行比较\",{\"1\":{\"262\":1}}],[\"由于是无向图\",{\"1\":{\"223\":1}}],[\"由于没有结束标识\",{\"1\":{\"245\":1}}],[\"由于已经交换\",{\"1\":{\"212\":1}}],[\"由于堆正是一种完全二叉树\",{\"1\":{\"209\":1}}],[\"由于堆的长度会随着提取最大元素而减小\",{\"1\":{\"48\":1}}],[\"由于引入了\",{\"1\":{\"195\":1,\"207\":1}}],[\"由于要保持二叉搜索树\",{\"1\":{\"195\":1}}],[\"由于要时刻满足小圆盘在大圆盘之上\",{\"1\":{\"71\":1}}],[\"由于层序遍历序列并不包含这些\",{\"1\":{\"190\":1}}],[\"由于加法和异或满足交换律\",{\"1\":{\"178\":1}}],[\"由于链表节点需要额外存储指针\",{\"1\":{\"158\":1}}],[\"由于入栈的元素可能会源源不断地增加\",{\"1\":{\"157\":1}}],[\"由于数组成员是同一类型\",{\"1\":{\"244\":1}}],[\"由于数组的长度不可变\",{\"1\":{\"142\":1}}],[\"由于数组是已排序的\",{\"1\":{\"86\":1}}],[\"由于初始化了一个\",{\"1\":{\"120\":1}}],[\"由于每个状态都只与其上一行的状态有关\",{\"1\":{\"111\":1}}],[\"由于每个物品都会产生不选和选两条搜索分支\",{\"1\":{\"108\":1}}],[\"由于每个格子只与其左边和上边的格子有关\",{\"1\":{\"106\":1}}],[\"由于每个格子是由其左方格子和上方格子转移而来\",{\"1\":{\"102\":1}}],[\"由于物品编号i从1开始计数\",{\"1\":{\"107\":1}}],[\"由于仅需多考虑前面一个状态\",{\"1\":{\"99\":1}}],[\"由于省去了数组\",{\"1\":{\"96\":1}}],[\"由于dp\",{\"1\":{\"96\":1}}],[\"由于动态规划不包含回溯过程\",{\"1\":{\"95\":1}}],[\"由于无法预测哪些选择可生成有效的解\",{\"1\":{\"78\":1}}],[\"由于在\",{\"1\":{\"37\":1}}],[\"由于\",{\"1\":{\"21\":1,\"53\":1,\"198\":1,\"211\":1}}],[\"由于i和j都是int类型\",{\"1\":{\"20\":1}}],[\"由\",{\"1\":{\"16\":1,\"251\":1}}],[\"否则就成了函数声明\",{\"1\":{\"361\":1}}],[\"否则就被编译器忽略\",{\"1\":{\"321\":1}}],[\"否则目标变量没了\",{\"1\":{\"348\":1}}],[\"否则会出现数组越界问题\",{\"1\":{\"344\":1}}],[\"否则返回false\",{\"1\":{\"379\":1}}],[\"否则返回0\",{\"1\":{\"321\":1}}],[\"否则返回特殊值\",{\"1\":{\"310\":2}}],[\"否则输出not\",{\"1\":{\"321\":1}}],[\"否则可能出现内存泄漏\",{\"1\":{\"315\":1}}],[\"否则编译器无法知道如何解读内存块保存的二进制数据\",{\"1\":{\"313\":1}}],[\"否则\",{\"1\":{\"297\":1}}],[\"否则执行代码块2\",{\"1\":{\"297\":1}}],[\"否则报错\",{\"1\":{\"286\":1}}],[\"否则为假逻辑或\",{\"1\":{\"278\":1}}],[\"否则将违反其定义\",{\"1\":{\"194\":1}}],[\"否\",{\"1\":{\"16\":1}}],[\"是传给myclass构造函数的参数\",{\"1\":{\"364\":2}}],[\"是闰年\",{\"1\":{\"361\":1}}],[\"是不需要使用互斥锁进行保护的\",{\"1\":{\"354\":1}}],[\"是32\",{\"1\":{\"332\":1}}],[\"是ascii码中对应的数字\",{\"1\":{\"332\":1}}],[\"是ascii码表中的第0个字符\",{\"1\":{\"245\":1}}],[\"是浮点类型的格式占位符\",{\"1\":{\"331\":1}}],[\"是指在模板中一部分参数被具体指定\",{\"1\":{\"367\":1}}],[\"是指为模板提供特定类型或特定值的完整实现\",{\"1\":{\"367\":1}}],[\"是指根据需要向系统申请所需大小的空间\",{\"1\":{\"312\":1}}],[\"是指从该节点到它的最远叶节点的距离\",{\"1\":{\"199\":1}}],[\"是要输出的字符串\",{\"1\":{\"309\":1}}],[\"是写入的字符的ascii码值参数说明\",{\"1\":{\"309\":1}}],[\"是结构体数据类型\",{\"1\":{\"302\":1}}],[\"是数据类型\",{\"1\":{\"302\":1}}],[\"是c语言中的一种用户自定义数据类型\",{\"1\":{\"301\":1}}],[\"是c语言中的一种指针类型\",{\"1\":{\"263\":1}}],[\"是c语言用于表示时间值的数据类型\",{\"1\":{\"291\":1}}],[\"是从字符串中提取数据而不是从用户输入提取数据\",{\"1\":{\"291\":1}}],[\"是将内容写入字符串而不是输出sscanf\",{\"1\":{\"291\":1}}],[\"是由c系统提供的\",{\"1\":{\"285\":1}}],[\"是由微软公司发布的集成开发环境\",{\"1\":{\"270\":1}}],[\"是野指针\",{\"1\":{\"267\":1}}],[\"是按字符数组处理的\",{\"1\":{\"263\":1}}],[\"是线性的c语言中\",{\"1\":{\"246\":1}}],[\"是逻辑上的概念\",{\"1\":{\"246\":1}}],[\"是多个相同类型数据按一定顺序排列的集合\",{\"1\":{\"243\":1}}],[\"是顶点\",{\"1\":{\"214\":1}}],[\"是两个独立的概念\",{\"1\":{\"176\":1}}],[\"是哈希表的一个重要概念\",{\"1\":{\"168\":1}}],[\"是计算机中组织和存储数据的方式\",{\"1\":{\"132\":1}}],[\"是在数组定义时明确指定且固定的\",{\"1\":{\"244\":1}}],[\"是在有限时间内解决特定问题的一组指令或操作步骤\",{\"1\":{\"131\":1}}],[\"是在向上\",{\"1\":{\"69\":1}}],[\"是动态规划中最常见的问题形式\",{\"1\":{\"107\":1}}],[\"是边界条件\",{\"1\":{\"102\":1}}],[\"是同一个子集\",{\"1\":{\"85\":1}}],[\"是等价的\",{\"1\":{\"82\":1}}],[\"是直至目前已被选择的元素\",{\"1\":{\"81\":1}}],[\"是输入数组中的所有元素\",{\"1\":{\"81\":1}}],[\"是路径列表\",{\"1\":{\"77\":1}}],[\"是因为该算法在搜索解空间时会采用\",{\"1\":{\"75\":1}}],[\"是根节点的值\",{\"1\":{\"67\":1}}],[\"是一组运算数\",{\"1\":{\"275\":1}}],[\"是一款由microsoft开发的免费\",{\"1\":{\"270\":1}}],[\"是一个标识符\",{\"1\":{\"318\":1}}],[\"是一个以字符串形式指定的打开模式\",{\"1\":{\"310\":1}}],[\"是一个定义在\",{\"1\":{\"309\":1,\"310\":1}}],[\"是一个定义在标准库\",{\"1\":{\"266\":1}}],[\"是一个指针类型\",{\"1\":{\"304\":1}}],[\"是一个指针数组\",{\"1\":{\"287\":1}}],[\"是一个指针\",{\"1\":{\"263\":1}}],[\"是一个数组\",{\"1\":{\"263\":1}}],[\"是一个重要的算法范式\",{\"1\":{\"92\":1}}],[\"是一个非常形象的名词\",{\"1\":{\"76\":1}}],[\"是一个典型的分治问题\",{\"1\":{\"66\":1}}],[\"是一种特殊的符号\",{\"1\":{\"275\":1}}],[\"是一种满足特定条件的完全二叉树\",{\"1\":{\"208\":1}}],[\"是一种形象化的说法\",{\"1\":{\"201\":1}}],[\"是一种非线性数据结构\",{\"1\":{\"180\":1,\"213\":1}}],[\"是一种非常重要且常见的算法策略\",{\"1\":{\"58\":1}}],[\"是一种遵循先进先出规则的线性数据结构\",{\"1\":{\"159\":1}}],[\"是一种遵循后进先出逻辑的线性数据结构\",{\"1\":{\"155\":1}}],[\"是一种线性数据结构\",{\"1\":{\"138\":1,\"146\":1}}],[\"是一种算法策略\",{\"1\":{\"136\":1}}],[\"是一种重复执行某个任务的控制结构\",{\"1\":{\"136\":1}}],[\"是一种常见的解决优化问题的算法\",{\"1\":{\"113\":1}}],[\"是一种通过穷举来解决问题的方法\",{\"1\":{\"74\":1}}],[\"是一种通用字符集\",{\"1\":{\"18\":1}}],[\"是一种基于堆数据结构实现的高效排序算法\",{\"1\":{\"47\":1}}],[\"是一种基于分治策略的排序算法\",{\"1\":{\"42\":1,\"45\":1}}],[\"是一种基于分治策略的高效搜索算法\",{\"1\":{\"20\":1}}],[\"是一种简单的排序算法\",{\"1\":{\"40\":1}}],[\"是分治策略的一个典型应用\",{\"1\":{\"49\":1}}],[\"是否已被选择\",{\"1\":{\"81\":1}}],[\"是否基于比较\",{\"1\":{\"33\":1}}],[\"是否在哈希表中\",{\"1\":{\"30\":1}}],[\"是\",{\"1\":{\"16\":1,\"54\":1,\"337\":1}}],[\"b树和b+树\",{\"0\":{\"469\":1}}],[\"be\",{\"1\":{\"382\":2}}],[\"bound\",{\"1\":{\"379\":2}}],[\"boost中智能指针关系\",{\"1\":{\"351\":1}}],[\"book\",{\"1\":{\"257\":2,\"344\":1,\"345\":1}}],[\"boolalpha\",{\"1\":{\"379\":2}}],[\"bool变量只能赋值为0或1\",{\"1\":{\"333\":1}}],[\"bool仍是整数类型\",{\"1\":{\"333\":1}}],[\"bool\",{\"1\":{\"16\":1,\"39\":1,\"77\":2,\"81\":4,\"82\":5,\"90\":6,\"156\":1,\"157\":1,\"160\":1,\"161\":1,\"163\":3,\"164\":1,\"258\":1,\"259\":1,\"318\":3,\"333\":3,\"361\":13,\"379\":4,\"389\":1,\"390\":1,\"440\":1}}],[\"b天生是a的友元\",{\"1\":{\"361\":1}}],[\"b的类型为const\",{\"1\":{\"357\":1}}],[\"b4=1\",{\"1\":{\"331\":1}}],[\"b4=198\",{\"1\":{\"331\":1}}],[\"b4=300\",{\"1\":{\"330\":2}}],[\"b4=\",{\"1\":{\"330\":1,\"331\":2}}],[\"b4\",{\"1\":{\"330\":3,\"331\":3}}],[\"b3=200\",{\"1\":{\"330\":2}}],[\"b3=\",{\"1\":{\"330\":1,\"331\":4}}],[\"b3\",{\"1\":{\"330\":2,\"331\":3}}],[\"b2=1\",{\"1\":{\"331\":1}}],[\"b2=0\",{\"1\":{\"331\":1}}],[\"b2=\",{\"1\":{\"330\":3,\"331\":2}}],[\"b2\",{\"1\":{\"330\":2,\"331\":3,\"332\":5,\"337\":2}}],[\"b1=3\",{\"1\":{\"331\":2}}],[\"b1=100\",{\"1\":{\"330\":2}}],[\"b1=\",{\"1\":{\"330\":1,\"331\":2}}],[\"b1\",{\"1\":{\"330\":2,\"331\":3,\"332\":5,\"337\":2}}],[\"b是带参数的宏对应字符串\",{\"1\":{\"319\":1}}],[\"b>>3=\",{\"1\":{\"280\":3}}],[\"b<<2=\",{\"1\":{\"280\":3}}],[\"block具有很强的灵活性\",{\"1\":{\"270\":1}}],[\"block的最大特点是它支持通过插件的方式对ide自身功能进行扩展\",{\"1\":{\"270\":1}}],[\"block是一个免费的跨平台ide\",{\"1\":{\"270\":1}}],[\"block\",{\"1\":{\"270\":1}}],[\"b=000001f5fc3f47d0\",{\"1\":{\"314\":2}}],[\"b=000001f5fc3f4770\",{\"1\":{\"314\":1}}],[\"b=0\",{\"1\":{\"288\":2}}],[\"b=210\",{\"1\":{\"288\":4}}],[\"b=2\",{\"1\":{\"282\":1}}],[\"b=20\",{\"1\":{\"279\":1}}],[\"b=200\",{\"1\":{\"251\":1}}],[\"b=98\",{\"1\":{\"281\":1}}],[\"b=99\",{\"1\":{\"278\":1}}],[\"b=16\",{\"1\":{\"280\":2}}],[\"b=100\",{\"1\":{\"251\":1}}],[\"b=\",{\"1\":{\"251\":2,\"278\":1,\"279\":1,\"280\":1,\"281\":1,\"288\":3,\"314\":3}}],[\"bf\",{\"1\":{\"205\":3}}],[\"bfs的算法实现\",{\"0\":{\"223\":1}}],[\"bfs\",{\"0\":{\"222\":1},\"1\":{\"186\":1,\"223\":3}}],[\"bsae\",{\"1\":{\"357\":1}}],[\"bst\",{\"1\":{\"193\":2,\"194\":4,\"195\":4}}],[\"bst树\",{\"0\":{\"192\":1}}],[\"bsize\",{\"1\":{\"73\":2}}],[\"breadth\",{\"1\":{\"186\":2}}],[\"breaking\",{\"1\":{\"373\":6}}],[\"break语句用于终止某个语句块的执行\",{\"1\":{\"299\":1}}],[\"break\",{\"1\":{\"39\":1,\"48\":1,\"85\":1,\"120\":1,\"193\":1,\"195\":1,\"211\":1,\"212\":1,\"219\":2,\"259\":1,\"297\":9,\"299\":2,\"345\":8,\"373\":6,\"389\":3,\"403\":2,\"404\":12,\"405\":2,\"406\":4,\"438\":3,\"439\":6}}],[\"b++\",{\"1\":{\"278\":1}}],[\"b+\",{\"1\":{\"63\":1}}],[\"bad\",{\"1\":{\"382\":17}}],[\"bat\",{\"1\":{\"373\":2,\"406\":6}}],[\"bat继承manmal\",{\"1\":{\"373\":1}}],[\"baninheritclass\",{\"1\":{\"354\":5}}],[\"bancopyclass\",{\"1\":{\"354\":10}}],[\"basic\",{\"1\":{\"344\":1}}],[\"baseobj\",{\"1\":{\"382\":2}}],[\"baseptr\",{\"1\":{\"357\":2}}],[\"base\",{\"1\":{\"40\":3,\"41\":8,\"357\":2,\"373\":6,\"376\":5,\"382\":3}}],[\"bar\",{\"1\":{\"321\":2}}],[\"baoan\",{\"1\":{\"302\":2}}],[\"baii\",{\"1\":{\"257\":1}}],[\"balancefactor\",{\"1\":{\"199\":1,\"205\":3}}],[\"balance\",{\"1\":{\"199\":1,\"264\":2}}],[\"balanced\",{\"1\":{\"183\":1,\"198\":1}}],[\"backlog\",{\"1\":{\"436\":2}}],[\"backtrack\",{\"1\":{\"77\":4,\"81\":4,\"82\":3,\"83\":1,\"85\":6,\"86\":3,\"90\":3,\"92\":3}}],[\"backtracking\",{\"1\":{\"74\":1}}],[\"back\",{\"1\":{\"50\":1,\"379\":2,\"388\":2,\"389\":1,\"390\":1,\"395\":2,\"396\":1,\"397\":1,\"437\":2,\"438\":1,\"440\":1}}],[\"buf=\",{\"1\":{\"344\":1}}],[\"buffer是指向要读取的数组中首个对象的指针\",{\"1\":{\"310\":1}}],[\"buffer\",{\"1\":{\"310\":12,\"364\":4,\"390\":5,\"397\":5,\"440\":5}}],[\"bufsize\",{\"1\":{\"73\":3}}],[\"buf\",{\"1\":{\"73\":7,\"344\":1}}],[\"buildtree\",{\"1\":{\"69\":1}}],[\"bucketstmp\",{\"1\":{\"172\":3}}],[\"buckets\",{\"1\":{\"50\":12,\"167\":1,\"170\":1,\"172\":1}}],[\"bucketsort\",{\"1\":{\"50\":1}}],[\"bucket\",{\"1\":{\"49\":1,\"50\":6,\"167\":1}}],[\"bubblesortwithflag\",{\"1\":{\"39\":1}}],[\"bubblesort\",{\"1\":{\"38\":1}}],[\"bubble\",{\"1\":{\"37\":1}}],[\"b\",{\"1\":{\"33\":2,\"63\":1,\"70\":1,\"71\":3,\"72\":5,\"73\":3,\"96\":5,\"98\":4,\"128\":4,\"214\":3,\"246\":2,\"250\":5,\"251\":7,\"257\":1,\"276\":2,\"277\":7,\"278\":2,\"279\":4,\"280\":8,\"281\":5,\"286\":6,\"288\":11,\"293\":1,\"297\":2,\"303\":4,\"304\":2,\"314\":13,\"319\":4,\"332\":4,\"335\":5,\"348\":4,\"357\":4,\"361\":8,\"367\":1,\"379\":10}}],[\"bind绑定add函数\",{\"1\":{\"379\":1}}],[\"bind绑定函数和部分参数\",{\"1\":{\"379\":1}}],[\"bind\",{\"1\":{\"379\":4,\"436\":2}}],[\"binarysearchtree\",{\"1\":{\"193\":1,\"194\":1,\"195\":1}}],[\"binarysearchrightedge\",{\"1\":{\"27\":1}}],[\"binarysearchleftedge\",{\"1\":{\"26\":1}}],[\"binarysearchlcro\",{\"1\":{\"21\":1}}],[\"binarysearchinsertion\",{\"1\":{\"24\":1,\"26\":1,\"27\":1}}],[\"binarysearchinsertionsimple\",{\"1\":{\"23\":1}}],[\"binarysearch\",{\"1\":{\"20\":1,\"64\":1}}],[\"binary\",{\"1\":{\"20\":1,\"180\":1,\"183\":2,\"192\":1,\"198\":1}}],[\"bird2又继承animal\",{\"1\":{\"373\":1}}],[\"bird2\",{\"1\":{\"373\":3}}],[\"bird\",{\"1\":{\"373\":4}}],[\"bit\",{\"1\":{\"16\":1,\"330\":1}}],[\"bytes\",{\"1\":{\"310\":4}}],[\"byte\",{\"1\":{\"16\":2,\"304\":3,\"330\":1}}],[\"4号文件描述符对应的是服务器创建的epoll模型\",{\"1\":{\"398\":1}}],[\"47\",{\"1\":{\"379\":2}}],[\"4年一润且百年不润\",{\"1\":{\"361\":1}}],[\"4次\",{\"1\":{\"361\":1}}],[\"43\",{\"1\":{\"351\":2}}],[\"431\",{\"1\":{\"335\":1}}],[\"4e\",{\"1\":{\"331\":1}}],[\"4e+38\",{\"1\":{\"331\":1}}],[\"4个字节\",{\"1\":{\"330\":1}}],[\"4294967216\",{\"1\":{\"337\":1}}],[\"42\",{\"1\":{\"310\":1,\"313\":2,\"351\":2,\"357\":3,\"367\":8,\"370\":1,\"373\":2,\"379\":17,\"382\":2}}],[\"4行\",{\"1\":{\"298\":1}}],[\"44\",{\"1\":{\"291\":1,\"304\":2,\"338\":2,\"351\":3}}],[\"45933945\",{\"1\":{\"330\":1}}],[\"45\",{\"1\":{\"286\":2,\"351\":2}}],[\"45和31之间较大的是\",{\"1\":{\"286\":2}}],[\"483\",{\"1\":{\"330\":4}}],[\"48\",{\"1\":{\"280\":2}}],[\"4932到1\",{\"1\":{\"331\":1}}],[\"49\",{\"1\":{\"276\":1}}],[\"4之后\",{\"1\":{\"267\":1}}],[\"4gb\",{\"1\":{\"261\":1}}],[\"404\",{\"1\":{\"524\":1}}],[\"408\",{\"1\":{\"288\":1}}],[\"40010\",{\"1\":{\"337\":1}}],[\"400000\",{\"1\":{\"264\":1}}],[\"40000\",{\"1\":{\"246\":1,\"337\":1}}],[\"4000\",{\"1\":{\"246\":1}}],[\"400\",{\"1\":{\"246\":1,\"314\":1,\"361\":1}}],[\"40\",{\"1\":{\"244\":5,\"246\":2,\"262\":6,\"263\":3,\"267\":1,\"297\":2,\"379\":2}}],[\"4^\",{\"1\":{\"86\":1}}],[\"4\",{\"0\":{\"17\":1,\"25\":1,\"26\":1,\"27\":1,\"40\":1,\"41\":1,\"63\":1,\"69\":1,\"78\":1,\"96\":1,\"104\":1,\"107\":1,\"108\":1,\"109\":1,\"110\":1,\"111\":2,\"116\":1,\"142\":1,\"150\":1,\"153\":1,\"184\":1,\"192\":1,\"193\":1,\"194\":1,\"195\":1,\"196\":2,\"197\":1,\"204\":1,\"207\":1,\"212\":1,\"219\":1,\"225\":1,\"230\":1,\"246\":1,\"252\":1,\"264\":1,\"273\":1,\"278\":1,\"288\":1,\"299\":1,\"304\":1,\"315\":1,\"320\":1,\"328\":1,\"333\":1,\"336\":1,\"337\":1,\"338\":1,\"391\":1,\"398\":1,\"405\":1,\"439\":1,\"442\":1,\"457\":1,\"464\":1,\"475\":1,\"501\":1,\"536\":1},\"1\":{\"16\":1,\"18\":7,\"33\":1,\"53\":1,\"54\":1,\"85\":14,\"86\":5,\"139\":1,\"147\":2,\"170\":1,\"172\":1,\"173\":1,\"177\":1,\"180\":2,\"182\":1,\"190\":1,\"214\":2,\"218\":1,\"219\":1,\"244\":6,\"245\":1,\"246\":11,\"255\":2,\"257\":1,\"258\":1,\"259\":2,\"261\":2,\"262\":4,\"263\":1,\"267\":2,\"271\":1,\"272\":1,\"276\":3,\"283\":1,\"286\":1,\"287\":1,\"288\":2,\"297\":3,\"298\":5,\"299\":1,\"302\":1,\"303\":3,\"304\":1,\"309\":1,\"310\":1,\"313\":1,\"314\":3,\"317\":1,\"318\":2,\"320\":1,\"321\":2,\"330\":8,\"331\":3,\"335\":12,\"337\":1,\"338\":1,\"342\":1,\"344\":2,\"348\":10,\"351\":1,\"354\":2,\"361\":2,\"364\":1,\"373\":1,\"379\":26,\"404\":2,\"436\":1}}],[\"creat\",{\"1\":{\"406\":1}}],[\"create\",{\"1\":{\"395\":2}}],[\"createobj\",{\"1\":{\"354\":3}}],[\"ctl\",{\"1\":{\"396\":2,\"397\":4}}],[\"ctime\",{\"1\":{\"291\":2}}],[\"custom\",{\"1\":{\"382\":2}}],[\"customexceptionptr\",{\"1\":{\"382\":3}}],[\"customexception\",{\"1\":{\"382\":6}}],[\"curr\",{\"1\":{\"291\":4}}],[\"cur\",{\"1\":{\"170\":40,\"193\":22,\"194\":11,\"195\":22,\"219\":29,\"310\":2}}],[\"cv\",{\"1\":{\"379\":3}}],[\"cbegin\",{\"1\":{\"379\":1}}],[\"cbrt\",{\"1\":{\"291\":1}}],[\"circle\",{\"1\":{\"376\":18}}],[\"cin进行输入输出\",{\"1\":{\"370\":1}}],[\"cin\",{\"1\":{\"361\":8,\"370\":2,\"382\":2}}],[\"centos服务器\",{\"1\":{\"406\":1}}],[\"cend\",{\"1\":{\"379\":1}}],[\"cerr\",{\"1\":{\"370\":4,\"382\":5,\"389\":1,\"390\":2,\"391\":1,\"395\":1,\"396\":1,\"397\":2,\"436\":3,\"438\":1,\"439\":3,\"440\":2}}],[\"ceil\",{\"1\":{\"291\":2}}],[\"cgarbo\",{\"1\":{\"354\":1}}],[\"c源文件\",{\"0\":{\"345\":1}}],[\"c+\",{\"1\":{\"332\":1}}],[\"c++异常\",{\"0\":{\"380\":1},\"1\":{\"382\":1}}],[\"c++多态\",{\"0\":{\"374\":1}}],[\"c++继承\",{\"0\":{\"371\":1}}],[\"c++标准io流\",{\"1\":{\"370\":1}}],[\"c++io流\",{\"0\":{\"368\":1}}],[\"c++模板\",{\"0\":{\"365\":1}}],[\"c++内存管理\",{\"0\":{\"362\":1}}],[\"c++默认构造函数的练习\",{\"1\":{\"361\":1}}],[\"c++类和对象\",{\"0\":{\"359\":1}}],[\"c++类型转换\",{\"0\":{\"355\":1},\"1\":{\"357\":1}}],[\"c++stl库\",{\"0\":{\"358\":1}}],[\"c++98\",{\"1\":{\"354\":4}}],[\"c++98中产生了第一个智能指针auto\",{\"1\":{\"351\":1}}],[\"c++特殊类设计\",{\"0\":{\"352\":1}}],[\"c++tr1引入boost中的shared\",{\"1\":{\"351\":1}}],[\"c++boost给出了更实用的scoped\",{\"1\":{\"351\":1}}],[\"c++11提供\",{\"1\":{\"379\":1}}],[\"c++11引入条件变量来协调多个线程的执行\",{\"1\":{\"379\":1}}],[\"c++11引入的原子操作类型\",{\"1\":{\"379\":1}}],[\"c++11引入final修饰虚函数\",{\"1\":{\"376\":1}}],[\"c++11引入了boost中的unique\",{\"1\":{\"351\":1}}],[\"c++11则是在类外增加关键字final\",{\"1\":{\"354\":1}}],[\"c++11\",{\"0\":{\"377\":1},\"1\":{\"354\":3}}],[\"c++11可以在拷贝构造函数后面加上=delete\",{\"1\":{\"354\":1}}],[\"c++11后弃用\",{\"1\":{\"351\":1}}],[\"c++11后被弃用\",{\"1\":{\"351\":1}}],[\"c++11以前使用\",{\"1\":{\"351\":1}}],[\"c++智能指针\",{\"0\":{\"349\":1}}],[\"c++指针空值nullptr\",{\"1\":{\"348\":1}}],[\"c++范围for循环\",{\"1\":{\"348\":1}}],[\"c++关键字auto\",{\"1\":{\"348\":1}}],[\"c++常引用使用场景\",{\"1\":{\"348\":1}}],[\"c++常引用权限问题\",{\"1\":{\"348\":1}}],[\"c++引用\",{\"1\":{\"348\":1}}],[\"c++函数重载\",{\"1\":{\"348\":1}}],[\"c++缺省参数\",{\"1\":{\"348\":1}}],[\"c++输入与输出\",{\"1\":{\"348\":1}}],[\"c++基础\",{\"0\":{\"346\":1}}],[\"c++开发效率\",{\"1\":{\"270\":1}}],[\"c++集成开发环境\",{\"1\":{\"270\":1}}],[\"c++和fortan程序的开发\",{\"1\":{\"270\":1}}],[\"c++\",{\"1\":{\"110\":1,\"146\":2}}],[\"c表示char类型\",{\"1\":{\"332\":1}}],[\"c和\",{\"1\":{\"289\":1}}],[\"c文件扩展名是\",{\"1\":{\"285\":1}}],[\"c=3\",{\"1\":{\"282\":1}}],[\"c=53\",{\"1\":{\"279\":1}}],[\"c=\",{\"1\":{\"279\":1,\"288\":3,\"332\":1}}],[\"c程序动态内存分配\",{\"0\":{\"312\":1}}],[\"c程序中\",{\"1\":{\"308\":1}}],[\"c程序中的所有函数都是互相独立的\",{\"1\":{\"285\":1}}],[\"c程序由一条条语句构成\",{\"1\":{\"272\":1}}],[\"c程序的执行入口是main\",{\"1\":{\"272\":1}}],[\"c程序源文件以\",{\"1\":{\"272\":1}}],[\"c程序执行流程\",{\"0\":{\"271\":1}}],[\"cmake构建支持\",{\"1\":{\"270\":1}}],[\"cmp2\",{\"1\":{\"294\":4}}],[\"cmp1\",{\"1\":{\"294\":5}}],[\"cmp\",{\"1\":{\"85\":1,\"86\":1}}],[\"cd\",{\"1\":{\"257\":1}}],[\"c3=2000\",{\"1\":{\"330\":2}}],[\"c3=\",{\"1\":{\"330\":1,\"332\":4}}],[\"c3\",{\"1\":{\"250\":1,\"251\":2,\"330\":2,\"332\":2}}],[\"c2会超出范围\",{\"1\":{\"332\":1}}],[\"c2=9\",{\"1\":{\"332\":1}}],[\"c2=\",{\"1\":{\"330\":3,\"332\":3}}],[\"c2\",{\"1\":{\"250\":1,\"251\":2,\"330\":3,\"332\":2}}],[\"c23\",{\"1\":{\"241\":1}}],[\"c1=200\",{\"1\":{\"332\":1}}],[\"c1=a\",{\"1\":{\"332\":1}}],[\"c1=100\",{\"1\":{\"330\":2}}],[\"c1=\",{\"1\":{\"330\":1,\"332\":2}}],[\"c1\",{\"1\":{\"250\":1,\"251\":2,\"330\":3,\"332\":2}}],[\"c17\",{\"1\":{\"241\":1}}],[\"c11标准增加了7个关键字\",{\"1\":{\"259\":1}}],[\"c11在2017年修补\",{\"1\":{\"241\":1}}],[\"c11\",{\"1\":{\"241\":1}}],[\"c99允许定义一个类型为void的指针变量\",{\"1\":{\"313\":1}}],[\"c99标准加入\",{\"1\":{\"331\":1}}],[\"c99标准增加了5个关键字\",{\"1\":{\"259\":1}}],[\"c99标准添加的类型\",{\"1\":{\"258\":1}}],[\"c99\",{\"1\":{\"241\":1}}],[\"c90\",{\"1\":{\"241\":1}}],[\"c89\",{\"1\":{\"241\":1}}],[\"c语言\",{\"0\":{\"528\":1}}],[\"c语言根据数据的特性和用途进行了类型划分\",{\"1\":{\"329\":1}}],[\"c语言允许宏带有参数\",{\"1\":{\"319\":1}}],[\"c语言允许为一个数据类型起一个新的别名\",{\"1\":{\"304\":1}}],[\"c语言编译器在编译程序之前\",{\"1\":{\"317\":1}}],[\"c语言中的类型转换\",{\"1\":{\"357\":1}}],[\"c语言中的i\",{\"1\":{\"309\":1}}],[\"c语言中\",{\"1\":{\"332\":1}}],[\"c语言中使用不同进制表示整数\",{\"1\":{\"325\":1}}],[\"c语言中变量\",{\"1\":{\"256\":1}}],[\"c语言的输出格式\",{\"1\":{\"325\":1}}],[\"c语言的输入与输出\",{\"0\":{\"309\":1}}],[\"c语言的文件读写\",{\"0\":{\"310\":1}}],[\"c语言的发行版本\",{\"0\":{\"241\":1}}],[\"c语言提供了一系列函数处理存储设备上的文件\",{\"1\":{\"310\":1}}],[\"c语言提供了共用体类型\",{\"1\":{\"303\":1}}],[\"c语言提供了struct关键字\",{\"1\":{\"302\":1}}],[\"c语言约定\",{\"1\":{\"287\":1}}],[\"c语言注释\",{\"0\":{\"273\":1}}],[\"c语言严格区分大小写\",{\"1\":{\"272\":1}}],[\"c语言开发注意事项\",{\"0\":{\"272\":1}}],[\"c语言开发环境\",{\"0\":{\"269\":1}}],[\"c语言对字符串\",{\"1\":{\"263\":1}}],[\"c语言概述\",{\"0\":{\"238\":1}}],[\"clearfdarray\",{\"1\":{\"438\":2}}],[\"clearpollfds\",{\"1\":{\"389\":2}}],[\"clean\",{\"1\":{\"113\":1}}],[\"cloning\",{\"1\":{\"376\":3}}],[\"clonedanimal\",{\"1\":{\"376\":2}}],[\"clone\",{\"1\":{\"376\":3}}],[\"close\",{\"1\":{\"370\":2,\"388\":1,\"390\":4,\"395\":2,\"397\":2,\"403\":3,\"404\":1,\"405\":1,\"406\":4,\"437\":1,\"440\":4}}],[\"clog\",{\"1\":{\"370\":2}}],[\"class\",{\"1\":{\"302\":1,\"354\":11,\"357\":7,\"361\":24,\"364\":1,\"367\":6,\"373\":29,\"376\":9,\"379\":1,\"382\":4,\"388\":1,\"389\":1,\"390\":1,\"395\":1,\"396\":1,\"397\":1,\"436\":1,\"437\":1,\"438\":1,\"440\":1}}],[\"classes\",{\"1\":{\"258\":1}}],[\"client通信\",{\"0\":{\"403\":1}}],[\"client\",{\"1\":{\"390\":1,\"397\":1,\"403\":3,\"404\":2,\"405\":2,\"406\":2,\"440\":1}}],[\"clion是一款由jetbrains推出的跨平台c\",{\"1\":{\"270\":1}}],[\"clion\",{\"1\":{\"270\":1}}],[\"climbingstairsconstraintdp\",{\"1\":{\"99\":1}}],[\"climbingstairsdpcomp\",{\"1\":{\"96\":1}}],[\"climbingstairsdp\",{\"1\":{\"95\":1}}],[\"climbingstairsdfsmem\",{\"1\":{\"94\":1}}],[\"climbingstairsdfs\",{\"1\":{\"93\":1}}],[\"climbingstairsbacktrack\",{\"1\":{\"92\":1}}],[\"caught\",{\"1\":{\"382\":5}}],[\"cannot\",{\"1\":{\"382\":2}}],[\"calculating\",{\"1\":{\"376\":1}}],[\"calculatearea\",{\"1\":{\"376\":1}}],[\"calloc函数calloc\",{\"1\":{\"314\":1}}],[\"calloc\",{\"1\":{\"50\":2,\"53\":1,\"54\":1,\"98\":1,\"99\":1,\"105\":1,\"106\":1,\"110\":1,\"111\":1,\"314\":3}}],[\"catch\",{\"1\":{\"382\":6}}],[\"cat\",{\"1\":{\"373\":7}}],[\"cast的使用\",{\"1\":{\"357\":1}}],[\"cast主要用于指针或引用去除const\",{\"1\":{\"357\":1}}],[\"cast<const\",{\"1\":{\"382\":1}}],[\"cast<char\",{\"1\":{\"357\":1}}],[\"cast<double>\",{\"1\":{\"382\":1}}],[\"cast<derived\",{\"1\":{\"357\":1,\"382\":1}}],[\"cast<mydervivedclass\",{\"1\":{\"357\":1}}],[\"cast<int\",{\"1\":{\"357\":1}}],[\"cast<int>\",{\"1\":{\"357\":2}}],[\"cast\",{\"1\":{\"357\":9,\"382\":5}}],[\"case\",{\"1\":{\"259\":1,\"297\":10,\"345\":7,\"389\":2,\"404\":10,\"438\":2,\"439\":4}}],[\"car1\",{\"1\":{\"302\":1}}],[\"car\",{\"1\":{\"302\":2}}],[\"capture\",{\"1\":{\"379\":2}}],[\"capacity\",{\"1\":{\"124\":2,\"161\":4,\"164\":7,\"167\":11,\"168\":1,\"170\":1,\"172\":1,\"175\":2,\"344\":1,\"361\":6}}],[\"cap\",{\"1\":{\"109\":1,\"110\":5,\"111\":4,\"120\":5}}],[\"chrono\",{\"1\":{\"379\":1}}],[\"check\",{\"1\":{\"314\":3}}],[\"chen\",{\"1\":{\"302\":2}}],[\"chocolate\",{\"1\":{\"304\":1}}],[\"choice\",{\"1\":{\"77\":11,\"81\":3,\"82\":4,\"92\":3}}],[\"choicessize\",{\"1\":{\"81\":6,\"82\":6,\"85\":6,\"86\":3}}],[\"choices\",{\"1\":{\"77\":10,\"81\":6,\"82\":3,\"85\":10,\"86\":7,\"87\":1,\"92\":6}}],[\"ch\",{\"1\":{\"293\":33,\"294\":1,\"310\":12,\"379\":2}}],[\"child\",{\"1\":{\"180\":2,\"195\":4,\"201\":11,\"202\":10,\"203\":1,\"204\":1,\"207\":5,\"405\":1}}],[\"chaining\",{\"1\":{\"170\":1}}],[\"charptr\",{\"1\":{\"357\":1}}],[\"char取值范围0\",{\"1\":{\"332\":1}}],[\"char取值范围\",{\"1\":{\"332\":1}}],[\"char类型可以进行数学运算字符型同样分为signed\",{\"1\":{\"332\":1}}],[\"char类型本质是一个整数\",{\"1\":{\"332\":1}}],[\"char类型的字面量是用单引号括起来的单个字符可以使用转义字符\",{\"1\":{\"332\":1}}],[\"character是要写入的字符\",{\"1\":{\"310\":1}}],[\"character是要写入的字符的ascii码值\",{\"1\":{\"309\":1}}],[\"character\",{\"1\":{\"293\":4,\"309\":1,\"310\":2}}],[\"characters\",{\"1\":{\"292\":1}}],[\"char等\",{\"1\":{\"286\":1}}],[\"char\",{\"1\":{\"16\":1,\"18\":1,\"90\":11,\"167\":4,\"170\":2,\"172\":4,\"177\":8,\"190\":1,\"245\":6,\"259\":1,\"261\":2,\"263\":3,\"287\":2,\"288\":3,\"289\":4,\"291\":3,\"292\":31,\"293\":1,\"294\":4,\"297\":2,\"302\":20,\"303\":4,\"304\":5,\"309\":5,\"310\":18,\"332\":16,\"335\":5,\"344\":9,\"348\":2,\"357\":1,\"361\":11,\"364\":1,\"367\":2,\"379\":2,\"382\":2,\"390\":1,\"391\":1,\"397\":1,\"398\":1,\"403\":2,\"404\":5,\"405\":1,\"406\":2,\"439\":1,\"440\":1}}],[\"csize\",{\"1\":{\"73\":2}}],[\"cout<<\",{\"1\":{\"376\":2,\"379\":1,\"389\":1,\"396\":1,\"438\":2}}],[\"cout\",{\"1\":{\"348\":24,\"351\":6,\"357\":3,\"361\":32,\"364\":2,\"367\":13,\"370\":4,\"373\":8,\"376\":10,\"379\":46,\"382\":4,\"389\":1,\"390\":4,\"396\":1,\"397\":3,\"398\":1,\"439\":4,\"440\":4}}],[\"count是要读取的对象数\",{\"1\":{\"310\":1}}],[\"count++\",{\"1\":{\"113\":1}}],[\"count\",{\"1\":{\"93\":2,\"94\":3,\"113\":2,\"143\":2,\"287\":1,\"304\":1,\"310\":2,\"348\":1}}],[\"counter稳定排序\",{\"1\":{\"56\":1}}],[\"counter\",{\"1\":{\"53\":12,\"54\":10,\"56\":6}}],[\"countingsortdigit\",{\"1\":{\"56\":2}}],[\"countingsort\",{\"1\":{\"54\":1}}],[\"countingsortnaive\",{\"1\":{\"53\":1}}],[\"counting\",{\"1\":{\"52\":1}}],[\"copyrights\",{\"1\":{\"344\":1,\"345\":1,\"348\":1,\"351\":1,\"354\":1,\"357\":1,\"361\":1,\"364\":1,\"367\":1,\"370\":1,\"373\":1,\"376\":1,\"379\":1,\"382\":1}}],[\"copied\",{\"1\":{\"310\":1}}],[\"comm\",{\"1\":{\"403\":4,\"404\":1,\"405\":1,\"406\":3}}],[\"commonfunction\",{\"1\":{\"373\":3}}],[\"commonvar\",{\"1\":{\"373\":9}}],[\"com\",{\"1\":{\"257\":1,\"344\":1,\"345\":1,\"348\":1,\"351\":1,\"354\":1,\"357\":1,\"361\":1,\"364\":1,\"367\":1,\"370\":1,\"373\":1,\"376\":1,\"379\":1,\"382\":1}}],[\"comparison\",{\"1\":{\"292\":1}}],[\"compare\",{\"1\":{\"50\":1}}],[\"complex和\",{\"1\":{\"259\":1}}],[\"completed\",{\"1\":{\"370\":2}}],[\"complete\",{\"1\":{\"183\":1}}],[\"coins\",{\"1\":{\"113\":5}}],[\"coinchangegreedy\",{\"1\":{\"113\":1}}],[\"costsize\",{\"1\":{\"98\":4}}],[\"cost\",{\"1\":{\"98\":11}}],[\"collision\",{\"1\":{\"168\":1}}],[\"col++\",{\"1\":{\"90\":1}}],[\"col的范围是\",{\"1\":{\"90\":1}}],[\"col2\",{\"1\":{\"89\":1}}],[\"col1=row2\",{\"1\":{\"89\":1}}],[\"col为恒定值\",{\"1\":{\"89\":1}}],[\"col\",{\"1\":{\"89\":1,\"90\":9}}],[\"cols\",{\"1\":{\"89\":3,\"90\":8,\"246\":3,\"298\":3}}],[\"consumerthread\",{\"1\":{\"379\":2}}],[\"consumer\",{\"1\":{\"379\":4}}],[\"const成员变量\",{\"1\":{\"361\":1}}],[\"const取地址\",{\"1\":{\"361\":1}}],[\"const引发的浅拷贝崩溃问题\",{\"1\":{\"361\":1}}],[\"const修饰this\",{\"1\":{\"361\":1}}],[\"constptr\",{\"1\":{\"357\":2}}],[\"const定义常量需指定数据类型\",{\"1\":{\"255\":1}}],[\"const定义的常量有详细的数据类型\",{\"1\":{\"255\":1}}],[\"const是关键字\",{\"1\":{\"255\":1}}],[\"const关键字\",{\"1\":{\"255\":1}}],[\"const\",{\"1\":{\"167\":3,\"170\":1,\"177\":4,\"255\":2,\"259\":1,\"262\":1,\"288\":3,\"289\":4,\"292\":6,\"294\":4,\"309\":1,\"310\":11,\"321\":1,\"344\":2,\"348\":4,\"354\":14,\"357\":8,\"361\":57,\"367\":2,\"376\":10,\"379\":3,\"382\":11,\"440\":1}}],[\"condition\",{\"1\":{\"379\":1}}],[\"con\",{\"1\":{\"345\":9}}],[\"con=\",{\"1\":{\"345\":1}}],[\"contactmenu\",{\"1\":{\"344\":4,\"345\":1}}],[\"contactmodify\",{\"1\":{\"344\":3,\"345\":1}}],[\"contactprint\",{\"1\":{\"344\":3,\"345\":1}}],[\"contactsortup\",{\"1\":{\"344\":3}}],[\"contactsort\",{\"1\":{\"344\":3,\"345\":1}}],[\"contactsearch\",{\"1\":{\"344\":3,\"345\":1}}],[\"contactsave\",{\"1\":{\"344\":3,\"345\":1}}],[\"contactfind\",{\"1\":{\"344\":6}}],[\"contactdelete\",{\"1\":{\"344\":3,\"345\":1}}],[\"contactdestroy\",{\"1\":{\"344\":3,\"345\":1}}],[\"contactadd\",{\"1\":{\"344\":3,\"345\":1}}],[\"contactcheck\",{\"1\":{\"344\":5}}],[\"contactinit\",{\"1\":{\"344\":3,\"345\":1}}],[\"contactinfo\",{\"1\":{\"344\":12}}],[\"contactload\",{\"1\":{\"344\":4}}],[\"contact\",{\"0\":{\"344\":1},\"1\":{\"344\":32,\"345\":2}}],[\"content\",{\"1\":{\"310\":1}}],[\"continue语句用于结束本次循环\",{\"1\":{\"299\":1}}],[\"continue\",{\"1\":{\"85\":1,\"86\":2,\"92\":1,\"259\":1,\"299\":2,\"390\":2,\"396\":2,\"397\":1,\"438\":1,\"440\":2}}],[\"connected\",{\"1\":{\"214\":1}}],[\"conquer\",{\"1\":{\"58\":1}}],[\"code旨在提供一种优秀的编码体验\",{\"1\":{\"270\":1}}],[\"code\",{\"1\":{\"18\":1,\"270\":5,\"292\":1,\"320\":1,\"382\":4}}],[\"cplusplus\",{\"1\":{\"348\":1}}],[\"cpp里\",{\"1\":{\"361\":1}}],[\"cpp\",{\"0\":{\"530\":1},\"1\":{\"50\":1,\"357\":1,\"361\":3}}],[\"cpu\",{\"1\":{\"16\":1}}],[\"c\",{\"1\":{\"33\":2,\"70\":2,\"71\":3,\"72\":8,\"73\":3,\"108\":8,\"109\":12,\"110\":8,\"111\":7,\"146\":1,\"241\":6,\"245\":3,\"257\":1,\"271\":1,\"272\":1,\"276\":2,\"279\":8,\"285\":1,\"286\":6,\"287\":2,\"288\":3,\"289\":7,\"293\":15,\"297\":6,\"302\":5,\"303\":6,\"304\":1,\"309\":4,\"310\":3,\"320\":2,\"325\":1,\"332\":5,\"335\":5,\"344\":1,\"345\":2,\"348\":3,\"351\":1,\"354\":1,\"357\":1,\"361\":1,\"364\":1,\"367\":1,\"370\":1,\"373\":1,\"376\":1,\"379\":2,\"382\":1,\"403\":3,\"404\":2,\"406\":2}}],[\"主线程等待新线程结束\",{\"1\":{\"379\":3}}],[\"主线程执行一些任务\",{\"1\":{\"379\":2}}],[\"主线程继续执行其他任务\",{\"1\":{\"379\":1}}],[\"主函数中使用全局数据\",{\"1\":{\"288\":2}}],[\"主函数返回值0表示运行成功\",{\"1\":{\"287\":1}}],[\"主函数的声明中可以带有两个参数\",{\"1\":{\"287\":1}}],[\"主函数的参数\",{\"1\":{\"287\":1}}],[\"主函数的返回值\",{\"1\":{\"287\":1}}],[\"主函数的作用\",{\"1\":{\"287\":1}}],[\"主函数也不能调用自己\",{\"1\":{\"287\":1}}],[\"主函数是程序的入口函数\",{\"1\":{\"287\":1}}],[\"主函数与函数原型\",{\"0\":{\"287\":1}}],[\"主函数\",{\"1\":{\"286\":2,\"287\":1,\"288\":2}}],[\"主对角线\",{\"1\":{\"90\":1}}],[\"主要为了支持移动语义\",{\"1\":{\"379\":1}}],[\"主要用于模板和泛型编程中\",{\"1\":{\"357\":1}}],[\"主要用第三种\",{\"1\":{\"333\":1}}],[\"主要记住\",{\"1\":{\"332\":1}}],[\"主要有三大流程控制语句\",{\"1\":{\"295\":1}}],[\"主要有以下几点区别\",{\"1\":{\"263\":1}}],[\"主要有以下原因\",{\"1\":{\"44\":1}}],[\"主要进行一些文本上的处理\",{\"1\":{\"271\":1}}],[\"主要可分为两种类型\",{\"1\":{\"208\":1}}],[\"主要包括以下几种\",{\"1\":{\"16\":1}}],[\"主页\",{\"0\":{\"0\":1}}],[\"在某次调用select函数时就会检测到监听套接字的读事件就绪\",{\"1\":{\"439\":1}}],[\"在某些情况下将资源从一个对象移动到另一个对象\",{\"1\":{\"379\":1}}],[\"在某些硬币组合下\",{\"1\":{\"117\":1}}],[\"在当前代码中是直接退出了\",{\"1\":{\"403\":1}}],[\"在主函数中直接抛出它并不是常规做法\",{\"1\":{\"382\":2}}],[\"在使用typeid运算符获取无效类型信息时抛出的异常\",{\"1\":{\"382\":1}}],[\"在类型转换中遇到无效的类型转换时抛出的异常\",{\"1\":{\"382\":1}}],[\"在类外实现\",{\"1\":{\"361\":1}}],[\"在try块中放置可能抛出异常的代码\",{\"1\":{\"382\":1}}],[\"在析构函数中释放互斥锁\",{\"1\":{\"379\":1}}],[\"在线程函数中通过引用修改外部变量的值\",{\"1\":{\"379\":1}}],[\"在线程函数中通过该地址修改变量\",{\"1\":{\"379\":2}}],[\"在线程函数中修改实参的值\",{\"1\":{\"379\":2}}],[\"在线程函数中修改后也不会\",{\"1\":{\"379\":1}}],[\"在等待的线程返回前\",{\"1\":{\"379\":1}}],[\"在默认函数定义或声明时加上=delete\",{\"1\":{\"379\":1}}],[\"在默认函数定义或者声明时加上=default\",{\"1\":{\"379\":1}}],[\"在虚函数后加=0\",{\"1\":{\"376\":1}}],[\"在重写基类虚函数时\",{\"1\":{\"376\":1}}],[\"在派生类中\",{\"1\":{\"373\":1}}],[\"在模板后用<类型>来指定类型\",{\"1\":{\"367\":1}}],[\"在垃圾回收类的析构函数中完成单例对象的释放\",{\"1\":{\"354\":1}}],[\"在单例类中定义一个静态的垃圾回收类对象\",{\"1\":{\"354\":1}}],[\"在单例类中实现一个内嵌的垃圾回收类\",{\"1\":{\"354\":1}}],[\"在单例类中编写一个delinstance函数\",{\"1\":{\"354\":1}}],[\"在整个if语句之后进行解锁\",{\"1\":{\"354\":1}}],[\"在静态区创建对象\",{\"1\":{\"354\":1}}],[\"在拷贝构造函数后面加上=delete\",{\"1\":{\"354\":1}}],[\"在对象析构时释放资源\",{\"1\":{\"351\":1}}],[\"在对象构造时获取资源\",{\"1\":{\"351\":1}}],[\"在赋值运算中\",{\"1\":{\"337\":1}}],[\"在源文件中定义\",{\"1\":{\"334\":1}}],[\"在现代编译器中不需要使用\",{\"1\":{\"334\":1}}],[\"在scanf中\",{\"1\":{\"331\":1}}],[\"在printf中和\",{\"1\":{\"331\":1}}],[\"在printf中对应float类型\",{\"1\":{\"331\":1}}],[\"在不同计算机上\",{\"1\":{\"330\":1}}],[\"在不断进行入队和出队的过程中\",{\"1\":{\"161\":1}}],[\"在其原码的基础上\",{\"1\":{\"327\":1}}],[\"在需要的时候随时引用这些头文件\",{\"1\":{\"320\":1}}],[\"在替换文本中可以含有各个形参带参宏调用的一般形式为\",{\"1\":{\"319\":1}}],[\"在展开过程中不仅要进行文本替换\",{\"1\":{\"319\":1}}],[\"在宏替换时\",{\"1\":{\"319\":1}}],[\"在宏调用中的参数称为\",{\"1\":{\"319\":1}}],[\"在宏定义中的参数称为\",{\"1\":{\"319\":1}}],[\"在宏定义的替换文本中可以使用已经定义的宏名\",{\"1\":{\"318\":1}}],[\"在宏展开时由预处理程序层层替换\",{\"1\":{\"318\":1}}],[\"在编写分配内存的代码时\",{\"1\":{\"315\":1}}],[\"在编译之前\",{\"1\":{\"271\":1}}],[\"在编译之前执行\",{\"1\":{\"255\":1}}],[\"在编译过程中执行2\",{\"1\":{\"255\":1}}],[\"在堆区开辟一个\",{\"1\":{\"314\":1}}],[\"在文本读取过程中\",{\"1\":{\"310\":1}}],[\"在c++中struct被升级为了类\",{\"1\":{\"361\":1}}],[\"在c语言中struct是结构体不能在struct里定义函数\",{\"1\":{\"361\":1}}],[\"在c语言中使用char数组表示\",{\"1\":{\"332\":1}}],[\"在c语言中\",{\"1\":{\"302\":1}}],[\"在c程序中使用的非常多\",{\"1\":{\"276\":1}}],[\"在定义时也可以不给出共用体名\",{\"1\":{\"303\":1}}],[\"在定义时也可以不给出结构体名\",{\"1\":{\"302\":1}}],[\"在定义结构体的同时定义结构体变量\",{\"1\":{\"302\":1}}],[\"在定义函数时\",{\"1\":{\"286\":1}}],[\"在程序入口前先将static指针初始化为空\",{\"1\":{\"354\":2}}],[\"在程序入口之前完成单例对象的初始化\",{\"1\":{\"354\":1}}],[\"在程序结束时才被释放\",{\"1\":{\"288\":1}}],[\"在程序的任何地方都可以被访问\",{\"1\":{\"288\":1}}],[\"在函数内定义的变量\",{\"1\":{\"288\":1}}],[\"在函数和代码块\",{\"1\":{\"288\":1}}],[\"在调用函数时\",{\"1\":{\"286\":1}}],[\"在windows上\",{\"1\":{\"271\":1}}],[\"在没有给指针变量显式初始化的情况下\",{\"1\":{\"267\":1}}],[\"在内存中开辟了一个字符数组用来存放字符串\",{\"1\":{\"263\":1}}],[\"在特定情况下数组名可以被视为一个指针\",{\"1\":{\"263\":1}}],[\"在32位系统中\",{\"1\":{\"261\":1}}],[\"在运行时才完成替换\",{\"1\":{\"255\":1}}],[\"在给某个字符数组赋值时\",{\"1\":{\"245\":1}}],[\"在深度优先遍历中\",{\"1\":{\"225\":1}}],[\"在遍历邻接顶点的过程中\",{\"1\":{\"223\":1}}],[\"在循环的每轮迭代中\",{\"1\":{\"223\":1}}],[\"在顶点对应链表中查找并删除指定边\",{\"1\":{\"219\":1}}],[\"在顶点对应链表的末尾添加边即可\",{\"1\":{\"219\":1}}],[\"在顶点列表中移除索引\",{\"1\":{\"218\":1}}],[\"在邻接表中删除顶点\",{\"1\":{\"219\":1}}],[\"在邻接表中添加一个新链表\",{\"1\":{\"219\":1}}],[\"在邻接表中添加一个链表\",{\"1\":{\"219\":1}}],[\"在邻接表中创建n个顶点和2m条边\",{\"1\":{\"219\":1}}],[\"在邻接表中需要通过遍历链表来查找边\",{\"1\":{\"217\":1}}],[\"在邻接矩阵中删除索引\",{\"1\":{\"218\":2}}],[\"在邻接矩阵中删除一行一列\",{\"1\":{\"218\":1}}],[\"在邻接矩阵的尾部添加一行一列\",{\"1\":{\"218\":1}}],[\"在有向图中\",{\"1\":{\"214\":1}}],[\"在无向图中\",{\"1\":{\"214\":1,\"219\":1}}],[\"在满二叉树中\",{\"1\":{\"183\":1}}],[\"在随机输入\",{\"1\":{\"176\":1}}],[\"在相同的哈希函数顺序下进行查找\",{\"1\":{\"174\":1}}],[\"在相同的输入和运行条件下\",{\"1\":{\"131\":1}}],[\"在该函数中进行单例对象的释放动作\",{\"1\":{\"354\":1}}],[\"在该位置插入节点\",{\"1\":{\"194\":1}}],[\"在该机制下\",{\"1\":{\"172\":1}}],[\"在该表示下\",{\"1\":{\"21\":1}}],[\"在原始哈希表中\",{\"1\":{\"170\":1}}],[\"在哈希表中访问对应的桶\",{\"1\":{\"167\":1}}],[\"在哈希表中\",{\"1\":{\"167\":2}}],[\"在哈希表中进行增删查改的时间复杂度都是\",{\"1\":{\"166\":1}}],[\"在队列的实现基础上\",{\"1\":{\"164\":1}}],[\"在队列中\",{\"1\":{\"162\":1}}],[\"在越过数组尾部时\",{\"1\":{\"161\":1}}],[\"在初始化列表时\",{\"1\":{\"158\":1}}],[\"在基于链表的实现中\",{\"1\":{\"158\":1}}],[\"在基于数组的实现中\",{\"1\":{\"158\":1}}],[\"在环形链表中\",{\"1\":{\"153\":1}}],[\"在链表表示下\",{\"1\":{\"188\":1}}],[\"在链表中搜索\",{\"1\":{\"219\":1}}],[\"在链表中查找值为\",{\"1\":{\"151\":1}}],[\"在链表中访问节点的效率较低\",{\"1\":{\"150\":1}}],[\"在链表中删除节点也非常方便\",{\"1\":{\"149\":1}}],[\"在链表中插入节点非常容易\",{\"1\":{\"148\":1}}],[\"在链表的节点\",{\"1\":{\"148\":1}}],[\"在复杂的系统环境中\",{\"1\":{\"145\":1}}],[\"在大括号中循环体语句之后执行\",{\"1\":{\"298\":1}}],[\"在大数据量下的效率较低\",{\"1\":{\"148\":1}}],[\"在大数据量下非常耗时\",{\"1\":{\"29\":1}}],[\"在大多数编程语言中\",{\"1\":{\"143\":1}}],[\"在未指定初始值的情况下\",{\"1\":{\"139\":1}}],[\"在迭代中\",{\"1\":{\"136\":1}}],[\"在介绍时间复杂度和空间复杂度之前\",{\"1\":{\"136\":1}}],[\"在能够解决问题的前提下\",{\"1\":{\"135\":1}}],[\"在数据添加和删除操作上更加便捷\",{\"1\":{\"132\":1}}],[\"在数组很大的情况下非常耗时\",{\"1\":{\"145\":1}}],[\"在数组的索引\",{\"1\":{\"141\":1}}],[\"在数组的一半中进行查找\",{\"1\":{\"64\":1}}],[\"在数组的一半中搜索目标元素\",{\"1\":{\"64\":1}}],[\"在数组中删除首元素的时间复杂度为o\",{\"1\":{\"161\":1}}],[\"在数组中插入元素的时间复杂度为o\",{\"1\":{\"148\":1}}],[\"在数组中查找指定元素\",{\"1\":{\"144\":1}}],[\"在数组中查找指定元素需要遍历数组\",{\"1\":{\"144\":1}}],[\"在数组中访问元素非常高效\",{\"1\":{\"140\":1}}],[\"在数组中进行查找\",{\"1\":{\"64\":1}}],[\"在数组中搜索目标元素\",{\"1\":{\"64\":1}}],[\"在数组中的索引\",{\"1\":{\"56\":1}}],[\"在数组和链表中\",{\"1\":{\"14\":1}}],[\"在1\",{\"1\":{\"127\":1}}],[\"在许多实际问题中有着广泛的应用\",{\"1\":{\"113\":1}}],[\"在限定背包容量下能放入物品的最大价值\",{\"1\":{\"107\":1}}],[\"在本题中\",{\"1\":{\"102\":1}}],[\"在本节中\",{\"1\":{\"92\":1,\"107\":1}}],[\"在做出这两种选择时\",{\"1\":{\"99\":1}}],[\"在做出选择\",{\"1\":{\"81\":1}}],[\"在分解过程中会出现许多重叠子问题\",{\"1\":{\"97\":1}}],[\"在分治\",{\"1\":{\"97\":1}}],[\"在分析这样做的原因之前\",{\"1\":{\"17\":1}}],[\"在动态规划问题中\",{\"1\":{\"96\":1}}],[\"在以下代码中\",{\"1\":{\"95\":1}}],[\"在逐个放置皇后的过程中\",{\"1\":{\"87\":1}}],[\"在下图中\",{\"1\":{\"86\":1}}],[\"在记录结果时\",{\"1\":{\"82\":1}}],[\"在上图中\",{\"1\":{\"214\":2}}],[\"在上面的案例中\",{\"1\":{\"99\":1}}],[\"在上一题的代码的基础上\",{\"1\":{\"82\":1}}],[\"在上述三种算法中\",{\"1\":{\"44\":1}}],[\"在这两个选择之下生成的所有排列都是重复的\",{\"1\":{\"82\":1}}],[\"在这种设定下\",{\"1\":{\"170\":1}}],[\"在这种情况下\",{\"1\":{\"33\":1,\"78\":1}}],[\"在这种想法的驱动下\",{\"1\":{\"18\":1}}],[\"在第一轮选择2之后\",{\"1\":{\"82\":1}}],[\"在第一轮中\",{\"1\":{\"82\":1}}],[\"在第三轮剪掉元素\",{\"1\":{\"81\":1}}],[\"在一个分支结构中又嵌套了另一个分支结构\",{\"1\":{\"297\":1}}],[\"在一个字符串中查找另一个字符串\",{\"1\":{\"292\":1}}],[\"在一个图中\",{\"1\":{\"79\":1}}],[\"在一个序列中\",{\"1\":{\"63\":1}}],[\"在9x9的网格中填入数字1~9\",{\"1\":{\"79\":1}}],[\"在nxn\",{\"1\":{\"79\":1}}],[\"在递归调用中需要保存当前的状态\",{\"1\":{\"78\":1}}],[\"在处理大规模或者复杂问题时\",{\"1\":{\"78\":1}}],[\"在搜索过程中引入一些策略或者估计值\",{\"1\":{\"78\":1}}],[\"在搜索过程中\",{\"1\":{\"76\":2,\"85\":1}}],[\"在例题一代码的基础上\",{\"1\":{\"75\":1}}],[\"在移动圆盘的过程中\",{\"1\":{\"70\":1}}],[\"在归并排序和构建二叉树中\",{\"1\":{\"70\":1}}],[\"在构建左子树时\",{\"1\":{\"66\":1}}],[\"在实现代码中\",{\"1\":{\"64\":1}}],[\"在实际中\",{\"1\":{\"47\":1,\"178\":1}}],[\"在之前的章节中\",{\"1\":{\"64\":1}}],[\"在二叉树的中间层通常存在许多\",{\"1\":{\"190\":1}}],[\"在二叉树中插入与删除节点可以通过修改指针来实现\",{\"1\":{\"182\":1}}],[\"在二叉树中\",{\"1\":{\"180\":1,\"181\":1}}],[\"在二叉树中搜索所有值为7的节点\",{\"1\":{\"75\":1,\"76\":1}}],[\"在二叉搜索树的删除节点方法的基础上\",{\"1\":{\"207\":1}}],[\"在二叉搜索树\",{\"1\":{\"64\":1}}],[\"在二分查找中\",{\"1\":{\"64\":1}}],[\"在二分循环中\",{\"1\":{\"20\":1}}],[\"在排序算法中\",{\"1\":{\"60\":1}}],[\"在此基础上\",{\"1\":{\"55\":1,\"101\":1}}],[\"在每个节点都会遇到三个位置\",{\"1\":{\"187\":1}}],[\"在每个桶内部分别执行排序\",{\"1\":{\"49\":1}}],[\"在每行放置一个皇后\",{\"1\":{\"88\":1}}],[\"在每次决定放置前\",{\"1\":{\"89\":1}}],[\"在每次\",{\"1\":{\"75\":1}}],[\"在每轮中使用\",{\"1\":{\"42\":1}}],[\"在每轮中判断两个整数的和是否为\",{\"1\":{\"29\":1}}],[\"在代码块\",{\"1\":{\"288\":1}}],[\"在代码实现中\",{\"1\":{\"48\":1,\"111\":1,\"194\":1}}],[\"在代码中\",{\"1\":{\"36\":1,\"73\":1}}],[\"在交换堆顶元素和堆底元素时\",{\"1\":{\"48\":1}}],[\"在合并过程中\",{\"1\":{\"46\":1}}],[\"在执行哨兵划分操作时\",{\"1\":{\"44\":1}}],[\"在哨兵划分的最后一步\",{\"1\":{\"43\":1}}],[\"在输入数组完全倒序的情况下\",{\"1\":{\"43\":1}}],[\"在平均情况下\",{\"1\":{\"43\":1}}],[\"在插入操作过程中\",{\"1\":{\"41\":1}}],[\"在遇到有序数据时\",{\"1\":{\"41\":1}}],[\"在最佳结构和最差结构下\",{\"1\":{\"184\":1}}],[\"在最差情况下\",{\"1\":{\"41\":1,\"43\":1,\"69\":1,\"120\":1,\"186\":1,\"187\":1}}],[\"在最后一轮中\",{\"1\":{\"41\":1}}],[\"在引入记忆化后\",{\"1\":{\"104\":1}}],[\"在引入\",{\"1\":{\"37\":1}}],[\"在选择排序算法时\",{\"1\":{\"34\":1}}],[\"在算法中\",{\"1\":{\"136\":1}}],[\"在算法中直接被使用\",{\"1\":{\"16\":1}}],[\"在算法设计中\",{\"1\":{\"135\":1}}],[\"在算法题中\",{\"1\":{\"28\":1}}],[\"在i=j时为空\",{\"1\":{\"21\":1}}],[\"在区间\",{\"1\":{\"20\":4,\"21\":2,\"23\":2,\"24\":2,\"140\":1}}],[\"在庞大的\",{\"1\":{\"18\":1}}],[\"在\",{\"1\":{\"18\":1,\"54\":1,\"67\":1,\"74\":1,\"146\":1,\"182\":1,\"206\":1,\"287\":1}}],[\"在计算机中\",{\"1\":{\"18\":1}}],[\"在绝大多数现代操作系统中\",{\"1\":{\"16\":1}}],[\"可调用对象\",{\"1\":{\"379\":1}}],[\"可直接使用它们\",{\"1\":{\"285\":1}}],[\"可直接返回结果\",{\"1\":{\"39\":1}}],[\"可维护性和重用性一个c程序可以由一个或多个源文件构成\",{\"1\":{\"285\":1}}],[\"可变长度数组等\",{\"1\":{\"241\":1}}],[\"可分为连通图\",{\"1\":{\"214\":1}}],[\"可分为连续空间存储\",{\"1\":{\"15\":1}}],[\"可分为无向图\",{\"1\":{\"214\":1}}],[\"可能会在\",{\"1\":{\"379\":1}}],[\"可能造成精度损失\",{\"1\":{\"286\":1}}],[\"可能大于堆中其他元素\",{\"1\":{\"211\":1}}],[\"可能需要进行分批发送\",{\"1\":{\"442\":1}}],[\"可能需要\",{\"1\":{\"18\":1}}],[\"可选择向上爬\",{\"1\":{\"92\":1}}],[\"可用贪心算法等启发式算法来解决\",{\"1\":{\"79\":1}}],[\"可排序对象\",{\"1\":{\"54\":1}}],[\"可达到最佳时间复杂度o\",{\"1\":{\"39\":1}}],[\"可以对管道当中获取的命令进行解析处理\",{\"1\":{\"405\":1}}],[\"可以发现这两个进程确实是两个毫不相关的进程\",{\"1\":{\"403\":1}}],[\"可以标识并且在内存中有存储位置的表达式\",{\"1\":{\"379\":1}}],[\"可以访问私有\",{\"1\":{\"361\":1}}],[\"可以访问数组中的元素\",{\"1\":{\"244\":1}}],[\"可以参考以下两种方式\",{\"1\":{\"354\":1}}],[\"可以不加\",{\"1\":{\"344\":2}}],[\"可以获取数据类型或变量\",{\"1\":{\"335\":1}}],[\"可以表示单个字符\",{\"1\":{\"332\":1}}],[\"可以表示任意的\",{\"1\":{\"221\":1}}],[\"可以指定尾数部分所保留的小数位数\",{\"1\":{\"331\":1}}],[\"可以指定小数位数\",{\"1\":{\"331\":3}}],[\"可以保证是32位\",{\"1\":{\"330\":1}}],[\"可以保证找到最优解\",{\"1\":{\"114\":1}}],[\"可以结合使用\",{\"1\":{\"330\":1}}],[\"可以使用其特定的成员或行为\",{\"1\":{\"382\":1}}],[\"可以使用\",{\"1\":{\"373\":1}}],[\"可以使用long\",{\"1\":{\"330\":1}}],[\"可以使用这个指针来进行文件的读取和写入操作\",{\"1\":{\"310\":1}}],[\"可以把它放在\",{\"1\":{\"321\":1}}],[\"可以完成多重判断\",{\"1\":{\"321\":1}}],[\"可以在struct中定义函数\",{\"1\":{\"361\":1}}],[\"可以在库文件里使用\",{\"1\":{\"321\":1}}],[\"可以在程序开头处给出函数原型\",{\"1\":{\"287\":1}}],[\"可以省略\",{\"1\":{\"331\":1}}],[\"可以省略如果自定义的头文件在源文件所在目录的上级或者更上级\",{\"1\":{\"320\":1}}],[\"可以省略存储所有\",{\"1\":{\"190\":1}}],[\"可以是以下值之一\",{\"1\":{\"310\":1}}],[\"可以是常量\",{\"1\":{\"251\":1}}],[\"可以包括文件路径和文件名\",{\"1\":{\"310\":1}}],[\"可以为基本类型一次起多个别名\",{\"1\":{\"304\":1}}],[\"可以认为是各成员占的内存长度的叠加\",{\"1\":{\"303\":1}}],[\"可以进行赋值和取值\",{\"1\":{\"302\":1,\"303\":1}}],[\"可以极大提高c\",{\"1\":{\"270\":1}}],[\"可以先声明变量再赋值\",{\"1\":{\"250\":1}}],[\"可以引用这块内存区域\",{\"1\":{\"249\":1}}],[\"可以输出得更加整齐\",{\"1\":{\"246\":1}}],[\"可以将链表转化为\",{\"1\":{\"217\":1}}],[\"可以到达其余任意顶点\",{\"1\":{\"214\":1}}],[\"可以观察到\",{\"1\":{\"202\":1}}],[\"可以直接使用\",{\"1\":{\"289\":1}}],[\"可以直接删除\",{\"1\":{\"195\":1}}],[\"可以直接进行运算的类型\",{\"1\":{\"16\":1}}],[\"可以根据二叉搜索树的性质来查找\",{\"1\":{\"193\":1}}],[\"可以充分发挥二叉树\",{\"1\":{\"184\":1}}],[\"可以减少因取模操作而产生的周期性模式\",{\"1\":{\"177\":1}}],[\"可以最大化地保证哈希值的均匀分布\",{\"1\":{\"177\":1}}],[\"可以产生均匀分布的输出\",{\"1\":{\"176\":1}}],[\"可以看做是一种数据的流动\",{\"1\":{\"308\":1}}],[\"可以看到\",{\"1\":{\"161\":1,\"403\":1}}],[\"可以看出\",{\"1\":{\"63\":1}}],[\"可以朝两个方向遍历链表\",{\"1\":{\"153\":1}}],[\"可以找到近似最优解\",{\"1\":{\"114\":1}}],[\"可以通过相同的方式进行递归划分\",{\"1\":{\"72\":1}}],[\"可以合并为一个有序数组\",{\"1\":{\"59\":1}}],[\"可以独立解决\",{\"1\":{\"59\":1}}],[\"可以避免在此重复执行昂贵的次方计算\",{\"1\":{\"56\":1}}],[\"可以增加一个标志位\",{\"1\":{\"39\":1}}],[\"可以转化为查找\",{\"1\":{\"27\":2}}],[\"可读性更好\",{\"1\":{\"24\":1}}],[\"基类析构被声明为虚析构函数\",{\"1\":{\"376\":1}}],[\"基类的虚拟析构函数\",{\"1\":{\"376\":1}}],[\"基类虚函数返回基类对象的指针或引用\",{\"1\":{\"376\":1}}],[\"基类指针强制给派生类指针\",{\"1\":{\"373\":1}}],[\"基类指针可以强转给派生类指针\",{\"1\":{\"373\":1}}],[\"基类指针赋值派生类指针\",{\"1\":{\"373\":1}}],[\"基类对象不可以赋值给派生类对象\",{\"1\":{\"373\":1}}],[\"基类和派生类对象的赋值转换\",{\"1\":{\"373\":1}}],[\"基类\",{\"1\":{\"373\":3,\"376\":3}}],[\"基类base转换为派生类derived\",{\"1\":{\"357\":1}}],[\"基数排序无法保证得到正确的排序结果\",{\"1\":{\"56\":1}}],[\"基数排序也稳定\",{\"1\":{\"56\":1}}],[\"基数排序需要借助长度为n和d的数组\",{\"1\":{\"56\":1}}],[\"基数排序的流程如下所示\",{\"1\":{\"56\":1}}],[\"基数排序利用数字各位之间的递进关系\",{\"1\":{\"55\":1}}],[\"基数排序\",{\"1\":{\"55\":1,\"56\":1}}],[\"基数排序算法流程\",{\"0\":{\"56\":1}}],[\"基数排序算法\",{\"0\":{\"55\":1}}],[\"基准数可能会被交换至相等元素的右侧\",{\"1\":{\"43\":1}}],[\"基准数\",{\"1\":{\"42\":3}}],[\"基本语法\",{\"1\":{\"281\":1}}],[\"基本情况的解是已知的\",{\"1\":{\"136\":1}}],[\"基本满足了汉字的计算机处理需要然而\",{\"1\":{\"18\":1}}],[\"基本数据类型以二进制的形式存储在计算机中\",{\"1\":{\"16\":1}}],[\"基本数据类型是\",{\"1\":{\"16\":1}}],[\"基本数据类型\",{\"0\":{\"16\":1}}],[\"基于邻接表实现的无向图类\",{\"1\":{\"219\":1}}],[\"基于邻接矩阵实现的无向图结构体\",{\"1\":{\"218\":1}}],[\"基于对称性\",{\"1\":{\"202\":1}}],[\"基于链式地址实现的哈希表的操作方法发生了以下变化\",{\"1\":{\"170\":1}}],[\"基于链表实现的队列\",{\"1\":{\"160\":1}}],[\"基于链表实现的栈可以提供更加稳定的效率表现\",{\"1\":{\"158\":1}}],[\"基于链表实现的栈\",{\"1\":{\"156\":1}}],[\"基于链表可实现\",{\"1\":{\"15\":1}}],[\"基于环形数组实现的双向队列\",{\"1\":{\"164\":1}}],[\"基于环形数组实现的队列\",{\"1\":{\"161\":1}}],[\"基于双向链表实现的双向队列\",{\"1\":{\"163\":1}}],[\"基于此设计\",{\"1\":{\"161\":1}}],[\"基于数组实现的哈希表\",{\"1\":{\"167\":1}}],[\"基于数组实现的栈可能造成一定的空间浪费然而\",{\"1\":{\"158\":1}}],[\"基于数组实现的栈在触发扩容时效率会降低\",{\"1\":{\"158\":1}}],[\"基于数组实现的栈\",{\"1\":{\"157\":1}}],[\"基于数组可实现\",{\"1\":{\"15\":1}}],[\"基于迭代实现动态规划解法\",{\"1\":{\"105\":1}}],[\"基于回溯算法框架的代码实现虽然显得啰唆\",{\"1\":{\"77\":1}}],[\"基于变量描述子树区间\",{\"0\":{\"68\":1}}],[\"基于比较的排序算法\",{\"1\":{\"49\":1}}],[\"基于比较的排序依赖比较运算符\",{\"1\":{\"33\":1}}],[\"基于\",{\"1\":{\"30\":1}}],[\"基于补码表示\",{\"1\":{\"17\":1}}],[\"3号文件描述符对应的是监听套接字\",{\"1\":{\"398\":1}}],[\"3>\",{\"1\":{\"367\":1}}],[\"35\",{\"1\":{\"338\":1}}],[\"3e\",{\"1\":{\"331\":1}}],[\"38\",{\"1\":{\"331\":1}}],[\"333280960\",{\"1\":{\"373\":1}}],[\"33\",{\"1\":{\"304\":2}}],[\"3的12次方\",{\"1\":{\"291\":2}}],[\"3的边界情况\",{\"1\":{\"128\":1}}],[\"34的绝对值\",{\"1\":{\"291\":2}}],[\"34\",{\"1\":{\"266\":1,\"291\":2}}],[\"3sum\",{\"1\":{\"257\":1}}],[\"308\",{\"1\":{\"331\":1}}],[\"30\",{\"1\":{\"244\":5,\"246\":3,\"250\":1,\"251\":3,\"262\":6,\"263\":5,\"267\":1,\"279\":1,\"288\":3,\"301\":1,\"361\":4,\"379\":2}}],[\"300u\",{\"1\":{\"330\":2}}],[\"30000\",{\"1\":{\"246\":1}}],[\"3000\",{\"1\":{\"246\":1,\"265\":2}}],[\"300\",{\"1\":{\"244\":1,\"246\":1,\"286\":1,\"288\":1}}],[\"31向上取整\",{\"1\":{\"291\":4}}],[\"31\",{\"1\":{\"177\":1,\"244\":2,\"286\":1,\"291\":2,\"335\":1,\"361\":7}}],[\"36\",{\"1\":{\"168\":2,\"244\":2}}],[\"3这三个因子中\",{\"1\":{\"127\":1}}],[\"3阶的代价分别为1\",{\"1\":{\"98\":1}}],[\"32位\",{\"1\":{\"330\":7,\"331\":2}}],[\"32\",{\"1\":{\"18\":2,\"330\":6}}],[\"3d\",{\"1\":{\"16\":1}}],[\"3\",{\"0\":{\"16\":1,\"22\":1,\"23\":1,\"24\":1,\"37\":1,\"38\":1,\"39\":1,\"60\":1,\"61\":1,\"62\":1,\"68\":1,\"73\":1,\"77\":1,\"83\":1,\"90\":1,\"95\":1,\"100\":1,\"101\":1,\"102\":1,\"103\":2,\"104\":1,\"105\":1,\"106\":1,\"110\":1,\"115\":1,\"121\":1,\"125\":1,\"129\":1,\"133\":1,\"141\":1,\"149\":1,\"152\":1,\"158\":1,\"162\":1,\"163\":1,\"164\":1,\"174\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":2,\"183\":1,\"188\":1,\"189\":1,\"190\":1,\"191\":2,\"195\":1,\"203\":1,\"206\":1,\"211\":1,\"218\":1,\"224\":1,\"229\":1,\"241\":1,\"245\":1,\"251\":1,\"256\":1,\"257\":1,\"258\":1,\"259\":2,\"263\":1,\"272\":1,\"277\":1,\"287\":1,\"298\":1,\"303\":1,\"310\":1,\"314\":1,\"319\":1,\"327\":1,\"332\":1,\"335\":1,\"343\":1,\"344\":1,\"345\":1,\"390\":1,\"397\":1,\"404\":1,\"438\":1,\"441\":1,\"456\":1,\"463\":1,\"470\":1,\"474\":1,\"496\":1,\"500\":1,\"531\":1,\"535\":1},\"1\":{\"16\":1,\"18\":4,\"33\":1,\"36\":1,\"41\":2,\"48\":1,\"50\":1,\"51\":3,\"53\":1,\"54\":1,\"67\":7,\"70\":1,\"72\":2,\"76\":1,\"77\":1,\"81\":4,\"85\":14,\"95\":1,\"96\":1,\"98\":2,\"99\":2,\"128\":10,\"139\":1,\"147\":2,\"172\":1,\"178\":1,\"182\":1,\"183\":1,\"190\":1,\"201\":1,\"203\":1,\"214\":1,\"218\":1,\"219\":1,\"240\":1,\"243\":1,\"244\":6,\"245\":1,\"246\":8,\"249\":1,\"250\":1,\"251\":1,\"255\":4,\"257\":1,\"258\":1,\"261\":1,\"262\":8,\"263\":4,\"264\":1,\"267\":1,\"271\":1,\"272\":1,\"276\":5,\"279\":2,\"280\":3,\"283\":1,\"285\":1,\"286\":5,\"287\":1,\"288\":5,\"289\":2,\"290\":3,\"291\":3,\"292\":2,\"297\":2,\"298\":12,\"299\":3,\"301\":1,\"302\":1,\"303\":1,\"304\":1,\"305\":1,\"309\":1,\"310\":2,\"313\":3,\"314\":2,\"315\":1,\"317\":2,\"318\":9,\"319\":3,\"320\":1,\"321\":3,\"325\":3,\"326\":1,\"330\":1,\"331\":5,\"332\":1,\"338\":1,\"342\":1,\"344\":2,\"348\":14,\"351\":2,\"354\":8,\"357\":3,\"361\":5,\"364\":1,\"367\":2,\"370\":1,\"373\":2,\"376\":1,\"379\":28,\"382\":1,\"404\":2,\"406\":1,\"436\":1}}],[\"动态内存管理\",{\"1\":{\"379\":1}}],[\"动态内存分配\",{\"0\":{\"235\":1,\"311\":1},\"1\":{\"312\":1}}],[\"动态申请多个类的空间\",{\"1\":{\"364\":1}}],[\"动态申请释放一个类的空间\",{\"1\":{\"364\":1}}],[\"动态申请释放一个某类型空间并初始化\",{\"1\":{\"364\":1}}],[\"动态申请释放一个空间\",{\"1\":{\"364\":1}}],[\"动态申请释放多个某类型空间并初始化\",{\"1\":{\"364\":1}}],[\"动态申请释放多个某类型空间\",{\"1\":{\"364\":1}}],[\"动态转换\",{\"1\":{\"357\":1}}],[\"动态创建数组\",{\"1\":{\"314\":1}}],[\"动态分配的内存块地址\",{\"1\":{\"314\":1}}],[\"动态分配内存\",{\"1\":{\"314\":1}}],[\"动态数组\",{\"1\":{\"170\":1,\"219\":1}}],[\"动态数据结构\",{\"1\":{\"15\":1}}],[\"动态性\",{\"1\":{\"15\":1}}],[\"动态规划更高效\",{\"1\":{\"114\":1}}],[\"动态规划会根据之前阶段的所有决策来考虑当前决策\",{\"1\":{\"113\":1}}],[\"动态规划实质上就是在状态转移中填充dp表的过程\",{\"1\":{\"110\":1}}],[\"动态规划的解题流程会因问题的性质和难度而有所不同\",{\"1\":{\"102\":1}}],[\"动态规划问题还有一些判断的\",{\"1\":{\"101\":1}}],[\"动态规划问题探索\",{\"0\":{\"92\":1}}],[\"动态规划常用来求解最优化问题\",{\"1\":{\"97\":1}}],[\"动态规划中的子问题是相互依赖的\",{\"1\":{\"97\":1}}],[\"动态规划也对问题进行递归分解\",{\"1\":{\"97\":1}}],[\"动态规划也使用\",{\"1\":{\"95\":1}}],[\"动态规划是一种\",{\"1\":{\"95\":1}}],[\"动态规划\",{\"0\":{\"2\":1,\"91\":1,\"95\":1,\"105\":1,\"110\":1},\"1\":{\"92\":1,\"95\":1,\"97\":1,\"98\":1,\"99\":1,\"105\":1,\"110\":1}}],[\"等待子进程\",{\"1\":{\"405\":1}}],[\"等待数据准备完毕的通知\",{\"1\":{\"379\":1}}],[\"等待新进程结束\",{\"1\":{\"379\":2}}],[\"等待新线程结束\",{\"1\":{\"379\":1}}],[\"等待线程结束\",{\"1\":{\"379\":3}}],[\"等价\",{\"1\":{\"361\":1}}],[\"等价于\",{\"1\":{\"279\":3,\"320\":2}}],[\"等价于查找\",{\"1\":{\"26\":1}}],[\"等号右边的类型将转换为左边的类型\",{\"1\":{\"337\":1}}],[\"等同于\",{\"1\":{\"321\":2,\"330\":9}}],[\"等同于0\",{\"1\":{\"321\":1}}],[\"等到使用该块内存的时候\",{\"1\":{\"313\":1}}],[\"等符号\",{\"1\":{\"261\":1}}],[\"等手游中\",{\"1\":{\"214\":1}}],[\"等支持指针的语言中\",{\"1\":{\"146\":1}}],[\"等最优化描述\",{\"1\":{\"101\":1}}],[\"等\",{\"1\":{\"15\":1,\"108\":1,\"147\":1,\"178\":1,\"246\":1,\"270\":1,\"320\":1,\"330\":1,\"442\":2}}],[\"维度的数组\",{\"1\":{\"15\":1}}],[\"矩阵元素代表边\",{\"1\":{\"216\":1}}],[\"矩阵乘法\",{\"1\":{\"63\":1}}],[\"矩阵\",{\"1\":{\"15\":1}}],[\"而服务器则会一直在第一次调用的select函数中进行阻塞等待\",{\"1\":{\"439\":1}}],[\"而服务器在第一次调用select函数时只让select监视监听套接字的读事件\",{\"1\":{\"439\":1}}],[\"而服务端不从管道读取数据\",{\"1\":{\"403\":1}}],[\"而客户端需要做的就是\",{\"1\":{\"406\":1}}],[\"而override放在虚函数声明后\",{\"1\":{\"376\":1}}],[\"而另一部分参数保留为泛型形式\",{\"1\":{\"367\":1}}],[\"而初始化列表就是对象成员的定义\",{\"1\":{\"361\":1}}],[\"而后续调用getinstance函数获取单例对象只是一个读操作\",{\"1\":{\"354\":1}}],[\"而输入double类型时必须使用\",{\"1\":{\"331\":1}}],[\"而输入空间往往远大于输出空间\",{\"1\":{\"168\":1}}],[\"而形式值\",{\"1\":{\"327\":1}}],[\"而car1是一个car变量\",{\"1\":{\"302\":1}}],[\"而num1是一个具体的int变量\",{\"1\":{\"302\":1}}],[\"而不能是变量default是可选的\",{\"1\":{\"297\":1}}],[\"而不是外部实参\",{\"1\":{\"379\":1}}],[\"而不是进行深层次的拷贝\",{\"1\":{\"379\":1}}],[\"而不是使用初始值的类型\",{\"1\":{\"379\":1}}],[\"而不是直接用\",{\"1\":{\"379\":1}}],[\"而不是设置s2对象呢\",{\"1\":{\"361\":1}}],[\"而不是开一个临时变量进行值拷贝\",{\"1\":{\"348\":1}}],[\"而不是第一个元素的地址\",{\"1\":{\"263\":1}}],[\"而不是找出最优解\",{\"1\":{\"101\":1}}],[\"而argv\",{\"1\":{\"287\":1}}],[\"而指针返回的是本身的大小\",{\"1\":{\"263\":1}}],[\"而图则具有更高的自由度\",{\"1\":{\"221\":1}}],[\"而如果每个顶点都是唯一的\",{\"1\":{\"219\":1}}],[\"而如果最佳时间复杂度优于平均时间复杂度\",{\"1\":{\"33\":1}}],[\"而由于是无向图\",{\"1\":{\"218\":1}}],[\"而边的总数通常远小于n^2\",{\"1\":{\"217\":1}}],[\"而空节点的高度为\",{\"1\":{\"199\":1}}],[\"而二叉搜索树满足\",{\"1\":{\"196\":1}}],[\"而需要使用一个节点替换该节点\",{\"1\":{\"195\":1}}],[\"而广度优先遍历则遵循\",{\"1\":{\"186\":1}}],[\"而无法减少哈希冲突的发生\",{\"1\":{\"175\":1}}],[\"而无法确定该元素的左边和右边还有多少\",{\"1\":{\"24\":1}}],[\"而当所有节点都偏向一侧时\",{\"1\":{\"184\":1}}],[\"而当查询元素时\",{\"1\":{\"172\":1}}],[\"而当物品较多\",{\"1\":{\"108\":1}}],[\"而通过线性探测\",{\"1\":{\"172\":1}}],[\"而位于队列头部的人逐个离开\",{\"1\":{\"159\":1}}],[\"而对于出栈操作\",{\"1\":{\"156\":1}}],[\"而对于每棵子树\",{\"1\":{\"66\":1}}],[\"而链表是由多个独立的节点对象组成的\",{\"1\":{\"147\":1}}],[\"而有效地评估算法效率至关重要\",{\"1\":{\"135\":1}}],[\"而可以利用向下整除运算得到3的个数a\",{\"1\":{\"128\":1}}],[\"而高度由短板决定\",{\"1\":{\"123\":1}}],[\"而是需要将信息经过进一步的处理\",{\"1\":{\"404\":1}}],[\"而是由于主线程和新线程的并发执行\",{\"1\":{\"379\":1}}],[\"而是万能引用\",{\"1\":{\"379\":1}}],[\"而是等到某个线程需要使用这个单例对象时再进行创建\",{\"1\":{\"354\":1}}],[\"而是一个技术报告\",{\"1\":{\"351\":1}}],[\"而是一路向前地进行贪心选择\",{\"1\":{\"113\":1}}],[\"而是构造类型使用\",{\"1\":{\"332\":1}}],[\"而是存储该数字对应二进制数字的补码\",{\"1\":{\"327\":1}}],[\"而是存储密码的哈希值\",{\"1\":{\"176\":1}}],[\"而是当文件读取结束时\",{\"1\":{\"310\":1}}],[\"而是为了编码方便\",{\"1\":{\"304\":1}}],[\"而是跳过\",{\"1\":{\"173\":1}}],[\"而是利用一个常量\",{\"1\":{\"172\":1}}],[\"而是通过\",{\"1\":{\"171\":1}}],[\"而是在遍历每行时更新它\",{\"1\":{\"106\":1}}],[\"而是将求解问题看作一系列决策步骤\",{\"1\":{\"93\":1}}],[\"而是将它们展开在\",{\"1\":{\"81\":1}}],[\"而与过去经历的所有状态无关\",{\"1\":{\"99\":1}}],[\"而与全排列问题不同的是\",{\"1\":{\"85\":1}}],[\"而只需两个变量滚动前进即可\",{\"1\":{\"96\":1}}],[\"而且符合整型\",{\"1\":{\"297\":1}}],[\"而且会在编译阶段进行安全检查\",{\"1\":{\"255\":1}}],[\"而且在合理的剪枝操作下\",{\"1\":{\"78\":1}}],[\"而且解可以合并\",{\"1\":{\"72\":1}}],[\"而在宏调用中\",{\"1\":{\"319\":1}}],[\"而在内存中\",{\"1\":{\"246\":1}}],[\"而在\",{\"1\":{\"75\":1}}],[\"而在树中\",{\"1\":{\"14\":1}}],[\"而越过叶节点或返回父节点的\",{\"1\":{\"75\":1}}],[\"而f\",{\"1\":{\"72\":1}}],[\"而各条边\",{\"1\":{\"69\":1}}],[\"而为了描述这些索引区间\",{\"1\":{\"68\":1}}],[\"而分治搜索每轮可以排除一半选项\",{\"1\":{\"64\":1}}],[\"而非静态成员函数必须通过对象才能调用\",{\"1\":{\"354\":1}}],[\"而非\",{\"1\":{\"56\":1}}],[\"而非比较排序不使用比较运算符\",{\"1\":{\"33\":1}}],[\"而像\",{\"1\":{\"44\":1}}],[\"而大于基准数的元素移到其右侧\",{\"1\":{\"42\":1}}],[\"而j指向最右一个\",{\"1\":{\"27\":1}}],[\"而\",{\"1\":{\"18\":1,\"46\":1,\"313\":1,\"321\":1}}],[\"而这带来了许多问题\",{\"1\":{\"18\":1}}],[\"而哈希表的实现可能同时包含数组和链表\",{\"1\":{\"15\":1}}],[\"两步\",{\"1\":{\"442\":1}}],[\"两边量的数据类型不同时\",{\"1\":{\"337\":1}}],[\"两者绝对值的和是无符号整数的最大值再加\",{\"1\":{\"337\":1}}],[\"两者互不影响静态全局变量对需要编译多个源代码文件的程序\",{\"1\":{\"289\":1}}],[\"两者背后的思想是一致的\",{\"1\":{\"186\":1}}],[\"两者之和代表爬到第n阶的方案总数\",{\"1\":{\"99\":1}}],[\"两项数据\",{\"1\":{\"166\":1}}],[\"两种实现都支持栈定义中的各项操作\",{\"1\":{\"158\":1}}],[\"两种\",{\"1\":{\"87\":1}}],[\"两种剪枝对比\",{\"0\":{\"83\":1}}],[\"两种物理结构在时间效率和空间效率方面呈现出互补的特点\",{\"1\":{\"15\":1}}],[\"两个特例也构成重载\",{\"1\":{\"376\":1}}],[\"两个已经存在的对象赋值\",{\"1\":{\"361\":1}}],[\"两个已经存在的对象之间赋值\",{\"1\":{\"361\":1}}],[\"两个函数\",{\"1\":{\"309\":1}}],[\"两个变量\",{\"1\":{\"302\":1}}],[\"两个操作数都为假\",{\"1\":{\"278\":1}}],[\"两个操作数都为真\",{\"1\":{\"278\":1}}],[\"两个操作数都是整数执行整数除法\",{\"1\":{\"276\":1}}],[\"两个操作互为逆向\",{\"1\":{\"75\":1}}],[\"两个方向的边等价\",{\"1\":{\"216\":1}}],[\"两个学号指向了同一个姓名\",{\"1\":{\"168\":1}}],[\"两个有序子数组\",{\"1\":{\"59\":1}}],[\"两个步骤\",{\"1\":{\"58\":1}}],[\"两个维度进行分类\",{\"1\":{\"13\":1}}],[\"如除零错误\",{\"1\":{\"382\":1}}],[\"如逻辑断言失败\",{\"1\":{\"382\":1}}],[\"如临时对象\",{\"1\":{\"379\":1}}],[\"如一个数字\",{\"1\":{\"332\":1}}],[\"如一个数组或字符串\",{\"1\":{\"80\":1}}],[\"如精度要求更高可以使用long\",{\"1\":{\"331\":1}}],[\"如要取消宏定义使用\",{\"1\":{\"318\":1}}],[\"如有错误\",{\"1\":{\"318\":1}}],[\"如变量\",{\"1\":{\"288\":1,\"379\":1}}],[\"如本项目中\",{\"1\":{\"271\":1}}],[\"如uml工具\",{\"1\":{\"270\":1}}],[\"如\",{\"1\":{\"258\":4,\"261\":1,\"262\":1,\"330\":1,\"331\":6}}],[\"如3行4列形式\",{\"1\":{\"246\":1}}],[\"如下\",{\"1\":{\"330\":1,\"406\":1}}],[\"如下所示\",{\"1\":{\"287\":1}}],[\"如下代码\",{\"1\":{\"161\":1,\"361\":1}}],[\"如下图以\",{\"1\":{\"167\":1}}],[\"如下图\",{\"1\":{\"92\":1,\"94\":1,\"107\":1}}],[\"如下图所示\",{\"1\":{\"27\":2,\"29\":1,\"32\":1,\"36\":1,\"37\":1,\"46\":1,\"51\":2,\"71\":2,\"73\":1,\"76\":1,\"81\":2,\"82\":1,\"85\":1,\"87\":1,\"98\":1,\"99\":1,\"102\":1,\"104\":1,\"108\":1,\"110\":1,\"118\":2,\"122\":1,\"123\":2,\"126\":1,\"127\":1,\"128\":1,\"172\":1,\"189\":1,\"193\":1,\"195\":2,\"196\":1,\"201\":2,\"202\":1,\"204\":1,\"209\":1,\"211\":1,\"212\":1,\"214\":2,\"216\":1,\"222\":1,\"224\":1}}],[\"如上一节所述\",{\"1\":{\"150\":1}}],[\"如上图展示了数组的主要概念和存储方式\",{\"1\":{\"138\":1}}],[\"如上图所示\",{\"1\":{\"15\":1,\"20\":1,\"142\":1,\"148\":1,\"157\":1,\"162\":1}}],[\"如图所示\",{\"1\":{\"330\":1}}],[\"如图\",{\"1\":{\"213\":1,\"261\":2}}],[\"如图下图所示\",{\"1\":{\"70\":1,\"175\":1,\"180\":1,\"190\":2,\"192\":1}}],[\"如图下图\",{\"1\":{\"65\":1}}],[\"如图上图所示\",{\"1\":{\"18\":1,\"141\":1}}],[\"如图上图\",{\"1\":{\"15\":1}}],[\"如插入\",{\"1\":{\"63\":1}}],[\"如何定义枚举\",{\"1\":{\"301\":1}}],[\"如何避免野指针\",{\"1\":{\"267\":1}}],[\"如何基于\",{\"1\":{\"167\":1}}],[\"如何处理对角线约束呢\",{\"1\":{\"89\":1}}],[\"如何划分子树\",{\"0\":{\"67\":1}}],[\"如何判断分治问题\",{\"0\":{\"59\":1}}],[\"如何实现平均分配\",{\"0\":{\"51\":1}}],[\"如数字大小\",{\"1\":{\"32\":1}}],[\"如果服务器要能够对客户端进行响应\",{\"1\":{\"442\":1}}],[\"如果服务器在调用select函数时将timeout的值设置为特定的时间值\",{\"1\":{\"439\":1}}],[\"如果服务器在调用select函数时将timeout的值设置为0\",{\"1\":{\"439\":1}}],[\"如果直接调用read函数可能需要进行阻塞等待\",{\"1\":{\"440\":1}}],[\"如果5秒后依旧没有读事件就绪\",{\"1\":{\"439\":1}}],[\"如果select监视的文件描述符上没有事件就绪\",{\"1\":{\"439\":1}}],[\"如果是customexception\",{\"1\":{\"382\":1}}],[\"如果是就返回true\",{\"1\":{\"379\":1}}],[\"如果是未成年\",{\"1\":{\"297\":1}}],[\"如果使用无参构造函数创建的线程\",{\"1\":{\"379\":1}}],[\"如果使用隐式类型转换\",{\"1\":{\"313\":1}}],[\"如果基类的析构函数为虚函数\",{\"1\":{\"376\":1}}],[\"如果通过无参构造函数创建对象时\",{\"1\":{\"361\":1}}],[\"如果简单的将加锁解锁操作放到if语句前后\",{\"1\":{\"354\":1}}],[\"如果不对这个过程进行保护\",{\"1\":{\"354\":1}}],[\"如果不足以表示大数\",{\"1\":{\"330\":1}}],[\"如果线程通过getinstance获取到单例对象后\",{\"1\":{\"354\":1}}],[\"如果非常明确地希望转换数据类型\",{\"1\":{\"338\":1}}],[\"如果宽类型赋值给窄类型\",{\"1\":{\"337\":1}}],[\"如果窄类型赋值给宽类型\",{\"1\":{\"337\":1}}],[\"如果需要表示long\",{\"1\":{\"331\":1}}],[\"如果需要表示float类型字面量\",{\"1\":{\"331\":1}}],[\"如果需要表示无符号整数字面量\",{\"1\":{\"330\":1}}],[\"如果需要表示\",{\"1\":{\"330\":2}}],[\"如果需要修改某项功能\",{\"1\":{\"285\":1}}],[\"如果某个宏没有被定义过\",{\"1\":{\"321\":1}}],[\"如果某轮\",{\"1\":{\"39\":1}}],[\"如果它的参数是一个定义过的宏\",{\"1\":{\"321\":1}}],[\"如果宏extra\",{\"1\":{\"321\":1}}],[\"如果已经存在\",{\"1\":{\"321\":1}}],[\"如果多个判断条件皆不满足\",{\"1\":{\"321\":1}}],[\"如果有多个判断条件\",{\"1\":{\"321\":1}}],[\"如果有的话\",{\"1\":{\"271\":1}}],[\"如果要考虑单例对象的释放\",{\"1\":{\"354\":1}}],[\"如果要在源文件\",{\"1\":{\"320\":1}}],[\"如果要格式化输出地址\",{\"1\":{\"261\":1}}],[\"如果自定义的头文件在源文件的同级目录或源文件所在目录的下级目录\",{\"1\":{\"320\":1}}],[\"如果动态分配的内存空间没有被正确释放\",{\"1\":{\"314\":1}}],[\"如果在后面的代码中出现了宏名称\",{\"1\":{\"318\":1}}],[\"如果在后面的代码中出现了该标识符\",{\"1\":{\"255\":1}}],[\"如果在原内存块上进行缩减\",{\"1\":{\"314\":1}}],[\"如果内存分配失败\",{\"1\":{\"314\":1}}],[\"如果内存分配成功\",{\"1\":{\"314\":2}}],[\"如果内存重新分配成功\",{\"1\":{\"314\":1}}],[\"如果分配失败\",{\"1\":{\"314\":2}}],[\"如果读取过程中发生错误\",{\"1\":{\"310\":1}}],[\"如果读取成功\",{\"1\":{\"310\":2}}],[\"如果到达文件结束或发生错误\",{\"1\":{\"310\":2}}],[\"如果写入失败\",{\"1\":{\"310\":1}}],[\"如果写入失败或出现错误\",{\"1\":{\"309\":1}}],[\"如果写入成功\",{\"1\":{\"310\":3}}],[\"如果关闭失败\",{\"1\":{\"310\":1}}],[\"如果打开文件失败\",{\"1\":{\"310\":1}}],[\"如果为空则说明这个单例对象还没有被创建\",{\"1\":{\"354\":1}}],[\"如果为\",{\"1\":{\"304\":1}}],[\"如果只用一种数据结构表示学生的\",{\"1\":{\"303\":1}}],[\"如果指针变量p指向一个结构体变量stu\",{\"1\":{\"302\":1}}],[\"如果嵌套循环过多\",{\"1\":{\"298\":1}}],[\"如果判断条件是判等\",{\"1\":{\"297\":1}}],[\"如果成绩90分及以上\",{\"1\":{\"297\":1}}],[\"如果成绩80分\",{\"1\":{\"297\":1}}],[\"如果成绩\",{\"1\":{\"297\":1}}],[\"如果成绩不到\",{\"1\":{\"297\":1}}],[\"如果表达式的值等于0\",{\"1\":{\"321\":1}}],[\"如果表达式的值不等于0\",{\"1\":{\"321\":1}}],[\"如果表达式2成立\",{\"1\":{\"297\":1}}],[\"如果表达式1不成立\",{\"1\":{\"297\":1}}],[\"如果大于18岁\",{\"1\":{\"297\":1}}],[\"如果局部作用域中定义了与全局作用域中同名的标识符\",{\"1\":{\"288\":1}}],[\"如果主函数里面省略return\",{\"1\":{\"287\":1}}],[\"如果返回其它非零整数\",{\"1\":{\"287\":1}}],[\"如果实参数量如形参不一致\",{\"1\":{\"286\":1}}],[\"如果没有成功读取任何参数\",{\"1\":{\"310\":1}}],[\"如果没有break\",{\"1\":{\"297\":1}}],[\"如果没有显式初始化它们\",{\"1\":{\"288\":1}}],[\"如果没有显式指定初始值\",{\"1\":{\"288\":1}}],[\"如果没有该函数\",{\"1\":{\"287\":1}}],[\"如果没有返回值\",{\"1\":{\"286\":1}}],[\"如果没有确切的地址赋值\",{\"1\":{\"266\":1}}],[\"如果条件表达式为0\",{\"1\":{\"281\":1}}],[\"如果条件表达式为非0\",{\"1\":{\"281\":1}}],[\"如果一个表达式过于复杂\",{\"1\":{\"283\":1}}],[\"如果一个变量专门用来存放内存地址\",{\"1\":{\"261\":1}}],[\"如果一个问题满足决策树模型\",{\"1\":{\"101\":1}}],[\"如果一个问题包含重叠子问题\",{\"1\":{\"101\":1}}],[\"如果所赋值的数量可以与元素数量对应\",{\"1\":{\"246\":1}}],[\"如果数组的元素还是数组\",{\"1\":{\"246\":1}}],[\"如果数组分配的大小超过实际所需\",{\"1\":{\"138\":1}}],[\"如果与邻接矩阵一样\",{\"1\":{\"219\":1}}],[\"如果插入节点更大\",{\"1\":{\"211\":1}}],[\"如果考虑上述失衡二叉树的\",{\"1\":{\"202\":1}}],[\"如果将顶点看作节点\",{\"1\":{\"213\":1}}],[\"如果将\",{\"1\":{\"180\":1}}],[\"如果哈希冲突过于频繁\",{\"1\":{\"175\":1}}],[\"如果遇到空桶\",{\"1\":{\"172\":1}}],[\"如果队列不为空\",{\"1\":{\"160\":1}}],[\"如果队列为空\",{\"1\":{\"160\":1}}],[\"如果入栈元素本身就是节点对象\",{\"1\":{\"158\":1}}],[\"如果入栈时超出数组容量\",{\"1\":{\"158\":1}}],[\"如果想在数组中间插入一个元素\",{\"1\":{\"141\":1}}],[\"如果想在某方面取得提升\",{\"1\":{\"132\":1}}],[\"如果每次都选择性价比最高\",{\"1\":{\"117\":1}}],[\"如果每次都选择结束时间最早的任务\",{\"1\":{\"117\":1}}],[\"如果无法凑出目标金额\",{\"1\":{\"113\":1}}],[\"如果采取倒序遍历\",{\"1\":{\"111\":1}}],[\"如果采取正序遍历\",{\"1\":{\"111\":1}}],[\"如果问题包含明确的决策概念\",{\"1\":{\"101\":1}}],[\"如果两者匹配\",{\"1\":{\"176\":2}}],[\"如果两个格子满足row1\",{\"1\":{\"89\":1}}],[\"如果两台计算机使用的是不同的编码标准\",{\"1\":{\"18\":1}}],[\"如果该元素与左边元素相等\",{\"1\":{\"86\":1}}],[\"如果我们直接从列表中删除首元素\",{\"1\":{\"212\":1}}],[\"如果我们令单向链表的尾节点指向头节点\",{\"1\":{\"153\":1}}],[\"如果我们希望扩容数组\",{\"1\":{\"145\":1}}],[\"如果我们给爬楼梯问题添加一个约束\",{\"1\":{\"99\":1}}],[\"如果我们输入一个比较大的n\",{\"1\":{\"93\":1}}],[\"如果我们先选择1\",{\"1\":{\"81\":1}}],[\"如果我们提前知道商品价格的概率分布\",{\"1\":{\"51\":1}}],[\"如果前面的数字大于后面的数字\",{\"1\":{\"63\":1}}],[\"如果桶中有数据且数据小于当前值\",{\"1\":{\"50\":1}}],[\"如果\",{\"1\":{\"37\":1}}],[\"如果最差时间复杂度差于平均时间复杂度\",{\"1\":{\"33\":1}}],[\"如果存在\",{\"1\":{\"27\":1}}],[\"如果推出一个足够完整的字符集\",{\"1\":{\"18\":1}}],[\"如果缺少连续大块的内存空间\",{\"1\":{\"15\":1}}],[\"如换行符和制表符然而\",{\"1\":{\"18\":1}}],[\"当读取到一个完整的报文后再让服务器进行处理\",{\"1\":{\"442\":1}}],[\"当某一文件描述符的写事件就绪时我们才能够调用write函数向客户端发送数据\",{\"1\":{\"442\":1}}],[\"当某块内存被某个程序占用时\",{\"1\":{\"15\":1}}],[\"当该连接的读事件就绪时select函数会告知我们\",{\"1\":{\"440\":1}}],[\"当该对象被消耗时就会调用其析构函数\",{\"1\":{\"354\":1}}],[\"当调用accept函数从底层获取上来连接后\",{\"1\":{\"440\":1}}],[\"当调用add函数时\",{\"1\":{\"367\":1}}],[\"当有客户端发来连接请求后\",{\"1\":{\"439\":2}}],[\"当服务器检测到客户端退出后\",{\"1\":{\"441\":1}}],[\"当服务器端检测到客户端退出后\",{\"1\":{\"391\":1,\"398\":1}}],[\"当服务端退出后\",{\"1\":{\"403\":1}}],[\"当客户端退出后\",{\"1\":{\"403\":1}}],[\"当客户端和服务端运行起来时\",{\"1\":{\"403\":1}}],[\"当我们借助telnet工具向select服务器发起连接请求后\",{\"1\":{\"439\":1}}],[\"当我们用telnet工具连接epoll服务器后\",{\"1\":{\"398\":1}}],[\"当我们用telnet工具连接poll服务器后\",{\"1\":{\"391\":1}}],[\"当我们定义一个指向指针的指针时\",{\"1\":{\"265\":1}}],[\"当动态内存分配失败时抛出的异常\",{\"1\":{\"382\":1}}],[\"当throw其他类型的异常时\",{\"1\":{\"382\":1}}],[\"当分母为零时\",{\"1\":{\"382\":1}}],[\"当不再需要该单例对象时就可以主动调用delinstance释放单例对象\",{\"1\":{\"354\":1}}],[\"当中创建的是局部对象\",{\"1\":{\"354\":1}}],[\"当最后一个shared\",{\"1\":{\"351\":2}}],[\"当循环条件表达式成立\",{\"1\":{\"298\":1}}],[\"当没有匹配的case时\",{\"1\":{\"297\":1}}],[\"当条件表达式1成立时\",{\"1\":{\"297\":1}}],[\"当条件表达式成立\",{\"1\":{\"297\":1}}],[\"当条件表达式为真\",{\"1\":{\"297\":1}}],[\"当前系统\",{\"1\":{\"332\":1}}],[\"当前时间字符串\",{\"1\":{\"291\":2}}],[\"当前时间戳\",{\"1\":{\"291\":2}}],[\"当前状态往往仅与前面有限个状态有关\",{\"1\":{\"96\":1}}],[\"当函数返回或块级作用域结束时\",{\"1\":{\"288\":1}}],[\"当删除首行首列时达到最差情况\",{\"1\":{\"218\":1}}],[\"当两顶点之间存在边相连时\",{\"1\":{\"214\":1}}],[\"当索引越界时\",{\"1\":{\"209\":1}}],[\"当使用数组表示二叉树时\",{\"1\":{\"209\":1}}],[\"当节点\",{\"1\":{\"201\":1,\"202\":1}}],[\"当待删除节点的度为2时\",{\"1\":{\"195\":1}}],[\"当待删除节点的度为1时\",{\"1\":{\"195\":1}}],[\"当待删除节点的度为0时\",{\"1\":{\"195\":1}}],[\"当二叉树平衡时\",{\"1\":{\"193\":1}}],[\"当二叉树中存在大量\",{\"1\":{\"191\":1}}],[\"当二叉树的每层节点都被填满时\",{\"1\":{\"184\":1}}],[\"当给定一个二叉树的节点时\",{\"1\":{\"180\":1}}],[\"当用户输入密码时\",{\"1\":{\"176\":1}}],[\"当哈希表容量\",{\"1\":{\"175\":1}}],[\"当发生冲突时\",{\"1\":{\"173\":1}}],[\"当越过数组尾部时\",{\"1\":{\"172\":1}}],[\"当越过楼梯顶部时就将其剪枝\",{\"1\":{\"92\":1}}],[\"当链表很长时\",{\"1\":{\"170\":1}}],[\"当负载因子超过阈值时\",{\"1\":{\"170\":1,\"172\":1}}],[\"当负载因子超过0\",{\"1\":{\"170\":1}}],[\"当输入的\",{\"1\":{\"168\":1}}],[\"当输入数组完全有序时\",{\"1\":{\"41\":1}}],[\"当它们到达数组尾部时就无法继续移动了\",{\"1\":{\"161\":1}}],[\"当访问数组元素时\",{\"1\":{\"138\":1}}],[\"当访问到值为7的节点时\",{\"1\":{\"75\":1}}],[\"当余数为\",{\"1\":{\"128\":3}}],[\"当n=6时\",{\"1\":{\"127\":1}}],[\"当n=4时\",{\"1\":{\"87\":1}}],[\"当背包已满时跳出并返回解\",{\"1\":{\"120\":1}}],[\"当开始遍历第i行时\",{\"1\":{\"111\":1}}],[\"当物品编号越界i=0或背包剩余容量为0时\",{\"1\":{\"108\":1}}],[\"当到达网络边界时只剩下一种选择\",{\"1\":{\"103\":1}}],[\"当再次需要计算dp\",{\"1\":{\"94\":1}}],[\"当首次计算dp\",{\"1\":{\"94\":1}}],[\"当爬到第\",{\"1\":{\"92\":1}}],[\"当记录解时\",{\"1\":{\"90\":1}}],[\"当放置完所有行时\",{\"1\":{\"90\":1}}],[\"当做出选择xi后\",{\"1\":{\"86\":1}}],[\"当第一轮选择4时\",{\"1\":{\"85\":1}}],[\"当第一轮和第二轮分别选择3和4时\",{\"1\":{\"85\":1}}],[\"当数组中元素较多时\",{\"1\":{\"138\":1}}],[\"当数组元素较多\",{\"1\":{\"85\":1}}],[\"当数组不包含\",{\"1\":{\"27\":1}}],[\"当元素和等于\",{\"1\":{\"85\":1}}],[\"当状态长度等于元素数量时\",{\"1\":{\"81\":1,\"82\":1}}],[\"当深度很大时\",{\"1\":{\"78\":1}}],[\"当算法在搜索过程中遇到某个状态无法继续前进或无法得到满足条件的解时\",{\"1\":{\"75\":1}}],[\"当算法程序运行时\",{\"1\":{\"15\":1}}],[\"当遇到空桶时跳出\",{\"1\":{\"172\":1}}],[\"当遇到正确的解则将其记录\",{\"1\":{\"74\":1}}],[\"当遇到以上两种情况时\",{\"1\":{\"26\":1}}],[\"当子节点数量\",{\"1\":{\"195\":1}}],[\"当子问题得到解决时\",{\"1\":{\"64\":1}}],[\"当子数组长度为\",{\"1\":{\"45\":1,\"46\":1}}],[\"当计数排序不稳定时\",{\"1\":{\"56\":1}}],[\"当计数排序稳定时\",{\"1\":{\"56\":1}}],[\"当然\",{\"1\":{\"51\":1,\"354\":1}}],[\"当左右子数组都还有元素时\",{\"1\":{\"46\":1}}],[\"当搜索区间为空时跳出\",{\"1\":{\"20\":1,\"21\":1}}],[\"当\",{\"1\":{\"20\":4,\"21\":1,\"128\":1,\"164\":2,\"211\":1,\"267\":1}}],[\"当多种长度的\",{\"1\":{\"18\":1}}],[\"当谈及计算机中的数据时\",{\"1\":{\"16\":1}}],[\"表达式的计算结果等\",{\"1\":{\"379\":1}}],[\"表达式的值为假逻辑非\",{\"1\":{\"278\":1}}],[\"表达式的值就为真\",{\"1\":{\"278\":1}}],[\"表达式等\",{\"1\":{\"379\":1}}],[\"表达式\",{\"1\":{\"297\":1,\"318\":1,\"338\":1}}],[\"表达式语句都是顺序执行的\",{\"1\":{\"296\":1}}],[\"表达式称为实际参数\",{\"1\":{\"286\":1}}],[\"表达式2\",{\"1\":{\"281\":1}}],[\"表达式1\",{\"1\":{\"281\":1}}],[\"表达式一定具有值\",{\"1\":{\"275\":1}}],[\"表\",{\"1\":{\"95\":2,\"98\":1,\"99\":1,\"105\":1,\"106\":1,\"110\":1,\"111\":1}}],[\"表示本次select检测到读事件就绪时timeout的剩余时间为4秒\",{\"1\":{\"439\":1}}],[\"表示未捕获的异常\",{\"1\":{\"382\":1}}],[\"表示在运行时发生的错误\",{\"1\":{\"382\":1}}],[\"表示在逻辑上存在错误\",{\"1\":{\"382\":1}}],[\"表示在第i个台阶需要付出的代价\",{\"1\":{\"98\":1}}],[\"表示空指针\",{\"1\":{\"379\":1}}],[\"表示空节点或节点不存在\",{\"1\":{\"209\":1}}],[\"表示不能被继承或重写\",{\"1\":{\"376\":1}}],[\"表示对象存在过\",{\"1\":{\"361\":2}}],[\"表示让编译器将拷贝构造函数删除\",{\"1\":{\"354\":1}}],[\"表示特殊含义的字符多个字符称为字符串\",{\"1\":{\"332\":1}}],[\"表示尾数部分保留两位小数\",{\"1\":{\"331\":1}}],[\"表示保留2位小数\",{\"1\":{\"331\":3}}],[\"表示加载过库文件\",{\"1\":{\"321\":1}}],[\"表示判断条件为伪\",{\"1\":{\"321\":1}}],[\"表示判断条件不成立\",{\"1\":{\"321\":1}}],[\"表示可变数量的参数\",{\"1\":{\"310\":2}}],[\"表示要从中读取数据的文件流\",{\"1\":{\"310\":1}}],[\"表示要写入的文件流\",{\"1\":{\"310\":1}}],[\"表示要写入字符的文件流\",{\"1\":{\"310\":2}}],[\"表示要关闭的文件流\",{\"1\":{\"310\":1}}],[\"表示要打开的文件的名称\",{\"1\":{\"310\":1}}],[\"表示关闭操作成功\",{\"1\":{\"310\":1}}],[\"表示打开文件的方式\",{\"1\":{\"310\":1}}],[\"表示读取的字符\",{\"1\":{\"309\":1}}],[\"表示使用3bit存储a变量位段用途\",{\"1\":{\"305\":1}}],[\"表示北京地区一年四季的平均温度\",{\"1\":{\"301\":1}}],[\"表示星期一到星期天\",{\"1\":{\"301\":1}}],[\"表示传给程序的参数个数\",{\"1\":{\"287\":1}}],[\"表示有返回值类型\",{\"1\":{\"286\":1}}],[\"表示有多少条边从该顶点指出\",{\"1\":{\"214\":1}}],[\"表示有多少条边指向该顶点\",{\"1\":{\"214\":1}}],[\"表示将\",{\"1\":{\"265\":2}}],[\"表示指针所指向的内存地址的移动\",{\"1\":{\"262\":1}}],[\"表示指针指向的是什么类型的值\",{\"1\":{\"261\":1}}],[\"表示一个二进制位\",{\"1\":{\"330\":1}}],[\"表示一个指向浮点数的指针\",{\"1\":{\"261\":1}}],[\"表示一个指向字符的指针\",{\"1\":{\"261\":1}}],[\"表示一个字符\",{\"1\":{\"18\":1}}],[\"表示输出的形式为整数\",{\"1\":{\"251\":3}}],[\"表示整数\",{\"1\":{\"251\":1}}],[\"表示二维数组\",{\"1\":{\"246\":1}}],[\"表示字符串结束\",{\"1\":{\"245\":1}}],[\"表示元素的个数\",{\"1\":{\"243\":1}}],[\"表示此递归方法已经返回\",{\"1\":{\"225\":1}}],[\"表示开启了一个新的递归方法来访问新顶点\",{\"1\":{\"225\":1}}],[\"表示该节点是叶节点\",{\"1\":{\"195\":1}}],[\"表示该单元格的代价\",{\"1\":{\"102\":1}}],[\"表示任意二叉树\",{\"0\":{\"190\":1}}],[\"表示满二叉树\",{\"0\":{\"189\":1}}],[\"表示你在该台阶所需要付出的代价\",{\"1\":{\"98\":1}}],[\"表示状态i对应子问题的解\",{\"1\":{\"95\":1}}],[\"表示爬到第1\",{\"1\":{\"93\":1}}],[\"表示\",{\"1\":{\"81\":1}}],[\"表示当前状态下可以做出的选择\",{\"1\":{\"77\":1}}],[\"表示问题的当前状态\",{\"1\":{\"77\":1}}],[\"表示中的左右边界都被定义为闭区间\",{\"1\":{\"21\":1}}],[\"表示英文字符非常高效\",{\"1\":{\"18\":1}}],[\"表格\",{\"1\":{\"15\":1}}],[\"表现出\",{\"1\":{\"14\":1}}],[\"2是默认打开的\",{\"1\":{\"398\":1}}],[\"2都是占位符\",{\"1\":{\"379\":1}}],[\"2lf\",{\"1\":{\"331\":3}}],[\"2e12f\",{\"1\":{\"331\":1}}],[\"2e12\",{\"1\":{\"331\":1}}],[\"2e+4932\",{\"1\":{\"331\":1}}],[\"2e\",{\"1\":{\"331\":4}}],[\"2字节\",{\"1\":{\"330\":2}}],[\"25f\",{\"1\":{\"337\":1}}],[\"255\",{\"1\":{\"332\":1}}],[\"255之间的整数\",{\"1\":{\"310\":1}}],[\"256\",{\"1\":{\"18\":1,\"310\":1,\"395\":1,\"396\":1,\"397\":1}}],[\"2的绝对值\",{\"1\":{\"291\":2}}],[\"27\",{\"1\":{\"280\":2,\"291\":1}}],[\"2f分\",{\"1\":{\"291\":1}}],[\"2f\",{\"1\":{\"255\":2,\"288\":4,\"291\":4,\"297\":2,\"310\":1,\"318\":1,\"331\":1}}],[\"229996\",{\"1\":{\"331\":1}}],[\"22\",{\"1\":{\"246\":4,\"304\":2,\"382\":1}}],[\"295\",{\"1\":{\"330\":2}}],[\"294\",{\"1\":{\"330\":2}}],[\"299\",{\"1\":{\"286\":1}}],[\"29\",{\"1\":{\"244\":2,\"361\":1}}],[\"24\",{\"1\":{\"244\":2,\"246\":4,\"354\":1}}],[\"2|e|\",{\"1\":{\"223\":1,\"225\":1}}],[\"2个结点\",{\"1\":{\"186\":1}}],[\"28\",{\"1\":{\"177\":1,\"361\":1}}],[\"20s\",{\"1\":{\"344\":3}}],[\"20\",{\"1\":{\"244\":3,\"246\":4,\"250\":1,\"251\":3,\"262\":6,\"263\":7,\"267\":1,\"276\":3,\"279\":1,\"286\":3,\"288\":5,\"292\":3,\"294\":1,\"301\":1,\"302\":1,\"309\":1,\"330\":2,\"337\":1,\"361\":3,\"367\":4,\"376\":1,\"379\":5}}],[\"200u\",{\"1\":{\"330\":1}}],[\"2000ul\",{\"1\":{\"330\":1}}],[\"20000ull\",{\"1\":{\"330\":1}}],[\"2000000000000\",{\"1\":{\"331\":1}}],[\"200000\",{\"1\":{\"288\":1}}],[\"20000\",{\"1\":{\"246\":1}}],[\"2000\",{\"1\":{\"246\":1,\"314\":1}}],[\"200\",{\"1\":{\"244\":1,\"246\":2,\"250\":1,\"251\":1,\"287\":1,\"288\":1,\"289\":1,\"314\":1,\"332\":3,\"379\":2}}],[\"2024\",{\"1\":{\"344\":1,\"345\":1,\"348\":1,\"351\":1,\"354\":1,\"357\":1,\"361\":3,\"364\":1,\"367\":1,\"370\":1,\"373\":1,\"376\":1,\"379\":1,\"382\":1}}],[\"2023\",{\"1\":{\"291\":1}}],[\"2023年发布的c23计划增强安全性\",{\"1\":{\"241\":1}}],[\"2023年\",{\"1\":{\"241\":1}}],[\"2022\",{\"1\":{\"18\":1,\"361\":12}}],[\"2015\",{\"1\":{\"361\":1}}],[\"2018年发布的c17只解决了c11的缺陷\",{\"1\":{\"241\":1}}],[\"2018年\",{\"1\":{\"241\":1}}],[\"2011年\",{\"1\":{\"241\":1}}],[\"20336\",{\"1\":{\"168\":2}}],[\"2x2x2\",{\"1\":{\"127\":1}}],[\"2^64\",{\"1\":{\"330\":2}}],[\"2^63\",{\"1\":{\"330\":4}}],[\"2^32\",{\"1\":{\"330\":2}}],[\"2^31\",{\"1\":{\"330\":4}}],[\"2^16\",{\"1\":{\"330\":2}}],[\"2^15\",{\"1\":{\"330\":4}}],[\"2^\",{\"1\":{\"103\":1}}],[\"2^n\",{\"1\":{\"73\":1,\"93\":1,\"108\":1}}],[\"2步\",{\"1\":{\"103\":1}}],[\"2种方案\",{\"1\":{\"93\":1}}],[\"2阶分别有1\",{\"1\":{\"93\":1}}],[\"2n\",{\"1\":{\"90\":1}}],[\"2空间复杂度为o\",{\"1\":{\"36\":1}}],[\"2轮内循环\",{\"1\":{\"36\":1}}],[\"234\",{\"1\":{\"348\":1}}],[\"23e\",{\"1\":{\"331\":2}}],[\"230000\",{\"1\":{\"331\":1}}],[\"23student\",{\"1\":{\"257\":1}}],[\"236\",{\"1\":{\"168\":1}}],[\"23\",{\"1\":{\"33\":2,\"246\":4,\"351\":1}}],[\"210\",{\"1\":{\"325\":1}}],[\"214\",{\"1\":{\"264\":1}}],[\"21\",{\"1\":{\"33\":2,\"246\":4,\"286\":3,\"379\":1}}],[\"21886\",{\"1\":{\"18\":1}}],[\"2\",{\"0\":{\"15\":1,\"21\":1,\"24\":1,\"27\":1,\"30\":1,\"34\":1,\"35\":1,\"36\":1,\"39\":1,\"44\":1,\"51\":1,\"54\":1,\"59\":1,\"62\":1,\"67\":1,\"72\":1,\"76\":1,\"82\":1,\"86\":1,\"89\":1,\"94\":1,\"97\":1,\"98\":1,\"99\":2,\"102\":1,\"109\":1,\"114\":1,\"120\":1,\"124\":1,\"128\":1,\"132\":1,\"136\":1,\"140\":1,\"146\":1,\"147\":1,\"148\":2,\"149\":1,\"150\":1,\"151\":1,\"157\":1,\"159\":1,\"160\":1,\"161\":2,\"164\":1,\"168\":1,\"169\":1,\"170\":1,\"171\":2,\"172\":2,\"173\":3,\"174\":2,\"177\":1,\"182\":1,\"185\":1,\"186\":1,\"187\":2,\"190\":1,\"194\":1,\"200\":1,\"201\":1,\"202\":2,\"203\":1,\"204\":1,\"205\":1,\"210\":1,\"215\":1,\"216\":1,\"217\":2,\"223\":1,\"228\":1,\"240\":1,\"244\":1,\"250\":1,\"253\":1,\"254\":1,\"255\":2,\"258\":1,\"262\":1,\"271\":1,\"276\":1,\"286\":1,\"297\":1,\"302\":1,\"309\":1,\"313\":1,\"318\":1,\"326\":1,\"329\":1,\"330\":1,\"331\":2,\"332\":1,\"333\":1,\"334\":1,\"338\":1,\"342\":1,\"345\":1,\"387\":1,\"388\":1,\"389\":2,\"390\":1,\"391\":1,\"394\":1,\"395\":1,\"396\":2,\"397\":1,\"398\":1,\"403\":1,\"435\":1,\"436\":1,\"437\":2,\"438\":1,\"439\":1,\"440\":1,\"447\":1,\"450\":1,\"455\":1,\"462\":1,\"469\":1,\"473\":1,\"479\":1,\"484\":1,\"495\":1,\"499\":1,\"511\":1,\"525\":1,\"530\":1,\"534\":1},\"1\":{\"16\":1,\"18\":9,\"20\":3,\"21\":1,\"23\":1,\"24\":1,\"27\":1,\"29\":2,\"30\":2,\"33\":2,\"37\":3,\"41\":6,\"46\":1,\"48\":5,\"50\":4,\"53\":1,\"54\":1,\"56\":2,\"61\":1,\"64\":1,\"67\":4,\"70\":1,\"71\":1,\"72\":2,\"77\":3,\"81\":4,\"82\":4,\"85\":1,\"86\":1,\"90\":6,\"92\":3,\"93\":6,\"94\":4,\"95\":5,\"96\":3,\"98\":7,\"99\":12,\"103\":1,\"127\":1,\"128\":7,\"139\":1,\"147\":2,\"158\":1,\"170\":1,\"172\":2,\"178\":1,\"180\":1,\"181\":1,\"182\":2,\"183\":1,\"190\":1,\"195\":2,\"199\":1,\"206\":1,\"207\":2,\"209\":5,\"214\":2,\"218\":1,\"219\":1,\"240\":1,\"243\":1,\"244\":6,\"245\":2,\"246\":6,\"249\":1,\"250\":1,\"251\":1,\"254\":1,\"255\":3,\"257\":1,\"258\":1,\"261\":1,\"262\":7,\"263\":4,\"264\":2,\"265\":1,\"267\":1,\"271\":1,\"272\":1,\"273\":1,\"276\":2,\"278\":1,\"280\":5,\"281\":2,\"283\":1,\"285\":1,\"286\":1,\"287\":2,\"288\":3,\"289\":1,\"290\":2,\"291\":5,\"292\":3,\"297\":1,\"298\":12,\"299\":3,\"301\":1,\"302\":1,\"303\":1,\"304\":3,\"309\":1,\"310\":1,\"313\":1,\"314\":2,\"315\":1,\"317\":1,\"318\":2,\"319\":3,\"320\":1,\"321\":3,\"325\":3,\"326\":1,\"327\":1,\"330\":8,\"331\":5,\"332\":1,\"335\":2,\"337\":2,\"338\":1,\"342\":1,\"344\":3,\"348\":21,\"351\":3,\"354\":11,\"357\":3,\"361\":5,\"364\":5,\"367\":9,\"370\":1,\"373\":2,\"376\":1,\"379\":34,\"382\":2,\"391\":1,\"398\":1,\"403\":2,\"404\":3,\"405\":1,\"406\":2,\"436\":1,\"439\":1}}],[\"与lock\",{\"1\":{\"379\":1}}],[\"与基类虚函数返回值类型不同\",{\"1\":{\"376\":1}}],[\"与基于数组实现队列类似\",{\"1\":{\"164\":1}}],[\"与auto的在for遍历中的区别\",{\"1\":{\"348\":1}}],[\"与返回值类型无关\",{\"1\":{\"348\":1}}],[\"与全局变量和全局数组不同\",{\"1\":{\"288\":1}}],[\"与指针指向的数据类型有关\",{\"1\":{\"262\":1}}],[\"与printf相同\",{\"1\":{\"252\":1}}],[\"与格式占位符一一对应\",{\"1\":{\"251\":1}}],[\"与广度优先遍历类似\",{\"1\":{\"225\":2}}],[\"与该顶点相连的顶点\",{\"1\":{\"217\":1}}],[\"与元素入堆操作相似\",{\"1\":{\"212\":1}}],[\"与插入节点类似\",{\"1\":{\"195\":1}}],[\"与查找节点相同\",{\"1\":{\"194\":1}}],[\"与查找操作相似\",{\"1\":{\"194\":1}}],[\"与链表类似\",{\"1\":{\"180\":1,\"182\":2}}],[\"与线性探测相比\",{\"1\":{\"174\":1}}],[\"与值\",{\"1\":{\"166\":1}}],[\"与单向链表相比\",{\"1\":{\"153\":1}}],[\"与回溯算法一样\",{\"1\":{\"95\":1}}],[\"与之相反\",{\"1\":{\"95\":1}}],[\"与此同时\",{\"1\":{\"86\":1}}],[\"与第1步和第2步中描述的子集完全重复\",{\"1\":{\"85\":1}}],[\"与计数排序相同\",{\"1\":{\"56\":1}}],[\"与堆底元素\",{\"1\":{\"48\":1}}],[\"与\",{\"1\":{\"14\":1,\"16\":1,\"26\":1,\"75\":2,\"176\":1,\"180\":1,\"214\":1,\"303\":1,\"331\":1}}],[\"祖先\",{\"1\":{\"14\":1,\"180\":1}}],[\"1和\",{\"1\":{\"379\":1}}],[\"1和std\",{\"1\":{\"379\":1}}],[\"1为负数\",{\"1\":{\"361\":1}}],[\"1为正数\",{\"1\":{\"361\":1}}],[\"1byte\",{\"1\":{\"330\":1}}],[\"17\",{\"1\":{\"246\":2,\"264\":1,\"280\":3,\"286\":3,\"367\":1,\"379\":1}}],[\"140148637431360\",{\"1\":{\"379\":1}}],[\"140000\",{\"1\":{\"286\":1}}],[\"14s\",{\"1\":{\"344\":3}}],[\"147\",{\"1\":{\"330\":4}}],[\"141500e+00\",{\"1\":{\"331\":2}}],[\"141500\",{\"1\":{\"331\":2}}],[\"1415f\",{\"1\":{\"331\":1}}],[\"1415\",{\"1\":{\"321\":1,\"331\":1}}],[\"1415926\",{\"1\":{\"318\":2,\"348\":1}}],[\"141590\",{\"1\":{\"313\":1,\"318\":1}}],[\"14159\",{\"1\":{\"310\":1,\"313\":1,\"318\":1,\"348\":1}}],[\"14\",{\"1\":{\"246\":4,\"255\":3,\"263\":1,\"286\":1,\"288\":6,\"289\":1,\"291\":1,\"317\":1,\"318\":1,\"325\":1,\"344\":1,\"345\":1,\"348\":1,\"357\":2,\"361\":1,\"370\":1,\"379\":3}}],[\"149186\",{\"1\":{\"18\":1}}],[\"1353429820\",{\"1\":{\"344\":1,\"345\":1,\"348\":1,\"351\":1,\"354\":1,\"357\":1,\"361\":1,\"364\":1,\"367\":1,\"370\":1,\"373\":1,\"376\":1,\"379\":1,\"382\":1}}],[\"134转为6\",{\"1\":{\"338\":1}}],[\"134\",{\"1\":{\"338\":1}}],[\"130611760\",{\"1\":{\"288\":5}}],[\"13\",{\"1\":{\"246\":4,\"291\":5,\"325\":1,\"361\":4,\"379\":1}}],[\"136\",{\"1\":{\"168\":1}}],[\"1的元素\",{\"1\":{\"244\":2}}],[\"1的两个子数组\",{\"1\":{\"43\":1}}],[\"1110\",{\"1\":{\"327\":1}}],[\"1111\",{\"1\":{\"327\":3}}],[\"11\",{\"0\":{\"237\":1},\"1\":{\"246\":4,\"276\":2,\"280\":2,\"304\":2,\"337\":1,\"348\":1,\"361\":2,\"379\":1}}],[\"159\",{\"1\":{\"286\":1}}],[\"150\",{\"1\":{\"246\":2}}],[\"15\",{\"1\":{\"190\":1,\"244\":2,\"246\":2,\"289\":1,\"325\":1,\"331\":1,\"361\":2,\"367\":1,\"379\":1}}],[\"127\",{\"1\":{\"332\":1}}],[\"12e\",{\"1\":{\"331\":1}}],[\"12e2\",{\"1\":{\"331\":1}}],[\"12等\",{\"1\":{\"331\":1}}],[\"1234\",{\"1\":{\"370\":1}}],[\"123456\",{\"1\":{\"331\":1}}],[\"123456f\",{\"1\":{\"331\":1}}],[\"1234567800\",{\"1\":{\"331\":1}}],[\"12345678\",{\"1\":{\"331\":1}}],[\"123\",{\"1\":{\"292\":1,\"331\":1,\"379\":3}}],[\"12和16之间较大的是\",{\"1\":{\"286\":2}}],[\"120\",{\"1\":{\"244\":2,\"314\":2}}],[\"12\",{\"1\":{\"190\":1,\"244\":2,\"245\":1,\"246\":4,\"259\":2,\"276\":6,\"280\":3,\"286\":1,\"291\":34,\"318\":1,\"325\":1,\"331\":1,\"348\":1,\"361\":3,\"379\":3}}],[\"128~127\",{\"1\":{\"332\":1}}],[\"12836\",{\"1\":{\"168\":2}}],[\"128\",{\"1\":{\"18\":4,\"332\":1,\"403\":2,\"404\":1,\"405\":1,\"406\":2}}],[\"1行的状态\",{\"1\":{\"111\":1}}],[\"1背包问题\",{\"0\":{\"107\":1}}],[\"1个汉字=2字节\",{\"1\":{\"344\":1}}],[\"1个选择\",{\"1\":{\"90\":1}}],[\"1个圆盘借助\",{\"1\":{\"72\":2}}],[\"1个元素执行\",{\"1\":{\"38\":1}}],[\"1个元素已排序\",{\"1\":{\"36\":1}}],[\"10+20是右值\",{\"1\":{\"379\":1}}],[\"10s\",{\"1\":{\"344\":3}}],[\"10f\",{\"1\":{\"331\":1,\"337\":1}}],[\"10字节\",{\"1\":{\"331\":1}}],[\"10的平方根\",{\"1\":{\"291\":2}}],[\"1024\",{\"1\":{\"310\":1,\"389\":1,\"390\":2,\"438\":1,\"440\":2}}],[\"102\",{\"1\":{\"264\":1}}],[\"101\",{\"1\":{\"264\":1,\"332\":2}}],[\"108\",{\"1\":{\"244\":2}}],[\"10^\",{\"1\":{\"56\":2}}],[\"10\",{\"0\":{\"55\":1,\"56\":1,\"236\":1,\"294\":1},\"1\":{\"51\":2,\"56\":6,\"98\":1,\"108\":1,\"240\":1,\"244\":9,\"246\":4,\"250\":1,\"251\":3,\"262\":6,\"263\":7,\"267\":3,\"276\":7,\"278\":1,\"279\":1,\"281\":1,\"286\":2,\"288\":8,\"289\":2,\"291\":1,\"298\":3,\"299\":2,\"304\":1,\"330\":6,\"335\":1,\"337\":4,\"338\":1,\"348\":2,\"357\":1,\"361\":13,\"364\":4,\"367\":3,\"379\":8}}],[\"1003\",{\"1\":{\"302\":2}}],[\"1002\",{\"1\":{\"302\":2}}],[\"1000l\",{\"1\":{\"330\":4}}],[\"10000ll\",{\"1\":{\"330\":4}}],[\"1000000000000\",{\"1\":{\"382\":1}}],[\"1000000007\",{\"1\":{\"177\":4}}],[\"10000000\",{\"1\":{\"291\":1}}],[\"10000\",{\"1\":{\"246\":1,\"330\":2}}],[\"1000\",{\"1\":{\"51\":1,\"246\":1,\"264\":1,\"327\":2,\"330\":2}}],[\"100\",{\"1\":{\"18\":1,\"51\":1,\"167\":2,\"168\":2,\"176\":1,\"244\":2,\"246\":2,\"250\":1,\"251\":1,\"263\":2,\"264\":1,\"278\":1,\"286\":2,\"287\":1,\"288\":3,\"289\":2,\"291\":2,\"304\":3,\"309\":1,\"310\":3,\"314\":1,\"318\":1,\"325\":2,\"330\":6,\"335\":1,\"337\":2,\"361\":5,\"379\":2}}],[\"1次\",{\"1\":{\"41\":1}}],[\"1大的元素都被交换至正确位置\",{\"1\":{\"38\":1}}],[\"1轮空间复杂度为o\",{\"1\":{\"48\":1}}],[\"1轮后\",{\"1\":{\"48\":1}}],[\"1轮\",{\"1\":{\"36\":1,\"38\":1,\"150\":1}}],[\"1轮选择与交换后\",{\"1\":{\"36\":1}}],[\"18或更多\",{\"1\":{\"331\":1}}],[\"18446744073709551615\",{\"1\":{\"330\":2}}],[\"180\",{\"1\":{\"286\":1}}],[\"180的结果\",{\"1\":{\"286\":2}}],[\"18\",{\"1\":{\"33\":2,\"246\":2,\"276\":4,\"280\":1,\"297\":2,\"301\":1,\"361\":2,\"370\":1}}],[\"1即可\",{\"1\":{\"26\":1}}],[\"16字节\",{\"1\":{\"331\":1}}],[\"16位\",{\"1\":{\"330\":4}}],[\"162278\",{\"1\":{\"291\":1}}],[\"1697221633\",{\"1\":{\"291\":1}}],[\"16第二代\",{\"1\":{\"240\":1}}],[\"16\",{\"1\":{\"18\":4,\"246\":2,\"286\":2,\"302\":2,\"330\":2,\"335\":2,\"344\":3,\"364\":1,\"379\":1}}],[\"199\",{\"1\":{\"332\":1}}],[\"1999999991808\",{\"1\":{\"331\":1}}],[\"1999年\",{\"1\":{\"241\":1}}],[\"1991\",{\"1\":{\"18\":1}}],[\"1989年\",{\"1\":{\"241\":1}}],[\"1980\",{\"1\":{\"18\":1}}],[\"1978年\",{\"1\":{\"241\":1}}],[\"19\",{\"1\":{\"33\":6,\"246\":2,\"276\":2,\"302\":2,\"373\":1}}],[\"1表示负数真值\",{\"1\":{\"327\":1}}],[\"1表示负数\",{\"1\":{\"17\":1}}],[\"1字节\",{\"1\":{\"16\":1}}],[\"1比特\",{\"1\":{\"16\":1}}],[\"1\",{\"0\":{\"14\":1,\"20\":1,\"23\":1,\"26\":1,\"29\":1,\"32\":1,\"33\":2,\"34\":1,\"36\":1,\"38\":1,\"41\":1,\"43\":1,\"46\":1,\"48\":1,\"50\":1,\"53\":1,\"56\":1,\"58\":1,\"61\":1,\"66\":1,\"71\":1,\"75\":1,\"81\":1,\"85\":1,\"88\":1,\"92\":1,\"93\":2,\"94\":1,\"95\":1,\"96\":1,\"98\":1,\"101\":1,\"108\":1,\"113\":1,\"119\":1,\"123\":1,\"127\":1,\"131\":1,\"135\":1,\"138\":1,\"139\":2,\"140\":1,\"141\":1,\"142\":1,\"143\":1,\"144\":1,\"145\":1,\"147\":1,\"155\":1,\"156\":2,\"157\":1,\"158\":1,\"160\":1,\"163\":1,\"166\":1,\"167\":2,\"168\":1,\"170\":1,\"172\":1,\"176\":1,\"180\":1,\"181\":2,\"182\":1,\"183\":1,\"184\":1,\"186\":1,\"189\":1,\"193\":1,\"199\":1,\"201\":1,\"209\":1,\"214\":1,\"216\":1,\"222\":1,\"227\":1,\"239\":1,\"243\":1,\"248\":1,\"249\":2,\"250\":1,\"251\":1,\"252\":1,\"254\":1,\"257\":1,\"261\":1,\"270\":1,\"275\":1,\"285\":1,\"296\":1,\"301\":1,\"308\":1,\"312\":1,\"317\":1,\"324\":1,\"325\":2,\"326\":1,\"327\":1,\"328\":1,\"330\":1,\"337\":1,\"341\":1,\"344\":1,\"386\":1,\"388\":1,\"393\":1,\"395\":1,\"402\":1,\"434\":1,\"436\":1,\"444\":1,\"446\":1,\"449\":1,\"452\":1,\"454\":1,\"461\":1,\"468\":1,\"472\":1,\"478\":1,\"481\":1,\"483\":1,\"486\":1,\"488\":1,\"490\":1,\"492\":1,\"494\":1,\"498\":1,\"504\":1,\"506\":1,\"508\":1,\"510\":1,\"513\":1,\"515\":1,\"517\":1,\"519\":1,\"521\":1,\"523\":1,\"527\":1,\"528\":1,\"532\":1},\"1\":{\"16\":1,\"17\":1,\"18\":7,\"20\":13,\"21\":3,\"23\":5,\"24\":7,\"26\":2,\"27\":9,\"29\":3,\"30\":1,\"33\":2,\"36\":10,\"37\":4,\"38\":4,\"39\":4,\"41\":10,\"43\":4,\"45\":1,\"46\":9,\"48\":7,\"50\":4,\"53\":3,\"54\":6,\"56\":11,\"64\":8,\"67\":5,\"69\":6,\"70\":1,\"71\":1,\"72\":7,\"73\":10,\"77\":1,\"79\":2,\"81\":7,\"82\":4,\"85\":1,\"86\":3,\"90\":11,\"92\":3,\"93\":6,\"94\":8,\"95\":6,\"96\":4,\"98\":11,\"99\":14,\"103\":5,\"104\":3,\"105\":10,\"106\":6,\"107\":7,\"108\":8,\"109\":8,\"110\":11,\"111\":11,\"113\":5,\"118\":7,\"124\":2,\"127\":1,\"128\":9,\"138\":1,\"139\":1,\"140\":1,\"141\":2,\"142\":2,\"144\":1,\"147\":3,\"148\":1,\"150\":1,\"151\":1,\"157\":2,\"161\":8,\"163\":1,\"164\":5,\"166\":2,\"167\":2,\"172\":9,\"178\":1,\"181\":2,\"182\":2,\"183\":3,\"190\":1,\"195\":3,\"199\":7,\"200\":1,\"205\":2,\"206\":1,\"207\":2,\"209\":3,\"211\":1,\"212\":2,\"214\":3,\"216\":1,\"217\":1,\"218\":11,\"219\":5,\"223\":3,\"225\":1,\"243\":1,\"244\":6,\"245\":1,\"246\":9,\"249\":1,\"250\":1,\"251\":1,\"254\":1,\"255\":4,\"257\":3,\"258\":1,\"261\":1,\"262\":11,\"263\":6,\"264\":2,\"265\":1,\"267\":1,\"271\":1,\"272\":1,\"273\":1,\"276\":9,\"277\":4,\"279\":2,\"280\":1,\"281\":4,\"282\":1,\"283\":1,\"285\":1,\"286\":1,\"287\":1,\"288\":6,\"289\":1,\"290\":4,\"291\":2,\"294\":3,\"297\":2,\"298\":12,\"299\":3,\"301\":4,\"302\":1,\"303\":1,\"304\":3,\"309\":2,\"310\":6,\"313\":1,\"314\":4,\"315\":1,\"317\":2,\"318\":3,\"319\":6,\"320\":1,\"321\":4,\"325\":4,\"326\":3,\"327\":6,\"330\":14,\"331\":5,\"332\":2,\"333\":2,\"335\":4,\"337\":6,\"338\":2,\"342\":1,\"344\":13,\"345\":1,\"348\":22,\"351\":3,\"354\":12,\"357\":2,\"361\":44,\"364\":11,\"367\":3,\"370\":4,\"373\":3,\"376\":2,\"379\":29,\"382\":2,\"389\":3,\"390\":2,\"391\":3,\"396\":1,\"397\":1,\"398\":4,\"403\":9,\"404\":5,\"405\":5,\"406\":5,\"436\":1,\"438\":3,\"439\":6,\"440\":2}}],[\"和匿名管道通信是一样的\",{\"1\":{\"403\":1}}],[\"和weight\",{\"1\":{\"361\":1}}],[\"和unsigned\",{\"1\":{\"332\":1}}],[\"和原码\",{\"1\":{\"327\":1}}],[\"和原码相同\",{\"1\":{\"327\":1}}],[\"和指令的其余部分之间也可以有空格\",{\"1\":{\"317\":1}}],[\"和指向下一节点的\",{\"1\":{\"146\":1}}],[\"和scanf\",{\"1\":{\"309\":1}}],[\"和结构体变量是两个不同的概念\",{\"1\":{\"302\":1}}],[\"和类\",{\"1\":{\"302\":1}}],[\"和格式字符组成\",{\"1\":{\"251\":1}}],[\"和非连通图\",{\"1\":{\"214\":1}}],[\"和有向图\",{\"1\":{\"214\":1}}],[\"和分治关系\",{\"1\":{\"213\":1}}],[\"和分散空间存储\",{\"1\":{\"15\":1}}],[\"和边\",{\"1\":{\"213\":1}}],[\"和右子节点\",{\"1\":{\"180\":1}}],[\"和右子数组\",{\"1\":{\"46\":1}}],[\"和前驱节点\",{\"1\":{\"153\":1}}],[\"和某个元素的索引\",{\"1\":{\"140\":1}}],[\"和价值val\",{\"1\":{\"107\":1}}],[\"和dp\",{\"1\":{\"93\":1,\"96\":1}}],[\"和次对角线\",{\"1\":{\"87\":1}}],[\"和第1步中产生的子集完全重复\",{\"1\":{\"85\":1}}],[\"和目标元素9的回溯过程\",{\"1\":{\"86\":1}}],[\"和目标元素9\",{\"1\":{\"86\":1}}],[\"和目标9输入以下代码后的整体回溯效果\",{\"1\":{\"85\":1}}],[\"和目标9\",{\"1\":{\"85\":1}}],[\"和目标整数9\",{\"1\":{\"85\":1}}],[\"和一个容量为cap的背包\",{\"1\":{\"107\":1,\"118\":1}}],[\"和一个目标正整数\",{\"1\":{\"85\":1,\"86\":1}}],[\"和一个子问题f\",{\"1\":{\"72\":1}}],[\"和元素\",{\"1\":{\"81\":1}}],[\"和中序遍历\",{\"1\":{\"65\":1,\"67\":1,\"69\":1}}],[\"和索引\",{\"1\":{\"30\":1}}],[\"和\",{\"1\":{\"13\":1,\"18\":1,\"20\":1,\"24\":1,\"33\":1,\"42\":1,\"44\":1,\"45\":1,\"47\":1,\"56\":1,\"58\":1,\"66\":1,\"67\":2,\"68\":1,\"70\":1,\"77\":1,\"83\":1,\"85\":3,\"90\":2,\"93\":1,\"94\":1,\"103\":1,\"146\":3,\"147\":1,\"148\":1,\"160\":2,\"161\":1,\"163\":1,\"164\":1,\"166\":1,\"167\":1,\"168\":2,\"169\":1,\"172\":1,\"178\":1,\"180\":1,\"193\":1,\"195\":1,\"214\":1,\"215\":1,\"263\":4,\"286\":2,\"330\":1,\"351\":1,\"361\":1,\"442\":1}}],[\"图和树都需要应用搜索算法来实现遍历操作\",{\"1\":{\"221\":1}}],[\"图基于邻接表的实现\",{\"0\":{\"219\":1}}],[\"图基于邻接矩阵的实现\",{\"0\":{\"218\":1}}],[\"图的应用\",{\"0\":{\"464\":1}}],[\"图的存储与基本操作\",{\"0\":{\"462\":1}}],[\"图的定义\",{\"0\":{\"461\":1}}],[\"图的遍历方式也可分为两种\",{\"1\":{\"221\":1}}],[\"图的遍历\",{\"0\":{\"221\":1,\"463\":1}}],[\"图的顶点数量已达最大值\",{\"1\":{\"218\":1}}],[\"图的常用表示方式包括\",{\"1\":{\"215\":1}}],[\"图的常见类型与术语\",{\"0\":{\"214\":1}}],[\"图的表示\",{\"0\":{\"215\":1}}],[\"图数据结构包含以下常用术语\",{\"1\":{\"214\":1}}],[\"图下图展示了一个链式地址哈希表的例子\",{\"1\":{\"170\":1}}],[\"图着色问题\",{\"1\":{\"79\":1}}],[\"图片\",{\"1\":{\"16\":1,\"325\":1}}],[\"图等\",{\"1\":{\"15\":1}}],[\"图则由节点和边构成\",{\"1\":{\"14\":1}}],[\"图\",{\"0\":{\"213\":1,\"460\":1},\"1\":{\"13\":1,\"14\":1,\"15\":1,\"213\":2}}],[\"图论\",{\"0\":{\"4\":1}}],[\"堆区\",{\"1\":{\"314\":1}}],[\"堆化操作的循环轮数最多为o\",{\"1\":{\"211\":1}}],[\"堆化除叶节点以外的其他所有节点\",{\"1\":{\"48\":1}}],[\"堆底\",{\"1\":{\"208\":1}}],[\"堆顶元素是二叉树的根节点\",{\"1\":{\"212\":1}}],[\"堆顶元素出堆操作的时间复杂度也为o\",{\"1\":{\"212\":1}}],[\"堆顶元素出堆\",{\"0\":{\"212\":1}}],[\"堆顶元素即为二叉树的根节点\",{\"1\":{\"210\":1}}],[\"堆顶元素\",{\"1\":{\"208\":1}}],[\"堆顶\",{\"1\":{\"208\":1}}],[\"堆作为完全二叉树的一个特例\",{\"1\":{\"208\":1}}],[\"堆等数据结构中\",{\"1\":{\"64\":1}}],[\"堆是一种特殊的完全二叉树\",{\"1\":{\"63\":1}}],[\"堆的成立条件可能已被破坏\",{\"1\":{\"211\":1}}],[\"堆的存储与表示\",{\"0\":{\"209\":1}}],[\"堆的长度为\",{\"1\":{\"48\":1}}],[\"堆的长度减1\",{\"1\":{\"48\":1}}],[\"堆的性质得到修复\",{\"1\":{\"48\":1}}],[\"堆排序相较于选择\",{\"1\":{\"60\":1}}],[\"堆排序的流程如下图所示\",{\"1\":{\"48\":1}}],[\"堆排序算法流程\",{\"0\":{\"48\":1}}],[\"堆排序算法\",{\"0\":{\"47\":1}}],[\"堆排序\",{\"1\":{\"44\":2,\"47\":1,\"48\":1}}],[\"堆\",{\"0\":{\"208\":1},\"1\":{\"13\":1,\"14\":1,\"15\":2,\"48\":1,\"63\":1,\"208\":1}}],[\"树和森林\",{\"0\":{\"458\":1}}],[\"树和二叉树\",{\"0\":{\"453\":1}}],[\"树与二叉树的应用\",{\"0\":{\"459\":1}}],[\"树与二叉树\",{\"0\":{\"454\":1}}],[\"树代表的是\",{\"1\":{\"221\":1}}],[\"树或红黑树\",{\"1\":{\"217\":1}}],[\"树中插入节点后\",{\"1\":{\"206\":1}}],[\"树中的每个节点代表一个选择\",{\"1\":{\"83\":1}}],[\"树中的每个节点代表当前状态\",{\"1\":{\"81\":1}}],[\"树的遍历操作也是图的遍历操作的一种特例\",{\"1\":{\"221\":1}}],[\"树的节点插入操作与二叉搜索树在主体上类似\",{\"1\":{\"206\":1}}],[\"树的特点在于\",{\"1\":{\"200\":1}}],[\"树的相关操作需要获取节点高度\",{\"1\":{\"198\":1}}],[\"树节点结构体\",{\"1\":{\"198\":1}}],[\"树既是二叉搜索树\",{\"1\":{\"198\":1}}],[\"树是一种非线性数据结构\",{\"1\":{\"185\":1}}],[\"树是一种基于链表的数据结构\",{\"1\":{\"185\":1}}],[\"树是分治思想的代表\",{\"1\":{\"64\":1}}],[\"树等\",{\"1\":{\"63\":1}}],[\"树\",{\"0\":{\"179\":1},\"1\":{\"13\":1,\"14\":1,\"15\":2,\"63\":3,\"64\":1,\"213\":1}}],[\"栈和队列\",{\"0\":{\"448\":1}}],[\"栈和队列既可以使用数组实现\",{\"1\":{\"15\":1}}],[\"栈区域\",{\"1\":{\"288\":1}}],[\"栈已满\",{\"1\":{\"157\":1}}],[\"栈为空\",{\"1\":{\"156\":1,\"157\":1}}],[\"栈的两种实现对比\",{\"0\":{\"158\":1}}],[\"栈的顺序实现\",{\"0\":{\"157\":1}}],[\"栈的长度\",{\"1\":{\"156\":1}}],[\"栈的链式实现\",{\"0\":{\"156\":1}}],[\"栈底\",{\"1\":{\"155\":1}}],[\"栈顶\",{\"1\":{\"155\":1}}],[\"栈帧空间\",{\"1\":{\"43\":1,\"82\":1,\"90\":1,\"187\":1}}],[\"栈\",{\"0\":{\"155\":1,\"449\":1},\"1\":{\"13\":1,\"14\":1,\"15\":2,\"155\":1}}],[\"栈与队列\",{\"0\":{\"9\":1,\"154\":1}}],[\"数学相关函数\",{\"1\":{\"291\":1}}],[\"数独\",{\"1\":{\"79\":1}}],[\"数字\",{\"1\":{\"18\":1}}],[\"数字是以\",{\"1\":{\"17\":1}}],[\"数字编码\",{\"0\":{\"17\":1}}],[\"数据链路层\",{\"0\":{\"514\":1,\"515\":1}}],[\"数据的表示和运算\",{\"0\":{\"480\":1,\"481\":1}}],[\"数据读取完毕\",{\"1\":{\"406\":1}}],[\"数据写入完毕\",{\"1\":{\"406\":1}}],[\"数据准备完毕\",{\"1\":{\"379\":1}}],[\"数据从程序\",{\"1\":{\"308\":1}}],[\"数据从数据源\",{\"1\":{\"308\":1}}],[\"数据从顶部向下按层次排列\",{\"1\":{\"14\":1}}],[\"数据类型转换分为\",{\"1\":{\"336\":1}}],[\"数据类型转换\",{\"0\":{\"336\":1}}],[\"数据类型n\",{\"1\":{\"302\":1}}],[\"数据类型2\",{\"1\":{\"302\":1}}],[\"数据类型1\",{\"1\":{\"302\":1}}],[\"数据类型占据多少个字节\",{\"1\":{\"262\":1}}],[\"数据类型是指针所指向的地址处的数据类型\",{\"1\":{\"261\":1}}],[\"数据类型关键字\",{\"1\":{\"259\":1}}],[\"数据类型\",{\"0\":{\"329\":1},\"1\":{\"249\":1,\"261\":1,\"263\":2,\"303\":3}}],[\"数据存储\",{\"0\":{\"234\":1}}],[\"数据发送方可以计算数据的哈希值并将其一同发送\",{\"1\":{\"176\":1}}],[\"数据完整性检查\",{\"1\":{\"176\":1}}],[\"数据操作尽可能快速\",{\"1\":{\"132\":1}}],[\"数据会根据第k位从小到大排序\",{\"1\":{\"56\":1}}],[\"数据分布并不一定需要特意统计\",{\"1\":{\"51\":1}}],[\"数据按照一定顺序排列\",{\"1\":{\"14\":1}}],[\"数据结构本身仅存储数据信息\",{\"1\":{\"133\":1}}],[\"数据结构为算法提供了结构化存储的数据\",{\"1\":{\"133\":1}}],[\"数据结构是算法的基石\",{\"1\":{\"133\":1}}],[\"数据结构与算法高度相关\",{\"1\":{\"133\":1}}],[\"数据结构与算法的关系\",{\"0\":{\"133\":1}}],[\"数据结构设计是一个充满权衡的过程\",{\"1\":{\"132\":1}}],[\"数据结构定义\",{\"0\":{\"132\":1}}],[\"数据结构\",{\"0\":{\"13\":1,\"532\":1},\"1\":{\"132\":1}}],[\"数组和特殊矩阵\",{\"0\":{\"451\":1,\"452\":1}}],[\"数组不是基本数据类型\",{\"1\":{\"332\":1}}],[\"数组等具有块级作用域\",{\"1\":{\"288\":1}}],[\"数组等具有局部作用域\",{\"1\":{\"288\":1}}],[\"数组等具有全局作用域\",{\"1\":{\"288\":1}}],[\"数组等\",{\"1\":{\"288\":1}}],[\"数组+1会向后移动4个字节\",{\"1\":{\"263\":1}}],[\"数组下标必须在指定范围内使用\",{\"1\":{\"244\":1}}],[\"数组越界\",{\"1\":{\"244\":1}}],[\"数组名表示首元素地址\",{\"1\":{\"344\":2}}],[\"数组名访问数组元素不需要解引用\",{\"1\":{\"263\":1}}],[\"数组名不需要显式初始化\",{\"1\":{\"263\":1}}],[\"数组名不能进行自增\",{\"1\":{\"263\":1}}],[\"数组名通常是不可变的\",{\"1\":{\"263\":1}}],[\"数组名指向元素首地址\",{\"1\":{\"263\":1}}],[\"数组名的指向不可修改\",{\"1\":{\"263\":1}}],[\"数组名与真正的指针存在差别\",{\"1\":{\"263\":1}}],[\"数组名与真正的指针是不同的\",{\"1\":{\"263\":1}}],[\"数组名中存储了第一个元素的地址\",{\"1\":{\"263\":1}}],[\"数组名得到的是整个数组的大小\",{\"1\":{\"263\":1}}],[\"数组名在大多数情况下会被隐式地转换为指向数组第一个元素的指针\",{\"1\":{\"263\":1}}],[\"数组名字是\",{\"1\":{\"244\":1}}],[\"数组名\",{\"1\":{\"243\":1,\"244\":1,\"256\":1,\"263\":1}}],[\"数组相关概念\",{\"1\":{\"243\":1}}],[\"数组存储需要连续内存空间\",{\"1\":{\"191\":1}}],[\"数组存储在连续的内存空间中\",{\"1\":{\"191\":1}}],[\"数组表示也存在一些局限性\",{\"1\":{\"191\":1}}],[\"数组表示下的二叉树结构体\",{\"1\":{\"190\":1}}],[\"数组指针通常需要解引用才能访问数组元素\",{\"1\":{\"263\":1}}],[\"数组指针需要显式初始化\",{\"1\":{\"263\":1}}],[\"数组指针是可变的\",{\"1\":{\"263\":1}}],[\"数组指针指向数组的地址\",{\"1\":{\"263\":1}}],[\"数组指针指向的是数组的地址\",{\"1\":{\"263\":1}}],[\"数组指针指向的是整个数组的地址而不是第一个元素的地址\",{\"1\":{\"263\":1}}],[\"数组指针和数组名的区别\",{\"1\":{\"263\":1}}],[\"数组指针+1会向后移动4\",{\"1\":{\"263\":1}}],[\"数组指针名\",{\"1\":{\"263\":1}}],[\"数组指针数组指针\",{\"1\":{\"263\":1}}],[\"数组指针\",{\"1\":{\"186\":1}}],[\"数组长度\",{\"1\":{\"167\":1,\"245\":2}}],[\"数组实现额外支持随机访问\",{\"1\":{\"158\":1}}],[\"数组整体是一个变量\",{\"1\":{\"147\":1}}],[\"数组元素在内存中是\",{\"1\":{\"141\":1}}],[\"数组元素被存储在连续的内存空间中\",{\"1\":{\"140\":1}}],[\"数组在初始化后长度就固定了\",{\"1\":{\"138\":1}}],[\"数组在初始化后长度不可变\",{\"1\":{\"15\":1}}],[\"数组允许在o\",{\"1\":{\"138\":1}}],[\"数组为数据分配了连续的内存块\",{\"1\":{\"138\":1}}],[\"数组与链表的对比\",{\"0\":{\"152\":1}}],[\"数组与链表\",{\"0\":{\"137\":1}}],[\"数组中包含的节点数据比重较低\",{\"1\":{\"191\":1}}],[\"数组中包含元素的有效区间为\",{\"1\":{\"161\":1}}],[\"数组中连续被占用的位置越长\",{\"1\":{\"172\":1}}],[\"数组中的任意两个隔板\",{\"1\":{\"122\":1}}],[\"数组中可能包含重复元素\",{\"1\":{\"82\":1}}],[\"数组中可能不包含\",{\"1\":{\"26\":1}}],[\"数组dp大小为nxm\",{\"1\":{\"105\":1}}],[\"数组索引从0开始计数\",{\"1\":{\"107\":1}}],[\"数组索引\",{\"1\":{\"56\":1,\"167\":1}}],[\"数组的每个元素都是字符串通过这种方式可以通过命令行的方式执行源代码\",{\"1\":{\"287\":1}}],[\"数组的定义方法一\",{\"1\":{\"244\":1}}],[\"数组的操作\",{\"0\":{\"244\":1}}],[\"数组的长度\",{\"1\":{\"244\":3}}],[\"数组的长度一旦确定\",{\"1\":{\"243\":1}}],[\"数组的长度是不可变的\",{\"1\":{\"145\":1}}],[\"数组的特点\",{\"1\":{\"243\":1}}],[\"数组的概念\",{\"0\":{\"243\":1}}],[\"数组的插入和删除的平均时间复杂度均为o\",{\"1\":{\"142\":1}}],[\"数组的插入与删除操作有以下缺点\",{\"1\":{\"142\":1}}],[\"数组的前\",{\"1\":{\"41\":2}}],[\"数组的第\",{\"1\":{\"41\":1}}],[\"数组前n\",{\"1\":{\"36\":1}}],[\"数组前2个元素已排序\",{\"1\":{\"36\":1}}],[\"数组前1个元素已排序\",{\"1\":{\"36\":1}}],[\"数组可通过重新分配内存实现长度变化\",{\"1\":{\"15\":1}}],[\"数组\",{\"0\":{\"1\":1,\"138\":1,\"229\":1,\"242\":1},\"1\":{\"14\":1,\"15\":1,\"85\":1,\"90\":2,\"138\":1,\"170\":1,\"243\":1,\"379\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
